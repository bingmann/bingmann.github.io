% -*- mode: latex; mode: flyspell; ispell-local-dictionary: "en_US"; coding: utf-8 -*-

\documentclass[a4paper,landscape,12pt,twoside,english]{scrartcl}

\setlength\overfullrule{14pt} % this enables big black bars on overlong lines.

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{lmodern}
\usepackage{babel}

\title{Sound of LED Sorting Algorithms Printout}
\author{Timo Bingmann}

% small margin
\usepackage[tmargin=20mm,bmargin=20mm,lmargin=20mm,rmargin=20mm]{geometry}

% set default paragraph skip and indention
\setlength\parskip{\smallskipamount}
\setlength\parindent{0pt}

\pagestyle{empty}

% math support
\usepackage{amsmath,amssymb,array,mathtools}

% smaller enumerations
\usepackage{enumitem}
\setlist[enumerate]{topsep=\smallskipamount,parsep=0pt}
\setlist[itemize]{topsep=\smallskipamount,parsep=0pt}
\setlist[enumerate,1]{topsep=\smallskipamount,parsep=0pt,label=(\roman*)}

\usepackage[table]{xcolor}

% for graphics
\usepackage{graphicx}

% for nice graphics
\usepackage{tikz}
\usetikzlibrary{calc}

\usepackage{tabularx}
\usepackage{minted}
\usemintedstyle{manni}

% color
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

% listings
\usepackage{listings}
\lstset{
  language=C++,
  columns=fixed,
  basicstyle=\ttfamily,
  commentstyle=\color{mygreen},    % comment style
  keywordstyle=\color{blue},       % keyword style
  }


% Hyperref
\usepackage{hyperref}

\hypersetup{
  colorlinks=true,
  pdfborder={0 0 0},
  bookmarksopen=true,
  bookmarksopenlevel=1,
  bookmarksnumbered=true,
  linkcolor=blue!60!black,
  % linkcolor=black,
  urlcolor=blue!60!black,
  filecolor=green!60!black,
  citecolor=blue!60!black,
  pdfpagemode=UseNone,
  unicode=true,
  setpagesize=false,
  bookmarksdepth=subsection,
  pdftitle={title},
  pdfauthor={Timo Bingmann},
  pdfsubject={},
}

\begin{document}
\large\parskip=0pt

\fontsize{20}{22}\selectfont
\begin{minted}{c++}
// Insertion Sort, left to right
void InsertionSort(Item* A, size_t n) {
    for (size_t i = 1; i < n; ++i) {
        Item key = A[i];
        ssize_t j = i - 1;
        while (j >= 0 && A[j] > key) {
            swap(A[j], A[j + 1]);
            j--;
        }
    }
}
\end{minted}

\begin{minted}{c++}
// Selection Sort, left to right
void SelectionSort(Item* A, size_t n) {
    for (size_t i = 0; i < n - 1; ++i) {
        size_t j_min = i;
        for (size_t j = i + 1; j < n; ++j) {
            if (A[j] < A[j_min])
                j_min = j;
        }
        swap(A[i], A[j_min]);
    }
}
\end{minted}

\clearpage

\fontsize{16}{17.7}\selectfont
\begin{minted}{c++}
// BubbleSort O(n^2)
void BubbleSort(Item* A, size_t n) {
    for (size_t i = 0; i < n - 1; ++i) {
        for (size_t j = 0; j < n - 1 - i; ++j) {
            if (A[j] > A[j + 1])
                swap(A[j], A[j + 1]);
        }
    }
}
\end{minted}

\begin{minted}{c++}
// Shell's Sort
void ShellSort(Item* A, size_t n) {
    size_t incs[16] = {
        1391376, 463792, 198768, 86961, 33936, 13776, 4592, 1968,
        861, 336, 112, 48, 21, 7, 3, 1
    };
    for (size_t k = 0; k < 16; k++) {
        for (size_t h = incs[k], i = h; i < n; i++) {
            Item v = A[i];
            size_t j = i;
            while (j >= h && A[j - h] > v) {
                A[j] = A[j - h];
                j -= h;
            }
            A[j] = v;
        }
    }
}
\end{minted}

\clearpage
\fontsize{18}{20}\selectfont
\begin{minted}{c++}
// QuickSort with Hoare's partition scheme
void QuickSortLR(Item* A, ssize_t lo, ssize_t hi) {
    ssize_t p = QuickSortSelectPivot(A, lo, hi + 1);
    ssize_t i = lo, j = hi;
    while (i <= j) {
        while (A[i] < A[p])
            i++;
        while (A[j] > A[p])
            j--;
        if (i <= j) {
            swap(A[i], A[j]);
            // follow pivot if it is swapped
            p = (p == i ? j : p == j ? i : p);
            i++, j--;
        }
    }
    if (lo < j)
        QuickSortLR(A, lo, j);
    if (i < hi)
        QuickSortLR(A, i, hi);
}
void QuickSortLR(Item* A, size_t n) {
    QuickSortLR(A, 0, n - 1);
}
\end{minted}

\clearpage
\fontsize{19}{21}\selectfont
\begin{minted}{c++}
// QuickSort with Lomuto's partition scheme
size_t PartitionLL(Item* A, size_t lo, size_t hi) {
    // pick pivot and move to back
    size_t p = QuickSortSelectPivot(A, lo, hi);
    Item& pivot = A[p];
    swap(A[p], A[hi - 1]);
    ssize_t i = lo;
    for (size_t j = lo; j < hi - 1; ++j) {
        if (A[j] <= pivot)
            swap(A[i], A[j]), ++i;
    }
    swap(A[i], A[hi - 1]);
    return i;
}
void QuickSortLL(Item* A, size_t lo, size_t hi) {
    if (lo + 1 < hi) {
        size_t mid = PartitionLL(A, lo, hi);
        QuickSortLL(A, lo, mid), QuickSortLL(A, mid + 1, hi);
    }
}
void QuickSortLL(Item* A, size_t n) {
    QuickSortLL(A, 0, n);
}
\end{minted}

\clearpage
\fontsize{16}{18}\selectfont
\begin{minted}{c++}
// Dual-Pivot Quick Sort (code by Yaroslavskiy)
void QuickSortDualPivotYaroslavskiy(Item* A, int left, int right) {
    if (right > left) {
        if (A[left] > A[right])
            swap(A[left], A[right]);
        const Item p = A[left], q = A[right];
        ssize_t l = left + 1, g = right - 1, k = l;
        while (k <= g) {
            if (A[k] < p) {
                swap(A[k], A[l]), ++l;
            }
            else if (A[k] >= q) {
                while (A[g] > q && k < g)
                    --g;
                swap(A[k], A[g]), --g;
                if (A[k] < p)
                    swap(A[k], A[l]), ++l;
            }
            ++k;
        }
        --l, ++g;
        swap(A[left], A[l]), swap(A[right], A[g]);
        QuickSortDualPivotYaroslavskiy(A, left, l - 1);
        QuickSortDualPivotYaroslavskiy(A, l + 1, g - 1);
        QuickSortDualPivotYaroslavskiy(A, g + 1, right);
    }
}
\end{minted}

\clearpage
\fontsize{18}{20}\selectfont
\begin{minted}{c++}
void Merge(Item* A, size_t lo, size_t mid, size_t hi) {
    Item out[hi - lo];                     // allocate output
    size_t i = lo, j = mid, o = 0;         // merge first and second halves
    while (i < mid && j < hi) {
        Item ai = A[i], aj = A[j];         // copy out for fewer time steps
        out[o++] = (ai < aj ? (++i, ai) : (++j, aj));
    }
    while (i < mid)                        // copy rest
        out[o++] = A[i++];
    while (j < hi)
        out[o++] = A[j++];
    for (i = 0; i < hi - lo; ++i)          // copy back
        A[lo + i] = out[i];
}
void MergeSort(Item* A, size_t lo, size_t hi) {
    if (lo + 1 < hi) {
        size_t mid = (lo + hi) / 2;
        MergeSort(A, lo, mid), MergeSort(A, mid, hi);
        Merge(A, lo, mid, hi);
    }
}
void MergeSort(Item* A, size_t n) {
    return MergeSort(A, 0, n);
}
\end{minted}

\clearpage
\fontsize{15}{16}\selectfont
\begin{minted}{c++}
void HeapSort(Item* A, size_t n) {
    size_t i = n / 2;
    while (1) {
        if (i > 0) {
            // build heap, sift A[i] down the heap
            i--;
        }
        else {
            // pop largest element from heap: swap front to back, and sift
            // front A[0] down the heap
            if (--n == 0)
                return;
            swap(A[0], A[n]);
        }
        size_t parent = i, child = i * 2 + 1;
        // sift operation - push the value_ of A[i] down the heap
        while (child < n) {
            if (child + 1 < n && A[child + 1] > A[child]) {
                child++;
            }
            if (A[child] > A[parent]) {
                swap(A[parent], A[child]);
                parent = child, child = parent * 2 + 1;
            }
            else
                break;
        }
    }
}
\end{minted}

\clearpage
\fontsize{16}{17.5}\selectfont
\begin{minted}{c++}
void LinearProbingHT(Item* A, size_t n) {
    size_t cshift = random(n);
    for (size_t i = 0; i < n; ++i) {
        // pick a new item to insert
        Item v = Item((i + cshift) % n);
        size_t idx = (hash(v.value()) >> 2) % n;
        while (A[idx].value() != black) {
            idx = (idx + 1) % n;
        }
        A[idx] = v;
    }
}
\end{minted}
\begin{minted}{c++}
void QuadraticProbingHT(Item* A, size_t n) {
    size_t cshift = random(n);
    for (size_t i = 0; i < n; ++i) {
        // pick a new item to insert
        Item v = Item((i + cshift) % n);
        size_t idx = (hash(v.value()) >> 2) % n;
        size_t p = 0;
        while (A[idx].value() != black) {
            idx = (idx + (p + p * p) / 2) % n;
            if (++p == n)
                return;  // cycled. stop hashing.
        }
        A[idx] = v;
    }
}
\end{minted}

\clearpage
\fontsize{16}{18.1}\selectfont
\begin{minted}{c++}
void CuckooHashingTwo(Item* A, size_t n) {
    size_t cshift = random(n);
    for (size_t i = 0; i < n; ++i) {
        // pick a new item to insert
        Item v = Item((i + cshift) % n);
        uint32_t pos = hash2(0, v.value()) % n;
        if (A[pos].value() == black) {
            A[pos] = v; continue;
        }
        pos = hash2(1, v.value()) % n;
        if (A[pos].value() == black) {
            A[pos] = v; continue;
        }
        size_t r = 0;
        int hashfunction = 1;
        while (true) {
            pos = hash2(hashfunction, v.value()) % n;
            swap(v, A[pos]);
            if (v.value() == black)
                break;
            if (hash2(hashfunction, v.value()) % n == pos)
                hashfunction = (hashfunction + 1) % 2;
            if (++r >= n)
                return;
        }
    }
}
\end{minted}

\clearpage
\KOMAoptions{paper=A4,DIV=19,paper=portrait}
\recalctypearea
\fontsize{16}{18.1}\selectfont
\begin{minted}{c++}
void CuckooHashingThree(Item* A, size_t n) {
    size_t cshift = random(n);
    for (size_t i = 0; i < n; ++i) {
        // pick a new item to insert
        Item v = Item((i + cshift) % n);
        uint32_t pos = hash3(0, v.value()) % n;
        if (A[pos].value() == black) {
            A[pos] = v; continue;
        }
        pos = hash3(1, v.value()) % n;
        if (A[pos].value() == black) {
            A[pos] = v;
            continue;
        }
        pos = hash3(2, v.value()) % n;
        if (A[pos].value() == black) {
            A[pos] = v;
            continue;
        }
        // all three places full,
        // pick a random one to displace
        int hashfunction = random(3);
        pos = hash3(hashfunction, v.value()) % n;
        swap(v, A[pos]);
        size_t r = 0;
        while (true) {
            hashfunction = random(2);
            if (hash3(hashfunction, v.value()) % n == pos)
                hashfunction = 2;
            pos = hash3(hashfunction, v.value()) % n;
            swap(v, A[pos]);
            if (v.value() == black)
                break;
            if (++r >= n)
                return;
        }
    }
}
\end{minted}

\end{document}