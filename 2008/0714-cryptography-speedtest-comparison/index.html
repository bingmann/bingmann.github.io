<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><meta name="viewport" content="initial-scale=1"><title>Speedtest and Comparsion of Open-Source Cryptography Libraries and Compiler Flags - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="stylesheet" type="text/css" href="/css/fonts.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="http://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="http://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/js/base.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body style="background-image: url(/img/bgfractal3.jpg)"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/"><i class="icon-book"></i> Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2019/">2019</a></li><li><a href="/2018/">2018</a></li><li><a href="/2017/">2017</a></li><li><a href="/2016/">2016</a></li><li><a href="/2015/">2015</a></li><li><a href="/2014/">2014</a></li><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li class="nt"><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li><li class="ns"><a href="/search.html">Search</a></li></ul></li><li class="top"><a class="ni" href="/tags/"><i class="icon-tags"></i> Tags</a><div style="width: 14em; margin-left: -9em; margin-top: 4px"><a style="font-size: 10pt" href="/tags/algebra.html">algebra</a> <a style="font-size: 16pt" href="/tags/c++.html">c++</a> <a style="font-size: 12pt" href="/tags/code-example.html">code-example</a> <a style="font-size: 14pt" href="/tags/code-snippet.html">code-snippet</a> <a style="font-size: 11pt" href="/tags/coding_tricks.html">coding tricks</a> <a style="font-size: 10pt" href="/tags/compsci.html">compsci</a> <a style="font-size: 10pt" href="/tags/compsci_study_thesis.html">compsci study thesis</a> <a style="font-size: 9pt" href="/tags/crypto-speedtest.html">crypto-speedtest</a> <a style="font-size: 10pt" href="/tags/cryptography.html">cryptography</a> <a style="font-size: 9pt" href="/tags/cryptote.html">cryptote</a> <a style="font-size: 11pt" href="/tags/dissertation.html">dissertation</a> <a style="font-size: 12pt" href="/tags/flex-bison-cpp-example.html">flex-bison-cpp-example</a> <a style="font-size: 16pt" href="/tags/frontpage.html">frontpage</a> <a style="font-size: 15pt" href="/tags/fun.html">fun</a> <a style="font-size: 10pt" href="/tags/graphviz.html">graphviz</a> <a style="font-size: 9pt" href="http://www.hmtg.de">hartmetall</a> <a style="font-size: 9pt" href="/tags/helppc.html">helppc</a> <a style="font-size: 9pt" href="/tags/hifi_selbstbau.html">hifi selbstbau</a> <a style="font-size: 10pt" href="/tags/latex.html">latex</a> <a style="font-size: 10pt" href="/tags/librivox.html">librivox</a> <a style="font-size: 10pt" href="/tags/linux.html">linux</a> <a style="font-size: 9pt" href="/tags/market.html">market</a> <a style="font-size: 9pt" href="/tags/massive-sorting.html">massive-sorting</a> <a style="font-size: 11pt" href="/tags/maths.html">maths</a> <a style="font-size: 9pt" href="/tags/music.html">music</a> <a style="font-size: 10pt" href="/tags/netfundamentals.html">netfundamentals</a> <a style="font-size: 11pt" href="/tags/ns-3.html">ns-3</a> <a style="font-size: 10pt" href="/tags/parallel-string-sorting.html">parallel-string-sorting</a> <a style="font-size: 14pt" href="/tags/parsing.html">parsing</a> <a style="font-size: 9pt" href="/tags/qtsqlview.html">qtsqlview</a> <a style="font-size: 14pt" href="/tags/research.html">research</a> <a style="font-size: 11pt" href="/tags/sdios06.html">sdios06</a> <a style="font-size: 9pt" href="/tags/sdlfractal.html">sdlfractal</a> <a style="font-size: 14pt" href="/tags/sorting.html">sorting</a> <a style="font-size: 11pt" href="/tags/sound_of_sorting.html">sound of sorting</a> <a style="font-size: 10pt" href="/tags/stringology.html">stringology</a> <a style="font-size: 16pt" href="/tags/stx-btree.html">stx-btree</a> <a style="font-size: 16pt" href="/tags/stxxl.html">stxxl</a> <a style="font-size: 16pt" href="/tags/talk.html">talk</a> <a style="font-size: 15pt" href="/tags/thrill.html">thrill</a> <a style="font-size: 10pt" href="/tags/tutorium.html">tutorium</a> <a style="font-size: 16pt" href="/tags/university.html">university</a> <a style="font-size: 13pt" href="/tags/utilities.html">utilities</a> <a style="font-size: 10pt" href="/tags/vncrec.html">vncrec</a> <a style="font-size: 9pt" href="/tags/webdesign.html">webdesign</a> </div></li><li class="top"> <a class="ni" href="#"><i class="icon-cubes"></i> Projects</a> <ul style="margin-left: -8em; margin-top: 4px;" class="nx"> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2016/0114-diploma-thesis/">On Bispanning Graphs</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2013/parallel-string-sorting/">Parallel String Sorting</a></li> <li><a href="/2014/sqlplot-tools/">SqlPlotTools</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li><a href="/tags/stxxl.html">STXXL 1.4</a></li> <li><a href="/tags/thrill.html">Thrill - Big Data Framework</a></li> <li class="nt"><a href="/2014/vncrec-rgb/">VNCrec RGB 0.4</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="/publications.html"><i class="icon-graduation-cap"></i> Publications</a></li><li class="top"> <a class="ni" href="/about/"><i class="icon-info-circled"></i> About</a> <ul style="margin-left: -6em; margin-top: 4px" class="nx"> <li><a href="/about/">Timo Bingmann</a></li> <li><a href="/about/impressum.html">Impressum</a></li> </ul></li><li class="top"> <a class="ni" href="/subscribe.html"><i class="icon-rss-squared"></i> Subscribe</a></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2008/">2008</a> / <a href="/2008/0714-cryptography-speedtest-comparison/">0714-cryptography-speedtest-comparison</a></div></div><div class="ptcontent"><div style="float: right; clear: right; margin: 12pt 0pt 12pt 12pt; font-size: smaller; text-align: center" class="aimg"><a href="/2008/0714-cryptography-speedtest-comparison/"><img src="/2008/0714-cryptography-speedtest-comparison/p4-3200-gentoo-all-thumb.jpg" width="300" height="423" alt="Cryptograph Speedtest - All Tests: Speed by Data Length on p4-3200-gentoo" title="Cryptograph Speedtest - All Tests: Speed by Data Length on p4-3200-gentoo" /></a></div><h1>Speedtest and Comparsion of Open-Source Cryptography Libraries and Compiler Flags</h1><p class="info">Posted on 2008-07-14 14:53 by <a href="/about/">Timo Bingmann</a><a href="http://plus.google.com/+TimoBingmann?rel=author"></a> at <a href="/2008/0714-cryptography-speedtest-comparison/">Permlink</a> with <a href="/2008/0714-cryptography-speedtest-comparison/#notes">12 Comments</a>. Tags: <a href="/tags/cryptography.html">cryptography</a> <a href="/tags/crypto-speedtest.html">crypto-speedtest</a></p><div class="textcontent"><h2>Abstract</h2><p>There are many well-known open-source cryptography libraries available, which implement many different ciphers. So which library and which cipher(s) should one use for a new program? This comparison presents a wealth of experimentally determined speed test results to allow an educated answer to this question.</p><p>The speed tests encompass eight open-source cryptography libraries of which 15 different ciphers are examined. The performance experiments were run on five different computers which had up to six different Linux distributions installed, leading to ten CPU / distribution combinations tests. Ultimately the cipher code was also compiled using four different C++ compilers with 35 different optimization flag combinations.</p><p>Two different test programs were written: the first to verify cipher implementations against each other, the second to perform timed speed tests on the ciphers exported by the different libraries. A cipher speed test run is composed of both encryption <em>and</em> decryption of a buffer. The buffer length is varied from 16 bytes to 1 MB in size.</p><p>Many of the observed results are unexpected. Blowfish turned out to be the fastest cipher. But cipher selection cannot be solely based on speed, other parameters like (perceived) strength and age are more important. However raw speed data is important for further discussion.</p><p>When regarding the eight selected cryptography libraries, one would expect all libraries to contain approximately the same core cipher implementation, as all calculation results <em>have to be equal</em>. However the libraries&apos; performances varies greatly. OpenSSL and Beecrypt contain implementations with highest optimization levels, but the libraries only implement few ciphers. Tomcrypt, Botan and Crypto++ implement many different ciphers with consistently good performance on all of them. The smaller Nettle library trails somewhat behind, probably due to it&apos;s age.</p><p>The first real surprise of the speed comparison is the extremely slow test results measured on all ciphers implemented in libmcrypt and libgcrypt. libmcrypt&apos;s ciphers show an extremely long start-up overhead, but once it is amortized the cipher&apos;s throughput is equal to faster libraries. libgcrypt&apos;s results on the other hand are really abysmal and trail far behind all the other libraries. This does not bode well for GnuTLS&apos;s SSL performance. And libmcrypt&apos;s slow start promises bad performance for thousands of PHP applications encrypting small chunks of user data.</p><p>Most of the speed test experiments were run on Gentoo Linux, which compiles all programs from source with user-defined compiler flags. This contrasts to most other Linux distributions which ship pre-compiled binary packages. To verify that previous results stay valid on other distributions the experiments were rerun in chroot-jailed installations. As expected Gentoo Linux showed the highest performance, closely followed by the newer versions of Ubuntu (hardy) and Debian (lenny). The oldest distribution in the test, Debian etch, showed nearly 15% slower speed results than Gentoo.</p><p>To make the results transferable onto other computers and CPUs the speed test experiments were run on five different computers, which all had Debian etch installed. No unexpected results were observable: all results show the expected scaling with CPU speed. Most importantly no cache effects or special speed-ups were detectable. Most robust cipher was CAST5 and the one most fragile to CPU architecture was Serpent.</p><p>Most interesting for applications outside the scope of cipher algorithms was the compiler and optimization flags comparison. The speed test code and cipher library Crypto++ was compiled with many different compiler / flags combinations. It was even compiled and speed measured on Windows to compare Microsoft&apos;s compiler with those available on Linux.</p><p>The experimental results showed that Intel&apos;s C++ compiler produces by far the most optimized code for all ciphers tested. Second and third place goes to Microsoft Visual C++ 8.0 and <code>gcc 4.1.2</code>, which generate code which is roughly 16.5% and 17.5% slower than that generated by Intel&apos;s compiler. gcc&apos;s performance is highly dependent on the amount to optimization flags enabled: a simple <code>-O3</code> is not sufficient to produce well optimized binary code. Relative to <code>gcc 4.1.2</code> the older compiler version <code>3.4.6</code> is about 10% slower on most tests.</p><p>All in all the experimental results provide some hard numbers on which to base further discussion. Hopefully some of the libraries&apos; spotlighted deficits can be corrected or at least explained. Lastly the most concrete result: the cipher and library I will use for my planned application is Serpent from the Botan library.</p><h2>Download Source</h2><table class="darkfullframe"> <tr> <td colspan="3"><b>Cryptography Library Speedtest Version 0.1</b> (current) released 2008-07-14</td> </tr> <tr> <td>Source code archive:</td> <td><a href="crypto-speedtest-0.1.tar.bz2">Download crypto-speedtest-0.1.tar.bz2 (4680kb)</a><br /><tt>MD5: 37fea6c2623da97f09e85401c29a9768</tt></td> <td><a href="crypto-speedtest-0.1/">Browse online</a></td> </tr></table><h2>Table of Contents</h2><ol> <li><a href="#c01-motivation">Motivation</a></li> <li><a href="#c02-description">Description of Libraries, Ciphers and Compilers</a> <ol> <li><a href="#c02-s01-libraries">Libraries Tested</a></li> <li><a href="#c02-s02-ciphers">Ciphers Tested</a></li> <li><a href="#c02-s03-compilers">Compiler and Flags Tested</a></li> </ol> </li> <li><a href="#c03-method">Test Method</a> <ol> <li><a href="#c03-s01-verify">verify</a></li> <li><a href="#c03-s02-speedtest">speedtest</a></li> </ol> </li> <li><a href="#c04-environment">Test Environment</a> <ol> <li><a href="#c04-s01-cpudistro">CPUs and Distributions</a></li> <li><a href="#c04-s02-plots">Test Program Runs and Plots</a></li> <li><a href="#c04-s03-plotsflags">Compiler / Flags Test Program Runs and Plots (<code>results-flags</code>)</a></li> </ol> </li> <li><a href="#c05-discussion">Observation and Discussion</a> <ol> <li><a href="#c05-s01-cipher">Ciphers Compared</a></li> <li><a href="#c05-s02-library">Libraries Compared by Cipher</a></li> <li><a href="#c05-s03-distro">Findings On Different Distributions</a></li> <li><a href="#c05-s04-cpu">Ciphers compared by CPU</a></li> <li><a href="#c05-s05-flags">Compiler and Optimization Flags</a></li> </ol> </li> <li><a href="#c06-conclusion">Conclusion</a></li> <li style="list-style-type: none">Appendix <ol style="list-style-type: lower-roman"> <li><a href="distro-detailed.html">Detailed Distribution Package Versions</a></li> <li><a href="distro-speed.html">Full Speed Table Listing for All Distributions</a></li> <li><a href="cpu-speed.html">Detailed Speed Table Listing for All CPUs</a></li> <li><a href="compiler-speed.html">Full Speed Table Listing for All Compiler Flags</a></li> </ol> </li></ol><h2><a id="c01-motivation"></a>1&nbsp; Motivation</h2><p>Currently I am working on a program dubbed CryptoTE. It is a text editor which automatically saves documents and attachments in an encrypted container file. The idea is to transparently encrypt sensitive passwords and other data so other, possibly malicious programs (and users) cannot read the text. Yes, I know there are many &quot;Password Keeper&quot; programs available on the Internet. However CryptoTE, being a text editor, will be much simpler: it will not force you to structure your password data, no tables, attributes, etc. Last reason: I need it myself. CryptoTE will be available on idlebox.net when finished.</p><p>During current development of CryptoTE I have to decide, which cryptography library and which cipher(s) to choose for encrypting data. Currently I don&apos;t plan on having the user select one of 100 different ciphers, and thus leave cipher selection to some arbitrary choice of the user. (&quot;Blowfish looks pretty, reminds me of my last diving trip, I&apos;ll take that one.&quot;) So the list of available ciphers will be very short. I also don&apos;t care for the following misleading entry on the features list: &quot;This super program has 1000 different ciphers&quot; (which are actually just implemented by the library it uses).</p><p>The basic idea before starting this extensive comparison, was to use one of the currently strongest (public) ciphers: Rijndael (AES), Serpent or Twofish. Easy so far, but which library to use? Probably libgcrypt or libmcrypt, because the first is used by GnuTLS and the second is a long existing PHP extension used by many, many web applications.</p><p>However the results of this speed comparison test shows that this choice would not have been optimal. It turned out that there are substantial differences in the different libraries encryption speeds.</p><p>Once the speed test was written, the initial results showed such surprising differences, that I extended the test. I ran the library speed test on different Linux distributions and different CPUs / computers. This should determine if the differences were specific to my favorite distribution (Gentoo) or to my desktop computer&apos;s CPU architecture.</p><p>Testing different distributions however is not really fair. Most important criterion for the cipher speed are the compiler flags used to compile the library sources during packaging. So I expected a distribution using the <code>-O2</code> flag to show lower speeds than a distribution compiled with <code>-O3</code> (like my Gentoo is).</p><p>Thus I further extended the speed test to compare three different custom cipher implementations across different compilers and compiler flags, in the end even running the speed test on Windows (to satisfy the curiosity of a friend of mine). Here too the speed test results are unexpected.</p><h2><a id="c02-description"></a>2&nbsp; Description of Libraries, Ciphers and Compilers</h2><p>The speed comparison test was performed using many different ciphers found in well-known open source cryptography libraries. It was run on five different CPUs and six different Linux distributions to reveal details about distribution packaging, compiler flags and CPU attributes.</p><p>This section will describe in short which libraries, ciphers and compilers where compared.</p><h3><a id="c02-s01-libraries"></a>2.1&nbsp; Libraries Tested</h3><table class="datatable1"> <caption>Table 1: Cryptography Libraries Tested</caption> <tr> <th>Library</th> <th>Versions</th> <th>Language</th> <th>License</th> <th>Reason</th> </tr> <tr> <td><a href="http://www.gnupg.org">libgcrypt</a></td> <td>1.2.3 / 1.2.4 / 1.4.0</td> <td>C</td> <td><a href="http://www.gnu.org/copyleft/lesser.html">LGPL</a></td> <td>Used by <a href="http://www.gnu.org/software/gnutls/">GnuTLS</a>, which I prefer over OpenSSL because it throws no valgrind memory errors.</td> </tr> <tr> <td><a href="http://mcrypt.sourceforge.net">libmcrypt</a></td> <td>2.5.7 / 2.5.8</td> <td>C</td> <td><a href="http://www.gnu.org/copyleft/lesser.html">LGPL</a></td> <td>Long existing PHP extension. Used by lots and lots of web sites</td> </tr> <tr> <td><a href="http://botan.randombit.net">Botan</a></td> <td>1.6.1 / 1.6.2 / 1.6.3</td> <td>C++</td> <td><a href="http://botan.randombit.net/license.html">BSD</a></td> <td>Newer library. More liberal license. Good C++ interface instead of old-fashion C.</td> </tr> <tr> <td><a href="http://www.cryptopp.com">Crypto++</a></td> <td>5.2.1c2a / 5.5 / 5.5.1 / 5.5.2</td> <td>C++</td> <td><a href="http://www.cryptopp.com/License.txt">Special</a></td> <td>Another C++ library which seems to have a more Win32-ish background.</td> </tr> <tr> <td><a href="http://www.openssl.org">OpenSSL</a></td> <td>0.9.8b / 0.9.8c / 0.9.8e / 0.9.8g</td> <td>C</td> <td><a href="http://www.openssl.org/source/license.html">Special</a></td> <td>Well, it&apos;s OpenSSL. Just the low-level cipher interface is tested.</td> </tr> <tr> <td><a href="http://www.lysator.liu.se/~nisse/nettle/">Nettle</a></td> <td>1.14.1 / 1.15</td> <td>C</td> <td><a href="http://www.gnu.org/copyleft/lesser.html">LGPL</a></td> <td>Very small(!) low-level library.</td> </tr> <tr> <td><a href="http://beecrypt.sourceforge.net">Beecrypt</a></td> <td>4.1.2</td> <td>C</td> <td><a href="http://www.gnu.org/copyleft/lesser.html">LGPL</a></td> <td>Another small and possibly fast library.</td> </tr> <tr> <td><a href="http://libtom.org">Tomcrypt</a></td> <td>1.06 / 1.17</td> <td>C</td> <td><a href="http://en.wikipedia.org/wiki/Public_domain">Public Domain</a></td> <td>Least entangled library of cipher implementations.</td> </tr></table><p>The license of all these libraries are problematic, because the actual encryption cipher source code is often in the public domain. However, that is some lawyer&apos;s job to figure out. For a detailed listing of each libraries&apos; versions see the extra page: <a href="distro-detailed.html">Distribution Package Versions</a>.</p><p>Furthermore three custom cipher implementations were included in the speed test. These custom implementations are basically the publicly available original cipher source code modified and extended by myself for direct inclusion in my C++ programs. Included are:</p><ul> <li>Optimized Rijndael (AES) by <a href="http://www.iaik.tugraz.at/aboutus/people/rijmen/index.php">Vincent Rijmen</a>, Antoon Bosselaers and Paulo Barreto.</li> <li>Serpent cipher optimized by <a href="http://fp.gladman.plus.com/">Dr. Brian Gladman</a>.</li> <li>Another implementation of the Serpent cipher extracted from <a href="http://botan.randombit.net">Botan</a>. This is included to compare compiler settings and also because this implementation will be used in CryptoTE.</li></ul><h3><a id="c02-s02-ciphers"></a>2.2&nbsp; Ciphers Tested</h3><p>The ciphers available in the different libraries vary greatly. Mostly I chose to run a speed test on the strongest ciphers included in the library. All ciphers are tested in ECB (Electronic Codebook) mode, because it is available everywhere and best tests the cipher implementation itself.</p><table class="datatable1" style="text-align: center"> <caption>Table 2: Tested Ciphers in the Cryptography Libraries</caption> <tr> <th>Cipher</th> <th>Blocksize (bits)</th> <th>Keysize (bits)</th> <th>Libgcrypt</th> <th>Libmcrypt</th> <th>Botan</th> <th>Crypto++</th> <th>OpenSSL</th> <th>Nettle</th> <th>Beecrypt</th> <th>Tomcrypt</th> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael AES</a></td> <td>128</td> <td>256</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Serpent_(cipher)">Serpent</a></td> <td>128</td> <td>256</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&nbsp;</td> <td>&bull;</td> <td>&nbsp;</td> <td>&nbsp;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Twofish">Twofish</a></td> <td>128</td> <td>256</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&nbsp;</td> <td>&bull;</td> <td>&nbsp;</td> <td>&bull;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/CAST-256">CAST6 (256)</a></td> <td>128</td> <td>256</td> <td>&nbsp;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/GOST_28147-89">GOST</a></td> <td>64</td> <td>256</td> <td>&nbsp;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/SAFER">Safer+</a></td> <td>128</td> <td>256</td> <td>&nbsp;</td> <td>&bull;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&bull;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/LOKI97">Loki97</a></td> <td>128</td> <td>256</td> <td>&nbsp;</td> <td>&bull;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Anubis_%28cipher%29">Anubis</a></td> <td>128</td> <td>256</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&bull;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Blowfish_%28cipher%29">Blowfish</a></td> <td>64</td> <td>128</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/CAST-128">CAST5 (128)</a></td> <td>64</td> <td>128</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&nbsp;</td> <td>&bull;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Triple_DES">3DES</a></td> <td>64</td> <td>168</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&nbsp;</td> <td>&bull;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/XTEA">XTEA</a></td> <td>64</td> <td>128</td> <td>&nbsp;</td> <td>&bull;</td> <td>&bull;</td> <td>&bull;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&bull;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/NOEKEON">Noekeon</a></td> <td>128</td> <td>128</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&bull;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/KHAZAD">Khazad</a></td> <td>64</td> <td>128</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&bull;</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Skipjack_%28cipher%29">Skipjack</a></td> <td>64</td> <td>80</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&bull;</td> </tr></table><h3><a id="c02-s03-compilers"></a>2.3&nbsp; Compiler and Flags Tested</h3><p>Quite late during this speed test process, I decided to also test different compilers and compiler flag combintations. gcc was available in two different versions on my Gentoo system. Further I installed the Intel C/C++ Compiler using their &quot;Non-Commercial Software Development&quot; license. Lastly a friend wanted me to compare it with Visual C++, of which I have an academic edition.</p><table class="datatable1 vtop"> <caption>Table 3: Compiler and Flags Tested</caption> <tr> <th>Name</th> <th style="text-align: center">Version</th> <th>Platform</th> <th>Flags Tested</th> </tr> <tr> <td><a href="http://gcc.gnu.org/">GNU Compiler Collection</a></td> <td style="text-align: center">4.1.2</td> <td>Gentoo Linux</td> <td style="font-size: smaller"><code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>,<br /><code>-O2 -march=pentium4</code>,<br /><code>-O3 -march=pentium4</code>,<br /><code>-O2 -march=pentium4 -fomit-frame-pointer</code>,<br /><code>-O3 -march=pentium4 -fomit-frame-pointer</code>,<br /><code>-O2 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer</code>,<br /><code>-O3 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer</code>,<br /><code>-O2 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer -funroll-loops</code>,<br /><code>-O3 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer -funroll-loops</code></td> </tr> <tr> <td><a href="http://gcc.gnu.org/">GNU Compiler Collection</a></td> <td style="text-align: center">3.4.6</td> <td>Gentoo Linux</td> <td style="font-size: smaller"><code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code>,<br /><code>-O2 -march=pentium4</code>,<br /><code>-O3 -march=pentium4</code>,<br /><code>-O2 -march=pentium4 -fomit-frame-pointer</code>,<br /><code>-O3 -march=pentium4 -fomit-frame-pointer</code>,<br /><code>-O2 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer</code>,<br /><code>-O3 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer</code>,<br /><code>-O2 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer -funroll-loops</code>,<br /><code>-O3 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer -funroll-loops</code></td> </tr> <tr> <td><a href="http://www.intel.com/cd/software/products/asmo-na/eng/compilers/index.htm">Intel C/C++ Compiler</a></td> <td style="text-align: center">10.0</td> <td>Gentoo Linux</td> <td style="font-size: smaller"><code>-O0</code>, <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code></td> </tr> <tr> <td><a href="http://www.microsoft.com/visualc/">Microsoft Visual C++</a></td> <td style="text-align: center">8.0 (2005)</td> <td>Windows XP</td> <td style="font-size: smaller"><code>/Od</code>, <code>/O1</code>, <code>/O2</code>, <code>/Ox</code></td> </tr></table><p>The basic <code>-O#</code> optimization flags were tested on all three compilers. Some further gcc flags were also tested, as the default <code>-O#</code> are still quite restrictive. Furthermore (not included in the preceding list) I ran the speed tests on <a href="http://www.mingw.org/">MinGW</a> to double-check the timer resolution on Windows.</p><h2><a id="c03-method"></a>3&nbsp; Test Method</h2><p>Two programs are used to test and compare the cipher implementations.</p><h3><a id="c03-s01-verify"></a>3.1&nbsp; <code>verify</code></h3><p>The first test is not a speed measurement, instead the program <code>verify</code> is used to validate the different libraries against each other. Some fixed input is run through different libraries and the encrypted output is compared. This is done to check the different implementation (especially those which I modified) for correctness.</p><p><code>Verify</code> only tests five ciphers: Rijndael, Serpent, Twofish, Blowfish and 3DES. Rijndael, Blowfish and 3DES are implemented in almost every library and Serpent is the cipher I ultimately chose. Twofish and Blowfish are surprisingly fast in some results, so I had to check that they actually did some work.</p><p>For each library or custom implementation <code>verify</code> takes a 128 KB buffer filled with a specific pattern. It then encrypts the buffer and compares the result with the another encrypted buffers, thus checking that both (or more) implementations returned the same results. Then the cipher is used to decrypt the buffer again, and the buffer contents is verified to be the original data pattern.</p><p>The following implementations are checked against each other:</p><ul> <li>Rijndael (AES): Custom(Rijmen), libgcrypt, libmcrypt, Botan, Crypto++, OpenSSL, Nettle, Beecrypt, Tomcrypt. (That are all libraries)</li> <li>Serpent: Custom(Gladman), Custom(Botan), libgcrypt, libmcrypt, Botan, Crypto++, Nettle.</li> <li>Twofish: libgcrypt, libmcrypt, Botan, Crypto++, Tomcrypt.</li> <li>Blowfish: libgcrypt, libmcrypt, Botan, Crypto++, Nettle, Tomcrypt.</li> <li>3DES: libgcrypt, libmcrypt, Botan, Crypto++, OpenSSL, Nettle, Tomcrypt. (All except Beecrypt)</li></ul><h3><a id="c03-s02-speedtest"></a>3.2&nbsp; <code>speedtest</code></h3><p>The core of each speed test consists of one encryption pass directly followed by a decryption pass. Thus both encryption and decryption speed of the cipher is tested and results will reflect the time to encrypt <i>plus</i> decrypt. The passes are performed on one buffer filled with a pattern.</p><p>The first statistic variable is the buffer size en/decrypted. It ranges from 16 bytes to 1 MB. Only the buffer sizes 2<sup>4+n</sup> with n = 0 .. 16 are measured. By also testing very small buffers, library overhead and cipher key preprocessing/initialization time is measured indirectly. This start-up overhead becomes smaller as the buffers get larger.</p><p>To make results more accurate with the inaccurate time measurement device (<code>gettimeofday()</code>), small buffer size en/decryption is repeated a large number of times. The total run of all repeats is then divides by the number of repeatitions. The number of repeatition begins so that at least 64 KB of data is processed. If one repeated run takes less than 0.7 seconds, the same test is redone with twice the amount of data processed. This way the repetition loop is increased until processing takes a sufficiently long time to allow good measurement with only moderate timer resolution.</p><p>Furthermore each buffer size (including all internal repetitions) is tested 16 times. The different buffer sizes are not tested individually, but different sizes consecutively and then all are repeated.</p><p>The time is measured on Linux using <code>gettimeofday()</code> and on Windows using <code>timeGetTime()</code>. The results are written out to a text file for further processing with gnuplot. Each result includes the buffer size, average, standard deviation, minimum and maximum; both the absolute time measured and the reached throughput speed are printed into the result file.</p><h2><a id="c04-environment"></a>4&nbsp; Test Environment</h2><h3><a id="c04-s01-cpudistro"></a>4.1&nbsp; CPUs and Distributions</h3><p>The speed measurements were performed on five different computers available to me. They have five different CPUs:</p><ul> <li>Intel Pentium 4 at 3.2 GHz with 1024 KB L2 cache - Short: <b>p4-3200</b></li> <li>Intel Pentium 3 (Mobile) at 1.0 GHz with 512 KB L2 cache - Short: <b>p3-1000</b></li> <li>Intel Pentium 2 at 300 MHz with 512 KB L2 cache - Short: <b>p2-300</b></li> <li>Intel Celeron at 2.66 GHz with 256 KB L2 cache - Short: <b>cel-2660</b></li> <li>AMD Athlong XP 2000+ with 256 KB L2 cache - Short: <b>ath-2000</b></li></ul><p>To compare distribution package speed six different Linux distributions where used:</p><ul> <li>Gentoo stable</li> <li>Debian 4.0 etch (currently <code>stable</code>)</li> <li>Debian lenny (currently <code>testing</code>)</li> <li>Ubuntu 7.10 Gutsy Gibbon</li> <li>Ubuntu 8.04 Hardy Heron</li> <li>Fedora 8</li></ul><p>For a detailed listing of the different libraries package versions used in the speed tests, see the extra page: <a href="distro-detailed.html">Distribution Package Versions</a>.</p><h3><a id="c04-s02-plots"></a>4.2&nbsp; Basic Test Program Runs and Plots (<code>results</code>)</h3><p>The <code>speedtest</code> program was run many times. Small code changes and adaptions required many re-runs during the whole testing process. The final runs were performed from 2008-04-09 to 2008-04-22. They produced the text result files found in the downloadable package.</p><p>The text result files contain the raw time and speed numbers. Two different gnuplot scripts are included, which visualize the numbers to show different aspects.</p><p>The <a href="crypto-speedtest-0.1/results/"><code>results</code> directory</a> of the package contains PDFs named <code>&lt;cpu&gt;-&lt;distro&gt;.pdf</code> and <code>&lt;cpu&gt;-&lt;distro&gt;-all.pdf</code> (e.g. <code>p4-3200-gentoo.pdf</code>). These graphs read result files from only one run of all speedtests; the first plots contain the different ciphers contained in each library. The second part then groups the results by cipher: displaying the speed of the different libraries.</p><p>The PDFs <code>&lt;cpu&gt;-&lt;distro&gt;-all.pdf</code> contain all libraries and all ciphers run on a single CPU/distribution combination. These graphs contain 57 plot lines and are really full. Their size is trimmed to be printed on A4 paper.</p><p>To compare the different CPU/Distribution combinations against each other, two further PDFs are included: <code>sidebyside-comparison.pdf</code> and <code>distrospeed.pdf</code>.</p><p>The <code>sidebyside-comparison.pdf</code> contains eight plots on each page. The plots of all <code>&lt;cpu&gt;-&lt;distro&gt;.pdf</code> are grouped together and plots displaying the same cipher/libraries are put on one page. This way a direct side-by-side comparison can be done.</p><p>More individually the <code>distrospeed.pdf</code> contains plots which show the same library as run on different CPU/distro combinations. Not all combinations are included, only those run on my p4-3200 desktop computer are compared.</p><h3><a id="c04-s03-plotsflags"></a>4.3&nbsp; Compiler / Flags Test Program Runs and Plots (<code>results-flags</code>)</h3><p>The test runs to compare different compilers and compiler flag sets are also included in the package under a different results directory. The final runs of this result set were performed on 2008-05-26. All compiler tests were run on the same CPU / computer: p4-3200 - Pentium 4 3.2 GHz</p><p>The biggest issue was to automate compilation of both the speedtest code <em>and the cryptography libraries</em> with all the different flags and compilers. This was not done for all cryptography libraries, but only for Crypto++. It&apos;s configuration script was easy and allowed easy exact definition of the compiler and flags (other libraries&apos; configure stripped out or automatically added optimization flags). Crypto++ also provided project files for Visual C++.</p><p>The <a href="crypto-speedtest-0.1/results-flags/"><code>results-flags</code> directory</a> contains some compilation automation scripts and a perl/gnuplot script. The script calls gnuplot subprograms and feeds generated gnuplot command into the plotter to create the two PDFs named <code>flags.pdf</code> and <code>flags-gcc3.4.pdf</code>.</p><p><code>flags.pdf</code> is the primary result file and compares the different compilers and compiler flags for all the different ciphers available.</p><p><code>flags-gcc3.4.pdf</code> was only used to check MinGW&apos;s special <code>gcc 3.4.5</code> against the <code>gcc 3.4.6</code> on Gentoo Linux. Thus the timer resolution of Windows and Linux was double-checked so the results of Visual C++ are comparable to those run on Linux.</p><h2><a id="c05-discussion"></a>5&nbsp; Observation and Discussion</h2><p>This section describes the observations and results found in the different graphs. Please note that all these results are subjective and statistically irrelevant because of the small number of computers tested. However they do give insight into the problems of encryption performance.</p><p>All plot bitmaps in the following text are linked to their full-scale PDF originals.</p><h3><a id="c05-s01-cipher"></a>5.1&nbsp; Ciphers Compared</h3><p>The first set of plots contain straight-forward performance data of the different ciphers provided by each library.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=1"><img src="img/p4-3200-gentoo-01.jpg" alt="libgcrypt Ciphers: Absolute Time by Data Length" title="libgcrypt Ciphers: Absolute Time by Data Length" width="500" height="350" /></a></p><p>The plot above displays absolute time in seconds required to run one unit of the speed test. One speed test unit consists of encryption <i>and</i> decryption of a buffer with specific length. The length of the buffer tested is the value on the x-axis and ranges from 16 to 1024768 bytes. The buffer lengths are plotted logarithmically, meaning each step to the right actually doubles the length. This way the small length are also showed in detail. In the above graph the average absolute time and the standard deviation (only visible as the small horizontal dashes) are plotted.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=2"><img src="img/p4-3200-gentoo-02.jpg" alt="libgcrypt Ciphers: Speed by Data Length" title="libgcrypt Ciphers: Speed by Data Length" width="500" height="350" /></a></p><p>Much more informative is the above plot, which shows speed instead of absolute time. Where <code>speed = bytes / time</code>. The speed is displayed in megabyte per second. The above plot shows some ciphers available in the libgcrypt library.</p><p>First observations identifies Twofish to be the fastest cipher, once buffers are larger than about 9000 bytes. It achieves more than 20 MB/s throughput.</p><p>All ciphers require a start-up overhead, which explains the lower speed for small buffer. This start-up overhead mainly consists of cipher key-schedule context precalculations, but other things like library-overhead, memory-allocation and initialization also take their toll. Twofish and Blowfish need longest to start-up, all others are about the same. The start-up speed is visible in the graph by regarding how large a buffer must be to amortize the precalculations. This is where the plot line reaches it&apos;s horizontal value.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=6"><img src="img/p4-3200-gentoo-06.jpg" alt="Botan Ciphers: Speed by Data Length" title="Botan Ciphers: Speed by Data Length" width="500" height="350" /></a></p><p>The above plot shows the ciphers tested in the Botan library. This plot shows a totally different picture than the previous one. This time Blowfish is the &quot;winner&quot;. But, more important, <i>all</i> ciphers perform significantly better than the implementation in libgcrypt; of course one can only directly compare ciphers available in both libraries. Note the y-axis scale going up to 40 MB/s</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=8"><img src="img/p4-3200-gentoo-08.jpg" alt="Crypto++ Ciphers: Speed by Data Length" title="Crypto++ Ciphers: Speed by Data Length" width="500" height="350" /></a></p><p>Similar speeds are observable in the above plot of the ciphers from the Crypto++ library. Best performing cipher is again Blowfish with almost 50 MB/s throughput. However it is also the slowest to start-up and reach it&apos;s peak performance. All other ciphers perform similarly with their counterparts in the Botan library, with the exception of Serpent. For some reason Serpent is less than half as fast as in the Botan library.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=4"><img src="img/p4-3200-gentoo-04.jpg" alt="libmcrypt Ciphers: Speed by Data Length" title="libmcrypt Ciphers: Speed by Data Length" width="500" height="350" /></a></p><p>The real surprise of the speedtest is the above plot showing ciphers implemented in the libmcrypt library. The plot shows a massively higher start-up time for all ciphers in the library. Performance of libmcrypt for small buffers from 1000 to 10000 bytes is abysmally lower than for all other libraries. However after the start-up overhead is amortized, the cipher implementations reach the their expected speeds. I have no idea why libmcrypt has such an overhead during cipher allocation and initialization. This cannot be due to key schedule setup of similar cipher-related aspects, because they are common to all libraries. It must be something with (possibly special secure) memory allocation, cipher look-up, multi-thread mutex locking or other aspects of the library&apos;s organization. I rather not think about the myriads of web applications using libmcrypt via PHP to encrypt small bits of user data, which is stored in some SQL database.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=11"><img src="img/p4-3200-gentoo-11.jpg" alt="OpenSSL Ciphers: Speed by Data Length" title="OpenSSL Ciphers: Speed by Data Length" width="500" height="350" /></a></p><p>During my search for encryption libraries, I noted that the ubiquitous OpenSSL library also exports low-level cipher functions. Obviously the selection of ciphers in OpenSSL is directly linked to those required for SSL communication channels. It only provides 3DES, Blowfish, CAST5 and, in the newer OpenSSL versions, also AES. However the comparison of different libraries below will show that the relatively few cipher implementations in OpenSSL are highly optimized.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=13"><img src="img/p4-3200-gentoo-13.jpg" alt="Nettle Ciphers: Speed by Data Length" title="Nettle Ciphers: Speed by Data Length" width="500" height="350" /></a></p><p>The nettle library contains well-performing implementation of the most common ciphers.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=15"><img src="img/p4-3200-gentoo-15.jpg" alt="Tomcrypt Ciphers: Speed by Data Length" title="Tomcrypt Ciphers: Speed by Data Length" width="500" height="350" /></a></p><p>Last but one library in this first list is Tomcrypt. It contributes 11 ciphers to the speed test, some quite exotic like Noekeon, Skipjack and Anubis. Wikipedia brands Noekeon as a rather vulnerable cipher. Skipjack seems to have been a classified NSA cipher. Most interesting is Anubis which was (co-)created by the same person who initially designed AES (Rijndael).</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=17"><img src="img/p4-3200-gentoo-17.jpg" alt="Beecrypt Ciphers: Speed by Data Length" title="Beecrypt Ciphers: Speed by Data Length" width="500" height="350" /></a></p><p>Last library is Beecrypt, which contains only two block ciphers. Thus the data plot contains only two lines. These results appear again in a better context in the library comparison below.</p><h4><a id="c05-s01-p01-cipher-subconclusion"></a>5.1.1&nbsp; Sub-Conclusion</h4><p>So which is the fastest cipher? That is a difficult question to answer. The main problem is that all test results above were generated on Gentoo. Gentoo is a Linux distribution compiled from source on each installation. So each Gentoo installation is to some degree <i>different</i> from others because compiler flags, used system libraries and other aspects can change quickly.</p><p>This is why the real &quot;best&quot; cipher speed comparison table is postponed to one of following sections, in which different distributions are compared. Jump to the &quot;best cipher&quot; table if you are impatient.</p><p>The following table shows the maximum speed in KB/s of each cipher implementation:</p><table class="datatable1" style="text-align: right"> <caption>Table 4: Maximum Speed of Each Cipher</caption> <col span="1" class="liner" /> <tbody> <tr> <th></th> <th><a href="http://www.gnupg.org/">libgcrypt</a></th> <th><a href="http://mcrypt.sourceforge.net/">libmcrypt</a></th> <th><a href="http://botan.randombit.net/">Botan</a></th> <th><a href="http://www.cryptopp.com/">Crypto++</a></th> <th><a href="http://www.openssl.org/">OpenSSL</a></th> <th><a href="http://www.lysator.liu.se/%7Enisse/nettle/">Nettle</a></th> <th><a href="http://beecrypt.sourceforge.net/">Beecrypt</a></th> <th><a href="http://libtom.org/">Tomcrypt</a></th> <th>Average</th> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Blowfish_%28cipher%29">Blowfish</a></td> <td>6,765</td> <td>42,673</td> <td>38,828</td> <td>50,407</td> <td>56,510</td> <td>32,910</td> <td>52,751</td> <td>50,141</td> <td>41,373</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/CAST-128">CAST5 (128)</a></td> <td>22,061</td> <td>33,538</td> <td>36,306</td> <td>32,522</td> <td>34,775</td> <td>35,264</td> <td></td> <td>36,798</td> <td>33,037</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/NOEKEON">Noekeon</a></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>30,311</td> <td>30,312</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Twofish">Twofish</a></td> <td>24,947</td> <td>22,235</td> <td>26,160</td> <td>28,360</td> <td></td> <td>26,208</td> <td></td> <td>35,548</td> <td>27,243</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael AES</a></td> <td>13,925</td> <td>10,398</td> <td>21,917</td> <td>27,111</td> <td>45,461</td> <td>34,754</td> <td>23,684</td> <td>40,119</td> <td>27,171</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Anubis_%28cipher%29">Anubis</a></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>27,049</td> <td>27,049</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/XTEA">XTEA</a></td> <td></td> <td>21,168</td> <td>23,849</td> <td>20,603</td> <td></td> <td></td> <td></td> <td>26,882</td> <td>23,126</td> </tr> <tr> <td> <a href="http://en.wikipedia.org/wiki/CAST-256">CAST6 (256)</a></td> <td></td> <td>18,207</td> <td>13,298</td> <td>18,539</td> <td></td> <td></td> <td></td> <td></td> <td>16,681</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/GOST_28147-89">GOST</a></td> <td></td> <td>13,511</td> <td>17,943</td> <td>18,281</td> <td></td> <td></td> <td></td> <td></td> <td>16,578</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Serpent_%28cipher%29">Serpent</a></td> <td>7,004</td> <td>15,111</td> <td>30,268</td> <td>12,220</td> <td></td> <td>11,272</td> <td></td> <td></td> <td>15,175</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/LOKI97">Loki97</a></td> <td></td> <td>9,552</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>9,552</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Skipjack_%28cipher%29">Skipjack</a></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>6,928</td> <td>6,928</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Triple_DES">3DES</a></td> <td>5,195</td> <td>3,525</td> <td>6,979</td> <td>6,702</td> <td>11,940</td> <td>4,845</td> <td></td> <td>5,683</td> <td>6,410</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/SAFER">Safer+</a></td> <td></td> <td>4,886</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>7,075</td> <td>5,981</td> </tr> </tbody></table><h3><a id="c05-s02-library"></a>5.2&nbsp; Libraries Compared by Cipher</h3><p>The second set of plots compares the eight cryptography libraries against each other. One cipher is selected for comparison and all libraries providing this cipher are plotted into one chart. Obviously not all libraries provide all ciphers, so the plots have different amount of lines.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=18"><img src="img/p4-3200-gentoo-18.jpg" alt="Rijndael AES: Speed by Data Length" title="Rijndael AES: Speed by Data Length" width="500" height="350" /></a></p><p>The first cipher to compare is Rijndael (AES). It is provided in all eight libraries, plus one extra custom implementation. The custom implementation is basically the original Rijndael code as released by the author. The only modification was to adapted it into a convenient C++ class.</p><p>The plot shows that the different libraries vary greatly in performance. In the range from 10 MB/s to more than 40 MB/s the libraries&apos; performances are fairly distributed. Lowest in speed is libmcrypt, while the highest speed was achieved by OpenSSL. My custom implementation came in third. Start-up overhead was also highest in libmcrypt. Most other libraries show low start-up overhead.</p><p>All Rijndael implementations were verified against each other, which means that all work as expected and output the same cipher text for equal input. Thus the above results cannot show totally different calculations; the output is always the same.</p><p>This is maybe the most surprising result of the whole speed test: all cipher implementations&apos; calculation results are verified to be <em>exactly the same</em>, yet the performance of the tested libraries vary so greatly that this seems absurd.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=19"><img src="img/p4-3200-gentoo-19.jpg" alt="Serpent: Speed by Data Length" title="Serpent: Speed by Data Length" width="500" height="350" /></a></p><p>The second plot shows how fast the Serpent cipher is performed by the different libraries. For Serpent two different custom implementations are included. The first is optimized by Dr. Brian Gladman using different theoretic methods. The second was extracted from Botan, it will be used by my CryptoTE editor.</p><p>Serpent is a slower (and more secure) cipher than Rijndael. The average libraries all show a performance speed of less than 15 MB/s. However the big exception turned out to be Botan, showing almost twice the speed of all other libraries. With almost 30 MB/s it surpasses many Rijndael implementations. This is why I extracted it from Botan into a stand-alone C++ class for used in my programs. The speed of Botan was retained and for small buffers the start-up overhead introduced by Botan was eliminated. Whether this amazing performance is due to special CPU features or compiler flags will be discussed in the following sections.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=20"><img src="img/p4-3200-gentoo-20.jpg" alt="Twofish: Speed by Data Length" title="Twofish: Speed by Data Length" width="500" height="350" /></a></p><p>Twofish is another candidate from the AES-contest. It is implemented by six of the studied libraries. All show the same slow start-up of the cipher. It requires much preprocessing of the key material but achieves a higher throughput than Serpent for larger buffers. The speed achieved by all libraries is larger than 20 MB/s.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=21"><img src="img/p4-3200-gentoo-21.jpg" alt="Blowfish: Speed by Data Length" title="Blowfish: Speed by Data Length" width="500" height="350" /></a></p><p>Predecessor of Twofish is the Blowfish cipher. Implemented by all eight examined libraries, it shows a similar slow start-up like Twofish. After amortizing the start-up overhead, Blowfish performs faster than Twofish. However the two should not be compared directly, because they perform in different security classes: Blowfish is old and Twofish is much newer and is generally regareded as more secure.</p><p>With almost 50 MB/s, Beecrypt&apos;s Blowfish implementation presented the highest achieved speed in the complete speed test on Gentoo. Close behind are Crypto++, Tomcrypt and OpenSSL. Compared to 50 MB/s libgcrypt&apos;s speed of roughly 6 MB/s, even on large buffer sizes, is really bad.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=22"><img src="img/p4-3200-gentoo-22.jpg" alt="CAST5: Speed by Data Length" title="CAST5: Speed by Data Length" width="500" height="350" /></a></p><p>The cipher CAST5 is rather old, but still used e.g. by PGP / GnuPG for symmetric encryption. It is implemented by all libraries except beecrypt. This time all libraries perform similarly with an average speed of around 32 MB/s. Only libgcrypt falls out of the line.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/p4-3200-gentoo.pdf#page=23"><img src="img/p4-3200-gentoo-23.jpg" alt="Triple DES: Speed by Data Length" title="Triple DES: Speed by Data Length" width="500" height="350" /></a></p><p>Last cipher to be compared is 3DES. Triple DES is very old compared to the others, however it is still widely used in VPN, SSL and hardware circuits. It is implemented by all libraries except beecrypt. Most unexpected is the speed of OpenSSL&apos;s implementation of 3DES. It beats all others by far. Obviously much optimization has been put into this implementation, probably because 3DES is one the encryption ciphers routinely used for SSL connections.</p><h4><a id="c05-s02-p01-library-subconclusion"></a>5.2.1&nbsp; Sub-Conclusion</h4><p>So which is the best / fastest library? That question can be answered here only for the Gentoo distribution. Comparing the libraries on Gentoo has the advantage, that Gentoo begin source-compiled can enable all optimizations and does not introduce performance problems imposed by pre-compiled binary packages or other problems, which the binary package maintainer may have created.</p><p>However how to compare a library like beecrypt which implements only two ciphers to a library which implements eleven ciphers? Obviously only the ciphers actually available can be scored. The scoring analysis was done as follows: First the average speed for each cipher was calculated. Then each library&apos;s speed delta (difference to the average) was regarded and added up. Thus the total difference all implemented ciphers was taken for the following ranking. Note that in this analysis, if a cipher is implemented by only one library, the cipher adds zero score to the total. All speeds are in KB/s:</p><table class="datatable1" style="text-align: right; font-size: smaller"> <caption>Table 5: Library Speed Compared to Average</caption> <col span="1" class="liner" /> <tr> <th>p4-3200-gentoo</th> <th>Custom</th> <th><a href="http://www.openssl.org/">OpenSSL</a></th> <th><a href="http://beecrypt.sourceforge.net/">Beecrypt</a></th> <th><a href="http://libtom.org/">Tomcrypt</a></th> <th><a href="http://botan.randombit.net/">Botan</a></th> <th><a href="http://www.cryptopp.com/">Crypto++</a></th> <th><a href="http://www.lysator.liu.se/%7Enisse/nettle/">Nettle</a></th> <th><a href="http://mcrypt.sourceforge.net/">libmcrypt</a></th> <th><a href="http://www.gnupg.org/">libgcrypt</a></th> <th>Average</th> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Blowfish_%28cipher%29">Blowfish</a></td> <td>&nbsp;</td> <td>47,299 / +6,884</td> <td>52,662 / +12,247</td> <td>49,685 / +9,269</td> <td>40,781 / +365</td> <td>50,448 / +10,033</td> <td>32,170 / -8,246</td> <td>44,355 / +3,940</td> <td>5,922 / -34,493</td> <td>40,415</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/CAST-128">CAST5 (128)</a></td> <td>&nbsp;</td> <td>37,528 / +4,480</td> <td>&nbsp;</td> <td>41,494 / +8,446</td> <td>36,062 / +3,014</td> <td>32,018 / -1,030</td> <td>35,514 / +2,466</td> <td>33,618 / +570</td> <td>15,103 / -17,945</td> <td>33,048</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/NOEKEON">Noekeon</a></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>31,621 / +0</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>31,621</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Anubis_%28cipher%29">Anubis</a></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>27,898 / +0</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>27,898</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael AES</a></td> <td>35,817 / +7,929</td> <td>44,153 / +16,265</td> <td>23,588 / -4,300</td> <td>40,245 / +12,356</td> <td>21,807 / -6,082</td> <td>27,155 / -734</td> <td>34,625 / +6,737</td> <td>10,145 / -17,743</td> <td>13,459 / -14,429</td> <td>27,888</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Twofish">Twofish</a></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>36,545 / +9,462</td> <td>26,189 / -894</td> <td>28,224 / +1,141</td> <td>25,903 / -1,180</td> <td>23,352 / -3,731</td> <td>22,283 / -4,799</td> <td>27,082</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/XTEA">XTEA</a></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>26,910 / +3,768</td> <td>23,844 / +702</td> <td>20,595 / -2,547</td> <td>&nbsp;</td> <td>21,218 / -1,924</td> <td>&nbsp;</td> <td>23,142</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/KHAZAD">Khazad</a></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>17,221 / +0</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>17,221</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/GOST_28147-89">GOST</a></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>17,912 / +735</td> <td>18,736 / +1,559</td> <td>&nbsp;</td> <td>14,885 / -2,293</td> <td>&nbsp;</td> <td>17,178</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Serpent_(cipher)">Serpent</a></td> <td>29,171 / +12,112</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>30,775 / +13,715</td> <td>12,266 / -4,794</td> <td>10,914 / -6,145</td> <td>14,962 / -2,097</td> <td>6,910 / -10,149</td> <td>17,059</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/CAST-256">CAST6 (256)</a></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>13,349 / -3,647</td> <td>18,824 / +1,827</td> <td>&nbsp;</td> <td>18,816 / +1,820</td> <td>&nbsp;</td> <td>16,996</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/LOKI97">Loki97</a></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>9,637 / +0</td> <td>&nbsp;</td> <td>9,637</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Skipjack_%28cipher%29">Skipjack</a></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>8,683 / +0</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>8,683</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/Triple_DES">3DES</a></td> <td>&nbsp;</td> <td>12,070 / +5,649</td> <td>&nbsp;</td> <td>5,644 / -776</td> <td>6,698 / +277</td> <td>6,744 / +323</td> <td>4,940 / -1,481</td> <td>3,834 / -2,587</td> <td>5,015 / -1,406</td> <td>6,421</td> </tr> <tr> <td><a href="http://en.wikipedia.org/wiki/SAFER">Safer+</a></td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>3,463 / -712</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>4,888 / +712</td> <td>&nbsp;</td> <td>4,175</td> </tr> <tr> <td class="linet">Delta Sum</td> <td class="linet">+20,041</td> <td class="linet">+33,278</td> <td class="linet">+7,947</td> <td class="linet">+41,813</td> <td class="linet">+8,186</td> <td class="linet">+5,779</td> <td class="linet">-7,848</td> <td class="linet">-23,332</td> <td class="linet">-83,221</td> <td class="linet">&nbsp;</td> </tr> <tr> <td>Delta Average</td> <td>+10,020</td> <td>+8,320</td> <td>+3,974</td> <td>+3,801</td> <td>+910</td> <td>+642</td> <td>-1,308</td> <td>-2,121</td> <td>-13,870</td> <td>&nbsp;</td> </tr></table><p>The winning &quot;library&quot; are my custom implementations. No surprise there, I wouldn&apos;t have included them in the test if they were slow.</p><p>So the real winner is OpenSSL. It&apos;s implementations are on average 8,320 KB/s faster than the average implementation. Second and third place are very close and go to Beecrypt and Tomcrypt.</p><h3><a id="c05-s03-distro"></a>5.3&nbsp; Findings On Different Distributions</h3><p>First problem of the last two sections was that all libraries were taken from my Gentoo system. Gentoo however is a distribution where all packages are compiled from source using individual compiler flags. This approach is not shared by most other Linux distributions, which ship pre-compiled binary packages.</p><p>So are the finding above specific to my Gentoo system? Or even to the flags specified in my configurations?</p><p>To clarify this issue, five other Linux distributions were installed in chroot jails on the same computer. The speed test compiled in the chroot thus use the binary-distributed library versions.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/distrospeed.pdf#page=1"><img src="img/distrospeed-01.jpg" alt="libgcrypt Ciphers: Speed by Data Length" title="libgcrypt Ciphers: Speed by Data Length" width="500" height="707" /></a></p><p>The chart above plots the selected ciphers from libgcrypt run on the six Linux distributions on the same CPU. Each cipher has one distinct color and the six distributions are distinguished through the different line styles, solid dashed, dot-line-dot, etc. (Click on the plot for a zoomable PDF.)</p><p>One can see that some ciphers, that is Rijndael, Serpent and Blowfish, perform very similar on all platforms: their colored lines follow about the same path. Twofish too performs similar on all distributions except on Gentoo, probably due to extra compiler optimization. CAST5 shows a rather large variation of speeds; CAST5 also has large standard deviations compared to the others. 3DES also shows a rather large speed range.</p><p>All in all, no real surprises are in the above chart. Maybe the most strange is that compiler-optimized Gentoo (the solid line) performs a lot better on Twofish but also a lot worse on CAST5.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/distrospeed.pdf#page=2"><img src="img/distrospeed-02.jpg" alt="libmcrypt Ciphers: Speed by Data Length" title="libmcrypt Ciphers: Speed by Data Length" width="500" height="707" /></a></p><p>Next library above is libmcrypt. This chart verifies that mcrypt has very slow start-up times and not only on Gentoo, but on all distributions. The chart excludes some cipher (XTEA, Safer+ and Loki97) to increase readability. Again some ciphers show very little variation in throughput speed: Rijndael, CAST6 and 3DES. All others also show no great surprises.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/distrospeed.pdf#page=3"><img src="img/distrospeed-03.jpg" alt="Botan Ciphers: Speed by Data Length" title="Botan Ciphers: Speed by Data Length" width="400" height="566" /></a><a href="crypto-speedtest-0.1/results/distrospeed.pdf#page=7"><img src="img/distrospeed-07.jpg" alt="Tomcrypt Ciphers: Speed by Data Length" title="Tomcrypt Ciphers: Speed by Data Length" width="400" height="566" /></a></p><p>Botan and Tomcrypt show the same effects. Some cipher implementations perform nearly equivalently on all distributions, others show a larger but no huge variation.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/distrospeed.pdf#page=4"><img src="img/distrospeed-04.jpg" alt="Crypto++ Ciphers: Speed by Data Length" title="Crypto++ Ciphers: Speed by Data Length" width="400" height="566" /></a><a href="crypto-speedtest-0.1/results/distrospeed.pdf#page=6"><img src="img/distrospeed-06.jpg" alt="Nettle Ciphers: Speed by Data Length" title="Nettle Ciphers: Speed by Data Length" width="400" height="566" /></a></p><p>The corresponding chart for Crypto++ is very full and shows a wide variation even of ciphers previously unvarying. Crypto++ seems to be very sensitive to optimization. Nettle&apos;s chart shows the same observations as before.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/distrospeed.pdf#page=5"><img src="img/distrospeed-05.jpg" alt="OpenSSL Ciphers: Speed by Data Length" title="OpenSSL Ciphers: Speed by Data Length" width="400" height="566" /></a><a href="crypto-speedtest-0.1/results/distrospeed.pdf#page=8"><img src="img/distrospeed-08.jpg" alt="Beecrypt Ciphers: Speed by Data Length" title="Beecrypt Ciphers: Speed by Data Length" width="400" height="566" /></a></p><p>The two remaining library are OpenSSL and Beecrypt. OpenSSL shows that it&apos;s cipher implementations perform almost unvaryingly well on all distributions. This promises good performance for SSL secure sockets on all distributions.</p><p>Beecrypt shows only one new aspect: the Blowfish implementation on Debian-lenny shows a serious fall as compared to Debian-etch. This is probably due to the gcc compiler version change to 4.2. More about compilers and compiler flags later.</p><h4><a id="c05-s03-p01-distro-subconclusion"></a>5.3.1&nbsp; Sub-Conclusion</h4><p>So which distribution performs best? To analyze this question, the speed table was created for each distribution. It contains the maximum value of each plot, the maximum speed the cipher reached. Then the average speed of all cipher / library test runs performed on one Linux distribution is calculated. The table below shows this average and the average over all test runs. The values below the average are (minimum - maximum) speed across all ciphers implemented in the library. Again all values are in KB/s.</p><table class="datatable1" style="text-align: right; font-size: smaller"> <caption>Table 6: Average Library Performance on Different Distributions with Range</caption> <col span="1" class="liner" /> <thead> <tr> <th></th> <th>gcrypt</th> <th>mcrypt</th> <th>botan</th> <th>cryptopp</th> <th>openssl</th> <th>nettle</th> <th>beecrypt</th> <th>tomcrypt</th> <th>custom</th> <th>average</th> <th>relative</th> </tr> </thead> <tbody> <tr> <td class="hide">p4-3200-gentoo</td> <td class="hide">11,449</td> <td class="hide">18,155</td> <td class="hide">24,157</td> <td class="hide">23,890</td> <td class="hide">35,263</td> <td class="hide">24,011</td> <td class="hide">38,125</td> <td class="hide">26,310</td> <td class="hide">32,494</td> <td class="hide">23,610</td> <td class="hide">100%</td> </tr> <tr style="font-size: smaller"> <td></td> <td>(5,015 - 22,283)</td> <td>(3,834 - 44,355)</td> <td>(6,698 - 40,781)</td> <td>(6,744 - 50,448)</td> <td>(12,070 - 47,299)</td> <td>(4,940 - 35,514)</td> <td>(23,588 - 52,662)</td> <td>(3,463 - 49,685)</td> <td>(29,171 - 35,817)</td> <td></td> <td></td> </tr> <tr> <td class="hide">p4-3200-ubuntu-hardy</td> <td class="hide">12,192</td> <td class="hide">18,175</td> <td class="hide">20,412</td> <td class="hide">24,390</td> <td class="hide">33,743</td> <td class="hide">19,161</td> <td class="hide">36,411</td> <td class="hide">28,477</td> <td class="hide">32,077</td> <td class="hide">22,941</td> <td class="hide">2.8%</td> </tr> <tr style="font-size: smaller"> <td></td> <td>(6,490 - 19,975)</td> <td>(3,468 - 40,554)</td> <td>(6,007 - 39,000)</td> <td>(3,304 - 41,518)</td> <td>(11,707 - 45,198)</td> <td>(2,438 - 30,706)</td> <td>(23,285 - 49,538)</td> <td>(3,570 - 52,340)</td> <td>(26,935 - 37,219)</td> <td></td> <td></td> </tr> <tr> <td class="hide">p4-3200-debian-lenny</td> <td class="hide">12,384</td> <td class="hide">15,044</td> <td class="hide">20,480</td> <td class="hide">24,459</td> <td class="hide">33,179</td> <td class="hide">21,071</td> <td class="hide">25,094</td> <td class="hide">28,290</td> <td class="hide">31,819</td> <td class="hide">22,140</td> <td class="hide">6.2%</td> </tr> <tr style="font-size: smaller"> <td></td> <td>(6,564 - 20,171)</td> <td>(3,017 - 32,796)</td> <td>(5,920 - 38,985)</td> <td>(3,345 - 41,500)</td> <td>(11,972 - 45,110)</td> <td>(2,393 - 34,414)</td> <td>(23,591 - 26,597)</td> <td>(3,523 - 52,293)</td> <td>(27,296 - 36,341)</td> <td></td> <td></td> </tr> <tr> <td class="hide">p4-3200-ubuntu-gutsy</td> <td class="hide">11,261</td> <td class="hide">18,176</td> <td class="hide">19,759</td> <td class="hide">18,051</td> <td class="hide">33,844</td> <td class="hide">20,928</td> <td class="hide">36,354</td> <td class="hide">26,544</td> <td class="hide">31,904</td> <td class="hide">21,620</td> <td class="hide">8.4%</td> </tr> <tr style="font-size: smaller"> <td></td> <td>(3,804 - 21,024)</td> <td>(3,461 - 40,597)</td> <td>(6,296 - 37,651)</td> <td>(4,336 - 31,028)</td> <td>(11,878 - 45,176)</td> <td>(2,434 - 34,379)</td> <td>(23,293 - 49,416)</td> <td>(3,036 - 51,821)</td> <td>(28,183 - 35,626)</td> <td></td> <td></td> </tr> <tr> <td class="hide">p4-3200-fedora8</td> <td class="hide">11,140</td> <td class="hide">17,069</td> <td class="hide">23,755</td> <td class="hide">19,249</td> <td class="hide">32,225</td> <td class="hide">25,121</td> <td class="hide">32,960</td> <td class="hide">21,229</td> <td class="hide">29,038</td> <td class="hide">21,313</td> <td class="hide">9.7%</td> </tr> <tr style="font-size: smaller"> <td></td> <td>(2,246 - 20,412)</td> <td>(3,337 - 41,066)</td> <td>(7,311 - 35,071)</td> <td>(7,241 - 34,668)</td> <td>(11,974 - 45,253)</td> <td>(3,868 - 43,517)</td> <td>(20,742 - 45,177)</td> <td>(3,051 - 47,499)</td> <td>(24,503 - 33,573)</td> <td></td> <td></td> </tr> <tr> <td class="hide">p4-3200-debian-etch</td> <td class="hide">10,899</td> <td class="hide">15,049</td> <td class="hide">18,898</td> <td class="hide">12,523</td> <td class="hide">33,814</td> <td class="hide">21,324</td> <td class="hide">36,537</td> <td class="hide">26,862</td> <td class="hide">32,630</td> <td class="hide">20,179</td> <td class="hide">14.5%</td> </tr> <tr style="font-size: smaller"> <td></td> <td>(3,660 - 19,020)</td> <td>(2,990 - 32,804)</td> <td>(6,425 - 32,452)</td> <td>(4,439 - 42,647)</td> <td>(11,805 - 45,298)</td> <td>(2,559 - 34,795)</td> <td>(23,517 - 49,558)</td> <td>(3,448 - 51,800)</td> <td>(29,106 - 36,155)</td> <td></td> <td></td> </tr> </tbody></table><p>Obviously Gentoo is the fastest distribution. No surprise here, the libraries were compiled from source with high optimization levels.</p><p>The only other result seen here is that &quot;newer&quot; distributions (ubuntu-hardy and debian-lenny) perform better than older one. This is probably due to the compiler version bump from <code>gcc 3.4.x</code> to <code>gcc 4.1.x</code>. More about that in the section <a href="#c05-s05-flags">Compiler and Optimization Flags</a>.</p><p>See the external table file for a detailed <a href="distro-speed.html">speed table listing for all distributions</a>.</p><h3><a id="c05-s04-cpu"></a>5.4&nbsp; Ciphers compared by CPU</h3><p>The tests discussed in the last three sections (ciphers, libraries and distribution comparisons) were all performed on my development computer. It has a Pentium 4 CPU at 3.2 GHz. To determine if any of the previous results are due to special attributes of the Pentium 4 architecture, the speed test was repeated on four other CPUs / computers. To make the comparison independent of the Linux distribution, Debian etch was installed on all computers (chrooted on some). The plots below display results of the speed test on the five CPUs side by side. The sixth plot shows results from my Pentium 4 run with Gentoo, instead of Debian etch; these are the same plots as in the section &quot;<a href="#c05-s01-cipher">Ciphers Compared</a>&quot; just for comparison.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/cpu-sidebyside-comparison-3x2.pdf#page=2"><img src="img/cpu-sidebyside-comparison-3x2-02.jpg" alt="libgcrypt Ciphers: Speed by Data Length" title="libgcrypt Ciphers: Speed by Data Length" width="800" height="378" /></a></p><p>Again we address libgcrypt&apos;s results first. All five results from Debian etch look similar. From p2-300 to p3-1000 the cipher&apos;s speed increases twofold (Rijndael from 2 MB/s to 7 MB/s), but all relative speeds are unchanged. Also cel-2660 and p4-3200 show very much the same picture, scaled only by the increased CPU speed. Yet these two charts pairs (p2-300/p3-1000 vs. cel-2660/p4-3200) show different relative speeds: most obvious Twofish is best on p2-300/p3-1000 but CAST5 wins on cel-2660/p4-3200. More interesting is the fact that the three ciphers Blowfish, Serpent and 3DES don&apos;t scale with CPU speed as well as the other three do. ath-2000 shows a third picture, different from p2-300/p3-1000 and cel-2660/p4-3200. 3DES and Serpent are actually faster on the ath-2000 than on p4-3200. These implementation seem to work better with AMD&apos;s CPUs than Intel&apos;s.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/cpu-sidebyside-comparison-3x2.pdf#page=4"><img src="img/cpu-sidebyside-comparison-3x2-04.jpg" alt="libmcrypt Ciphers: Speed by Data Length" title="libmcrypt Ciphers: Speed by Data Length" width="800" height="378" /></a></p><p>On all CPUs libmcrypt on Debian etch shows the same slow start-up. Since this rules out the library for almost all purposes, I will not go into more detail on the CPU comparison.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/cpu-sidebyside-comparison-3x2.pdf#page=6"><img src="img/cpu-sidebyside-comparison-3x2-06.jpg" alt="Botan Ciphers: Speed by Data Length" title="Botan Ciphers: Speed by Data Length" width="800" height="378" /></a></p><p>Next we regard a faster library: Botan. Again the CPUs&apos; results form three distinct groups with equal relative speeds: p2-300/p3-1000, cel-2660/p4-3200 and ath-2000. But compared to libgcrypt the relative speeds change less: only Serpent and Twofish show large changes from CPU to CPU. Again ath-2000 shows better relative speed results for these cipher than the faster CPUs cel-2660/p4-3200. Interesting is also the comparison of Debian etch with Gentoo on the p4-3200: the plots show almost equal relative performance with Gentoo&apos;s higher optimization; with one exception: Serpent performs four times as fast on Gentoo.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/cpu-sidebyside-comparison-3x2.pdf#page=8"><img src="img/cpu-sidebyside-comparison-3x2-08.jpg" alt="Crypto++ Ciphers: Speed by Data Length" title="Crypto++ Ciphers: Speed by Data Length" width="800" height="378" /></a></p><p>Crypto++ is the next library in the speedtest. We already saw that Crypto++ is very sensitive to optimization flags. Looking at the five charts, p3-1000 immediately falls into the eye: Twofish is the fastest cipher only on that CPU, all others show very high Blowfish speeds instead. Blowfish is almost twice as fast on those CPUs than the next fastest cipher: Rijndael. For a more detailed analysis the above plots were regenerated without the Blowfish data set.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/cpu-sidebyside-comparison-3x2.pdf#page=9"><img src="img/cpu-sidebyside-comparison-3x2-09.jpg" alt="OpenSSL Ciphers: Speed by Data Length" title="OpenSSL Ciphers: Speed by Data Length" width="800" height="378" /></a></p><p>Without Blowfish the other ciphers show almost equal relative performance on the four CPUs p2-300, ath-2000, cel-2660, p4-3200. But even on the other ciphers the CPU p3-1000 performs differently. Most notably the Twofish cipher reaches almost 12 MB/s on p3-1000, but only 5 MB/s on ath-2000. Why this CPU walks out of the line is beyond me.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/cpu-sidebyside-comparison-3x2.pdf#page=11"><img src="img/cpu-sidebyside-comparison-3x2-11.jpg" alt="Nettle Ciphers: Speed by Data Length" title="Nettle Ciphers: Speed by Data Length" width="800" height="378" /></a></p><p>OpenSSL&apos;s highly optimized cipher implementations perform very well on all tested CPUs. Again this promises very good SSL socket speeds on all x86 CPUs. No further important observations are found on these charts.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/cpu-sidebyside-comparison-3x2.pdf#page=13"><img src="img/cpu-sidebyside-comparison-3x2-13.jpg" alt="Tomcrypt Ciphers: Speed by Data Length" title="Tomcrypt Ciphers: Speed by Data Length" width="800" height="378" /></a></p><p>Beecrypt&apos;s results can again be grouped into three similar charts: p2-300/p3-1000, ath-2000 and cel-2660/p4-3200. Like on libgcrypt, some ciphers (Serpent, 3DES) do not speed-up as well as others: Rijndael, CAST5, Blowfish and Twofish utilize the faster CPUs better. And the Athlon does a better job with the less-scalable ciphers than Intel&apos;s CPUs.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results/cpu-sidebyside-comparison-3x2.pdf#page=15"><img src="img/cpu-sidebyside-comparison-3x2-15.jpg" alt="Beecrypt Ciphers: Speed by Data Length" title="Beecrypt Ciphers: Speed by Data Length" width="800" height="378" /></a></p><p>Tomcrypt shows the same results as already seen on libgcrypt, Beecrypt and less prominently on the other result comparisons.</p><h4><a id="c05-s04-p01-cpu-subconclusion"></a>5.4.1&nbsp; Sub-Conclusion</h4><p>What do we conclude from the cross-CPU examination? First and most important point is that the performance of an individual cipher does not depend on specific the CPU architecture. The speed usually scales well with CPU speed. However there are exceptions: some cipher implementations do not scale as well as others. Most often 3DES and Serpent show less relative performance gain.</p><p>Second interesting point is to determine the cipher which scales best. This requires a short calculation, because we need to account for the CPU&apos;s speedup. Thus the first step is to calculate the relative speed-up of each CPU. So first the average speed over all speed tests on all CPUs is taken: all-average in the following table. Then the average speed over all tests on each individual CPU is calculated and from that the relative speed to all-average is calculated: e.g. p3-1000 reaches only 65.2% of the all-average speed.</p><table class="datatable1" style="text-align: right; font-size: smaller"> <caption>Table 7: Average CPU / Computer Performance</caption> <col span="1" class="liner" /> <thead> <tr> <th>&nbsp;</th> <th>average</th> <th>relative</th> </tr> </thead> <tbody> <tr> <td>all-average</td> <td>11,609</td> <td>&nbsp;</td> </tr> <tr> <td>p2-300-debian-etch</td> <td>2,053</td> <td>17.7%</td> </tr> <tr> <td>p3-1000-debian-etch</td> <td>7,574</td> <td>65.2%</td> </tr> <tr> <td>ath-2000-debian-etch</td> <td>11,591</td> <td>99.8%</td> </tr> <tr> <td>cel-2660-debian-etch</td> <td>16,645</td> <td>143.4%</td> </tr> <tr> <td>p4-3200-debian-etch</td> <td>20,179</td> <td>173.8%</td> </tr> </tbody></table><p>Then the average performance of each cipher is calculated again across all CPUs and for each CPU individually. Of course only the libraries are taken into account which actually implement the cipher.</p><p>In the last step, for each cipher to average performance of all CPUs is scaled down by the speed-up multiplier calculated above to get the <em>linear scaled, expected</em> speed of the cipher. This expected speed is then compared to the actually measured speed: negative values show less than expected speed, positive show a larger speed-up. The difference is shown in the table below, the sum of all differenced to the expected performance signifies how well the CPU is suited for (the tested) cryptography algorithms.</p><table class="datatable1" style="text-align: right; font-size: smaller"> <caption>Table 8: Cipher Performance Across All Tested CPUs / Computers</caption> <col span="1" class="liner" /> <thead> <tr> <th>&nbsp;</th> <th>average</th> <th>cast5</th> <th>cast6</th> <th>3des</th> <th>blowfish</th> <th>rijndael</th> <th>xtea</th> <th>twofish</th> <th>serpent</th> <th>total</th> </tr> </thead> <tbody> <tr> <td class="hide">all-average</td> <td class="hide">11,609</td> <td class="hide">15,525</td> <td class="hide">7,356</td> <td class="hide">3,281</td> <td class="hide">20,369</td> <td class="hide">15,348</td> <td class="hide">9,869</td> <td class="hide">13,607</td> <td class="hide">6,732</td> <td class="hide">&nbsp;</td> </tr> <tr> <td>relative to average</td> <td>&nbsp;</td> <td>133.7%</td> <td>63.4%</td> <td>28.3%</td> <td>175.5%</td> <td>132.2%</td> <td>85.0%</td> <td>117.2%</td> <td>58.0%</td> <td>&nbsp;</td> </tr> <tr> <td class="hide">p2-300-debian-etch</td> <td class="hide">2,053</td> <td class="hide">2,714</td> <td class="hide">1,332</td> <td class="hide">605</td> <td class="hide">3,459</td> <td class="hide">2,705</td> <td class="hide">1,584</td> <td class="hide">2,596</td> <td class="hide">1,336</td> <td class="hide">&nbsp;</td> </tr> <tr> <td class="hide">expected</td> <td class="hide">17.7%</td> <td class="hide">2,746</td> <td class="hide">1,301</td> <td class="hide">580</td> <td class="hide">3,603</td> <td class="hide">2,715</td> <td class="hide">1,746</td> <td class="hide">2,407</td> <td class="hide">1,191</td> <td class="hide">&nbsp;</td> </tr> <tr> <td>difference</td> <td>&nbsp;</td> <td>-32</td> <td>30</td> <td>24</td> <td>-144</td> <td>-10</td> <td>-162</td> <td>189</td> <td>145</td> <td>41</td> </tr> <tr> <td class="hide">p3-1000-debian-etch</td> <td class="hide">7,574</td> <td class="hide">9,597</td> <td class="hide">5,617</td> <td class="hide">1,988</td> <td class="hide">12,335</td> <td class="hide">9,647</td> <td class="hide">5,921</td> <td class="hide">10,558</td> <td class="hide">5,326</td> <td class="hide">&nbsp;</td> </tr> <tr> <td class="hide">expected</td> <td class="hide">65.2%</td> <td class="hide">10,130</td> <td class="hide">4,800</td> <td class="hide">2,141</td> <td class="hide">13,291</td> <td class="hide">10,014</td> <td class="hide">6,439</td> <td class="hide">8,878</td> <td class="hide">4,392</td> <td class="hide">&nbsp;</td> </tr> <tr> <td>difference</td> <td>&nbsp;</td> <td>-532</td> <td>817</td> <td>-153</td> <td>-955</td> <td>-367</td> <td>-518</td> <td>1,680</td> <td>933</td> <td>905</td> </tr> <tr> <td class="hide">ath-2000-debian-etch</td> <td class="hide">11,591</td> <td class="hide">15,162</td> <td class="hide">7,015</td> <td class="hide">3,404</td> <td class="hide">20,625</td> <td class="hide">14,602</td> <td class="hide">9,387</td> <td class="hide">13,534</td> <td class="hide">8,715</td> <td class="hide">&nbsp;</td> </tr> <tr> <td class="hide">expected</td> <td class="hide">99.8%</td> <td class="hide">15,501</td> <td class="hide">7,345</td> <td class="hide">3,276</td> <td class="hide">20,338</td> <td class="hide">15,324</td> <td class="hide">9,854</td> <td class="hide">13,586</td> <td class="hide">6,721</td> <td class="hide">&nbsp;</td> </tr> <tr> <td>difference</td> <td>&nbsp;</td> <td>-340</td> <td>-330</td> <td>128</td> <td>287</td> <td>-723</td> <td>-467</td> <td>-52</td> <td>1,994</td> <td>497</td> </tr> <tr> <td class="hide">cel-2660-debian-etch</td> <td class="hide">16,645</td> <td class="hide">22,688</td> <td class="hide">10,292</td> <td class="hide">4,813</td> <td class="hide">29,502</td> <td class="hide">22,529</td> <td class="hide">14,659</td> <td class="hide">18,718</td> <td class="hide">8,255</td> <td class="hide">&nbsp;</td> </tr> <tr> <td class="hide">expected</td> <td class="hide">143.4%</td> <td class="hide">22,260</td> <td class="hide">10,548</td> <td class="hide">4,704</td> <td class="hide">29,207</td> <td class="hide">22,007</td> <td class="hide">14,151</td> <td class="hide">19,510</td> <td class="hide">9,652</td> <td class="hide">&nbsp;</td> </tr> <tr> <td>difference</td> <td>&nbsp;</td> <td>428</td> <td>-256</td> <td>108</td> <td>295</td> <td>523</td> <td>508</td> <td>-792</td> <td>-1,397</td> <td>-583</td> </tr> <tr> <td class="hide">p4-3200-debian-etch</td> <td class="hide">20,179</td> <td class="hide">27,463</td> <td class="hide">12,526</td> <td class="hide">5,595</td> <td class="hide">35,925</td> <td class="hide">27,256</td> <td class="hide">17,795</td> <td class="hide">22,626</td> <td class="hide">10,026</td> <td class="hide">&nbsp;</td> </tr> <tr> <td class="hide">expected</td> <td class="hide">173.8%</td> <td class="hide">26,986</td> <td class="hide">12,787</td> <td class="hide">5,703</td> <td class="hide">35,407</td> <td class="hide">26,679</td> <td class="hide">17,155</td> <td class="hide">23,652</td> <td class="hide">11,702</td> <td class="hide">&nbsp;</td> </tr> <tr> <td class="lineb">difference</td> <td class="lineb">&nbsp;</td> <td class="lineb">476</td> <td class="lineb">-261</td> <td class="lineb">-108</td> <td class="lineb">517</td> <td class="lineb">577</td> <td class="lineb">639</td> <td class="lineb">-1,026</td> <td class="lineb">-1,676</td> <td class="lineb">-860</td> </tr> <tr> <td class="hide">min</td> <td class="hide">&nbsp;</td> <td class="hide">-532</td> <td class="hide">-330</td> <td class="hide">-153</td> <td class="hide">-955</td> <td class="hide">-723</td> <td class="hide">-518</td> <td class="hide">-1,026</td> <td class="hide">-1,676</td> <td class="hide">&nbsp;</td> </tr> <tr> <td class="hide">max</td> <td class="hide">&nbsp;</td> <td class="hide">476</td> <td class="hide">817</td> <td class="hide">128</td> <td class="hide">517</td> <td class="hide">577</td> <td class="hide">639</td> <td class="hide">1,680</td> <td class="hide">1,994</td> <td class="hide">&nbsp;</td> </tr> <tr> <td>normalized min</td> <td>&nbsp;</td> <td>-398</td> <td>-521</td> <td>-541</td> <td>-544</td> <td>-547</td> <td>-610</td> <td>-875</td> <td>-2,890</td> <td>&nbsp;</td> </tr> <tr> <td class="hide">range</td> <td class="hide">&nbsp;</td> <td class="hide">1,009</td> <td class="hide">1,148</td> <td class="hide">281</td> <td class="hide">1,473</td> <td class="hide">1,300</td> <td class="hide">1,158</td> <td class="hide">2,706</td> <td class="hide">3,670</td> <td class="hide">&nbsp;</td> </tr> <tr> <td>normalized range</td> <td>&nbsp;</td> <td>754</td> <td>1,811</td> <td>993</td> <td>839</td> <td>984</td> <td>1,362</td> <td>2,309</td> <td>6,329</td> <td>&nbsp;</td> </tr> </tbody></table><p>From the differences to the expected performance the cipher best suited for all tested CPU can be determined: the worst-case is compared (highest negative performance speed-up). However because the min values are in KB/s speed a direct comparison is not valid: faster ciphers bring larger differences to the expected speed. The minimum speed difference has to be normalized by the average cipher&apos;s speed to allow a direct comparison. The same normalization is done for the (min - max) range size, which shows how large the cipher&apos;s speed fluctuation is.</p><p>So obviously p3-1000 is the CPU most suited for cipher algorithms. It performs on average 113 KB/s faster than the others. However compared to the actual speed of 2-10 MB/s this speed-up is not substantial.</p><p>The cipher performing best relative to all CPUs is CAST5. It has the least break-in of speed when run on all CPUs. Next are CAST6 and 3DES, which also show solid performance regardless of the CPU. Most fragile to CPU architecture is Serpent; it shows almost 1.676 kB/s less speed on the p4-3200 than expected.</p><p>Surprising is that 3DES shows the least fluctuation: the range of its speed differences is only 281 KB/s. On all CPUs 3DES performs almost exactly as expected by the average. However relative to 3DES&apos;s slow speed this range is not that small. The normalized ranges of CAST5, 3DES, Blowfish and Rijndael all show that these ciphers are quite independent of the CPU. Again Serpent shows the largest range of speed differences.</p><p>See the external table file for a detailed <a href="cpu-speed.html">speed table listing for all CPUs</a>.</p><h3><a id="c05-s05-flags"></a>5.5&nbsp; Compiler and Optimization Flags</h3><p>The last collection of test results are centered on the question &quot;How important is the compiler and compiler flags for the encryption speed?&quot;. This question already arises above during the comparisons of different distributions. Here the binary package maintainer or in case of Gentoo the distribution user sets the (gcc) compiler flags used to compile the library source code.</p><p>To examine the compiler flags influence the cipher source code was compiled using all the 35 different flags shown in table &quot;<a href="#c02-s03-compilers">Compiler and Flags Tested</a>&quot;. As stated above the biggest problem was to verify that the build scripts (configure + make) of the library actually passed the flags on to the compiler.</p><p>To improve readability of the following plots only a subset of all compiler flags are displayed. The longer gcc compiler flag sequences are shortened to allow compact display in the legend:</p><table class="datatable1 vtop"> <caption>Table 9: Shortened Compiler Flags</caption> <tr> <th>Shortened</th> <th>Flags</th> </tr> <tr> <td><code>-O2 p4</code></td> <td><code>-O2 -march=pentium4</code></td> </tr> <tr> <td><code>-O3 p4</code></td> <td><code>-O3 -march=pentium4</code></td> </tr> <tr> <td><code>-O2 p4 ofp</code></td> <td><code>-O2 -march=pentium4 -fomit-frame-pointer</code></td> </tr> <tr> <td><code>-O3 p4 ofp</code></td> <td><code>-O3 -march=pentium4 -fomit-frame-pointer</code></td> </tr> <tr> <td><code>-O2 p4s ofp</code></td> <td><code>-O2 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer</code></td> </tr> <tr> <td><code>-O3 p4s ofp</code></td> <td><code>-O3 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer</code></td> </tr> <tr> <td><code>-O2 p4s ofp ul</code></td> <td><code>-O2 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer -funroll-loops</code></td> </tr> <tr> <td><code>-O3 p4s ofp ul</code></td> <td><code>-O3 -march=pentium4 -msse -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer -funroll-loops</code></td> </tr></table><p>Of the above flags, only the <code>-O3</code> variants are included in the following plots.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results-flags/flags.pdf#page=1"><img src="img/flags-01.jpg" alt="Custom Rijndael - Speed by Data Length" title="Custom Rijndael - Speed by Data Length" width="500" height="507" /></a></p><p>The first three plots compare compiler flags based on the three custom cipher implementations. First is the Rijndael implementation, which already shows the main trends of the compiler and flags comparison: Intel&apos;s C++ compiler generates the fastest code. Next best is gcc with the highest level of optimization. Microsoft Visual C++ passes somewhere in the middle field.</p><p>Another important observation is that the <code>gcc 4.1.2 -O3 p4 ofp</code> flag combination performs nearly equal to &quot;<code>-O3 p4s ofp</code>&quot; and &quot;<code>-O3 p4s ofp ul</code>&quot;. This means that the flags <code>-funroll-loops</code> and <code>-msse -msse2 -msse3 -mfpmath=sse</code> does not change performance.</p><p>An outlier result is the one generated by <code>gcc 4.1.2 -O1</code>: it show way faster performance that all other gcc results. The reason for this fast result is unknown: less optimization seems to do some ciphers (here Rijndael) good.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results-flags/flags.pdf#page=2"><img src="img/flags-02.jpg" alt="Gladman Serpent - Speed by Data Length" title="Gladman Serpent - Speed by Data Length" width="500" height="507" /></a></p><p>Second custom implementation is Gladman&apos;s Serpent code. Again Intel&apos;s C++ compiler wins the race by a long shot. This time the second place goes to Microsoft&apos;s Visual C++, which also shows a large winning margin against gcc.</p><p>Interesting here is that all three compiler perform nearly the same when optimization is disabled: the red lines are almost equal.</p><p>gcc again shows large performance gains from more compiler flags, peaking again with <code>gcc 4.1.2 -O3 p4 ofp</code>.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results-flags/flags.pdf#page=3"><img src="img/flags-03.jpg" alt="MyBotan Serpent - Speed by Data Length" title="MyBotan Serpent - Speed by Data Length" width="500" height="507" /></a></p><p>The custom cipher code extracted from Botan is an interesting candidate for optimization: it mainly contains eight substitution box functions, the transformation and support functions of which all are declared <code>static inline</code>.</p><p> <p>Lots of room for optimizations like instruction schedueling, reordering and register allocation. However the cipher code contains only few branches and loops. Except for the loop over the 256-bit blocks no branches are contained in the main execution part.</p><p>The plot shows again Intel&apos;s compiler to provide highest optimization. The second place goes this time to gcc, but only with the highest optimization flags level in the test. Third is Visual C++.</p><p>Remarkable is the large difference between the winning combinations, which are above 20 MB/s, and the middle field of gcc flag combinations: they all show speeds smaller than 10MB/s. The jump from 10MB/s to more than 20MB/s happens when <code>-fomit-frame-pointer</code> is added to the flags. This was also visible in the last two plot, but the jump is really large in the current plot.</p><p>Again <code>gcc 4.1.2 -O1</code> shows a result breaking out of the middle field. This time it does not reach <code>-O3 p4 ofp</code> levels.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results-flags/flags.pdf#page=4"><img src="img/flags-04.jpg" alt="Crypto++ Rijndael - Speed by Data Length" title="Crypto++ Rijndael - Speed by Data Length" width="500" height="507" /></a></p><p>Now we study the results of cipher implementations in the Crypto++ library. First up is Rijndael.</p><p>The plot shows a much larger spread of results than the three custom implementations. Again the winning order is Intel&apos;s followed by Visual C++ and gcc. However the winning speed results are much closer together than in the last three tests.</p><p><code>gcc 4.1.2 -O1</code> again shows larger speed optimization than <code>-O3 ofp</code> combinations. But again the difference is smaller than before.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results-flags/flags.pdf#page=5"><img src="img/flags-05.jpg" alt="Crypto++ Serpent - Speed by Data Length" title="Crypto++ Serpent - Speed by Data Length" width="500" height="507" /></a></p><p>Crypto++&apos;s implementation of Serpent shows very much the same results as MyBotan Serpent: <code>icc</code> best, gcc with <code>-O3 ofp</code> second and <code>msvc</code> third. Again <code>gcc 4.1.2 -O1</code> shows a special performance.</p><p>This time <code>gcc 3.4.6</code> also shows good speed results, nearly reaching <code>gcc 4.1.2</code>. In the preceding tests <code>gcc 3.4.6</code> did not show good performance compared to the other results.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results-flags/flags.pdf#page=6"><img src="img/flags-06.jpg" alt="Crypto++ Twofish - Speed by Data Length" title="Crypto++ Twofish - Speed by Data Length" width="500" height="507" /></a></p><p>The plot above compares by the Twofish implementation in Crypto++. It shows the same findings as in the previous plots.</p><p>The PDF plot file contains six more comparisons with different ciphers from Crypto++. All show the same observations as the first six and are therefore omitted here. Check the PDF or tarball for the other charts.</p><h4><a id="c05-s05-p01-compiler-subconclusion"></a>5.5.1&nbsp; Sub-Conclusion</h4><p>The central point of interest in this section is to find the fastest compiler / compiler flags combination for all ciphers. For this comparison the speed of all ciphers are averaged for each compiler flags combination. The only other calculation of interest is to see how much slower the other compilers are. So each total average is also displayed relative to the fastest compiler / flags combination.</p><table class="datatable1" style="text-align: right; font-size: smaller"> <caption>Table 10: Top Compiler / Compiler Flags</caption> <col span="1" class="liner" /> <col /> <col span="1" class="liner" /> <thead> <tr> <th>&nbsp;</th> <th>average</th> <th>relative</th> <th>my-rijndael</th> <th>gladman-serpent</th> <th>mybotan-serpent</th> <th>cryptopp-rijndael</th> <th>cryptopp-serpent</th> <th>cryptopp-twofish</th> <th>...</th> </tr> </thead> <tbody> <tr> <td>icc-O1</td> <td>34,977</td> <td>100.00%</td> <td>46,864</td> <td>27,123</td> <td>30,029</td> <td>39,456</td> <td>32,779</td> <td>58,783</td> <td>...</td> </tr> <tr> <td>icc-O2</td> <td>34,713</td> <td>99.25%</td> <td>47,630</td> <td>27,905</td> <td>30,195</td> <td>39,638</td> <td>32,291</td> <td>58,961</td> <td>...</td> </tr> <tr> <td>icc-O3</td> <td>34,653</td> <td>99.07%</td> <td>47,534</td> <td>27,873</td> <td>30,196</td> <td>39,283</td> <td>32,112</td> <td>58,979</td> <td>...</td> </tr> <tr> <td>icc-Os</td> <td>32,620</td> <td>93.26%</td> <td>46,541</td> <td>27,950</td> <td>8,254</td> <td>39,510</td> <td>32,626</td> <td>58,911</td> <td>...</td> </tr> <tr> <td>msvc8-Ox</td> <td>29,168</td> <td>83.39%</td> <td>26,135</td> <td>21,027</td> <td>22,888</td> <td>38,032</td> <td>25,234</td> <td>39,159</td> <td>...</td> </tr> <tr> <td>msvc8-O2</td> <td>29,098</td> <td>83.19%</td> <td>25,895</td> <td>21,155</td> <td>22,642</td> <td>37,967</td> <td>25,312</td> <td>39,015</td> <td>...</td> </tr> <tr> <td>gcc41-O3-p4s-ofp</td> <td>28,863</td> <td>82.52%</td> <td>34,955</td> <td>13,040</td> <td>26,198</td> <td>31,906</td> <td>28,338</td> <td>37,214</td> <td>...</td> </tr> <tr> <td>gcc41-O3-p4-ofp</td> <td>28,790</td> <td>82.31%</td> <td>34,493</td> <td>13,290</td> <td>26,846</td> <td>32,154</td> <td>28,071</td> <td>37,091</td> <td>...</td> </tr> <tr> <td>gcc41-O3-p4s-ofp-ul</td> <td>28,770</td> <td>82.25%</td> <td>35,025</td> <td>13,457</td> <td>26,690</td> <td>32,065</td> <td>27,919</td> <td>38,452</td> <td>...</td> </tr> <tr> <td>gcc41-O2-p4-ofp</td> <td>28,327</td> <td>80.99%</td> <td>33,855</td> <td>12,723</td> <td>26,763</td> <td>31,633</td> <td>27,958</td> <td>37,086</td> <td>...</td> </tr> <tr> <td>gcc41-O2-p4s-ofp</td> <td>28,324</td> <td>80.98%</td> <td>34,230</td> <td>12,653</td> <td>26,539</td> <td>32,095</td> <td>27,190</td> <td>37,493</td> <td>...</td> </tr> <tr> <td>gcc41-O2-p4s-ofp-ul</td> <td>28,287</td> <td>80.87%</td> <td>34,160</td> <td>12,816</td> <td>26,820</td> <td>32,039</td> <td>27,489</td> <td>37,109</td> <td>...</td> </tr> <tr> <td>gcc41-O1</td> <td>26,537</td> <td>75.87%</td> <td>44,357</td> <td>6,293</td> <td>20,535</td> <td>33,495</td> <td>23,282</td> <td>36,114</td> <td>...</td> </tr> <tr> <td>gcc34-O3-p4s-ofp-ul</td> <td>25,837</td> <td>73.87%</td> <td>27,841</td> <td>8,709</td> <td>7,174</td> <td>35,445</td> <td>27,308</td> <td>35,370</td> <td>...</td> </tr> <tr> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> <td>...</td> </tr> </tbody></table><p>The table above shows only the first rows and columns of the complete table. See the external web page for the <a href="compiler-speed.html">full speed table listing for all compiler flags</a>.</p><p>Obviously Intel&apos;s C++ compiler is the fastest, it shows about the same performance gain for <code>-O1</code>, <code>-O2</code> and <code>-O3</code>. When size optimization is enabled <code>-Os</code> the speed drops about 7%.</p><p>Second best compiler in the test is Microsoft&apos;s Visual C++ 8.0: the code it creates performes roughly 16.5% slower than that created by Intel&apos;s compiler. Again the maximum optimization flag <code>/Ox</code> and <code>/O2</code> shows about equal performance.</p><p>But close behind is <code>gcc 4.1.2</code> with the flags combination <code>-O3 p4s ofp</code>, which creates 17.5% slower code than Intel&apos;s compiler. The older gcc version <code>3.4.6</code> is an amazing 26% slower than Intel&apos;s top mark.</p><p>However relative to <code>gcc 4.1.2</code> the older compiler version <code>3.4.6</code> is only 10% slower. This is an interesting result, especially in view of early reports on <code>gcc 4.x</code> to show poorer optimization than the tried-and-true old version <code>3.4.x</code>. This opinion was very popular for <code>4.0.x</code> versions of gcc. At least in the cipher code case, this does not hold for <code>4.1.x</code>.</p><p>A nice graphical overview of compiler speed is shown below: all average speed results are plotted by compiler / compiler flags combinations. The average speed results are sorted to show a monotone decreasing speed line.</p><p style="text-align: center"><a href="crypto-speedtest-0.1/results-flags/flags-graph.pdf"><img src="img/flags-graph-1.jpg" alt="Compiler Flags Comparison" title="Compiler Flags Comparison" width="500" height="350" /></a></p><p>Obvious jumps in the speed line are from <code>icc</code> to the others at 34 MB/s to 28 MB/s. Followed by a smaller jump between the <code>gcc 4.1.2</code> and <code>3.4.6</code> results around 26 MB/s. And the last large jump down to less than 10 MB/s which is due to test results without any optimization flags activated (<code>-O0</code>).</p><p>Another interesting observation is that many gcc flags have no effect on the cipher code generation. This is seen by the long steady intervals with minimum sloping.</p><h2><a id="c06-conclusion"></a>6&nbsp; Conclusion</h2><p>In this section some of the results observed above are rediscussed to form a final conclusion.</p><p>In section <a href="#c05-s01-cipher">Ciphers Compared</a> each of the 15 compared ciphers are evaluated on Gentoo. The average speed across all libraries implementing a particular cipher is calculated. Blowfish turned out to be the fastest cipher in the test. However selecting a cipher for a specific purpose must regard more parameters than the raw speed. More important is a cipher&apos;s strength as it is widely accepted by cryptography experts. Nevertheless the numbers are a concrete basis for cipher selection.</p><p>When regarding the selected cryptography <a href="#c05-s02-library">Libraries Compared by Cipher</a> large differences become visible. One would expect all libraries to contain about the same cipher implementations, as all calculation results <em>have to be the same</em>. However performance varies greatly, and the variation is not due to compiler flags or other external problems.</p><p>All OpenSSL&apos;s cipher implementations show high levels of optimizations, thus promising good performance for SSL sockets. Beecrypt implements only two ciphers, but these two implementations show very high speed: Beecrypt&apos;s Blowfish implementation reaches 52 MB/s, the highest speed result in the whole test. Tomcrypt provides the largest number of ciphers and consistently good performance on all of them. Botan and Crypto++ show similar speed results, each having some fast and some slower cipher implementations. The small Nettle is rather old and thus probably contains more out-dated, slower implementations.</p><p>The first real surprise of the speed comparison is the extremely slow test results measured on all ciphers implemented in libmcrypt and libgcrypt. libmcrypt&apos;s ciphers show an extremely long start-up overhead, but once it is amortized the cipher&apos;s throughput is equal to the other, faster libraries. libgcrypt&apos;s results on the other hand are really abysmal and trail far behind all other libraries. This does not bode well for GnuTLS&apos;s SSL socket&apos;s performance.</p><p>Next <a href="#c05-s03-distro">Findings On Different Distributions</a> are discussed to put the previous speed results, which were all measured on Gentoo, into perspective. The result shows that Gentoo really does perform faster than the others, probably due to the high optimization flags selected during source compilation of the libraries. Gentoo is followed by the newer versions of Ubuntu (hardy) and Debian (lenny). Fedora and Ubuntu gutsy perform about equally. The oldest distribution Debian etch takes the last place, showing almost 15% slower speed results than Gentoo.</p><p>The section <a href="#c05-s04-cpu">Ciphers compared by CPU</a> was included to make sure that the results collected on the primary testing computer would be transferable onto other systems. This proved to be the case. Little difference other than the expected relative speed scaling was observable for other CPUs. Most importantly no cache effects or special speed-ups were detectable. Most robust cipher was CAST5 and the one most fragile to CPU architecture was Serpent.</p><p>Most interesting for other applications outside the scope of cipher algorithms was the <a href="#c05-s05-flags">Compiler and Optimization Flags</a> comparison. It showed that Intel&apos;s C++ compiler produces by far the most optimized code for all ciphers tested. Second and third place goes to Microsoft Visual C++ 8.0 and <code>gcc 4.1.2</code>, which generate code which is roughly 16.5% and 17.5% slower than that generated by Intel&apos;s compiler. gcc&apos;s performance is highly dependent on the amount to optimization flags enabled: a simple <code>-O3</code> is not sufficient to produce well optimized binary code.</p></p></div><br/><a id="notes"></a><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/d41d8cd98f00b204e9800998ecf8427e" rel="nofollow"> <img src="/img/gravatar/d41d8cd98f00b204e9800998ecf8427e-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/d41d8cd98f00b204e9800998ecf8427e" rel="nofollow">Rick</a></b> at 2008-07-21 12:03 UTC</div><div class="commentbody"><p>Doesn&apos;t PKIF (pkif.sourceforge.net) have all/some of the algorithms you used? Why didn&apos;t you try that one? Is it using one of the same libraries or something?<br /><br />I only mention it because it seems more notable than some of the libraries that you did test. It has EAL 4 certs..</p></div></div><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/d41d8cd98f00b204e9800998ecf8427e" rel="nofollow"> <img src="/img/gravatar/d41d8cd98f00b204e9800998ecf8427e-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/d41d8cd98f00b204e9800998ecf8427e" rel="nofollow">CC</a></b> at 2008-07-21 12:52 UTC</div><div class="commentbody"><p>Very nice job on the symmetric-key part - what about a similar thing for the public-key part ?</p></div></div><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/d41d8cd98f00b204e9800998ecf8427e" rel="nofollow"> <img src="/img/gravatar/d41d8cd98f00b204e9800998ecf8427e-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/d41d8cd98f00b204e9800998ecf8427e" rel="nofollow">BJ</a></b> at 2008-07-28 05:05 UTC</div><div class="commentbody"><p>Great job! I looked for awhile for cipher speed tests. I&apos;m looking to use mcrypt in php. Thanks.</p></div></div><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/d41d8cd98f00b204e9800998ecf8427e" rel="nofollow"> <img src="/img/gravatar/d41d8cd98f00b204e9800998ecf8427e-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/d41d8cd98f00b204e9800998ecf8427e" rel="nofollow">gd_romain</a></b> at 2010-02-16 14:37 UTC</div><div class="commentbody"><p>Very nice job!<br /><br />I&apos;ve search this type of document in my dream for years ago :) </p></div></div><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/ffbe4820a6802d6fa177a10303a4c77e" rel="nofollow"> <img src="/img/gravatar/ffbe4820a6802d6fa177a10303a4c77e-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/ffbe4820a6802d6fa177a10303a4c77e" rel="nofollow">Mudassir</a></b> at 2010-04-02 19:14 UTC</div><div class="commentbody"><p>Great work. Could you please refer some similar article on Elliptic Curve Cryptography (ECC)? <br /></p></div></div><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/af715ce89694e2976e0cc44b9b91a964" rel="nofollow"> <img src="/img/gravatar/af715ce89694e2976e0cc44b9b91a964-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/af715ce89694e2976e0cc44b9b91a964" rel="nofollow">Timo</a></b> at 2010-04-08 05:48 UTC</div><div class="commentbody"><p>No sorry, I haven&apos;t been working with ECC yet.<br />Timo</p></div></div><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/d41d8cd98f00b204e9800998ecf8427e" rel="nofollow"> <img src="/img/gravatar/d41d8cd98f00b204e9800998ecf8427e-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/d41d8cd98f00b204e9800998ecf8427e" rel="nofollow">nm</a></b> at 2010-04-21 16:02 UTC</div><div class="commentbody"><p>It would be interesting if you were to repeat the tests with newer versions of gcc i.e. 4.2.x or 4.5. These now have profile based optimization and would be interesting to see perf with LTO and -fwhole-program turned on.</p></div></div><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/ffbe4820a6802d6fa177a10303a4c77e" rel="nofollow"> <img src="/img/gravatar/ffbe4820a6802d6fa177a10303a4c77e-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/ffbe4820a6802d6fa177a10303a4c77e" rel="nofollow">Mudassir Feroz</a></b> at 2010-05-10 18:44 UTC</div><div class="commentbody"><p>oh ok, Still great work. i appreciate. Now i need some stuff for testing a Cellular Automata for DIEHARD and ENT tests batteries in graphical mode just like these curves maybe. If you got any link or anything the please email me. i would b very greatful to u :) . <br /> <br />Thankss dear<br /></p></div></div><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/fd1f0072d831605f1271708e64d7b0fa" rel="nofollow"> <img src="/img/gravatar/fd1f0072d831605f1271708e64d7b0fa-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/fd1f0072d831605f1271708e64d7b0fa" rel="nofollow">tech surge</a></b> at 2010-09-12 15:21 UTC</div><div class="commentbody"><p>could you upload the executable with souce code <br /> <br />my boss wants me to create file encryption utility with different ciphers <br /> <br /> i am having hard time understanding crypto++ and i think you are the only one who has done detail cryptography in cryptopp<br /></p></div></div><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/af715ce89694e2976e0cc44b9b91a964" rel="nofollow"> <img src="/img/gravatar/af715ce89694e2976e0cc44b9b91a964-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/af715ce89694e2976e0cc44b9b91a964" rel="nofollow">Timo</a></b> at 2010-09-12 16:18 UTC</div><div class="commentbody"><p>It&apos;s all up there, and not difficult to find?<br />Timo</p></div></div><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/d0ac504bb33ed56dfefa00ff05e786e0" rel="nofollow"> <img src="/img/gravatar/d0ac504bb33ed56dfefa00ff05e786e0-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/d0ac504bb33ed56dfefa00ff05e786e0" rel="nofollow">fainardi83</a></b> at 2011-04-05 14:40 UTC</div><div class="commentbody"><p>hi <br />very good work <br /> <br />do you plan to update your benchmark including new library like polarssl by exemple <br /> <br />regards <br /></p></div></div><div class="commentframe"><div class="commentimage"> <a href="http://www.gravatar.com/af715ce89694e2976e0cc44b9b91a964" rel="nofollow"> <img src="/img/gravatar/af715ce89694e2976e0cc44b9b91a964-80.jpg" width="80" height="80" alt="Gravatar" /> </a></div><div class="commenttitle">Comment by <b><a href="http://www.gravatar.com/af715ce89694e2976e0cc44b9b91a964" rel="nofollow">Timo</a></b> at 2011-04-06 07:16 UTC</div><div class="commentbody"><p>Thanks, but sorry: my current interests and work are going outside the scope of cryptography and therefore no updates are planned or probable.<br />Timo</p></div></div><div class="commentframe" style="display: none; border-color: red" id="newpost_div"> <div class="commentimage"> <a href="http://www.gravatar.com/" id="newpost_imgurl"> <img id="newpost_img" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAAAAAA6fptVAAAAAXNSR0IArs4c6QAAAApJREFUCB1j+A8AAQEBADZfZ4AAAAAASUVORK5CYII=" width="80" height="80" alt="Gravatar" /> </a> </div> <div class="commenttitle">Comment by <b><span id="newpost_name">Name</span></b> at <span id="newpost_date">Date</span><span id="newpost_uri">- URI</span><a href="/2008/0714-cryptography-speedtest-comparison/" rel="nofollow"></a></div> <div class="commentbody" id="newpost_body"></div> <div class="commentbody" style="text-align: right"><big>Preview (Not Saved!)</big></div></div><a id="postnote"></a><form id="noteform" method="post" action="/sendpost.php"><div class="commentform" style="text-align: center"><table class="center thinframe" style="text-align: left"> <tr> <td colspan="2" style="text-align: center">Post Comment<input type="hidden" name="previewok" value="0" /><input type="hidden" name="posturi" value="/2008/0714-cryptography-speedtest-comparison/" /></td> </tr> <tr> <td>Name:</td> <td><input type="text" name="postname" size="40" /></td> </tr> <tr> <td>E-Mail or Homepage:<br /><span style="font-size: 8pt">&nbsp;</span></td> <td><input type="text" name="postmail" size="40" /><br /> <span style="font-size: 8pt">URLs (http://...) are displayed, e-mails are hidden and used for Gravatar.</span></td> </tr> <tr> <td colspan="2" style="text-align: center"> <textarea name="postbody" cols="80" rows="8"></textarea><br /> <span style="font-size: 8pt">Many common HTML elements are allowed in the text, but no CSS style.</span> </td> </tr> <tr> <td colspan="2" style="text-align: center"> <input type="button" name="Preview" value="Preview" onclick="return noteform_submit()" /> <input type="submit" name="Submit" value="Submit" disabled="disabled" id="newpost_submit" /> </td> </tr></table></div></form></div><div style="text-align: right; padding: 8pt; font-size: 12px"><a href="/xmlfeed/weblog-rss20.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABQAAAADwCexKkxAAAAWUlEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMCt0ZdTU/F/7/+1HEkydFpoKVPn+93sUlUujQvP/7UcRTAuNDJ2a//s/imDqtKVZofm/1qGYSZk7sfodGwAAiobBJtffoNAAAAAASUVORK5CYII=" alt="RSS 2.0 Weblog Feed" width="80" height="15"/></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAAaklEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMDV16rTQ/H/7V//69+//v/3/9oMEI6cuAwr+fv/+/b5d///v//0eJBgWOhMo+Gs9UPAdXDBy6lSYyn9wQZCZS0GCYDPXQcykzJ1Y/Y4NAABKvL80wyoMPgAAAABJRU5ErkJggg==" alt="Atom 1.0 Weblog Feed" width="80" height="15"/></a> <a href="http://validator.w3.org/check?uri=referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABKklEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6qIGzIRiKZs9GFoEaMRuZhhrYqqJXy8uZYauRxC/VHew7e3YTPAxnI5swG6JxNrKBNjB1EFmIgV0+HA6C8pqqzhXG7BbJJROQIwViMYQ7G2oDQQNn57JyG7kxiCfObrBmS5+BHMuYLkTzMnYDm5WY4lOZZRPKZocxes+aPbuwCFsYohiICLvZsKBAMrDTQ7K/StveU8icTzrOL8JdLpOyWJ49u8Bx9ozw8DY7UYW03hhdxZAOSg2c3jN79rSJs1vSKmfOnpFXNJmynELlvExlAADnaZpLFGEC2wAAAABJRU5ErkJggg==" alt="Valid XHTML 1.1" width="80" height="15"/></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABEUlEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6mIEQCsIjwhKoga0qerW8nBm2Gkn8Ut3BvrNnN8HCcDYM2cBIogzs8uFwEJTXVHWuMGa3SC6ZgIgUqCEwdxJr4OxcVm4jNwbxxNkN1mzpM2ajGIjsPGK9PLtZiSk+lVk2oWx2GKP3rNmzC4tQwpDoIIQb2Okh2V+lbe8pZM4nHecX4S6XSVksz55d4Dh7Rnh4m52oQlpvjK5iSAelBk7vmT172sTZLWmVM2fPyCuaTFlOoXJepjIAANlljDGY/l5pAAAAAElFTkSuQmCC" alt="Valid CSS (2.1)" width="80" height="15"/></a><br/>Copyright 2005-2019 <a href="/about/">Timo Bingmann</a> - <a href="/about/impressum.html">Impressum</a></div></body></html>