<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><title>/2009/cryptote/cryptote-0.5.390/libstc/scintilla/src/RESearch.cxx - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="stylesheet" type="text/css" href="/css/fonts.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="http://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="http://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/js/base.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body style="background-image: url(/img/bgfractal8.jpg)"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/"><i class="icon-book"></i> Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2015/">2015</a></li><li><a href="/2014/">2014</a></li><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li class="nt"><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li><li class="ns"><a href="/search.html">Search</a></li></ul></li><li class="top"><a class="ni" href="/tags/"><i class="icon-tags"></i> Tags</a><div style="width: 14em; margin-left: -9em; margin-top: 4px"><a style="font-size: 10pt" href="/tags/algebra.html">algebra</a> <a style="font-size: 16pt" href="/tags/c++.html">c++</a> <a style="font-size: 12pt" href="/tags/code-example.html">code-example</a> <a style="font-size: 14pt" href="/tags/code-snippet.html">code-snippet</a> <a style="font-size: 11pt" href="/tags/coding_tricks.html">coding tricks</a> <a style="font-size: 10pt" href="/tags/compsci.html">compsci</a> <a style="font-size: 10pt" href="/tags/compsci_study_thesis.html">compsci study thesis</a> <a style="font-size: 9pt" href="/tags/crypto-speedtest.html">crypto-speedtest</a> <a style="font-size: 10pt" href="/tags/cryptography.html">cryptography</a> <a style="font-size: 9pt" href="/tags/cryptote.html">cryptote</a> <a style="font-size: 12pt" href="/tags/flex-bison-cpp-example.html">flex-bison-cpp-example</a> <a style="font-size: 15pt" href="/tags/frontpage.html">frontpage</a> <a style="font-size: 14pt" href="/tags/fun.html">fun</a> <a style="font-size: 10pt" href="/tags/graphviz.html">graphviz</a> <a style="font-size: 9pt" href="http://www.hmtg.de">hartmetall</a> <a style="font-size: 9pt" href="/tags/helppc.html">helppc</a> <a style="font-size: 9pt" href="/tags/hifi_selbstbau.html">hifi selbstbau</a> <a style="font-size: 10pt" href="/tags/latex.html">latex</a> <a style="font-size: 10pt" href="/tags/librivox.html">librivox</a> <a style="font-size: 10pt" href="/tags/linux.html">linux</a> <a style="font-size: 9pt" href="/tags/massive-sorting.html">massive-sorting</a> <a style="font-size: 10pt" href="/tags/maths.html">maths</a> <a style="font-size: 9pt" href="/tags/music.html">music</a> <a style="font-size: 10pt" href="/tags/netfundamentals.html">netfundamentals</a> <a style="font-size: 11pt" href="/tags/ns-3.html">ns-3</a> <a style="font-size: 10pt" href="/tags/parallel-string-sorting.html">parallel-string-sorting</a> <a style="font-size: 9pt" href="/tags/qtsqlview.html">qtsqlview</a> <a style="font-size: 12pt" href="/tags/research.html">research</a> <a style="font-size: 11pt" href="/tags/sdios06.html">sdios06</a> <a style="font-size: 9pt" href="/tags/sdlfractal.html">sdlfractal</a> <a style="font-size: 13pt" href="/tags/sorting.html">sorting</a> <a style="font-size: 10pt" href="/tags/stringology.html">stringology</a> <a style="font-size: 16pt" href="/tags/stx-btree.html">stx-btree</a> <a style="font-size: 9pt" href="/tags/stx-exparser.html">stx-exparser</a> <a style="font-size: 13pt" href="/tags/stxxl.html">stxxl</a> <a style="font-size: 16pt" href="/tags/talk.html">talk</a> <a style="font-size: 10pt" href="/tags/tutorium.html">tutorium</a> <a style="font-size: 16pt" href="/tags/university.html">university</a> <a style="font-size: 13pt" href="/tags/utilities.html">utilities</a> <a style="font-size: 10pt" href="/tags/vncrec.html">vncrec</a> <a style="font-size: 9pt" href="/tags/webdesign.html">webdesign</a> </div></li><li class="top"> <a class="ni" href="#"><i class="icon-cubes"></i> Projects</a> <ul style="margin-left: -8em; margin-top: 4px;" class="nx"> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2013/parallel-string-sorting/">parallel-string-sorting</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2014/sqlplot-tools/">SqlPlotTools</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li><a href="/tags/stxxl.html">STXXL 1.4</a></li> <li class="nt"><a href="/2014/vncrec-rgb/">VNCrec RGB 0.4</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="#"><i class="icon-graduation-cap"></i> Research</a> <ul style="margin-left: -16em; margin-top: 4px" class="nx"> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP - External Memory Suffix Sorting</a></li> <li><a href="/2013/parallel-string-sorting/">Parallel String Sorting</a></li> <li><a href="/tags/massive-sorting.html">Practical Massively Parallel Sorting</a></li> <li><a href="/tags/stxxl.html">STXXL - External Memory Algorithms</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="/about/"><i class="icon-info-circled"></i> About</a> <ul style="margin-left: -6em; margin-top: 4px" class="nx"> <li><a href="/about/">Timo Bingmann</a></li> <li><a href="/about/impressum.html">Impressum</a></li> </ul></li><li class="top"> <a class="ni" href="/subscribe.html"><i class="icon-rss-squared"></i> Subscribe</a></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2009/">2009</a> / <a href="/2009/cryptote/">cryptote</a> / <a href="/2009/cryptote/cryptote-0.5.390/">cryptote-0.5.390</a> / <a href="/2009/cryptote/cryptote-0.5.390/libstc/">libstc</a> / <a href="/2009/cryptote/cryptote-0.5.390/libstc/scintilla/">scintilla</a> / <a href="/2009/cryptote/cryptote-0.5.390/libstc/scintilla/src/">src</a> / <a href="/2009/cryptote/cryptote-0.5.390/libstc/scintilla/src/RESearch.cxx.html">RESearch.cxx</a> (<a href="/2009/cryptote/cryptote-0.5.390/libstc/scintilla/src/RESearch.cxx">Download File</a>)</div></div><div class="ptfullwidth"><pre class="codesnippet" style="font-family: monospace"><tt>// Scintilla source code edit control
/** @file RESearch.cxx
 ** Regular expression search library.
 **/

/*
 * regex - Regular expression pattern matching and replacement
 *
 * By:  Ozan S. Yigit (oz)
 *      Dept. of Computer Science
 *      York University
 *
 * Original code available from http://www.cs.yorku.ca/~oz/
 * Translation to C++ by Neil Hodgson neilh@scintilla.org
 * Removed all use of register.
 * Converted to modern function prototypes.
 * Put all global/static variables into an object so this code can be
 * used from multiple threads, etc.
 * Some extensions by Philippe Lhoste PhiLho(a)GMX.net
 *
 * These routines are the PUBLIC DOMAIN equivalents of regex
 * routines as found in 4.nBSD UN*X, with minor extensions.
 *
 * These routines are derived from various implementations found
 * in software tools books, and Conroy&apos;s grep. They are NOT derived
 * from licensed/restricted software.
 * For more interesting/academic/complicated implementations,
 * see Henry Spencer&apos;s regexp routines, or GNU Emacs pattern
 * matching module.
 *
 * Modification history removed.
 *
 * Interfaces:
 *  RESearch::Compile:      compile a regular expression into a NFA.
 *
 *          const char *RESearch::Compile(const char *pattern, int length,
 *                                        bool caseSensitive, bool posix)
 *
 * Returns a short error string if they fail.
 *
 *  RESearch::Execute:      execute the NFA to match a pattern.
 *
 *          int RESearch::Execute(characterIndexer &amp;ci, int lp, int endp)
 *
 *  RESearch::Substitute:   substitute the matched portions in a new string.
 *
 *          int RESearch::Substitute(CharacterIndexer &amp;ci, char *src, char *dst)
 *
 *  re_fail:                failure routine for RESearch::Execute. (no longer used)
 *
 *          void re_fail(char *msg, char op)
 *
 * Regular Expressions:
 *
 *      [1]     char    matches itself, unless it is a special
 *                      character (metachar): . \ [ ] * + ^ $
 *                      and ( ) if posix option.
 *
 *      [2]     .       matches any character.
 *
 *      [3]     \       matches the character following it, except:
 *                      - \a, \b, \f, \n, \r, \t, \v match the corresponding C
 *                      escape char, respectively BEL, BS, FF, LF, CR, TAB and VT;
 *                      Note that \r and \n are never matched because Scintilla
 *                      regex searches are made line per line
 *                      (stripped of end-of-line chars).
 *                      - if not in posix mode, when followed by a
 *                      left or right round bracket (see [7]);
 *                      - when followed by a digit 1 to 9 (see [8]);
 *                      - when followed by a left or right angle bracket
 *                      (see [9]);
 *                      - when followed by d, D, s, S, w or W (see [10]);
 *                      - when followed by x and two hexa digits (see [11].
 *                      Backslash is used as an escape character for all
 *                      other meta-characters, and itself.
 *
 *      [4]     [set]   matches one of the characters in the set.
 *                      If the first character in the set is &quot;^&quot;,
 *                      it matches the characters NOT in the set, i.e.
 *                      complements the set. A shorthand S-E (start dash end)
 *                      is used to specify a set of characters S up to
 *                      E, inclusive. S and E must be characters, otherwise
 *                      the dash is taken literally (eg. in expression [\d-a]).
 *                      The special characters &quot;]&quot; and &quot;-&quot; have no special
 *                      meaning if they appear as the first chars in the set.
 *                      To include both, put - first: [-]A-Z]
 *                      (or just backslash them).
 *                      examples:        match:
 *
 *                              [-]|]    matches these 3 chars,
 *
 *                              []-|]    matches from ] to | chars
 *
 *                              [a-z]    any lowercase alpha
 *
 *                              [^-]]    any char except - and ]
 *
 *                              [^A-Z]   any char except uppercase
 *                                       alpha
 *
 *                              [a-zA-Z] any alpha
 *
 *      [5]     *       any regular expression form [1] to [4]
 *                      (except [7], [8] and [9] forms of [3]),
 *                      followed by closure char (*)
 *                      matches zero or more matches of that form.
 *
 *      [6]     +       same as [5], except it matches one or more.
 *                      Both [5] and [6] are greedy (they match as much as possible).
 *
 *      [7]             a regular expression in the form [1] to [12], enclosed
 *                      as \(form\) (or (form) with posix flag) matches what
 *                      form matches. The enclosure creates a set of tags,
 *                      used for [8] and for pattern substitution.
 *                      The tagged forms are numbered starting from 1.
 *
 *      [8]             a \ followed by a digit 1 to 9 matches whatever a
 *                      previously tagged regular expression ([7]) matched.
 *
 *      [9]     \&lt;      a regular expression starting with a \&lt; construct
 *              \&gt;      and/or ending with a \&gt; construct, restricts the
 *                      pattern matching to the beginning of a word, and/or
 *                      the end of a word. A word is defined to be a character
 *                      string beginning and/or ending with the characters
 *                      A-Z a-z 0-9 and _. Scintilla extends this definition
 *                      by user setting. The word must also be preceded and/or
 *                      followed by any character outside those mentioned.
 *
 *      [10]    \l      a backslash followed by d, D, s, S, w or W,
 *                      becomes a character class (both inside and
 *                      outside sets []).
 *                        d: decimal digits
 *                        D: any char except decimal digits
 *                        s: whitespace (space, \t \n \r \f \v)
 *                        S: any char except whitespace (see above)
 *                        w: alphanumeric &amp; underscore (changed by user setting)
 *                        W: any char except alphanumeric &amp; underscore (see above)
 *
 *      [11]    \xHH    a backslash followed by x and two hexa digits,
 *                      becomes the character whose Ascii code is equal
 *                      to these digits. If not followed by two digits,
 *                      it is &apos;x&apos; char itself.
 *
 *      [12]            a composite regular expression xy where x and y
 *                      are in the form [1] to [11] matches the longest
 *                      match of x followed by a match for y.
 *
 *      [13]    ^       a regular expression starting with a ^ character
 *              $       and/or ending with a $ character, restricts the
 *                      pattern matching to the beginning of the line,
 *                      or the end of line. [anchors] Elsewhere in the
 *                      pattern, ^ and $ are treated as ordinary characters.
 *
 *
 * Acknowledgements:
 *
 *  HCR&apos;s Hugh Redelmeier has been most helpful in various
 *  stages of development. He convinced me to include BOW
 *  and EOW constructs, originally invented by Rob Pike at
 *  the University of Toronto.
 *
 * References:
 *              Software tools                  Kernighan &amp; Plauger
 *              Software tools in Pascal        Kernighan &amp; Plauger
 *              Grep [rsx-11 C dist]            David Conroy
 *              ed - text editor                Un*x Programmer&apos;s Manual
 *              Advanced editing on Un*x        B. W. Kernighan
 *              RegExp routines                 Henry Spencer
 *
 * Notes:
 *
 *  This implementation uses a bit-set representation for character
 *  classes for speed and compactness. Each character is represented
 *  by one bit in a 256-bit block. Thus, CCL always takes a
 *	constant 32 bytes in the internal nfa, and RESearch::Execute does a single
 *  bit comparison to locate the character in the set.
 *
 * Examples:
 *
 *  pattern:    foo*.*
 *  compile:    CHR f CHR o CLO CHR o END CLO ANY END END
 *  matches:    fo foo fooo foobar fobar foxx ...
 *
 *  pattern:    fo[ob]a[rz]
 *  compile:    CHR f CHR o CCL bitset CHR a CCL bitset END
 *  matches:    fobar fooar fobaz fooaz
 *
 *  pattern:    foo\\+
 *  compile:    CHR f CHR o CHR o CHR \ CLO CHR \ END END
 *  matches:    foo\ foo\\ foo\\\  ...
 *
 *  pattern:    \(foo\)[1-3]\1  (same as foo[1-3]foo)
 *  compile:    BOT 1 CHR f CHR o CHR o EOT 1 CCL bitset REF 1 END
 *  matches:    foo1foo foo2foo foo3foo
 *
 *  pattern:    \(fo.*\)-\1
 *  compile:    BOT 1 CHR f CHR o CLO ANY END EOT 1 CHR - REF 1 END
 *  matches:    foo-foo fo-fo fob-fob foobar-foobar ...
 */

#include &quot;CharClassify.h&quot;
#include &quot;RESearch.h&quot;

// Shut up annoying Visual C++ warnings:
#ifdef _MSC_VER
#pragma warning(disable: 4514)
#endif

#ifdef SCI_NAMESPACE
using namespace Scintilla;
#endif

#define OKP     1
#define NOP     0

#define CHR     1
#define ANY     2
#define CCL     3
#define BOL     4
#define EOL     5
#define BOT     6
#define EOT     7
#define BOW     8
#define EOW     9
#define REF     10
#define CLO     11

#define END     0

/*
 * The following defines are not meant to be changeable.
 * They are for readability only.
 */
#define BLKIND  0370
#define BITIND  07

const char bitarr[] = { 1, 2, 4, 8, 16, 32, 64, &apos;\200&apos; };

#define badpat(x)	(*nfa = END, x)

/*
 * Character classification table for word boundary operators BOW
 * and EOW is passed in by the creator of this object (Scintilla
 * Document). The Document default state is that word chars are:
 * 0-9, a-z, A-Z and _
 */

RESearch::RESearch(CharClassify *charClassTable) {
	charClass = charClassTable;
	Init();
}

RESearch::~RESearch() {
	Clear();
}

void RESearch::Init() {
	sta = NOP;                  /* status of lastpat */
	bol = 0;
	for (int i = 0; i &lt; MAXTAG; i++)
		pat[i] = 0;
	for (int j = 0; j &lt; BITBLK; j++)
		bittab[j] = 0;
}

void RESearch::Clear() {
	for (int i = 0; i &lt; MAXTAG; i++) {
		delete []pat[i];
		pat[i] = 0;
		bopat[i] = NOTFOUND;
		eopat[i] = NOTFOUND;
	}
}

bool RESearch::GrabMatches(CharacterIndexer &amp;ci) {
	bool success = true;
	for (unsigned int i = 0; i &lt; MAXTAG; i++) {
		if ((bopat[i] != NOTFOUND) &amp;&amp; (eopat[i] != NOTFOUND)) {
			unsigned int len = eopat[i] - bopat[i];
			pat[i] = new char[len + 1];
			if (pat[i]) {
				for (unsigned int j = 0; j &lt; len; j++)
					pat[i][j] = ci.CharAt(bopat[i] + j);
				pat[i][len] = &apos;\0&apos;;
			} else {
				success = false;
			}
		}
	}
	return success;
}

void RESearch::ChSet(unsigned char c) {
	bittab[((c) &amp; BLKIND) &gt;&gt; 3] |= bitarr[(c) &amp; BITIND];
}

void RESearch::ChSetWithCase(unsigned char c, bool caseSensitive) {
	if (caseSensitive) {
		ChSet(c);
	} else {
		if ((c &gt;= &apos;a&apos;) &amp;&amp; (c &lt;= &apos;z&apos;)) {
			ChSet(c);
			ChSet(static_cast&lt;unsigned char&gt;(c - &apos;a&apos; + &apos;A&apos;));
		} else if ((c &gt;= &apos;A&apos;) &amp;&amp; (c &lt;= &apos;Z&apos;)) {
			ChSet(c);
			ChSet(static_cast&lt;unsigned char&gt;(c - &apos;A&apos; + &apos;a&apos;));
		} else {
			ChSet(c);
		}
	}
}

const unsigned char escapeValue(unsigned char ch) {
	switch (ch) {
	case &apos;a&apos;:	return &apos;\a&apos;;
	case &apos;b&apos;:	return &apos;\b&apos;;
	case &apos;f&apos;:	return &apos;\f&apos;;
	case &apos;n&apos;:	return &apos;\n&apos;;
	case &apos;r&apos;:	return &apos;\r&apos;;
	case &apos;t&apos;:	return &apos;\t&apos;;
	case &apos;v&apos;:	return &apos;\v&apos;;
	}
	return 0;
}

static int GetHexaChar(unsigned char hd1, unsigned char hd2) {
	int hexValue = 0;
	if (hd1 &gt;= &apos;0&apos; &amp;&amp; hd1 &lt;= &apos;9&apos;) {
		hexValue += 16 * (hd1 - &apos;0&apos;);
	} else if (hd1 &gt;= &apos;A&apos; &amp;&amp; hd1 &lt;= &apos;F&apos;) {
		hexValue += 16 * (hd1 - &apos;A&apos; + 10);
	} else if (hd1 &gt;= &apos;a&apos; &amp;&amp; hd1 &lt;= &apos;f&apos;) {
		hexValue += 16 * (hd1 - &apos;a&apos; + 10);
	} else
		return -1;
	if (hd2 &gt;= &apos;0&apos; &amp;&amp; hd2 &lt;= &apos;9&apos;) {
		hexValue += hd2 - &apos;0&apos;;
	} else if (hd2 &gt;= &apos;A&apos; &amp;&amp; hd2 &lt;= &apos;F&apos;) {
		hexValue += hd2 - &apos;A&apos; + 10;
	} else if (hd2 &gt;= &apos;a&apos; &amp;&amp; hd2 &lt;= &apos;f&apos;) {
		hexValue += hd2 - &apos;a&apos; + 10;
	} else
		return -1;
	return hexValue;
}

/**
 * Called when the parser finds a backslash not followed
 * by a valid expression (like \( in non-Posix mode).
 * @param pattern: pointer on the char after the backslash.
 * @param incr: (out) number of chars to skip after expression evaluation.
 * @return the char if it resolves to a simple char,
 * or -1 for a char class. In this case, bittab is changed.
 */
int RESearch::GetBackslashExpression(
		const char *pattern,
		int &amp;incr) {
	// Since error reporting is primitive and messages are not used anyway,
	// I choose to interpret unexpected syntax in a logical way instead
	// of reporting errors. Otherwise, we can stick on, eg., PCRE behavior.
	incr = 0;	// Most of the time, will skip the char &quot;naturally&quot;.
	int c;
	int result = -1;
	unsigned char bsc = *pattern;
	if (!bsc) {
		// Avoid overrun
		result = &apos;\\&apos;;	// \ at end of pattern, take it literally
		return result;
	}

	switch (bsc) {
	case &apos;a&apos;:
	case &apos;b&apos;:
	case &apos;n&apos;:
	case &apos;f&apos;:
	case &apos;r&apos;:
	case &apos;t&apos;:
	case &apos;v&apos;:
		result = escapeValue(bsc);
		break;
	case &apos;x&apos;: {
			unsigned char hd1 = *(pattern + 1);
			unsigned char hd2 = *(pattern + 2);
			int hexValue = GetHexaChar(hd1, hd2);
			if (hexValue &gt;= 0) {
				result = hexValue;
				incr = 2;	// Must skip the digits
			} else {
				result = &apos;x&apos;;	// \x without 2 digits: see it as &apos;x&apos;
			}
		}
		break;
	case &apos;d&apos;:
		for (c = &apos;0&apos;; c &lt;= &apos;9&apos;; c++) {
			ChSet(static_cast&lt;unsigned char&gt;(c));
		}
		break;
	case &apos;D&apos;:
		for (c = 0; c &lt; MAXCHR; c++) {
			if (c &lt; &apos;0&apos; || c &gt; &apos;9&apos;) {
				ChSet(static_cast&lt;unsigned char&gt;(c));
			}
		}
		break;
	case &apos;s&apos;:
		ChSet(&apos; &apos;);
		ChSet(&apos;\t&apos;);
		ChSet(&apos;\n&apos;);
		ChSet(&apos;\r&apos;);
		ChSet(&apos;\f&apos;);
		ChSet(&apos;\v&apos;);
		break;
	case &apos;S&apos;:
		for (c = 0; c &lt; MAXCHR; c++) {
			if (c != &apos; &apos; &amp;&amp; !(c &gt;= 0x09 &amp;&amp; c &lt;= 0x0D)) {
				ChSet(static_cast&lt;unsigned char&gt;(c));
			}
		}
	case &apos;w&apos;:
		for (c = 0; c &lt; MAXCHR; c++) {
			if (iswordc(static_cast&lt;unsigned char&gt;(c))) {
				ChSet(static_cast&lt;unsigned char&gt;(c));
			}
		}
		break;
	case &apos;W&apos;:
		for (c = 0; c &lt; MAXCHR; c++) {
			if (!iswordc(static_cast&lt;unsigned char&gt;(c))) {
				ChSet(static_cast&lt;unsigned char&gt;(c));
			}
		}
		break;
	default:
		result = bsc;
	}
	return result;
}

const char *RESearch::Compile(const char *pattern, int length, bool caseSensitive, bool posix) {
	char *mp=nfa;          /* nfa pointer       */
	char *lp;              /* saved pointer     */
	char *sp=nfa;          /* another one       */
	char *mpMax = mp + MAXNFA - BITBLK - 10;

	int tagi = 0;          /* tag stack index   */
	int tagc = 1;          /* actual tag count  */

	int n;
	char mask;             /* xor mask -CCL/NCL */
	int c1, c2, prevChar;

	if (!pattern || !length) {
		if (sta)
			return 0;
		else
			return badpat(&quot;No previous regular expression&quot;);
	}
	sta = NOP;

	const char *p=pattern;     /* pattern pointer   */
	for (int i=0; i&lt;length; i++, p++) {
		if (mp &gt; mpMax)
			return badpat(&quot;Pattern too long&quot;);
		lp = mp;
		switch (*p) {

		case &apos;.&apos;:               /* match any char  */
			*mp++ = ANY;
			break;

		case &apos;^&apos;:               /* match beginning */
			if (p == pattern)
				*mp++ = BOL;
			else {
				*mp++ = CHR;
				*mp++ = *p;
			}
			break;

		case &apos;$&apos;:               /* match endofline */
			if (!*(p+1))
				*mp++ = EOL;
			else {
				*mp++ = CHR;
				*mp++ = *p;
			}
			break;

		case &apos;[&apos;:               /* match char class */
			*mp++ = CCL;
			prevChar = 0;

			i++;
			if (*++p == &apos;^&apos;) {
				mask = &apos;\377&apos;;
				i++;
				p++;
			} else
				mask = 0;

			if (*p == &apos;-&apos;) {	/* real dash */
				i++;
				prevChar = *p;
				ChSet(*p++);
			}
			if (*p == &apos;]&apos;) {	/* real brace */
				i++;
				prevChar = *p;
				ChSet(*p++);
			}
			while (*p &amp;&amp; *p != &apos;]&apos;) {
				if (*p == &apos;-&apos;) {
					if (prevChar &lt; 0) {
						// Previous def. was a char class like \d, take dash literally
						prevChar = *p;
						ChSet(*p);
					} else if (*(p+1)) {
						if (*(p+1) != &apos;]&apos;) {
							c1 = prevChar + 1;
							i++;
							c2 = *++p;
							if (c2 == &apos;\\&apos;) {
								if (!*(p+1))	// End of RE
									return badpat(&quot;Missing ]&quot;);
								else {
									i++;
									p++;
									int incr;
									c2 = GetBackslashExpression(p, incr);
									i += incr;
									p += incr;
									if (c2 &gt;= 0) {
										// Convention: \c (c is any char) is case sensitive, whatever the option
										ChSet(static_cast&lt;unsigned char&gt;(c2));
										prevChar = c2;
									} else {
										// bittab is already changed
										prevChar = -1;
									}
								}
							}
							if (prevChar &lt; 0) {
								// Char after dash is char class like \d, take dash literally
								prevChar = &apos;-&apos;;
								ChSet(&apos;-&apos;);
							} else {
								// Put all chars between c1 and c2 included in the char set
								while (c1 &lt;= c2) {
									ChSetWithCase(static_cast&lt;unsigned char&gt;(c1++), caseSensitive);
								}
							}
						} else {
							// Dash before the ], take it literally
							prevChar = *p;
							ChSet(*p);
						}
					} else {
						return badpat(&quot;Missing ]&quot;);
					}
				} else if (*p == &apos;\\&apos; &amp;&amp; *(p+1)) {
					i++;
					p++;
					int incr;
					int c = GetBackslashExpression(p, incr);
					i += incr;
					p += incr;
					if (c &gt;= 0) {
						// Convention: \c (c is any char) is case sensitive, whatever the option
						ChSet(static_cast&lt;unsigned char&gt;(c));
						prevChar = c;
					} else {
						// bittab is already changed
						prevChar = -1;
					}
				} else {
					prevChar = *p;
					ChSetWithCase(*p, caseSensitive);
				}
				i++;
				p++;
			}
			if (!*p)
				return badpat(&quot;Missing ]&quot;);

			for (n = 0; n &lt; BITBLK; bittab[n++] = 0)
				*mp++ = static_cast&lt;char&gt;(mask ^ bittab[n]);

			break;

		case &apos;*&apos;:               /* match 0 or more... */
		case &apos;+&apos;:               /* match 1 or more... */
			if (p == pattern)
				return badpat(&quot;Empty closure&quot;);
			lp = sp;		/* previous opcode */
			if (*lp == CLO)		/* equivalence... */
				break;
			switch (*lp) {

			case BOL:
			case BOT:
			case EOT:
			case BOW:
			case EOW:
			case REF:
				return badpat(&quot;Illegal closure&quot;);
			default:
				break;
			}

			if (*p == &apos;+&apos;)
				for (sp = mp; lp &lt; sp; lp++)
					*mp++ = *lp;

			*mp++ = END;
			*mp++ = END;
			sp = mp;
			while (--mp &gt; lp)
				*mp = mp[-1];
			*mp = CLO;
			mp = sp;
			break;

		case &apos;\\&apos;:              /* tags, backrefs... */
			i++;
			switch (*++p) {
			case &apos;&lt;&apos;:
				*mp++ = BOW;
				break;
			case &apos;&gt;&apos;:
				if (*sp == BOW)
					return badpat(&quot;Null pattern inside \\&lt;\\&gt;&quot;);
				*mp++ = EOW;
				break;
			case &apos;1&apos;:
			case &apos;2&apos;:
			case &apos;3&apos;:
			case &apos;4&apos;:
			case &apos;5&apos;:
			case &apos;6&apos;:
			case &apos;7&apos;:
			case &apos;8&apos;:
			case &apos;9&apos;:
				n = *p-&apos;0&apos;;
				if (tagi &gt; 0 &amp;&amp; tagstk[tagi] == n)
					return badpat(&quot;Cyclical reference&quot;);
				if (tagc &gt; n) {
					*mp++ = static_cast&lt;char&gt;(REF);
					*mp++ = static_cast&lt;char&gt;(n);
				} else
					return badpat(&quot;Undetermined reference&quot;);
				break;
			default:
				if (!posix &amp;&amp; *p == &apos;(&apos;) {
					if (tagc &lt; MAXTAG) {
						tagstk[++tagi] = tagc;
						*mp++ = BOT;
						*mp++ = static_cast&lt;char&gt;(tagc++);
					} else
						return badpat(&quot;Too many \\(\\) pairs&quot;);
				} else if (!posix &amp;&amp; *p == &apos;)&apos;) {
					if (*sp == BOT)
						return badpat(&quot;Null pattern inside \\(\\)&quot;);
					if (tagi &gt; 0) {
						*mp++ = static_cast&lt;char&gt;(EOT);
						*mp++ = static_cast&lt;char&gt;(tagstk[tagi--]);
					} else
						return badpat(&quot;Unmatched \\)&quot;);
				} else {
					int incr;
					int c = GetBackslashExpression(p, incr);
					i += incr;
					p += incr;
					if (c &gt;= 0) {
						*mp++ = CHR;
						*mp++ = static_cast&lt;unsigned char&gt;(c);
					} else {
						*mp++ = CCL;
						mask = 0;
						for (n = 0; n &lt; BITBLK; bittab[n++] = 0)
							*mp++ = static_cast&lt;char&gt;(mask ^ bittab[n]);
					}
				}
			}
			break;

		default :               /* an ordinary char */
			if (posix &amp;&amp; *p == &apos;(&apos;) {
				if (tagc &lt; MAXTAG) {
					tagstk[++tagi] = tagc;
					*mp++ = BOT;
					*mp++ = static_cast&lt;char&gt;(tagc++);
				} else
					return badpat(&quot;Too many () pairs&quot;);
			} else if (posix &amp;&amp; *p == &apos;)&apos;) {
				if (*sp == BOT)
					return badpat(&quot;Null pattern inside ()&quot;);
				if (tagi &gt; 0) {
					*mp++ = static_cast&lt;char&gt;(EOT);
					*mp++ = static_cast&lt;char&gt;(tagstk[tagi--]);
				} else
					return badpat(&quot;Unmatched )&quot;);
			} else {
				unsigned char c = *p;
				if (!c)	// End of RE
					c = &apos;\\&apos;;	// We take it as raw backslash
				if (caseSensitive || !iswordc(c)) {
					*mp++ = CHR;
					*mp++ = c;
				} else {
					*mp++ = CCL;
					mask = 0;
					ChSetWithCase(c, false);
					for (n = 0; n &lt; BITBLK; bittab[n++] = 0)
						*mp++ = static_cast&lt;char&gt;(mask ^ bittab[n]);
				}
			}
			break;
		}
		sp = lp;
	}
	if (tagi &gt; 0)
		return badpat((posix ? &quot;Unmatched (&quot; : &quot;Unmatched \\(&quot;));
	*mp = END;
	sta = OKP;
	return 0;
}

/*
 * RESearch::Execute:
 *   execute nfa to find a match.
 *
 *  special cases: (nfa[0])
 *      BOL
 *          Match only once, starting from the
 *          beginning.
 *      CHR
 *          First locate the character without
 *          calling PMatch, and if found, call
 *          PMatch for the remaining string.
 *      END
 *          RESearch::Compile failed, poor luser did not
 *          check for it. Fail fast.
 *
 *  If a match is found, bopat[0] and eopat[0] are set
 *  to the beginning and the end of the matched fragment,
 *  respectively.
 *
 */
int RESearch::Execute(CharacterIndexer &amp;ci, int lp, int endp) {
	unsigned char c;
	int ep = NOTFOUND;
	char *ap = nfa;

	bol = lp;
	failure = 0;

	Clear();

	switch (*ap) {

	case BOL:			/* anchored: match from BOL only */
		ep = PMatch(ci, lp, endp, ap);
		break;
	case EOL:			/* just searching for end of line normal path doesn&apos;t work */
		if (*(ap+1) == END) {
			lp = endp;
			ep = lp;
			break;
		} else {
			return 0;
		}
	case CHR:			/* ordinary char: locate it fast */
		c = *(ap+1);
		while ((lp &lt; endp) &amp;&amp; (ci.CharAt(lp) != c))
			lp++;
		if (lp &gt;= endp)	/* if EOS, fail, else fall thru. */
			return 0;
	default:			/* regular matching all the way. */
		while (lp &lt; endp) {
			ep = PMatch(ci, lp, endp, ap);
			if (ep != NOTFOUND)
				break;
			lp++;
		}
		break;
	case END:			/* munged automaton. fail always */
		return 0;
	}
	if (ep == NOTFOUND)
		return 0;

	bopat[0] = lp;
	eopat[0] = ep;
	return 1;
}

/*
 * PMatch: internal routine for the hard part
 *
 *  This code is partly snarfed from an early grep written by
 *  David Conroy. The backref and tag stuff, and various other
 *  innovations are by oz.
 *
 *  special case optimizations: (nfa[n], nfa[n+1])
 *      CLO ANY
 *          We KNOW .* will match everything upto the
 *          end of line. Thus, directly go to the end of
 *          line, without recursive PMatch calls. As in
 *          the other closure cases, the remaining pattern
 *          must be matched by moving backwards on the
 *          string recursively, to find a match for xy
 *          (x is &quot;.*&quot; and y is the remaining pattern)
 *          where the match satisfies the LONGEST match for
 *          x followed by a match for y.
 *      CLO CHR
 *          We can again scan the string forward for the
 *          single char and at the point of failure, we
 *          execute the remaining nfa recursively, same as
 *          above.
 *
 *  At the end of a successful match, bopat[n] and eopat[n]
 *  are set to the beginning and end of subpatterns matched
 *  by tagged expressions (n = 1 to 9).
 */

extern void re_fail(char *,char);

#define isinset(x,y)	((x)[((y)&amp;BLKIND)&gt;&gt;3] &amp; bitarr[(y)&amp;BITIND])

/*
 * skip values for CLO XXX to skip past the closure
 */

#define ANYSKIP 2 	/* [CLO] ANY END          */
#define CHRSKIP 3	/* [CLO] CHR chr END      */
#define CCLSKIP 34	/* [CLO] CCL 32 bytes END */

int RESearch::PMatch(CharacterIndexer &amp;ci, int lp, int endp, char *ap) {
	int op, c, n;
	int e;		/* extra pointer for CLO  */
	int bp;		/* beginning of subpat... */
	int ep;		/* ending of subpat...    */
	int are;	/* to save the line ptr.  */

	while ((op = *ap++) != END)
		switch (op) {

		case CHR:
			if (ci.CharAt(lp++) != *ap++)
				return NOTFOUND;
			break;
		case ANY:
			if (lp++ &gt;= endp)
				return NOTFOUND;
			break;
		case CCL:
			if (lp &gt;= endp)
				return NOTFOUND;
			c = ci.CharAt(lp++);
			if (!isinset(ap,c))
				return NOTFOUND;
			ap += BITBLK;
			break;
		case BOL:
			if (lp != bol)
				return NOTFOUND;
			break;
		case EOL:
			if (lp &lt; endp)
				return NOTFOUND;
			break;
		case BOT:
			bopat[*ap++] = lp;
			break;
		case EOT:
			eopat[*ap++] = lp;
			break;
 		case BOW:
			if ((lp!=bol &amp;&amp; iswordc(ci.CharAt(lp-1))) || !iswordc(ci.CharAt(lp)))
				return NOTFOUND;
			break;
		case EOW:
			if (lp==bol || !iswordc(ci.CharAt(lp-1)) || iswordc(ci.CharAt(lp)))
				return NOTFOUND;
			break;
		case REF:
			n = *ap++;
			bp = bopat[n];
			ep = eopat[n];
			while (bp &lt; ep)
				if (ci.CharAt(bp++) != ci.CharAt(lp++))
					return NOTFOUND;
			break;
		case CLO:
			are = lp;
			switch (*ap) {

			case ANY:
				while (lp &lt; endp)
					lp++;
				n = ANYSKIP;
				break;
			case CHR:
				c = *(ap+1);
				while ((lp &lt; endp) &amp;&amp; (c == ci.CharAt(lp)))
					lp++;
				n = CHRSKIP;
				break;
			case CCL:
				while ((lp &lt; endp) &amp;&amp; isinset(ap+1,ci.CharAt(lp)))
					lp++;
				n = CCLSKIP;
				break;
			default:
				failure = true;
				//re_fail(&quot;closure: bad nfa.&quot;, *ap);
				return NOTFOUND;
			}

			ap += n;

			while (lp &gt;= are) {
				if ((e = PMatch(ci, lp, endp, ap)) != NOTFOUND)
					return e;
				--lp;
			}
			return NOTFOUND;
		default:
			//re_fail(&quot;RESearch::Execute: bad nfa.&quot;, static_cast&lt;char&gt;(op));
			return NOTFOUND;
		}
	return lp;
}

/*
 * RESearch::Substitute:
 *  substitute the matched portions of the src in dst.
 *
 *  &amp;    substitute the entire matched pattern.
 *
 *  \digit  substitute a subpattern, with the given tag number.
 *      Tags are numbered from 1 to 9. If the particular
 *      tagged subpattern does not exist, null is substituted.
 */
int RESearch::Substitute(CharacterIndexer &amp;ci, char *src, char *dst) {
	unsigned char c;
	int  pin;
	int bp;
	int ep;

	if (!*src || !bopat[0])
		return 0;

	while ((c = *src++) != 0) {
		switch (c) {

		case &apos;&amp;&apos;:
			pin = 0;
			break;

		case &apos;\\&apos;:
			c = *src++;
			if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) {
				pin = c - &apos;0&apos;;
				break;
			}

		default:
			*dst++ = c;
			continue;
		}

		if ((bp = bopat[pin]) != 0 &amp;&amp; (ep = eopat[pin]) != 0) {
			while (ci.CharAt(bp) &amp;&amp; bp &lt; ep)
				*dst++ = ci.CharAt(bp++);
			if (bp &lt; ep)
				return 0;
		}
	}
	*dst = &apos;\0&apos;;
	return 1;
}

</tt></pre></div><div style="text-align: right; padding: 8pt; font-size: 12px"><a href="/xmlfeed/weblog-rss20.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABQAAAADwCexKkxAAAAWUlEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMCt0ZdTU/F/7/+1HEkydFpoKVPn+93sUlUujQvP/7UcRTAuNDJ2a//s/imDqtKVZofm/1qGYSZk7sfodGwAAiobBJtffoNAAAAAASUVORK5CYII=" alt="RSS 2.0 Weblog Feed" width="80" height="15"/></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAAaklEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMDV16rTQ/H/7V//69+//v/3/9oMEI6cuAwr+fv/+/b5d///v//0eJBgWOhMo+Gs9UPAdXDBy6lSYyn9wQZCZS0GCYDPXQcykzJ1Y/Y4NAABKvL80wyoMPgAAAABJRU5ErkJggg==" alt="Atom 1.0 Weblog Feed" width="80" height="15"/></a> <a href="http://validator.w3.org/check?uri=referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABKklEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6qIGzIRiKZs9GFoEaMRuZhhrYqqJXy8uZYauRxC/VHew7e3YTPAxnI5swG6JxNrKBNjB1EFmIgV0+HA6C8pqqzhXG7BbJJROQIwViMYQ7G2oDQQNn57JyG7kxiCfObrBmS5+BHMuYLkTzMnYDm5WY4lOZZRPKZocxes+aPbuwCFsYohiICLvZsKBAMrDTQ7K/StveU8icTzrOL8JdLpOyWJ49u8Bx9ozw8DY7UYW03hhdxZAOSg2c3jN79rSJs1vSKmfOnpFXNJmynELlvExlAADnaZpLFGEC2wAAAABJRU5ErkJggg==" alt="Valid XHTML 1.1" width="80" height="15"/></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABEUlEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6mIEQCsIjwhKoga0qerW8nBm2Gkn8Ut3BvrNnN8HCcDYM2cBIogzs8uFwEJTXVHWuMGa3SC6ZgIgUqCEwdxJr4OxcVm4jNwbxxNkN1mzpM2ajGIjsPGK9PLtZiSk+lVk2oWx2GKP3rNmzC4tQwpDoIIQb2Okh2V+lbe8pZM4nHecX4S6XSVksz55d4Dh7Rnh4m52oQlpvjK5iSAelBk7vmT172sTZLWmVM2fPyCuaTFlOoXJepjIAANlljDGY/l5pAAAAAElFTkSuQmCC" alt="Valid CSS (2.1)" width="80" height="15"/></a><br/>Copyright 2005-2015 <a href="/about/">Timo Bingmann</a> - <a href="/about/impressum.html">Impressum</a></div><script type="text/javascript">var _paq = _paq || []; _paq.push(["trackPageView"]); _paq.push(["enableLinkTracking"]);(function() {var u=(("https:" == document.location.protocol) ? "https" : "http") + "://panthema.net/wik-331/"; _paq.push(["setTrackerUrl", u+"js/"]); _paq.push(["setSiteId", "2"]);var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";g.defer=true; g.async=true; g.src=u+"js/"; s.parentNode.insertBefore(g,s);})();</script><noscript><p><img src="http://panthema.net/wik-331/js/?idsite=2&amp;rec=1" style="border:0" alt="" /></p></noscript></body></html>