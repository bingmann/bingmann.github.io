<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><title>Speed Test Results of STX B+ Tree - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="http://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="http://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/js/base.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body style="background-image: url(/img/bgfractal5.jpg)"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/">Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li class="nt"><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li><li class="ns"><a href="/search.html">Search</a></li></ul></li><li class="top"><a class="ni" href="/tags/">Tags</a><div style="width: 14em; margin-left: -9em; margin-top: 4px"><a style="font-size: 10pt" href="/tags/algebra.html">algebra</a> <a style="font-size: 16pt" href="/tags/c++.html">c++</a> <a style="font-size: 12pt" href="/tags/code-example.html">code-example</a> <a style="font-size: 14pt" href="/tags/code-snippet.html">code-snippet</a> <a style="font-size: 11pt" href="/tags/coding_tricks.html">coding tricks</a> <a style="font-size: 10pt" href="/tags/compsci.html">compsci</a> <a style="font-size: 10pt" href="/tags/compsci_study_thesis.html">compsci study thesis</a> <a style="font-size: 9pt" href="/tags/crypto-speedtest.html">crypto-speedtest</a> <a style="font-size: 10pt" href="/tags/cryptography.html">cryptography</a> <a style="font-size: 9pt" href="/tags/cryptote.html">cryptote</a> <a style="font-size: 12pt" href="/tags/flex-bison-cpp-example.html">flex-bison-cpp-example</a> <a style="font-size: 12pt" href="/tags/frontpage.html">frontpage</a> <a style="font-size: 13pt" href="/tags/fun.html">fun</a> <a style="font-size: 10pt" href="/tags/graphviz.html">graphviz</a> <a style="font-size: 9pt" href="http://www.hmtg.de">hartmetall</a> <a style="font-size: 9pt" href="/tags/helppc.html">helppc</a> <a style="font-size: 9pt" href="/tags/hifi_selbstbau.html">hifi selbstbau</a> <a style="font-size: 10pt" href="/tags/latex.html">latex</a> <a style="font-size: 10pt" href="/tags/librivox.html">librivox</a> <a style="font-size: 10pt" href="/tags/linux.html">linux</a> <a style="font-size: 10pt" href="/tags/maths.html">maths</a> <a style="font-size: 9pt" href="/tags/music.html">music</a> <a style="font-size: 10pt" href="/tags/netfundamentals.html">netfundamentals</a> <a style="font-size: 11pt" href="/tags/ns-3.html">ns-3</a> <a style="font-size: 9pt" href="/tags/parallel-string-sorting.html">parallel-string-sorting</a> <a style="font-size: 9pt" href="/tags/qtsqlview.html">qtsqlview</a> <a style="font-size: 10pt" href="/tags/research.html">research</a> <a style="font-size: 11pt" href="/tags/sdios06.html">sdios06</a> <a style="font-size: 9pt" href="/tags/sdlfractal.html">sdlfractal</a> <a style="font-size: 11pt" href="/tags/sorting.html">sorting</a> <a style="font-size: 10pt" href="/tags/stringology.html">stringology</a> <a style="font-size: 16pt" href="/tags/stx-btree.html">stx-btree</a> <a style="font-size: 9pt" href="/tags/stx-exparser.html">stx-exparser</a> <a style="font-size: 10pt" href="/tags/stxxl.html">stxxl</a> <a style="font-size: 15pt" href="/tags/talk.html">talk</a> <a style="font-size: 10pt" href="/tags/tutorium.html">tutorium</a> <a style="font-size: 16pt" href="/tags/university.html">university</a> <a style="font-size: 13pt" href="/tags/utilities.html">utilities</a> <a style="font-size: 9pt" href="/tags/webdesign.html">webdesign</a> </div></li><li class="top"> <a class="ni" href="#">Projects</a> <ul style="margin-left: -8em; margin-top: 4px;" class="nx"> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2013/parallel-string-sorting/">parallel-string-sorting</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li class="nt"><a href="/2013/1212-stxxl-1.4.0/">STXXL 1.4</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="#">Research</a> <ul style="margin-left: -16em; margin-top: 4px" class="nx"> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP - External Memory Suffix Sorting</a></li> <li><a href="/2013/parallel-string-sorting/">pS5 - Parallel String Sorting</a></li> <li><a href="/tags/stxxl.html">STXXL - External Memory Algorithms</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="/about/">About</a> <ul style="margin-left: -6em; margin-top: 4px" class="nx"> <li><a href="/about/">Timo Bingmann</a></li> <li><a href="/about/impressum.html">Impressum</a></li> </ul></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2007/">2007</a> / <a href="/2007/stx-btree/">stx-btree</a> / <a href="/2007/stx-btree/speedtest/">speedtest</a></div></div><div class="pttextcontent"><div style="float: right; clear: right; margin: 12pt 0pt 12pt 12pt; font-size: smaller; text-align: center"><a href="/2007/stx-btree/speedtest/"><img src="/2007/stx-btree/thumb.png" width="252" height="193" alt="Design of a small B+ tree" title="Design of a small B+ tree" /></a></div><h1>Speed Test Results of STX B+ Tree</h1><div class="sbframe" style="height: 16em; width: 248px"><a id="shoutbox"></a><table class="sbtable"> <tr><td class="a0">TalkBox</td></tr> <tr><td style="text-align: center" class="d0"><i>No posts yet.</i></td></tr>  <tr style="display: none" id="newpost_div"><td class="d1"><a href="http://www.gravatar.com/" id="newpost_imgurl" rel="nofollow"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAAAAAA6fptVAAAAAXNSR0IArs4c6QAAAApJREFUCB1j+A8AAQEBADZfZ4AAAAAASUVORK5CYII=" width="34" height="34" class="sbimg" id="newpost_img" alt="Gravatar" /></a><b><span id="newpost_name">Name</span></b>: <span id="newpost_body">Text</span></td></tr><tr><td class="d1"><form id="noteform" method="post" action="/sendpost.php"><div style="margin: 2px; text-align: center"><input type="hidden" name="previewok" value="0" /><input type="hidden" name="posturi" value="/2007/stx-btree/speedtest/" /><input type="text" name="postname" size="30" value="Name" style="width: 95%" class="sbedit" onfocus="if (value == 'Name') { value=''; }" onblur="if (value == '') { value='Name'; }" /><br /><input type="text" name="postmail" size="30" value="Homepage/Gravatar E-Mail" style="width: 95%" class="sbedit" onfocus="if (value == 'Homepage/Gravatar E-Mail') { value=''; }" onblur="if (value == '') { value='Homepage/Gravatar E-Mail'; }" /><br /><textarea name="postbody" cols="30" rows="2" style="width: 95%" class="sbtext" onfocus="if (value == 'Text') { value=''; }" onblur="if (value == '') { value='Text'; }">Text</textarea><br /><input type="button" name="Preview" value="Preview" onclick="return sbform_submit()" class="sbbutton" /><input type="submit" name="Submit" value="Submit" disabled="disabled" id="newpost_submit" class="sbbutton" /></div></form></td></tr></table></div><p class="info">Posted on 2007-04-27, last updated 2013-05-05 by <a href="/about/">Timo Bingmann</a><a href="http://plus.google.com/+TimoBingmann?rel=author"></a> at <a href="/2007/stx-btree/speedtest/">Permlink</a>.</p><h2>Speed Test Experiments</h2><p>The B+ tree source package contains a speedtest program which compares the libstdc++ STL red-black tree with the implemented B+ tree with many different parameters. The newer STL hash table container from the <code>__gnu_cxx</code> namespace and the TR1 hash table <code>tr1::unordered_map</code> is also tested against the two trees. To keep focus on the algorithms and reduce data copying the multiset specializations were chosen. Note that the comparison between hash table and trees is somewhat unfair, because the hash table does not keep the keys sorted, and thus cannot be used for all applications.</p><p>Three set of test procedures are used: the first only inserts <em>n</em> random integers into the tree / hash table. The second test first inserts <em>n</em> random integers, then performs <em>n</em> lookups for those integers and finally erases all n integers. The last test only performs <em>n</em> lookups on a tree pre-filled with n integers. All lookups are successful.</p><p>These three test sequences are preformed for <em>n</em> from 125 to 4,096,000 / 32,768,000 or 65,536,000 where <em>n</em> is doubled after each test run. For each <em>n</em> the test procedure is repeated until at least one second execution time elapses during the repeated cycle. This way the measured speed for small <em>n</em> is averaged over up to 65,536 repetitions.</p><p>Lastly, it is purpose of the test to determine a good node size for the B+ tree. Therefore the test runs are performed on different slot sizes; both inner and leaf nodes hold the same number of items. The number of slots tested ranges from 4 to 256 slots and therefore yields node sizes from about 50 to 2,048 bytes. This requires that the B+ tree template is instantiated for each of the probed node sizes! In the 2011 and 2013 test, only every other slot size is actually tested.</p><p>Three test results are included in the 0.9 tarball: one done <a href="#results2007">in 2007</a> with version 0.7, another done <a href="#results2011">in 2011</a> with version 0.8.6, and the third <a href="#results2013">in 2013</a> with version 0.9, mainly to verify the speed gains from removing binary search. <strong>The speed increase between 0.9 and 0.8.6 is discussed in <a href="/2013/0507-STX-B+Tree-0.9/">a separate blog post</a>.</strong></p><a id="results2007"></a><h1>Results 2007</h1><p>The speed test source code was compiled with <code>g++ 4.1.2 -O3 -fomit-frame-pointer</code>. Compilation of the speed test with <code>-O3</code> takes very long and requires much RAM. It is not automatically built when running &quot;make all&quot;.</p><p>Some non-exhaustive tests with the Intel C++ Compiler showed drastically different results. It optimized the B+ tree algorithms much better than gcc. More work is needed to get g++ to optimize as well as icc.</p><p>The results are be displayed below using gnuplot. All tests were run on a Pentium4 3.2 GHz with 2 GB RAM. A high-resolution PDF plot of the following images can be found in the package at <code>speedtest/results-2007/speedtest.pdf</code> or by clicking one the plots:</p><p style="text-align: center"> <a href="results-2007/speedtest.pdf"><img alt="speedtest-01.png" src="results-2007/speedtest-01.png" title="speedtest-01.png" width="700" height="467" /></a></p><p style="text-align: center"> <a href="results-2007/speedtest.pdf"><img alt="speedtest-02.png" src="results-2007/speedtest-02.png" title="speedtest-02.png" width="700" height="467" /></a></p><p>The first two plots above show the absolute time measured for inserting <em>n</em> items into seven different tree variants. For small <em>n</em> (the first plot) the speed of red-black tree and B+ tree are very similar. For large <em>n</em> the red-black tree slows down, and for <em>n</em> &gt; 1,024,000 items the red-black tree requires almost twice as much time as a B+ tree with 32 slots. The STL hash table performs better than the STL map but not as good as the B+ tree implementations with higher slot counts.</p><p>The next plot shows the insertion time per item, which is calculated by dividing the absolute time by the number of inserted items. Notice that insertion time is now in microseconds. The plot shows that the red-black tree reaches some limitation at about <em>n</em> = 16,000 items. Beyond this item count the B+ tree (with 32 slots) performs much better than the STL multiset. The STL hash table resizes itself in defined intervals, which leads to non-linearly increasing insert times.</p><p style="text-align: center"> <a href="results-2007/speedtest.pdf"><img alt="speedtest-03.png" src="results-2007/speedtest-03.png" title="speedtest-03.png" width="700" height="467" /></a></p><p style="text-align: center"> <a href="results-2007/speedtest.pdf"><img alt="speedtest-04.png" src="results-2007/speedtest-04.png" title="speedtest-04.png" width="700" height="467" /></a></p><p>The last plots goal is to find the best node size for the B+ tree. It displays the total measured time of the insertion test depending on the number of slots in inner and leaf nodes. Only runs with more than 1 million inserted items are plotted. One can see that the minimum is around 65 slots for each of the curves. However to reduce unused memory in the nodes the most practical slot size is around 35. This amounts to total node sizes of about 280 bytes. Thus in the implementation a target size of 256 bytes was chosen.</p><p>The following two plots show the same aspects as above, except that not only insertion time was measured. Instead in the first plot a whole insert/find/delete cycle was performed and measured. The second plot is restricted to the lookup / find part.</p><p style="text-align: center"> <a href="results-2007/speedtest.pdf"><img alt="speedtest-07.png" src="results-2007/speedtest-07.png" title="speedtest-07.png" width="700" height="467" /></a></p><p style="text-align: center"> <a href="results-2007/speedtest.pdf"><img alt="speedtest-11.png" src="results-2007/speedtest-11.png" title="speedtest-11.png" width="700" height="467" /></a></p><p>The results for the trees are in general accordance to those of only insertion. However the hash table implementation performs much faster in both tests. This is expected, because hash table lookup (and deletion) requires fewer memory accesses than tree traversal. Thus a hash table implementation will always be faster than trees. But of course hash tables do not store items in sorted order. Interestingly the hash table&apos;s performance is not linear in the number of items: it&apos;s peak performance is not with small number of items, but with around 10,000 items. And for item counts larger than 100,000 the hash table slows down: lookup time more than doubles. However, after doubling, the lookup time does not change much: lookup on tables with 1 million items takes approximately the same time as with 4 million items.</p><a id="results2011"></a><h1>Results 2011</h1><p>In 2011, after some smaller patches and fixes to the main code, I decided to rerun the old speed test on my new hardware and with up-to-date compilers.</p><p>The speedtest source code was compiled on a x86_64 architecture using <code>gcc 4.4.5</code> with flags <code>-O3 -fomit-frame-pointer</code>. It was run on an Intel Core i7 950 clocked at 3.07 GHz. According to cpuinfo, this processor contains 8 MB L2 cache.</p><p>The full results of the newly run tests are found in the package at <code>speedtest/results-2011/speedtest.pdf</code> or can be downloaded by clicking the following plot:</p><p style="text-align: center"> <a href="results-2011/speedtest.pdf"><img alt="speedtest-03.png" src="results-2011/speedtest-03.png" title="speedtest-03.png" width="700" height="490" /></a></p><p>This plot is maybe the most interesting, especially compared with the old run from 2007. Again the B+ tree multiset implementation is faster than the red-black tree for large number of items in the tree. However, due to the faster hardware and larger cache sizes, the average insertion speed plots diverge notable at around 100,000 items instead of at 16,000 items for the older Pentium 4 CPU. Nevertheless, the graphs diverge for larger <em>n</em> in approximately the same fashion as in the older plots.</p><p>This lets one assume that the basic cache hierarchy architecture has not changed and the B+ tree implementation still works much better for larger item counts than the red-black tree.</p><a id="results2013"></a><h1>Results 2013</h1><p>In 2013, version 0.9 of the library was released with patches that accumulated over the years. Since some these patches were done to speed up the <code>btree_set</code> specialization, the speedtest now includes tests for both <code>map</code> and <code>set</code> containers. I also added the <code>tr1::unordered_map</code> hash map implementation from gcc.</p><p><strong>The speed increase between 0.9 and 0.8.6 is discussed in <a href="/2013/0507-STX-B+Tree-0.9/">this blog post</a>.</strong></p><p>The speed tests were compiled on a x86_64 architecture with <code>gcc 4.5.0</code> with <code>-O3 -march=native</code>. It was run on Intel Core i7 920 clocked with 2.67 GHz, and containing 32 KiB L1 data cache, 256 KiB L2 cache, 8 MiB (shared) L3 cache and 12 GiB DDR3-800 RAM.</p><p>We first regard the canonical insertion plot with <code>multimap</code> variants and compare it with the results from 2011:</p><p style="text-align: center"> <a href="results-2013/speedtest.pdf"><img alt="speedtest-01.png" src="results-2013/speedtest-01.png" title="speedtest-01.png" width="700" height="490" /></a></p><p>As expected, the machines are very similar. Note that the plot line colors are shifted due to <code>tr1::unordered_map</code>. This is maybe most interesting too: the <code>tr1::unordered_map</code> hash map implementation turned out to be slightly faster for insertion than the older <code>__gnu_cxx::hash_map</code> hash tables.</p><p>The following plot shows the time of lookups in a B+ tree map depending on the node size. The default configuration tries to create node sizes of 256 bytes (via calculations from the <code>key_type</code> size). For the integer test case this yields 64 keys in a node, which is still a sweet spot for today&apos;s 64-bit architectures:</p><p style="text-align: center"> <a href="results-2013/speedtest.pdf"><img alt="speedtest-06.png" src="results-2013/speedtest-06.png" title="speedtest-06.png" width="700" height="490" /></a></p><p>New in this year&apos;s speed test results is the following plot showing the <code>multimap</code>. Previous speed tests worked exclusively with <code>set</code>s.</p><p style="text-align: center"> <a href="results-2013/speedtest.pdf"><img alt="speedtest-11.png" src="results-2013/speedtest-11.png" title="speedtest-11.png" width="700" height="490" /></a></p><p>To compare <code>set</code> and <code>map</code> speeds directly, regard the following ratio plot, which shows how much faster an integer set is over an integer pair map (of the different types):</p><p style="text-align: center"> <a href="results-2013/ratio-set-over-map.pdf"><img alt="ratio-set-over-map-3.png" src="results-2013/ratio-set-over-map-3.png" title="ratio-set-over-map-3.png" width="700" height="490" /></a></p>Because the B+ tree saves only keys in the inner nodes, the B+ map not much slower than the set. Thus the ratio of set over map is better for larger node sizes, even though large node sizes have other problems. As the <code>std::map</code> mixes keys and values in the red-black tree nodes, the standard set is alot faster than the map. Here again, the B+ tree is more efficient and there is no reason not to use it for larger integer maps. </div><div style="text-align: right; padding: 8pt; font-size: 12px"><a href="/xmlfeed/weblog-rss20.xml"><img src="/img/xmlfeed-rss20.png" alt="RSS 2.0 Weblog Feed" height="15" width="80" /></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="/img/xmlfeed-atom10.png" alt="Atom 1.0 Weblog Feed" height="15" width="80" /></a> <a href="http://validator.w3.org/check?uri=referer"><img src="/img/w3c-xhtml10.png" alt="Valid XHTML 1.1" height="15" width="80" /></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="/img/w3c-css.png" alt="Valid CSS (2.1)" height="15" width="80" /></a><br/>Copyright 2005-2013 <a href="/about/">Timo Bingmann</a> - <a href="/about/impressum.html">Impressum</a></div><script type="text/javascript">var _paq = _paq || []; _paq.push(["trackPageView"]); _paq.push(["enableLinkTracking"]);(function() {var u=(("https:" == document.location.protocol) ? "https" : "http") + "://panthema.net/wik-331/"; _paq.push(["setTrackerUrl", u+"js/"]); _paq.push(["setSiteId", "2"]);var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";g.defer=true; g.async=true; g.src=u+"js/"; s.parentNode.insertBefore(g,s);})();</script><noscript><p><img src="http://panthema.net/wik-331/js/?idsite=2&amp;rec=1" style="border:0" alt="" /></p></noscript></body></html>