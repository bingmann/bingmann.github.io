<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>STX B+ Tree Template Classes: stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">STX B+ Tree Template Classes&#160;<span id="projectnumber">0.8.6</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00036.html">stx</a>      </li>
      <li class="navelem"><a class="el" href="a00007.html">btree_multiset</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="stx::btree_multiset" -->
<p>Specialized B+ tree template class implementing STL's multiset container.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00032_source.html">btree_multiset.h</a>&gt;</code></p>

<p><a href="a00057.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">empty_struct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The empty struct used as a placeholder for the data_type.  <a href="a00014.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">First template parameter: The key type of the btree.  <a href="#adaf86bdcdf48a7d4ed87ae020436287e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Second template parameter: Key comparison function object.  <a href="#ab4d81bc53597e88abe6617421837df21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Third template parameter: Traits object used to define more parameters of the B+ tree.  <a href="#adf34a1c10a3b0e0c1caa0358b9d4f059"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fourth template parameter: STL allocator.  <a href="#a3bd75b696bde37ad47838d8058503799"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00014.html">empty_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a4797d9899509ebbd391f6478f85fefd9">data_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The empty data_type.  <a href="#a4797d9899509ebbd391f6478f85fefd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a5fe61553bb02818305fde84b5342e753">value_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the set value_type: the key_type.  <a href="#a5fe61553bb02818305fde84b5342e753"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00007.html">btree_multiset</a><br class="typebreak"/>
&lt; <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a>, <a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a>, <br class="typebreak"/>
<a class="el" href="a00007.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a>, <a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a99552060748673aa8a60e7d663f8f4a4">self</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of our own type.  <a href="#a99552060748673aa8a60e7d663f8f4a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00002.html">stx::btree</a>&lt; <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a>, <br class="typebreak"/>
<a class="el" href="a00014.html">data_type</a>, <a class="el" href="a00007.html#a5fe61553bb02818305fde84b5342e753">value_type</a>, <br class="typebreak"/>
<a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a>, <a class="el" href="a00007.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a>, true, <br class="typebreak"/>
<a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ab1ede8348d5ec50a52d993b2b9f87465">btree_impl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation type of the btree_base.  <a href="#ab1ede8348d5ec50a52d993b2b9f87465"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::value_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a7ef41640ce62bdd8b1857ae6c3ef1c51">value_compare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function class comparing two value_type keys.  <a href="#a7ef41640ce62bdd8b1857ae6c3ef1c51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00002.html#a883a5c48e52ec6e9927037e892f54692">btree_impl::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type used to count keys.  <a href="#acb308af84d816e44d6fcaaf075b08a22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::tree_stats&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a268704f56c398ed05b600262f8c1d558">tree_stats</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Small structure containing statistics about the tree.  <a href="#a268704f56c398ed05b600262f8c1d558"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like iterator object for B+ tree items.  <a href="#a0d0c6764234271152a77643d5f160889"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like iterator object for B+ tree items.  <a href="#ac3b6e263ec2f54cab4e541b02e2156bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
btree_impl::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">create mutable reverse iterator by using STL magic  <a href="#aa20cfd7ed6236bc3c51b20d5a77a5286"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
btree_impl::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">create constant reverse iterator by using STL magic  <a href="#aa137474f07b11232834fc838c96f89b4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ae51979526a758ca48dff71269509d30d">btree_multiset</a> (const <a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;alloc=<a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor initializing an empty B+ tree with the standard key comparison function.  <a href="#ae51979526a758ca48dff71269509d30d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a4411a079d52cdac10490c9f44827ed63">btree_multiset</a> (const <a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a> &amp;kcf, const <a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;alloc=<a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing an empty B+ tree with a special key comparison object.  <a href="#a4411a079d52cdac10490c9f44827ed63"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00007.html#afacbb565d340ff96007110b66542a2a7">btree_multiset</a> (InputIterator first, InputIterator last, const <a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;alloc=<a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing a B+ tree with the range [first,last)  <a href="#afacbb565d340ff96007110b66542a2a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00007.html#a90d80cc52006eec0ae72dc7d1e6b2dac">btree_multiset</a> (InputIterator first, InputIterator last, const <a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a> &amp;kcf, const <a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;alloc=<a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing a B+ tree with the range [first,last) and a special key comparison object.  <a href="#a90d80cc52006eec0ae72dc7d1e6b2dac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#aec3bb61dacff05a504ae53889d8e3bf3">~btree_multiset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees up all used B+ tree memory pages.  <a href="#aec3bb61dacff05a504ae53889d8e3bf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#aad820bbc85b7beaaca43fbdb1b610b56">swap</a> (<a class="el" href="a00007.html">self</a> &amp;from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast swapping of two identical B+ tree objects.  <a href="#aad820bbc85b7beaaca43fbdb1b610b56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a3ecbf097192ab41b7a29db4349ce2d3e">key_comp</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to the key comparison object sorting the B+ tree.  <a href="#a3ecbf097192ab41b7a29db4349ce2d3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#a7ef41640ce62bdd8b1857ae6c3ef1c51">value_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a84f47ce04fb5330cb2d766a105b278a2">value_comp</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to a constructed value_type comparison object.  <a href="#a84f47ce04fb5330cb2d766a105b278a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ac2fc089101a5d6fdf86ee2d09b9eacce">get_allocator</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base node allocator provided during construction.  <a href="#ac2fc089101a5d6fdf86ee2d09b9eacce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a77cc7f5486c5add7feb4c9e601c4d921">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all keys and all nodes of the tree.  <a href="#a77cc7f5486c5add7feb4c9e601c4d921"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a0c8b01c05f01540fe8e7c87f7e798557">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#a0c8b01c05f01540fe8e7c87f7e798557"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#a3b3fdd20ed1c32051e6e8e9762789178"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#acca702924e73cc5df9f8e27f59259f7c">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only constant iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#acca702924e73cc5df9f8e27f59259f7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a8fa9d5230ddb6f9306b2e941c1448ece">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only constant iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#a8fa9d5230ddb6f9306b2e941c1448ece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ad5ff92256da155cf0a800c0be6d37f10">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write reverse iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#ad5ff92256da155cf0a800c0be6d37f10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#accb388873e7a00b1779a27487e4c0200">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write reverse iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#accb388873e7a00b1779a27487e4c0200"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#aab7bf40d95f5e2e3a6f48ff132e5aa5c">rbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only reverse iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#aab7bf40d95f5e2e3a6f48ff132e5aa5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a01090ac817bc6525160dbee3b2943ad1">rend</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only reverse iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#a01090ac817bc6525160dbee3b2943ad1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a9be405a164ded347358ce38599d768bd">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of keys in the B+ tree.  <a href="#a9be405a164ded347358ce38599d768bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a1943f3a2270fd9a13deb4d98855eb4bc">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is at least one key in the B+ tree.  <a href="#a1943f3a2270fd9a13deb4d98855eb4bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a2b0012b20d4bc04d78d1297d78550d8a">max_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest possible size of the B+ Tree.  <a href="#a2b0012b20d4bc04d78d1297d78550d8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00007.html#a268704f56c398ed05b600262f8c1d558">tree_stats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a926c5bb8fbf409b1371c1ca211ba2bde">get_stats</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the current statistics.  <a href="#a926c5bb8fbf409b1371c1ca211ba2bde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a1438934e738862154bbcfa1314b485bb">exists</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-STL function checking whether a key is in the B+ tree.  <a href="#a1438934e738862154bbcfa1314b485bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a130a3b87e39b1d9ff8be6df80b942737">find</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns an iterator to the key slot if found.  <a href="#a130a3b87e39b1d9ff8be6df80b942737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ac3bf82364b3392aa056b866a012ac0d8">find</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns an constant iterator to the key slot if found.  <a href="#ac3bf82364b3392aa056b866a012ac0d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ab2ae64a7de25306d48798d502de46b6c">count</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns the number of identical key entries found.  <a href="#ab2ae64a7de25306d48798d502de46b6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#acf1949d71f9c83184c98d084d66c56a4">lower_bound</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns an iterator to the first pair equal to or greater than key, or <a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller.  <a href="#acf1949d71f9c83184c98d084d66c56a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#afb5c018e2dd2c9f53a148ddf0781921d">lower_bound</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns a constant iterator to the first pair equal to or greater than key, or <a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller.  <a href="#afb5c018e2dd2c9f53a148ddf0781921d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a5e1197bbc27c927ebe4087541d601f20">upper_bound</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns an iterator to the first pair greater than key, or <a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal.  <a href="#a5e1197bbc27c927ebe4087541d601f20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a5833bec011824d4b54b716b685ae74ca">upper_bound</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns a constant iterator to the first pair greater than key, or <a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal.  <a href="#a5833bec011824d4b54b716b685ae74ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>, <a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a405388c6589746b4a01af6ab8a4b4321">equal_range</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns both <a class="el" href="a00007.html#acf1949d71f9c83184c98d084d66c56a4" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00007.html#a5e1197bbc27c927ebe4087541d601f20" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>.  <a href="#a405388c6589746b4a01af6ab8a4b4321"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>, <br class="typebreak"/>
<a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#aeffb8c7205996ac1a5ac40976f47a96f">equal_range</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns both <a class="el" href="a00007.html#acf1949d71f9c83184c98d084d66c56a4" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00007.html#a5e1197bbc27c927ebe4087541d601f20" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>.  <a href="#aeffb8c7205996ac1a5ac40976f47a96f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a8151cc2608a7a0634d5a94e3824f8e34">operator==</a> (const <a class="el" href="a00007.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality relation of B+ trees of the same type.  <a href="#a8151cc2608a7a0634d5a94e3824f8e34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ae9ad03cbc3be10a4a972b06ec9abedec">operator!=</a> (const <a class="el" href="a00007.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality relation. Based on operator==.  <a href="#ae9ad03cbc3be10a4a972b06ec9abedec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a2dcdf9bb9c5e2eea56e9308388b07349">operator&lt;</a> (const <a class="el" href="a00007.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Total ordering relation of B+ trees of the same type.  <a href="#a2dcdf9bb9c5e2eea56e9308388b07349"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a7c85cec4d55431ea5e057602ba8fe5a0">operator&gt;</a> (const <a class="el" href="a00007.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater relation. Based on operator&lt;.  <a href="#a7c85cec4d55431ea5e057602ba8fe5a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a35de24d784f61ae794c1fa56fa9c6673">operator&lt;=</a> (const <a class="el" href="a00007.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-equal relation. Based on operator&lt;.  <a href="#a35de24d784f61ae794c1fa56fa9c6673"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a603b031718fb9bb00d0edefc58d560c3">operator&gt;=</a> (const <a class="el" href="a00007.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-equal relation. Based on operator&lt;.  <a href="#a603b031718fb9bb00d0edefc58d560c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html">self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a3e8081765077002a2cbc04e20506f03d">operator=</a> (const <a class="el" href="a00007.html">self</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">*** Fast Copy: Assign Operator and Copy Constructors  <a href="#a3e8081765077002a2cbc04e20506f03d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a988a8fc330955bc3e74976865c841904">btree_multiset</a> (const <a class="el" href="a00007.html">self</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a988a8fc330955bc3e74976865c841904"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ad35b00f9ff7f148dbb5cfee7ac8102af">insert</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to insert a key into the B+ tree.  <a href="#ad35b00f9ff7f148dbb5cfee7ac8102af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a0075140c2d21fe08b68f00e16630cff1">insert</a> (<a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a> hint, const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to insert a key into the B+ tree.  <a href="#a0075140c2d21fe08b68f00e16630cff1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00007.html#a617287e16b19e821e962c5e2c6eca2f9">insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to insert the range [first,last) of key_type into the B+ tree.  <a href="#a617287e16b19e821e962c5e2c6eca2f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#aa4e4cd44265e4c5fb8617ca3d17dd843">erase_one</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases one (the first) entry of the given key.  <a href="#aa4e4cd44265e4c5fb8617ca3d17dd843"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00007.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#afe2a42873c3a97234668e2feabc5191d">erase</a> (const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all the entries of the given key.  <a href="#afe2a42873c3a97234668e2feabc5191d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ac174897bad297d88927e6abe4056a3b8">erase</a> (<a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a> iter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the key/data pair referenced by the iterator.  <a href="#ac174897bad297d88927e6abe4056a3b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#aa5c867534e27a06c07baa2c17fbccfd1">erase</a> (<a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>, <a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all keys in the range [first,last).  <a href="#aa5c867534e27a06c07baa2c17fbccfd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a6aaf291909c709ea33419940352288b3">print</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the B+ tree structure with keys onto the given ostream.  <a href="#a6aaf291909c709ea33419940352288b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a8818ff27dd8b2275d4b6a68d728c6d77">print_leaves</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out only the leaves via the double linked list.  <a href="#a8818ff27dd8b2275d4b6a68d728c6d77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a862c504ed632b8591756c45273087e5a">verify</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a thorough verification of all B+ tree invariants.  <a href="#a862c504ed632b8591756c45273087e5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#af443508ecb8fd77f32f01709f2f9d666">dump</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the contents of the B+ tree out onto an ostream as a binary image.  <a href="#af443508ecb8fd77f32f01709f2f9d666"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a7f6dd7739f76cf5d1a31507ca3d80197">restore</a> (std::istream &amp;is)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore a binary image of a dumped B+ tree from an istream.  <a href="#a7f6dd7739f76cf5d1a31507ca3d80197"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ad3e346ec9ff913e6b17857f7de7fa6f0">leafslotmax</a> = <a class="el" href="a00002.html#a49865e80555e206e6039405191b21f40">btree_impl::leafslotmax</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base B+ tree parameter: The number of key/data slots in each leaf.  <a href="#ad3e346ec9ff913e6b17857f7de7fa6f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a291d8f653427c2dac2870ddd1e93a326">innerslotmax</a> = <a class="el" href="a00002.html#a801dc48f105e6f7d34fe22a301eee345">btree_impl::innerslotmax</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base B+ tree parameter: The number of key slots in each inner node, this can differ from slots in each leaf.  <a href="#a291d8f653427c2dac2870ddd1e93a326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a52ff2314ff166b6aec7ad572d37291cf">minleafslots</a> = <a class="el" href="a00002.html#a908b35146a3f01ee4f59882733274be7">btree_impl::minleafslots</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computed B+ tree parameter: The minimum number of key slots used in a leaf.  <a href="#a52ff2314ff166b6aec7ad572d37291cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a568261850e92855ce6dd296e969cf12d">mininnerslots</a> = <a class="el" href="a00002.html#aac1f08dd49f22cfbc8e534848d9d7924">btree_impl::mininnerslots</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computed B+ tree parameter: The minimum number of key slots used in an inner node.  <a href="#a568261850e92855ce6dd296e969cf12d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#ad58d175cab81f7f1947cdc54547fbf85">selfverify</a> = <a class="el" href="a00002.html#af4d008a956acd3726b1ca0ba9f604c5f">btree_impl::selfverify</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug parameter: Enables expensive and thorough checking of the B+ tree invariants after each insert/erase operation.  <a href="#ad58d175cab81f7f1947cdc54547fbf85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a1f660e9d76a8bc2d8afa950dec6f8fda">debug</a> = <a class="el" href="a00002.html#af91ee795a4d14f054563f08378085f6d">btree_impl::debug</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug parameter: Prints out lots of debug information about how the algorithms change the tree.  <a href="#a1f660e9d76a8bc2d8afa950dec6f8fda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#a2a11e2ee03e9bb4cb206826de0b135b2">allow_duplicates</a> = <a class="el" href="a00002.html#afa5653b47e117eb6b1ae3366deb9c6a0">btree_impl::allow_duplicates</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operational parameter: Allow duplicate keys in the btree.  <a href="#a2a11e2ee03e9bb4cb206826de0b135b2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00002.html">btree_impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html#aa78a74c628ee6ef25c5bffce7a9aacb2">tree</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The contained implementation object.  <a href="#aa78a74c628ee6ef25c5bffce7a9aacb2"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_set_traits&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt;<br/>
 class stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;</h3>

<p>Specialized B+ tree template class implementing STL's multiset container. </p>
<p>Implements the STL multiset using a B+ tree. It can be used as a drop-in replacement for std::multiset. Not all asymptotic time requirements are met in theory. The class has a traits class defining B+ tree properties like slots and self-verification. Furthermore an allocator can be specified for tree nodes.</p>
<p>It is somewhat inefficient to implement a multiset using a B+ tree, a plain B tree would hold fewer copies of the keys.</p>
<p>The set class is derived from the base implementation class btree by specifying an empty struct as data_type. All function are adapted to provide the inner class with placeholder objects. Most tricky to get right were the return type's of iterators which as value_type should be the same as key_type, and not a pair of key and dummy-struct. This is taken case of using some template magic in the btree class. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00055">55</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3bd75b696bde37ad47838d8058503799"></a><!-- doxytag: member="stx::btree_multiset::allocator_type" ref="a3bd75b696bde37ad47838d8058503799" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Alloc <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fourth template parameter: STL allocator. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00072">72</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab1ede8348d5ec50a52d993b2b9f87465"></a><!-- doxytag: member="stx::btree_multiset::btree_impl" ref="ab1ede8348d5ec50a52d993b2b9f87465" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00002.html">stx::btree</a>&lt;<a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a>, <a class="el" href="a00014.html">data_type</a>, <a class="el" href="a00007.html#a5fe61553bb02818305fde84b5342e753">value_type</a>, <a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a>, <a class="el" href="a00007.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a>, true, <a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>&gt; <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00002.html">btree_impl</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation type of the btree_base. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00100">100</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac3b6e263ec2f54cab4e541b02e2156bf"></a><!-- doxytag: member="stx::btree_multiset::const_iterator" ref="ac3b6e263ec2f54cab4e541b02e2156bf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::const_iterator <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like iterator object for B+ tree items. </p>
<p>The iterator points to a specific slot number in a leaf. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00152">152</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa137474f07b11232834fc838c96f89b4"></a><!-- doxytag: member="stx::btree_multiset::const_reverse_iterator" ref="aa137474f07b11232834fc838c96f89b4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::const_reverse_iterator <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create constant reverse iterator by using STL magic </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00158">158</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4797d9899509ebbd391f6478f85fefd9"></a><!-- doxytag: member="stx::btree_multiset::data_type" ref="a4797d9899509ebbd391f6478f85fefd9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00014.html">empty_struct</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00014.html">data_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The empty data_type. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00091">91</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d0c6764234271152a77643d5f160889"></a><!-- doxytag: member="stx::btree_multiset::iterator" ref="a0d0c6764234271152a77643d5f160889" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::iterator <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like iterator object for B+ tree items. </p>
<p>The iterator points to a specific slot number in a leaf. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00148">148</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab4d81bc53597e88abe6617421837df21"></a><!-- doxytag: member="stx::btree_multiset::key_compare" ref="ab4d81bc53597e88abe6617421837df21" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Compare <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Second template parameter: Key comparison function object. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00065">65</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="adaf86bdcdf48a7d4ed87ae020436287e"></a><!-- doxytag: member="stx::btree_multiset::key_type" ref="adaf86bdcdf48a7d4ed87ae020436287e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Key <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>First template parameter: The key type of the btree. </p>
<p>This is stored in inner nodes and leaves </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00062">62</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa20cfd7ed6236bc3c51b20d5a77a5286"></a><!-- doxytag: member="stx::btree_multiset::reverse_iterator" ref="aa20cfd7ed6236bc3c51b20d5a77a5286" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::reverse_iterator <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create mutable reverse iterator by using STL magic </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00155">155</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a99552060748673aa8a60e7d663f8f4a4"></a><!-- doxytag: member="stx::btree_multiset::self" ref="a99552060748673aa8a60e7d663f8f4a4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00007.html">btree_multiset</a>&lt;<a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a>, <a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a>, <a class="el" href="a00007.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a>, <a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>&gt; <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html">self</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedef of our own type. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00097">97</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb308af84d816e44d6fcaaf075b08a22"></a><!-- doxytag: member="stx::btree_multiset::size_type" ref="acb308af84d816e44d6fcaaf075b08a22" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00002.html#a883a5c48e52ec6e9927037e892f54692">btree_impl::size_type</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size type used to count keys. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00106">106</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="adf34a1c10a3b0e0c1caa0358b9d4f059"></a><!-- doxytag: member="stx::btree_multiset::traits" ref="adf34a1c10a3b0e0c1caa0358b9d4f059" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Traits <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#adf34a1c10a3b0e0c1caa0358b9d4f059">traits</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Third template parameter: Traits object used to define more parameters of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00069">69</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a268704f56c398ed05b600262f8c1d558"></a><!-- doxytag: member="stx::btree_multiset::tree_stats" ref="a268704f56c398ed05b600262f8c1d558" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::tree_stats <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#a268704f56c398ed05b600262f8c1d558">tree_stats</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Small structure containing statistics about the tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00109">109</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7ef41640ce62bdd8b1857ae6c3ef1c51"></a><!-- doxytag: member="stx::btree_multiset::value_compare" ref="a7ef41640ce62bdd8b1857ae6c3ef1c51" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::value_compare <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#a7ef41640ce62bdd8b1857ae6c3ef1c51">value_compare</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function class comparing two value_type keys. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00103">103</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5fe61553bb02818305fde84b5342e753"></a><!-- doxytag: member="stx::btree_multiset::value_type" ref="a5fe61553bb02818305fde84b5342e753" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#a5fe61553bb02818305fde84b5342e753">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the set value_type: the key_type. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00094">94</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae51979526a758ca48dff71269509d30d"></a><!-- doxytag: member="stx::btree_multiset::btree_multiset" ref="ae51979526a758ca48dff71269509d30d" args="(const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>()</code></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor initializing an empty B+ tree with the standard key comparison function. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00171">171</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4411a079d52cdac10490c9f44827ed63"></a><!-- doxytag: member="stx::btree_multiset::btree_multiset" ref="a4411a079d52cdac10490c9f44827ed63" args="(const key_compare &amp;kcf, const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>kcf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor initializing an empty B+ tree with a special key comparison object. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00178">178</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="afacbb565d340ff96007110b66542a2a7"></a><!-- doxytag: member="stx::btree_multiset::btree_multiset" ref="afacbb565d340ff96007110b66542a2a7" args="(InputIterator first, InputIterator last, const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor initializing a B+ tree with the range [first,last) </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00186">186</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00474">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a90d80cc52006eec0ae72dc7d1e6b2dac"></a><!-- doxytag: member="stx::btree_multiset::btree_multiset" ref="a90d80cc52006eec0ae72dc7d1e6b2dac" args="(InputIterator first, InputIterator last, const key_compare &amp;kcf, const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>kcf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor initializing a B+ tree with the range [first,last) and a special key comparison object. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00196">196</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00474">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="aec3bb61dacff05a504ae53889d8e3bf3"></a><!-- doxytag: member="stx::btree_multiset::~btree_multiset" ref="aec3bb61dacff05a504ae53889d8e3bf3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::~<a class="el" href="a00007.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees up all used B+ tree memory pages. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00204">204</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a988a8fc330955bc3e74976865c841904"></a><!-- doxytag: member="stx::btree_multiset::btree_multiset" ref="a988a8fc330955bc3e74976865c841904" args="(const self &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html">btree_multiset</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>The newly initialized B+ tree object will contain a copy of all keys. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00464">464</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0c8b01c05f01540fe8e7c87f7e798557"></a><!-- doxytag: member="stx::btree_multiset::begin" ref="a0c8b01c05f01540fe8e7c87f7e798557" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write iterator that points to the first slot in the first leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00253">253</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01493">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::begin()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="acca702924e73cc5df9f8e27f59259f7c"></a><!-- doxytag: member="stx::btree_multiset::begin" ref="acca702924e73cc5df9f8e27f59259f7c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only constant iterator that points to the first slot in the first leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00267">267</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01493">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::begin()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a77cc7f5486c5add7feb4c9e601c4d921"></a><!-- doxytag: member="stx::btree_multiset::clear" ref="a77cc7f5486c5add7feb4c9e601c4d921" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees all keys and all nodes of the tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00243">243</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01447">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::clear()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ab2ae64a7de25306d48798d502de46b6c"></a><!-- doxytag: member="stx::btree_multiset::count" ref="ab2ae64a7de25306d48798d502de46b6c" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to locate a key in the B+ tree and returns the number of identical key entries found. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00361">361</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01742">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::count()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="af443508ecb8fd77f32f01709f2f9d666"></a><!-- doxytag: member="stx::btree_multiset::dump" ref="af443508ecb8fd77f32f01709f2f9d666" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump the contents of the B+ tree out onto an ostream as a binary image. </p>
<p>The image contains memory pointers which will be fixed when the image is restored. For this to work your key_type must be an integral type and contain no pointers or references. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00565">565</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03643">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::dump()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a1943f3a2270fd9a13deb4d98855eb4bc"></a><!-- doxytag: member="stx::btree_multiset::empty" ref="a1943f3a2270fd9a13deb4d98855eb4bc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if there is at least one key in the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00317">317</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01654">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::empty()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a8fa9d5230ddb6f9306b2e941c1448ece"></a><!-- doxytag: member="stx::btree_multiset::end" ref="a8fa9d5230ddb6f9306b2e941c1448ece" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only constant iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00274">274</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01500">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::end()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a3b3fdd20ed1c32051e6e8e9762789178"></a><!-- doxytag: member="stx::btree_multiset::end" ref="a3b3fdd20ed1c32051e6e8e9762789178" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00260">260</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01500">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::end()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a405388c6589746b4a01af6ab8a4b4321"></a><!-- doxytag: member="stx::btree_multiset::equal_range" ref="a405388c6589746b4a01af6ab8a4b4321" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>, <a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&gt; <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns both <a class="el" href="a00007.html#acf1949d71f9c83184c98d084d66c56a4" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00007.html#a5e1197bbc27c927ebe4087541d601f20" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00397">397</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01860">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::equal_range()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="aeffb8c7205996ac1a5ac40976f47a96f"></a><!-- doxytag: member="stx::btree_multiset::equal_range" ref="aeffb8c7205996ac1a5ac40976f47a96f" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>, <a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a>&gt; <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns both <a class="el" href="a00007.html#acf1949d71f9c83184c98d084d66c56a4" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00007.html#a5e1197bbc27c927ebe4087541d601f20" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00403">403</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01860">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::equal_range()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="afe2a42873c3a97234668e2feabc5191d"></a><!-- doxytag: member="stx::btree_multiset::erase" ref="afe2a42873c3a97234668e2feabc5191d" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases all the entries of the given key. </p>
<p>This is implemented using <a class="el" href="a00007.html#aa4e4cd44265e4c5fb8617ca3d17dd843" title="Erases one (the first) entry of the given key.">erase_one()</a> and thus not very efficient. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00510">510</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02413">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::erase()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ac174897bad297d88927e6abe4056a3b8"></a><!-- doxytag: member="stx::btree_multiset::erase" ref="ac174897bad297d88927e6abe4056a3b8" args="(iterator iter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase the key/data pair referenced by the iterator. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00516">516</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02413">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::erase()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="aa5c867534e27a06c07baa2c17fbccfd1"></a><!-- doxytag: member="stx::btree_multiset::erase" ref="aa5c867534e27a06c07baa2c17fbccfd1" args="(iterator, iterator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase all keys in the range [first,last). </p>
<p>This function is currently not implemented by the B+ Tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00524">524</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa4e4cd44265e4c5fb8617ca3d17dd843"></a><!-- doxytag: member="stx::btree_multiset::erase_one" ref="aa4e4cd44265e4c5fb8617ca3d17dd843" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases one (the first) entry of the given key. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00503">503</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02390">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::erase_one()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a1438934e738862154bbcfa1314b485bb"></a><!-- doxytag: member="stx::btree_multiset::exists" ref="a1438934e738862154bbcfa1314b485bb" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-STL function checking whether a key is in the B+ tree. </p>
<p>The same as (find(k) != <a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a>) or (<a class="el" href="a00007.html#ab2ae64a7de25306d48798d502de46b6c" title="Tries to locate a key in the B+ tree and returns the number of identical key entries found...">count()</a> != 0). </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00340">340</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01677">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::exists()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a130a3b87e39b1d9ff8be6df80b942737"></a><!-- doxytag: member="stx::btree_multiset::find" ref="a130a3b87e39b1d9ff8be6df80b942737" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to locate a key in the B+ tree and returns an iterator to the key slot if found. </p>
<p>If unsuccessful it returns <a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a>. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00347">347</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01698">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::find()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ac3bf82364b3392aa056b866a012ac0d8"></a><!-- doxytag: member="stx::btree_multiset::find" ref="ac3bf82364b3392aa056b866a012ac0d8" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to locate a key in the B+ tree and returns an constant iterator to the key slot if found. </p>
<p>If unsuccessful it returns <a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a>. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00354">354</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01698">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::find()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ac2fc089101a5d6fdf86ee2d09b9eacce"></a><!-- doxytag: member="stx::btree_multiset::get_allocator" ref="ac2fc089101a5d6fdf86ee2d09b9eacce" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#a3bd75b696bde37ad47838d8058503799">allocator_type</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the base node allocator provided during construction. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00234">234</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01385">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::get_allocator()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a926c5bb8fbf409b1371c1ca211ba2bde"></a><!-- doxytag: member="stx::btree_multiset::get_stats" ref="a926c5bb8fbf409b1371c1ca211ba2bde" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00007.html#a268704f56c398ed05b600262f8c1d558">tree_stats</a>&amp; <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::get_stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a const reference to the current statistics. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00330">330</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01667">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::get_stats()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ad35b00f9ff7f148dbb5cfee7ac8102af"></a><!-- doxytag: member="stx::btree_multiset::insert" ref="ad35b00f9ff7f148dbb5cfee7ac8102af" args="(const key_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to insert a key into the B+ tree. </p>
<p>As this set allows duplicates, this function never fails. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00474">474</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02026">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::insert2()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

<p>Referenced by <a class="el" href="a00032_source.html#l00186">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::btree_multiset()</a>, and <a class="el" href="a00032_source.html#l00489">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a0075140c2d21fe08b68f00e16630cff1"></a><!-- doxytag: member="stx::btree_multiset::insert" ref="a0075140c2d21fe08b68f00e16630cff1" args="(iterator hint, const key_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to insert a key into the B+ tree. </p>
<p>The iterator hint is currently ignored by the B+ tree insertion routine. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00481">481</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02026">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::insert2()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a617287e16b19e821e962c5e2c6eca2f9"></a><!-- doxytag: member="stx::btree_multiset::insert" ref="a617287e16b19e821e962c5e2c6eca2f9" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to insert the range [first,last) of key_type into the B+ tree. </p>
<p>Each key is inserted individually. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00489">489</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00474">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ecbf097192ab41b7a29db4349ce2d3e"></a><!-- doxytag: member="stx::btree_multiset::key_comp" ref="a3ecbf097192ab41b7a29db4349ce2d3e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#ab4d81bc53597e88abe6617421837df21">key_compare</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constant access to the key comparison object sorting the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00218">218</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01341">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::key_comp()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="acf1949d71f9c83184c98d084d66c56a4"></a><!-- doxytag: member="stx::btree_multiset::lower_bound" ref="acf1949d71f9c83184c98d084d66c56a4" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns an iterator to the first pair equal to or greater than key, or <a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00368">368</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01775">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::lower_bound()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="afb5c018e2dd2c9f53a148ddf0781921d"></a><!-- doxytag: member="stx::btree_multiset::lower_bound" ref="afb5c018e2dd2c9f53a148ddf0781921d" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns a constant iterator to the first pair equal to or greater than key, or <a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00376">376</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01775">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::lower_bound()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a2b0012b20d4bc04d78d1297d78550d8a"></a><!-- doxytag: member="stx::btree_multiset::max_size" ref="a2b0012b20d4bc04d78d1297d78550d8a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the largest possible size of the B+ Tree. </p>
<p>This is just a function required by the STL standard, the B+ Tree can hold more items. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00324">324</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01661">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::max_size()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ae9ad03cbc3be10a4a972b06ec9abedec"></a><!-- doxytag: member="stx::btree_multiset::operator!=" ref="ae9ad03cbc3be10a4a972b06ec9abedec" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality relation. Based on operator==. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00419">419</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a2dcdf9bb9c5e2eea56e9308388b07349"></a><!-- doxytag: member="stx::btree_multiset::operator&lt;" ref="a2dcdf9bb9c5e2eea56e9308388b07349" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Total ordering relation of B+ trees of the same type. </p>
<p>It uses std::lexicographical_compare() for the actual comparison of elements. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00426">426</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a35de24d784f61ae794c1fa56fa9c6673"></a><!-- doxytag: member="stx::btree_multiset::operator&lt;=" ref="a35de24d784f61ae794c1fa56fa9c6673" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Less-equal relation. Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00438">438</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a3e8081765077002a2cbc04e20506f03d"></a><!-- doxytag: member="stx::btree_multiset::operator=" ref="a3e8081765077002a2cbc04e20506f03d" args="(const self &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html">self</a>&amp; <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>*** Fast Copy: Assign Operator and Copy Constructors </p>
<p>Assignment operator. All the keys are copied </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00453">453</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a8151cc2608a7a0634d5a94e3824f8e34"></a><!-- doxytag: member="stx::btree_multiset::operator==" ref="a8151cc2608a7a0634d5a94e3824f8e34" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality relation of B+ trees of the same type. </p>
<p>B+ trees of the same size and equal key (counts) are considered equal. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00413">413</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a7c85cec4d55431ea5e057602ba8fe5a0"></a><!-- doxytag: member="stx::btree_multiset::operator&gt;" ref="a7c85cec4d55431ea5e057602ba8fe5a0" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greater relation. Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00432">432</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a603b031718fb9bb00d0edefc58d560c3"></a><!-- doxytag: member="stx::btree_multiset::operator&gt;=" ref="a603b031718fb9bb00d0edefc58d560c3" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greater-equal relation. Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00444">444</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a6aaf291909c709ea33419940352288b3"></a><!-- doxytag: member="stx::btree_multiset::print" ref="a6aaf291909c709ea33419940352288b3" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print out the B+ tree structure with keys onto the given ostream. </p>
<p>This function requires that the header is compiled with BTREE_DEBUG and that key_type is printable via std::ostream. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00537">537</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03356">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::print()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a8818ff27dd8b2275d4b6a68d728c6d77"></a><!-- doxytag: member="stx::btree_multiset::print_leaves" ref="a8818ff27dd8b2275d4b6a68d728c6d77" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::print_leaves </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print out only the leaves via the double linked list. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00543">543</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03364">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::print_leaves()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="aab7bf40d95f5e2e3a6f48ff132e5aa5c"></a><!-- doxytag: member="stx::btree_multiset::rbegin" ref="aab7bf40d95f5e2e3a6f48ff132e5aa5c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only reverse iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00295">295</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01521">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::rbegin()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ad5ff92256da155cf0a800c0be6d37f10"></a><!-- doxytag: member="stx::btree_multiset::rbegin" ref="ad5ff92256da155cf0a800c0be6d37f10" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write reverse iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00281">281</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01521">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::rbegin()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a01090ac817bc6525160dbee3b2943ad1"></a><!-- doxytag: member="stx::btree_multiset::rend" ref="a01090ac817bc6525160dbee3b2943ad1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#aa137474f07b11232834fc838c96f89b4">const_reverse_iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only reverse iterator that points to the first slot in the first leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00302">302</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01528">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::rend()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="accb388873e7a00b1779a27487e4c0200"></a><!-- doxytag: member="stx::btree_multiset::rend" ref="accb388873e7a00b1779a27487e4c0200" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#aa20cfd7ed6236bc3c51b20d5a77a5286">reverse_iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write reverse iterator that points to the first slot in the first leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00288">288</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01528">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::rend()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a7f6dd7739f76cf5d1a31507ca3d80197"></a><!-- doxytag: member="stx::btree_multiset::restore" ref="a7f6dd7739f76cf5d1a31507ca3d80197" args="(std::istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::restore </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restore a binary image of a dumped B+ tree from an istream. </p>
<p>The B+ tree pointers are fixed using the dump order. For dump and restore to work your key_type must be an integral type and contain no pointers or references. Returns true if the restore was successful. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00574">574</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03660">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::restore()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a9be405a164ded347358ce38599d768bd"></a><!-- doxytag: member="stx::btree_multiset::size" ref="a9be405a164ded347358ce38599d768bd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#acb308af84d816e44d6fcaaf075b08a22">size_type</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of keys in the B+ tree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00311">311</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01648">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::size()</a>, and <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="aad820bbc85b7beaaca43fbdb1b610b56"></a><!-- doxytag: member="stx::btree_multiset::swap" ref="aad820bbc85b7beaaca43fbdb1b610b56" args="(self &amp;from)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00007.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fast swapping of two identical B+ tree objects. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00209">209</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a5833bec011824d4b54b716b685ae74ca"></a><!-- doxytag: member="stx::btree_multiset::upper_bound" ref="a5833bec011824d4b54b716b685ae74ca" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#ac3b6e263ec2f54cab4e541b02e2156bf">const_iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns a constant iterator to the first pair greater than key, or <a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00391">391</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l01818">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::upper_bound()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e1197bbc27c927ebe4087541d601f20"></a><!-- doxytag: member="stx::btree_multiset::upper_bound" ref="a5e1197bbc27c927ebe4087541d601f20" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#a0d0c6764234271152a77643d5f160889">iterator</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#adaf86bdcdf48a7d4ed87ae020436287e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns an iterator to the first pair greater than key, or <a class="el" href="a00007.html#a3b3fdd20ed1c32051e6e8e9762789178" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00383">383</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l01818">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::upper_bound()</a>.</p>

</div>
</div>
<a class="anchor" id="a84f47ce04fb5330cb2d766a105b278a2"></a><!-- doxytag: member="stx::btree_multiset::value_comp" ref="a84f47ce04fb5330cb2d766a105b278a2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html#a7ef41640ce62bdd8b1857ae6c3ef1c51">value_compare</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constant access to a constructed value_type comparison object. </p>
<p>Required by the STL </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00225">225</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l01348">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::value_comp()</a>.</p>

</div>
</div>
<a class="anchor" id="a862c504ed632b8591756c45273087e5a"></a><!-- doxytag: member="stx::btree_multiset::verify" ref="a862c504ed632b8591756c45273087e5a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::verify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run a thorough verification of all B+ tree invariants. </p>
<p>The program aborts via <a class="el" href="a00026.html#a6ac57b9b59dae34aea28cda65b0d14bb" title="Assertion only if BTREE_DEBUG is defined. This is not used in verify().">BTREE_ASSERT()</a> if something is wrong. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00554">554</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>References <a class="el" href="a00032_source.html#l00164">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l03430">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::verify()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a2a11e2ee03e9bb4cb206826de0b135b2"></a><!-- doxytag: member="stx::btree_multiset::allow_duplicates" ref="a2a11e2ee03e9bb4cb206826de0b135b2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#a2a11e2ee03e9bb4cb206826de0b135b2">allow_duplicates</a> = <a class="el" href="a00002.html#afa5653b47e117eb6b1ae3366deb9c6a0">btree_impl::allow_duplicates</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operational parameter: Allow duplicate keys in the btree. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00141">141</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1f660e9d76a8bc2d8afa950dec6f8fda"></a><!-- doxytag: member="stx::btree_multiset::debug" ref="a1f660e9d76a8bc2d8afa950dec6f8fda" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#a1f660e9d76a8bc2d8afa950dec6f8fda">debug</a> = <a class="el" href="a00002.html#af91ee795a4d14f054563f08378085f6d">btree_impl::debug</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Debug parameter: Prints out lots of debug information about how the algorithms change the tree. </p>
<p>Requires the header file to be compiled with BTREE_DEBUG and the key type must be std::ostream printable. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00138">138</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a291d8f653427c2dac2870ddd1e93a326"></a><!-- doxytag: member="stx::btree_multiset::innerslotmax" ref="a291d8f653427c2dac2870ddd1e93a326" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#a291d8f653427c2dac2870ddd1e93a326">innerslotmax</a> = <a class="el" href="a00002.html#a801dc48f105e6f7d34fe22a301eee345">btree_impl::innerslotmax</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Base B+ tree parameter: The number of key slots in each inner node, this can differ from slots in each leaf. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00119">119</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad3e346ec9ff913e6b17857f7de7fa6f0"></a><!-- doxytag: member="stx::btree_multiset::leafslotmax" ref="ad3e346ec9ff913e6b17857f7de7fa6f0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#ad3e346ec9ff913e6b17857f7de7fa6f0">leafslotmax</a> = <a class="el" href="a00002.html#a49865e80555e206e6039405191b21f40">btree_impl::leafslotmax</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Base B+ tree parameter: The number of key/data slots in each leaf. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00115">115</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a568261850e92855ce6dd296e969cf12d"></a><!-- doxytag: member="stx::btree_multiset::mininnerslots" ref="a568261850e92855ce6dd296e969cf12d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#a568261850e92855ce6dd296e969cf12d">mininnerslots</a> = <a class="el" href="a00002.html#aac1f08dd49f22cfbc8e534848d9d7924">btree_impl::mininnerslots</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computed B+ tree parameter: The minimum number of key slots used in an inner node. </p>
<p>If fewer slots are used, the inner node will be merged or slots shifted from it's siblings. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00129">129</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a52ff2314ff166b6aec7ad572d37291cf"></a><!-- doxytag: member="stx::btree_multiset::minleafslots" ref="a52ff2314ff166b6aec7ad572d37291cf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#a52ff2314ff166b6aec7ad572d37291cf">minleafslots</a> = <a class="el" href="a00002.html#a908b35146a3f01ee4f59882733274be7">btree_impl::minleafslots</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computed B+ tree parameter: The minimum number of key slots used in a leaf. </p>
<p>If fewer slots are used, the leaf will be merged or slots shifted from it's siblings. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00124">124</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad58d175cab81f7f1947cdc54547fbf85"></a><!-- doxytag: member="stx::btree_multiset::selfverify" ref="ad58d175cab81f7f1947cdc54547fbf85" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#ad58d175cab81f7f1947cdc54547fbf85">selfverify</a> = <a class="el" href="a00002.html#af4d008a956acd3726b1ca0ba9f604c5f">btree_impl::selfverify</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Debug parameter: Enables expensive and thorough checking of the B+ tree invariants after each insert/erase operation. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00133">133</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa78a74c628ee6ef25c5bffce7a9aacb2"></a><!-- doxytag: member="stx::btree_multiset::tree" ref="aa78a74c628ee6ef25c5bffce7a9aacb2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00002.html">btree_impl</a> <a class="el" href="a00007.html">stx::btree_multiset</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00007.html#aa78a74c628ee6ef25c5bffce7a9aacb2">tree</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The contained implementation object. </p>

<p>Definition at line <a class="el" href="a00032_source.html#l00164">164</a> of file <a class="el" href="a00032_source.html">btree_multiset.h</a>.</p>

<p>Referenced by <a class="el" href="a00032_source.html#l00253">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::begin()</a>, <a class="el" href="a00032_source.html#l00243">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::clear()</a>, <a class="el" href="a00032_source.html#l00361">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::count()</a>, <a class="el" href="a00032_source.html#l00565">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::dump()</a>, <a class="el" href="a00032_source.html#l00317">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::empty()</a>, <a class="el" href="a00032_source.html#l00260">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::end()</a>, <a class="el" href="a00032_source.html#l00397">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::equal_range()</a>, <a class="el" href="a00032_source.html#l00510">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase()</a>, <a class="el" href="a00032_source.html#l00503">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase_one()</a>, <a class="el" href="a00032_source.html#l00340">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::exists()</a>, <a class="el" href="a00032_source.html#l00347">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::find()</a>, <a class="el" href="a00032_source.html#l00234">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::get_allocator()</a>, <a class="el" href="a00032_source.html#l00330">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::get_stats()</a>, <a class="el" href="a00032_source.html#l00474">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>, <a class="el" href="a00032_source.html#l00218">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::key_comp()</a>, <a class="el" href="a00032_source.html#l00368">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::lower_bound()</a>, <a class="el" href="a00032_source.html#l00324">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::max_size()</a>, <a class="el" href="a00032_source.html#l00419">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator!=()</a>, <a class="el" href="a00032_source.html#l00426">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt;()</a>, <a class="el" href="a00032_source.html#l00438">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt;=()</a>, <a class="el" href="a00032_source.html#l00453">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator=()</a>, <a class="el" href="a00032_source.html#l00413">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator==()</a>, <a class="el" href="a00032_source.html#l00432">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt;()</a>, <a class="el" href="a00032_source.html#l00444">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt;=()</a>, <a class="el" href="a00032_source.html#l00537">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::print()</a>, <a class="el" href="a00032_source.html#l00543">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::print_leaves()</a>, <a class="el" href="a00032_source.html#l00281">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::rbegin()</a>, <a class="el" href="a00032_source.html#l00288">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::rend()</a>, <a class="el" href="a00032_source.html#l00574">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::restore()</a>, <a class="el" href="a00032_source.html#l00311">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::size()</a>, <a class="el" href="a00032_source.html#l00209">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::swap()</a>, <a class="el" href="a00032_source.html#l00383">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::upper_bound()</a>, <a class="el" href="a00032_source.html#l00225">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::value_comp()</a>, and <a class="el" href="a00032_source.html#l00554">stx::btree_multiset&lt; _Key, _Compare, _Traits, _Alloc &gt;::verify()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>stx/<a class="el" href="a00032_source.html">btree_multiset.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed May 18 2011 10:12:05 for STX B+ Tree Template Classes by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
