<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>STX B+ Tree Template Classes: stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">STX B+ Tree Template Classes&#160;<span id="projectnumber">0.8.6</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00036.html">stx</a>      </li>
      <li class="navelem"><a class="el" href="a00010.html">btree_set</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<h1>stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="stx::btree_set" -->
<p>Specialized B+ tree template class implementing STL's set container.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00034_source.html">btree_set.h</a>&gt;</code></p>

<p><a href="a00058.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">empty_struct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The macro BTREE_FRIENDS can be used by outside class to access the B+ tree internals.  <a href="a00015.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">First template parameter: The key type of the B+ tree.  <a href="#a30048df0132910557b9fc6eef098c260"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Second template parameter: Key comparison function object.  <a href="#af50de559aebda323728e4fa2452bee5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ae4153912a1f97b51f7bbad71b3129008">traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Third template parameter: Traits object used to define more parameters of the B+ tree.  <a href="#ae4153912a1f97b51f7bbad71b3129008"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef _Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fourth template parameter: STL allocator.  <a href="#add9d9415d959dd6280c4c9388463890b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00015.html">empty_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a00bbef593d8ccf4068c327a83ec63284">data_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The empty data_type.  <a href="#a00bbef593d8ccf4068c327a83ec63284"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a2d6c5e2aa366dfea07ab1232d0d96515">value_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the set value_type: the key_type.  <a href="#a2d6c5e2aa366dfea07ab1232d0d96515"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00010.html">btree_set</a>&lt; <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a>, <br class="typebreak"/>
<a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a>, <a class="el" href="a00010.html#ae4153912a1f97b51f7bbad71b3129008">traits</a>, <br class="typebreak"/>
<a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#aadf0dbca723b094c06361719ea3f9aae">self</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of our own type.  <a href="#aadf0dbca723b094c06361719ea3f9aae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00002.html">stx::btree</a>&lt; <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a>, <br class="typebreak"/>
<a class="el" href="a00015.html">data_type</a>, <a class="el" href="a00010.html#a2d6c5e2aa366dfea07ab1232d0d96515">value_type</a>, <br class="typebreak"/>
<a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a>, <a class="el" href="a00010.html#ae4153912a1f97b51f7bbad71b3129008">traits</a>, false, <br class="typebreak"/>
<a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#acfda07a714d6a99aed45258189bc8368">btree_impl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation type of the btree_base.  <a href="#acfda07a714d6a99aed45258189bc8368"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::value_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a9fc9960504727883e021ed064f831a9b">value_compare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function class comparing two value_type keys.  <a href="#a9fc9960504727883e021ed064f831a9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00002.html#a883a5c48e52ec6e9927037e892f54692">btree_impl::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ab2cb644afc7271107dcceb53e9a86f45">size_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type used to count keys.  <a href="#ab2cb644afc7271107dcceb53e9a86f45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::tree_stats&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#acb76d4594a31ed8906a25d08f5830f5e">tree_stats</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Small structure containing statistics about the tree.  <a href="#acb76d4594a31ed8906a25d08f5830f5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like iterator object for B+ tree items.  <a href="#a7d77049f9bbaaf25ba9edc0635c4627f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef btree_impl::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-like iterator object for B+ tree items.  <a href="#aa5d3d9c7b1218e5680f653fd8f9d8996"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
btree_impl::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#afb9918dafdccf1eaffa6b6ddc8de0938">reverse_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">create mutable reverse iterator by using STL magic  <a href="#afb9918dafdccf1eaffa6b6ddc8de0938"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
btree_impl::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a989d5052f0f73009ad08544bef214038">const_reverse_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">create constant reverse iterator by using STL magic  <a href="#a989d5052f0f73009ad08544bef214038"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a45a3f6e426f588acd351b258413e2797">btree_set</a> (const <a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a> &amp;alloc=<a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor initializing an empty B+ tree with the standard key comparison function.  <a href="#a45a3f6e426f588acd351b258413e2797"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a9b12b35835ef7a7bf7414fed7b572119">btree_set</a> (const <a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a> &amp;kcf, const <a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a> &amp;alloc=<a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing an empty B+ tree with a special key comparison object.  <a href="#a9b12b35835ef7a7bf7414fed7b572119"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00010.html#ad77eab6d282c872f2ad7c2dbe52c08b9">btree_set</a> (InputIterator first, InputIterator last, const <a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a> &amp;alloc=<a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing a B+ tree with the range [first,last)  <a href="#ad77eab6d282c872f2ad7c2dbe52c08b9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00010.html#ab7e9ff448fa299e15b8bb5d5b18d24cd">btree_set</a> (InputIterator first, InputIterator last, const <a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a> &amp;kcf, const <a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a> &amp;alloc=<a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializing a B+ tree with the range [first,last) and a special key comparison object.  <a href="#ab7e9ff448fa299e15b8bb5d5b18d24cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a252d6d1027b0d78a1bec9f63fc68cd82">~btree_set</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees up all used B+ tree memory pages.  <a href="#a252d6d1027b0d78a1bec9f63fc68cd82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a24321f7bdae8ffc461e48d6331cf25e3">swap</a> (<a class="el" href="a00010.html">self</a> &amp;from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast swapping of two identical B+ tree objects.  <a href="#a24321f7bdae8ffc461e48d6331cf25e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#abd0d44790a5ec381c5137b0dea712894">key_comp</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to the key comparison object sorting the B+ tree.  <a href="#abd0d44790a5ec381c5137b0dea712894"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a9fc9960504727883e021ed064f831a9b">value_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a2e31a7e133791f60117cfa2e0a323819">value_comp</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to a constructed value_type comparison object.  <a href="#a2e31a7e133791f60117cfa2e0a323819"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a603ef9ef20b9f7ad05401d5d6eca2ece">get_allocator</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base node allocator provided during construction.  <a href="#a603ef9ef20b9f7ad05401d5d6eca2ece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a52fe59cdd4576d9cc9266e42bca323b2">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all keys and all nodes of the tree.  <a href="#a52fe59cdd4576d9cc9266e42bca323b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a9521b86ca0d5142a12ae32523c1afb71">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#a9521b86ca0d5142a12ae32523c1afb71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#a8048755a5927b42cce11c19fa8953d93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ad79866f391eff27bb4da840c31f1b4cd">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only constant iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#ad79866f391eff27bb4da840c31f1b4cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a0e5c8c7a9deff3d2fe75f180d01b911e">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only constant iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#a0e5c8c7a9deff3d2fe75f180d01b911e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#afb9918dafdccf1eaffa6b6ddc8de0938">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a4f427468ae77255b8f6dfd99f09df632">rbegin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write reverse iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#a4f427468ae77255b8f6dfd99f09df632"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#afb9918dafdccf1eaffa6b6ddc8de0938">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a9e1eb2e0b1c92cee93524a002456fbaf">rend</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read/data-write reverse iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#a9e1eb2e0b1c92cee93524a002456fbaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a989d5052f0f73009ad08544bef214038">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#af6fcf44e17e2c3416228f3f016c46d18">rbegin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only reverse iterator that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#af6fcf44e17e2c3416228f3f016c46d18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a989d5052f0f73009ad08544bef214038">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a054c601b6f1f281868d8426a61e7020d">rend</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a read-only reverse iterator that points to the first slot in the first leaf of the B+ tree.  <a href="#a054c601b6f1f281868d8426a61e7020d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#ab2cb644afc7271107dcceb53e9a86f45">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ad00b79874786c1f20cae2b7e765b9e7a">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of keys in the B+ tree.  <a href="#ad00b79874786c1f20cae2b7e765b9e7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a763bf123995cf352f7a08bc43fe0597d">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is at least one key in the B+ tree.  <a href="#a763bf123995cf352f7a08bc43fe0597d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#ab2cb644afc7271107dcceb53e9a86f45">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ae3338e9685da6924c7be74906b3cf68b">max_size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest possible size of the B+ Tree.  <a href="#ae3338e9685da6924c7be74906b3cf68b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00010.html#acb76d4594a31ed8906a25d08f5830f5e">tree_stats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ae085f7427a2cb614b5a44c0b545fb86b">get_stats</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the current statistics.  <a href="#ae085f7427a2cb614b5a44c0b545fb86b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ac76905f0dc9369d4bb460f6e24bf7363">exists</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-STL function checking whether a key is in the B+ tree.  <a href="#ac76905f0dc9369d4bb460f6e24bf7363"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a7ed6ed0ae9f3993cedca7b7d8755be85">find</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns an iterator to the key slot if found.  <a href="#a7ed6ed0ae9f3993cedca7b7d8755be85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a4f4474b05a7a87b0ce0e9a451b25741d">find</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns an constant iterator to the key slot if found.  <a href="#a4f4474b05a7a87b0ce0e9a451b25741d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#ab2cb644afc7271107dcceb53e9a86f45">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a1dbbf865a4ad5a740419de17946b4a4c">count</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns the number of identical key entries found.  <a href="#a1dbbf865a4ad5a740419de17946b4a4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ab9bce6f24080308ab099b2ea41adbba7">lower_bound</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns an iterator to the first pair equal to or greater than key, or <a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller.  <a href="#ab9bce6f24080308ab099b2ea41adbba7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a555d7bf9ca80b37707ed8a2f2427bd10">lower_bound</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns a constant iterator to the first pair equal to or greater than key, or <a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller.  <a href="#a555d7bf9ca80b37707ed8a2f2427bd10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ab135d588af2fbdf1631a722b9014c524">upper_bound</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns an iterator to the first pair greater than key, or <a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal.  <a href="#ab135d588af2fbdf1631a722b9014c524"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a8cccc9b19e58b5c37f3f40ffd8ae3978">upper_bound</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns a constant iterator to the first pair greater than key, or <a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal.  <a href="#a8cccc9b19e58b5c37f3f40ffd8ae3978"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>, <a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#af023de2dd94f574e312e8e9f5515bd8c">equal_range</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns both <a class="el" href="a00010.html#ab9bce6f24080308ab099b2ea41adbba7" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00010.html#ab135d588af2fbdf1631a722b9014c524" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>.  <a href="#af023de2dd94f574e312e8e9f5515bd8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a>, <br class="typebreak"/>
<a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ac9dc81052691280fb5fd0b091c08ea0a">equal_range</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns both <a class="el" href="a00010.html#ab9bce6f24080308ab099b2ea41adbba7" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00010.html#ab135d588af2fbdf1631a722b9014c524" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>.  <a href="#ac9dc81052691280fb5fd0b091c08ea0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a7151704256c80cf7bc413b48bea52b75">operator==</a> (const <a class="el" href="a00010.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality relation of B+ trees of the same type.  <a href="#a7151704256c80cf7bc413b48bea52b75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a164d435a3f3c3ba2a00a4f4c8f1a91b2">operator!=</a> (const <a class="el" href="a00010.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality relation. Based on operator==.  <a href="#a164d435a3f3c3ba2a00a4f4c8f1a91b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a9e637bfa9b10589da6af42ac17048976">operator&lt;</a> (const <a class="el" href="a00010.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Total ordering relation of B+ trees of the same type.  <a href="#a9e637bfa9b10589da6af42ac17048976"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a201df2577f43d59328a442f38bbb6e30">operator&gt;</a> (const <a class="el" href="a00010.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater relation. Based on operator&lt;.  <a href="#a201df2577f43d59328a442f38bbb6e30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a9ce20587b88f126796b6e3784680f66e">operator&lt;=</a> (const <a class="el" href="a00010.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-equal relation. Based on operator&lt;.  <a href="#a9ce20587b88f126796b6e3784680f66e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#afefedc35ea11d982c716860a921f2a24">operator&gt;=</a> (const <a class="el" href="a00010.html">self</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-equal relation. Based on operator&lt;.  <a href="#afefedc35ea11d982c716860a921f2a24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html">self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a36ba21d19bf0aa1bc6b2ffb8e4ea8cfc">operator=</a> (const <a class="el" href="a00010.html">self</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">*** Fast Copy: Assign Operator and Copy Constructors  <a href="#a36ba21d19bf0aa1bc6b2ffb8e4ea8cfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#af37409eb0e66f7d3e80b8ad29470118b">btree_set</a> (const <a class="el" href="a00010.html">self</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#af37409eb0e66f7d3e80b8ad29470118b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#aea42997e9d00ecaabe5e868196c5e8f0">insert</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to insert a key into the B+ tree.  <a href="#aea42997e9d00ecaabe5e868196c5e8f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a9f6d35bf91f3c3c8721a73ce7ebba710">insert</a> (<a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a> hint, const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to insert a key into the B+ tree.  <a href="#a9f6d35bf91f3c3c8721a73ce7ebba710"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00010.html#a43c39f79bdb47c293017e39422a6371b">insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to insert the range [first,last) of iterators dereferencing to key_type into the B+ tree.  <a href="#a43c39f79bdb47c293017e39422a6371b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a0cf2d6744a938d3249f58263f68f4802">erase_one</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the key from the set.  <a href="#a0cf2d6744a938d3249f58263f68f4802"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html#ab2cb644afc7271107dcceb53e9a86f45">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a0b4f57f1b268095b0c33c5623280c4e4">erase</a> (const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all the key/data pairs associated with the given key.  <a href="#a0b4f57f1b268095b0c33c5623280c4e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#aea8d759b037157313042df5b6cad4b5b">erase</a> (<a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a> iter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the key/data pair referenced by the iterator.  <a href="#aea8d759b037157313042df5b6cad4b5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ad0bf46d5da971b9abef66a69bab86b33">erase</a> (<a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>, <a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all keys in the range [first,last).  <a href="#ad0bf46d5da971b9abef66a69bab86b33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ab52f7877dc24a1ada22eb093346926ad">print</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the B+ tree structure with keys onto the given ostream.  <a href="#ab52f7877dc24a1ada22eb093346926ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ab4f43a518a8294478c0a635e6cb822f4">print_leaves</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out only the leaves via the double linked list.  <a href="#ab4f43a518a8294478c0a635e6cb822f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#af88455baba68554522a181ad2a8dc8fc">verify</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a thorough verification of all B+ tree invariants.  <a href="#af88455baba68554522a181ad2a8dc8fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ab482ba64445f71f2c088f0c5ee981ea5">dump</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the contents of the B+ tree out onto an ostream as a binary image.  <a href="#ab482ba64445f71f2c088f0c5ee981ea5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a2f73e4b0a1d3ed2f6e73ef33dea0ac46">restore</a> (std::istream &amp;is)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore a binary image of a dumped B+ tree from an istream.  <a href="#a2f73e4b0a1d3ed2f6e73ef33dea0ac46"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#af20d59df4181356a7731674deeeafa0d">leafslotmax</a> = <a class="el" href="a00002.html#a49865e80555e206e6039405191b21f40">btree_impl::leafslotmax</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base B+ tree parameter: The number of key slots in each leaf.  <a href="#af20d59df4181356a7731674deeeafa0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#aa48cfb5c8f935ff286ca7a12e97886db">innerslotmax</a> = <a class="el" href="a00002.html#a801dc48f105e6f7d34fe22a301eee345">btree_impl::innerslotmax</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base B+ tree parameter: The number of key slots in each inner node, this can differ from slots in each leaf.  <a href="#aa48cfb5c8f935ff286ca7a12e97886db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a16ff8b6fdbbffcbdb50de080d4631015">minleafslots</a> = <a class="el" href="a00002.html#a908b35146a3f01ee4f59882733274be7">btree_impl::minleafslots</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computed B+ tree parameter: The minimum number of key slots used in a leaf.  <a href="#a16ff8b6fdbbffcbdb50de080d4631015"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a133181518b3bfeec73537984581cc8ef">mininnerslots</a> = <a class="el" href="a00002.html#aac1f08dd49f22cfbc8e534848d9d7924">btree_impl::mininnerslots</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computed B+ tree parameter: The minimum number of key slots used in an inner node.  <a href="#a133181518b3bfeec73537984581cc8ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#aeef1f92bbdd38ed63f588a56db598077">selfverify</a> = <a class="el" href="a00002.html#af4d008a956acd3726b1ca0ba9f604c5f">btree_impl::selfverify</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug parameter: Enables expensive and thorough checking of the B+ tree invariants after each insert/erase operation.  <a href="#aeef1f92bbdd38ed63f588a56db598077"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#ab3568dade6579ccf9a3f50df18eabb01">debug</a> = <a class="el" href="a00002.html#af91ee795a4d14f054563f08378085f6d">btree_impl::debug</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug parameter: Prints out lots of debug information about how the algorithms change the tree.  <a href="#ab3568dade6579ccf9a3f50df18eabb01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a76a14434ee750af9999bea4e2b657b36">allow_duplicates</a> = <a class="el" href="a00002.html#afa5653b47e117eb6b1ae3366deb9c6a0">btree_impl::allow_duplicates</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operational parameter: Allow duplicate keys in the btree.  <a href="#a76a14434ee750af9999bea4e2b657b36"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00002.html">btree_impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html#a352435bb00a9126a4c72b565553d13b7">tree</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The contained implementation object.  <a href="#a352435bb00a9126a4c72b565553d13b7"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_set_traits&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt;<br/>
 class stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;</h3>

<p>Specialized B+ tree template class implementing STL's set container. </p>
<p>Implements the STL set using a B+ tree. It can be used as a drop-in replacement for std::set. Not all asymptotic time requirements are met in theory. The class has a traits class defining B+ tree properties like slots and self-verification. Furthermore an allocator can be specified for tree nodes.</p>
<p>It is somewhat inefficient to implement a set using a B+ tree, a plain B tree would hold fewer copies of the keys.</p>
<p>The set class is derived from the base implementation class btree by specifying an empty struct as data_type. All function are adapted to provide the inner class with placeholder objects. Most tricky to get right were the return type's of iterators which as value_type should be the same as key_type, and not a pair of key and dummy-struct. This is taken case of using some template magic in the btree class. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00054">54</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="add9d9415d959dd6280c4c9388463890b"></a><!-- doxytag: member="stx::btree_set::allocator_type" ref="add9d9415d959dd6280c4c9388463890b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Alloc <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fourth template parameter: STL allocator. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00071">71</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="acfda07a714d6a99aed45258189bc8368"></a><!-- doxytag: member="stx::btree_set::btree_impl" ref="acfda07a714d6a99aed45258189bc8368" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00002.html">stx::btree</a>&lt;<a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a>, <a class="el" href="a00015.html">data_type</a>, <a class="el" href="a00010.html#a2d6c5e2aa366dfea07ab1232d0d96515">value_type</a>, <a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a>, <a class="el" href="a00010.html#ae4153912a1f97b51f7bbad71b3129008">traits</a>, false, <a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a>&gt; <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00002.html">btree_impl</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation type of the btree_base. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00099">99</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa5d3d9c7b1218e5680f653fd8f9d8996"></a><!-- doxytag: member="stx::btree_set::const_iterator" ref="aa5d3d9c7b1218e5680f653fd8f9d8996" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::const_iterator <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like iterator object for B+ tree items. </p>
<p>The iterator points to a specific slot number in a leaf. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00151">151</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a989d5052f0f73009ad08544bef214038"></a><!-- doxytag: member="stx::btree_set::const_reverse_iterator" ref="a989d5052f0f73009ad08544bef214038" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::const_reverse_iterator <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#a989d5052f0f73009ad08544bef214038">const_reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create constant reverse iterator by using STL magic </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00157">157</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a00bbef593d8ccf4068c327a83ec63284"></a><!-- doxytag: member="stx::btree_set::data_type" ref="a00bbef593d8ccf4068c327a83ec63284" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00015.html">empty_struct</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00015.html">data_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The empty data_type. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00090">90</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d77049f9bbaaf25ba9edc0635c4627f"></a><!-- doxytag: member="stx::btree_set::iterator" ref="a7d77049f9bbaaf25ba9edc0635c4627f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::iterator <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like iterator object for B+ tree items. </p>
<p>The iterator points to a specific slot number in a leaf. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00147">147</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="af50de559aebda323728e4fa2452bee5f"></a><!-- doxytag: member="stx::btree_set::key_compare" ref="af50de559aebda323728e4fa2452bee5f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Compare <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Second template parameter: Key comparison function object. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00064">64</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a30048df0132910557b9fc6eef098c260"></a><!-- doxytag: member="stx::btree_set::key_type" ref="a30048df0132910557b9fc6eef098c260" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Key <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>First template parameter: The key type of the B+ tree. </p>
<p>This is stored in inner nodes and leaves </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00061">61</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="afb9918dafdccf1eaffa6b6ddc8de0938"></a><!-- doxytag: member="stx::btree_set::reverse_iterator" ref="afb9918dafdccf1eaffa6b6ddc8de0938" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::reverse_iterator <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#afb9918dafdccf1eaffa6b6ddc8de0938">reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create mutable reverse iterator by using STL magic </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00154">154</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aadf0dbca723b094c06361719ea3f9aae"></a><!-- doxytag: member="stx::btree_set::self" ref="aadf0dbca723b094c06361719ea3f9aae" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00010.html">btree_set</a>&lt;<a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a>, <a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a>, <a class="el" href="a00010.html#ae4153912a1f97b51f7bbad71b3129008">traits</a>, <a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a>&gt; <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html">self</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedef of our own type. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00096">96</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab2cb644afc7271107dcceb53e9a86f45"></a><!-- doxytag: member="stx::btree_set::size_type" ref="ab2cb644afc7271107dcceb53e9a86f45" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00002.html#a883a5c48e52ec6e9927037e892f54692">btree_impl::size_type</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#ab2cb644afc7271107dcceb53e9a86f45">size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size type used to count keys. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00105">105</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae4153912a1f97b51f7bbad71b3129008"></a><!-- doxytag: member="stx::btree_set::traits" ref="ae4153912a1f97b51f7bbad71b3129008" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Traits <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#ae4153912a1f97b51f7bbad71b3129008">traits</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Third template parameter: Traits object used to define more parameters of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00068">68</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb76d4594a31ed8906a25d08f5830f5e"></a><!-- doxytag: member="stx::btree_set::tree_stats" ref="acb76d4594a31ed8906a25d08f5830f5e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::tree_stats <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#acb76d4594a31ed8906a25d08f5830f5e">tree_stats</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Small structure containing statistics about the tree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00108">108</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9fc9960504727883e021ed064f831a9b"></a><!-- doxytag: member="stx::btree_set::value_compare" ref="a9fc9960504727883e021ed064f831a9b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_impl::value_compare <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#a9fc9960504727883e021ed064f831a9b">value_compare</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function class comparing two value_type keys. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00102">102</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2d6c5e2aa366dfea07ab1232d0d96515"></a><!-- doxytag: member="stx::btree_set::value_type" ref="a2d6c5e2aa366dfea07ab1232d0d96515" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#a2d6c5e2aa366dfea07ab1232d0d96515">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the set value_type: the key_type. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00093">93</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a45a3f6e426f588acd351b258413e2797"></a><!-- doxytag: member="stx::btree_set::btree_set" ref="a45a3f6e426f588acd351b258413e2797" args="(const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html">btree_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a>()</code></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor initializing an empty B+ tree with the standard key comparison function. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00170">170</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9b12b35835ef7a7bf7414fed7b572119"></a><!-- doxytag: member="stx::btree_set::btree_set" ref="a9b12b35835ef7a7bf7414fed7b572119" args="(const key_compare &amp;kcf, const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html">btree_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>kcf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor initializing an empty B+ tree with a special key comparison object. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00177">177</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad77eab6d282c872f2ad7c2dbe52c08b9"></a><!-- doxytag: member="stx::btree_set::btree_set" ref="ad77eab6d282c872f2ad7c2dbe52c08b9" args="(InputIterator first, InputIterator last, const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html">btree_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor initializing a B+ tree with the range [first,last) </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00185">185</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00474">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="ab7e9ff448fa299e15b8bb5d5b18d24cd"></a><!-- doxytag: member="stx::btree_set::btree_set" ref="ab7e9ff448fa299e15b8bb5d5b18d24cd" args="(InputIterator first, InputIterator last, const key_compare &amp;kcf, const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html">btree_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>kcf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor initializing a B+ tree with the range [first,last) and a special key comparison object. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00195">195</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00474">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a252d6d1027b0d78a1bec9f63fc68cd82"></a><!-- doxytag: member="stx::btree_set::~btree_set" ref="a252d6d1027b0d78a1bec9f63fc68cd82" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::~<a class="el" href="a00010.html">btree_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees up all used B+ tree memory pages. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00203">203</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="af37409eb0e66f7d3e80b8ad29470118b"></a><!-- doxytag: member="stx::btree_set::btree_set" ref="af37409eb0e66f7d3e80b8ad29470118b" args="(const self &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html">btree_set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>The newly initialized B+ tree object will contain a copy of all keys. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00464">464</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9521b86ca0d5142a12ae32523c1afb71"></a><!-- doxytag: member="stx::btree_set::begin" ref="a9521b86ca0d5142a12ae32523c1afb71" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write iterator that points to the first slot in the first leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00252">252</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01493">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::begin()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ad79866f391eff27bb4da840c31f1b4cd"></a><!-- doxytag: member="stx::btree_set::begin" ref="ad79866f391eff27bb4da840c31f1b4cd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only constant iterator that points to the first slot in the first leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00266">266</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01493">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::begin()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a52fe59cdd4576d9cc9266e42bca323b2"></a><!-- doxytag: member="stx::btree_set::clear" ref="a52fe59cdd4576d9cc9266e42bca323b2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees all keys and all nodes of the tree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00242">242</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01447">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::clear()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a1dbbf865a4ad5a740419de17946b4a4c"></a><!-- doxytag: member="stx::btree_set::count" ref="a1dbbf865a4ad5a740419de17946b4a4c" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#ab2cb644afc7271107dcceb53e9a86f45">size_type</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to locate a key in the B+ tree and returns the number of identical key entries found. </p>
<p>As this is a unique set, <a class="el" href="a00010.html#a1dbbf865a4ad5a740419de17946b4a4c" title="Tries to locate a key in the B+ tree and returns the number of identical key entries found...">count()</a> returns either 0 or 1. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00361">361</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01742">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::count()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ab482ba64445f71f2c088f0c5ee981ea5"></a><!-- doxytag: member="stx::btree_set::dump" ref="ab482ba64445f71f2c088f0c5ee981ea5" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dump the contents of the B+ tree out onto an ostream as a binary image. </p>
<p>The image contains memory pointers which will be fixed when the image is restored. For this to work your key_type must be an integral type and contain no pointers or references. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00566">566</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03643">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::dump()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a763bf123995cf352f7a08bc43fe0597d"></a><!-- doxytag: member="stx::btree_set::empty" ref="a763bf123995cf352f7a08bc43fe0597d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if there is at least one key in the B+ tree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00316">316</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01654">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::empty()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a0e5c8c7a9deff3d2fe75f180d01b911e"></a><!-- doxytag: member="stx::btree_set::end" ref="a0e5c8c7a9deff3d2fe75f180d01b911e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only constant iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00273">273</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01500">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::end()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a8048755a5927b42cce11c19fa8953d93"></a><!-- doxytag: member="stx::btree_set::end" ref="a8048755a5927b42cce11c19fa8953d93" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00259">259</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01500">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::end()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="af023de2dd94f574e312e8e9f5515bd8c"></a><!-- doxytag: member="stx::btree_set::equal_range" ref="af023de2dd94f574e312e8e9f5515bd8c" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>, <a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>&gt; <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns both <a class="el" href="a00010.html#ab9bce6f24080308ab099b2ea41adbba7" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00010.html#ab135d588af2fbdf1631a722b9014c524" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00397">397</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01860">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::equal_range()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ac9dc81052691280fb5fd0b091c08ea0a"></a><!-- doxytag: member="stx::btree_set::equal_range" ref="ac9dc81052691280fb5fd0b091c08ea0a" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a>, <a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a>&gt; <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns both <a class="el" href="a00010.html#ab9bce6f24080308ab099b2ea41adbba7" title="Searches the B+ tree and returns an iterator to the first pair equal to or greater than key...">lower_bound()</a> and <a class="el" href="a00010.html#ab135d588af2fbdf1631a722b9014c524" title="Searches the B+ tree and returns an iterator to the first pair greater than key, or end() if all keys...">upper_bound()</a>. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00403">403</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01860">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::equal_range()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a0b4f57f1b268095b0c33c5623280c4e4"></a><!-- doxytag: member="stx::btree_set::erase" ref="a0b4f57f1b268095b0c33c5623280c4e4" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#ab2cb644afc7271107dcceb53e9a86f45">size_type</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases all the key/data pairs associated with the given key. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00510">510</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02413">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::erase()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="aea8d759b037157313042df5b6cad4b5b"></a><!-- doxytag: member="stx::btree_set::erase" ref="aea8d759b037157313042df5b6cad4b5b" args="(iterator iter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase the key/data pair referenced by the iterator. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00516">516</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02413">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::erase()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ad0bf46d5da971b9abef66a69bab86b33"></a><!-- doxytag: member="stx::btree_set::erase" ref="ad0bf46d5da971b9abef66a69bab86b33" args="(iterator, iterator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase all keys in the range [first,last). </p>
<p>This function is currently not implemented by the B+ Tree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00524">524</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0cf2d6744a938d3249f58263f68f4802"></a><!-- doxytag: member="stx::btree_set::erase_one" ref="a0cf2d6744a938d3249f58263f68f4802" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases the key from the set. </p>
<p>As this is a unique set, there is no difference to <a class="el" href="a00010.html#a0b4f57f1b268095b0c33c5623280c4e4" title="Erases all the key/data pairs associated with the given key.">erase()</a>. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00504">504</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02390">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::erase_one()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ac76905f0dc9369d4bb460f6e24bf7363"></a><!-- doxytag: member="stx::btree_set::exists" ref="ac76905f0dc9369d4bb460f6e24bf7363" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-STL function checking whether a key is in the B+ tree. </p>
<p>The same as (find(k) != <a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a>) or (<a class="el" href="a00010.html#a1dbbf865a4ad5a740419de17946b4a4c" title="Tries to locate a key in the B+ tree and returns the number of identical key entries found...">count()</a> != 0). </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00339">339</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01677">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::exists()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a7ed6ed0ae9f3993cedca7b7d8755be85"></a><!-- doxytag: member="stx::btree_set::find" ref="a7ed6ed0ae9f3993cedca7b7d8755be85" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to locate a key in the B+ tree and returns an iterator to the key slot if found. </p>
<p>If unsuccessful it returns <a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a>. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00346">346</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01698">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::find()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a4f4474b05a7a87b0ce0e9a451b25741d"></a><!-- doxytag: member="stx::btree_set::find" ref="a4f4474b05a7a87b0ce0e9a451b25741d" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to locate a key in the B+ tree and returns an constant iterator to the key slot if found. </p>
<p>If unsuccessful it returns <a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a>. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00353">353</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01698">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::find()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a603ef9ef20b9f7ad05401d5d6eca2ece"></a><!-- doxytag: member="stx::btree_set::get_allocator" ref="a603ef9ef20b9f7ad05401d5d6eca2ece" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#add9d9415d959dd6280c4c9388463890b">allocator_type</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the base node allocator provided during construction. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00233">233</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01385">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::get_allocator()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ae085f7427a2cb614b5a44c0b545fb86b"></a><!-- doxytag: member="stx::btree_set::get_stats" ref="ae085f7427a2cb614b5a44c0b545fb86b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00010.html#acb76d4594a31ed8906a25d08f5830f5e">tree_stats</a>&amp; <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::get_stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a const reference to the current statistics. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00329">329</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01667">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::get_stats()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="aea42997e9d00ecaabe5e868196c5e8f0"></a><!-- doxytag: member="stx::btree_set::insert" ref="aea42997e9d00ecaabe5e868196c5e8f0" args="(const key_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>, bool&gt; <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to insert a key into the B+ tree. </p>
<p>The insert will fail if it is already present. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00474">474</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02026">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::insert2()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

<p>Referenced by <a class="el" href="a00034_source.html#l00185">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::btree_set()</a>, and <a class="el" href="a00034_source.html#l00489">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f6d35bf91f3c3c8721a73ce7ebba710"></a><!-- doxytag: member="stx::btree_set::insert" ref="a9f6d35bf91f3c3c8721a73ce7ebba710" args="(iterator hint, const key_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to insert a key into the B+ tree. </p>
<p>The iterator hint is currently ignored by the B+ tree insertion routine. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00481">481</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l02026">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::insert2()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a43c39f79bdb47c293017e39422a6371b"></a><!-- doxytag: member="stx::btree_set::insert" ref="a43c39f79bdb47c293017e39422a6371b" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to insert the range [first,last) of iterators dereferencing to key_type into the B+ tree. </p>
<p>Each key/data pair is inserted individually. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00489">489</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00474">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="abd0d44790a5ec381c5137b0dea712894"></a><!-- doxytag: member="stx::btree_set::key_comp" ref="abd0d44790a5ec381c5137b0dea712894" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#af50de559aebda323728e4fa2452bee5f">key_compare</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constant access to the key comparison object sorting the B+ tree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00217">217</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01341">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::key_comp()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ab9bce6f24080308ab099b2ea41adbba7"></a><!-- doxytag: member="stx::btree_set::lower_bound" ref="ab9bce6f24080308ab099b2ea41adbba7" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns an iterator to the first pair equal to or greater than key, or <a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00368">368</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01775">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::lower_bound()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a555d7bf9ca80b37707ed8a2f2427bd10"></a><!-- doxytag: member="stx::btree_set::lower_bound" ref="a555d7bf9ca80b37707ed8a2f2427bd10" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns a constant iterator to the first pair equal to or greater than key, or <a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00376">376</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01775">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::lower_bound()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ae3338e9685da6924c7be74906b3cf68b"></a><!-- doxytag: member="stx::btree_set::max_size" ref="ae3338e9685da6924c7be74906b3cf68b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#ab2cb644afc7271107dcceb53e9a86f45">size_type</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the largest possible size of the B+ Tree. </p>
<p>This is just a function required by the STL standard, the B+ Tree can hold more items. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00323">323</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01661">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::max_size()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a164d435a3f3c3ba2a00a4f4c8f1a91b2"></a><!-- doxytag: member="stx::btree_set::operator!=" ref="a164d435a3f3c3ba2a00a4f4c8f1a91b2" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality relation. Based on operator==. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00419">419</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a9e637bfa9b10589da6af42ac17048976"></a><!-- doxytag: member="stx::btree_set::operator&lt;" ref="a9e637bfa9b10589da6af42ac17048976" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Total ordering relation of B+ trees of the same type. </p>
<p>It uses std::lexicographical_compare() for the actual comparison of elements. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00426">426</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a9ce20587b88f126796b6e3784680f66e"></a><!-- doxytag: member="stx::btree_set::operator&lt;=" ref="a9ce20587b88f126796b6e3784680f66e" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Less-equal relation. Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00438">438</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a36ba21d19bf0aa1bc6b2ffb8e4ea8cfc"></a><!-- doxytag: member="stx::btree_set::operator=" ref="a36ba21d19bf0aa1bc6b2ffb8e4ea8cfc" args="(const self &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">self</a>&amp; <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>*** Fast Copy: Assign Operator and Copy Constructors </p>
<p>Assignment operator. All the keys are copied </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00453">453</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a7151704256c80cf7bc413b48bea52b75"></a><!-- doxytag: member="stx::btree_set::operator==" ref="a7151704256c80cf7bc413b48bea52b75" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality relation of B+ trees of the same type. </p>
<p>B+ trees of the same size and equal elements are considered equal. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00413">413</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a201df2577f43d59328a442f38bbb6e30"></a><!-- doxytag: member="stx::btree_set::operator&gt;" ref="a201df2577f43d59328a442f38bbb6e30" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greater relation. Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00432">432</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="afefedc35ea11d982c716860a921f2a24"></a><!-- doxytag: member="stx::btree_set::operator&gt;=" ref="afefedc35ea11d982c716860a921f2a24" args="(const self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Greater-equal relation. Based on operator&lt;. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00444">444</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ab52f7877dc24a1ada22eb093346926ad"></a><!-- doxytag: member="stx::btree_set::print" ref="ab52f7877dc24a1ada22eb093346926ad" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print out the B+ tree structure with keys onto the given ostream. </p>
<p>This function requires that the header is compiled with BTREE_DEBUG and that key_type is printable via std::ostream. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00537">537</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03356">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::print()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ab4f43a518a8294478c0a635e6cb822f4"></a><!-- doxytag: member="stx::btree_set::print_leaves" ref="ab4f43a518a8294478c0a635e6cb822f4" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::print_leaves </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print out only the leaves via the double linked list. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00543">543</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03364">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::print_leaves()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="af6fcf44e17e2c3416228f3f016c46d18"></a><!-- doxytag: member="stx::btree_set::rbegin" ref="af6fcf44e17e2c3416228f3f016c46d18" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a989d5052f0f73009ad08544bef214038">const_reverse_iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only reverse iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00294">294</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01521">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::rbegin()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a4f427468ae77255b8f6dfd99f09df632"></a><!-- doxytag: member="stx::btree_set::rbegin" ref="a4f427468ae77255b8f6dfd99f09df632" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#afb9918dafdccf1eaffa6b6ddc8de0938">reverse_iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write reverse iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00280">280</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01521">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::rbegin()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a054c601b6f1f281868d8426a61e7020d"></a><!-- doxytag: member="stx::btree_set::rend" ref="a054c601b6f1f281868d8426a61e7020d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a989d5052f0f73009ad08544bef214038">const_reverse_iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read-only reverse iterator that points to the first slot in the first leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00301">301</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01528">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::rend()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a9e1eb2e0b1c92cee93524a002456fbaf"></a><!-- doxytag: member="stx::btree_set::rend" ref="a9e1eb2e0b1c92cee93524a002456fbaf" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#afb9918dafdccf1eaffa6b6ddc8de0938">reverse_iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs a read/data-write reverse iterator that points to the first slot in the first leaf of the B+ tree. </p>
<p>Uses STL magic. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00287">287</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01528">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::rend()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a2f73e4b0a1d3ed2f6e73ef33dea0ac46"></a><!-- doxytag: member="stx::btree_set::restore" ref="a2f73e4b0a1d3ed2f6e73ef33dea0ac46" args="(std::istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::restore </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restore a binary image of a dumped B+ tree from an istream. </p>
<p>The B+ tree pointers are fixed using the dump order. For dump and restore to work your key_type must be an integral type and contain no pointers or references. Returns true if the restore was successful. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00575">575</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l03660">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::restore()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="ad00b79874786c1f20cae2b7e765b9e7a"></a><!-- doxytag: member="stx::btree_set::size" ref="ad00b79874786c1f20cae2b7e765b9e7a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#ab2cb644afc7271107dcceb53e9a86f45">size_type</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of keys in the B+ tree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00310">310</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00026_source.html#l01648">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::size()</a>, and <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a24321f7bdae8ffc461e48d6331cf25e3"></a><!-- doxytag: member="stx::btree_set::swap" ref="a24321f7bdae8ffc461e48d6331cf25e3" args="(self &amp;from)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00010.html">self</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fast swapping of two identical B+ tree objects. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00208">208</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>.</p>

</div>
</div>
<a class="anchor" id="a8cccc9b19e58b5c37f3f40ffd8ae3978"></a><!-- doxytag: member="stx::btree_set::upper_bound" ref="a8cccc9b19e58b5c37f3f40ffd8ae3978" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#aa5d3d9c7b1218e5680f653fd8f9d8996">const_iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns a constant iterator to the first pair greater than key, or <a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00391">391</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l01818">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::upper_bound()</a>.</p>

</div>
</div>
<a class="anchor" id="ab135d588af2fbdf1631a722b9014c524"></a><!-- doxytag: member="stx::btree_set::upper_bound" ref="ab135d588af2fbdf1631a722b9014c524" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a7d77049f9bbaaf25ba9edc0635c4627f">iterator</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00010.html#a30048df0132910557b9fc6eef098c260">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches the B+ tree and returns an iterator to the first pair greater than key, or <a class="el" href="a00010.html#a8048755a5927b42cce11c19fa8953d93" title="Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B...">end()</a> if all keys are smaller or equal. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00383">383</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l01818">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::upper_bound()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e31a7e133791f60117cfa2e0a323819"></a><!-- doxytag: member="stx::btree_set::value_comp" ref="a2e31a7e133791f60117cfa2e0a323819" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html#a9fc9960504727883e021ed064f831a9b">value_compare</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constant access to a constructed value_type comparison object. </p>
<p>required by the STL </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00224">224</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l01348">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::value_comp()</a>.</p>

</div>
</div>
<a class="anchor" id="af88455baba68554522a181ad2a8dc8fc"></a><!-- doxytag: member="stx::btree_set::verify" ref="af88455baba68554522a181ad2a8dc8fc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::verify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run a thorough verification of all B+ tree invariants. </p>
<p>The program aborts via <a class="el" href="a00026.html#a6ac57b9b59dae34aea28cda65b0d14bb" title="Assertion only if BTREE_DEBUG is defined. This is not used in verify().">BTREE_ASSERT()</a> if something is wrong. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00555">555</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>References <a class="el" href="a00034_source.html#l00163">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::tree</a>, and <a class="el" href="a00026_source.html#l03430">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates, _Alloc &gt;::verify()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a76a14434ee750af9999bea4e2b657b36"></a><!-- doxytag: member="stx::btree_set::allow_duplicates" ref="a76a14434ee750af9999bea4e2b657b36" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#a76a14434ee750af9999bea4e2b657b36">allow_duplicates</a> = <a class="el" href="a00002.html#afa5653b47e117eb6b1ae3366deb9c6a0">btree_impl::allow_duplicates</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operational parameter: Allow duplicate keys in the btree. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00140">140</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab3568dade6579ccf9a3f50df18eabb01"></a><!-- doxytag: member="stx::btree_set::debug" ref="ab3568dade6579ccf9a3f50df18eabb01" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#ab3568dade6579ccf9a3f50df18eabb01">debug</a> = <a class="el" href="a00002.html#af91ee795a4d14f054563f08378085f6d">btree_impl::debug</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Debug parameter: Prints out lots of debug information about how the algorithms change the tree. </p>
<p>Requires the header file to be compiled with BTREE_DEBUG and the key type must be std::ostream printable. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00137">137</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa48cfb5c8f935ff286ca7a12e97886db"></a><!-- doxytag: member="stx::btree_set::innerslotmax" ref="aa48cfb5c8f935ff286ca7a12e97886db" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#aa48cfb5c8f935ff286ca7a12e97886db">innerslotmax</a> = <a class="el" href="a00002.html#a801dc48f105e6f7d34fe22a301eee345">btree_impl::innerslotmax</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Base B+ tree parameter: The number of key slots in each inner node, this can differ from slots in each leaf. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00118">118</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="af20d59df4181356a7731674deeeafa0d"></a><!-- doxytag: member="stx::btree_set::leafslotmax" ref="af20d59df4181356a7731674deeeafa0d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#af20d59df4181356a7731674deeeafa0d">leafslotmax</a> = <a class="el" href="a00002.html#a49865e80555e206e6039405191b21f40">btree_impl::leafslotmax</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Base B+ tree parameter: The number of key slots in each leaf. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00114">114</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a133181518b3bfeec73537984581cc8ef"></a><!-- doxytag: member="stx::btree_set::mininnerslots" ref="a133181518b3bfeec73537984581cc8ef" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#a133181518b3bfeec73537984581cc8ef">mininnerslots</a> = <a class="el" href="a00002.html#aac1f08dd49f22cfbc8e534848d9d7924">btree_impl::mininnerslots</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computed B+ tree parameter: The minimum number of key slots used in an inner node. </p>
<p>If fewer slots are used, the inner node will be merged or slots shifted from it's siblings. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00128">128</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a16ff8b6fdbbffcbdb50de080d4631015"></a><!-- doxytag: member="stx::btree_set::minleafslots" ref="a16ff8b6fdbbffcbdb50de080d4631015" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#a16ff8b6fdbbffcbdb50de080d4631015">minleafslots</a> = <a class="el" href="a00002.html#a908b35146a3f01ee4f59882733274be7">btree_impl::minleafslots</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computed B+ tree parameter: The minimum number of key slots used in a leaf. </p>
<p>If fewer slots are used, the leaf will be merged or slots shifted from it's siblings. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00123">123</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeef1f92bbdd38ed63f588a56db598077"></a><!-- doxytag: member="stx::btree_set::selfverify" ref="aeef1f92bbdd38ed63f588a56db598077" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#aeef1f92bbdd38ed63f588a56db598077">selfverify</a> = <a class="el" href="a00002.html#af4d008a956acd3726b1ca0ba9f604c5f">btree_impl::selfverify</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Debug parameter: Enables expensive and thorough checking of the B+ tree invariants after each insert/erase operation. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00132">132</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a352435bb00a9126a4c72b565553d13b7"></a><!-- doxytag: member="stx::btree_set::tree" ref="a352435bb00a9126a4c72b565553d13b7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Compare  = std::less&lt;_Key&gt;, typename _Traits  = btree_default_set_traits&lt;_Key&gt;, typename _Alloc  = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00002.html">btree_impl</a> <a class="el" href="a00010.html">stx::btree_set</a>&lt; _Key, _Compare, _Traits, _Alloc &gt;::<a class="el" href="a00010.html#a352435bb00a9126a4c72b565553d13b7">tree</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The contained implementation object. </p>

<p>Definition at line <a class="el" href="a00034_source.html#l00163">163</a> of file <a class="el" href="a00034_source.html">btree_set.h</a>.</p>

<p>Referenced by <a class="el" href="a00034_source.html#l00252">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::begin()</a>, <a class="el" href="a00034_source.html#l00242">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::clear()</a>, <a class="el" href="a00034_source.html#l00361">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::count()</a>, <a class="el" href="a00034_source.html#l00566">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::dump()</a>, <a class="el" href="a00034_source.html#l00316">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::empty()</a>, <a class="el" href="a00034_source.html#l00259">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::end()</a>, <a class="el" href="a00034_source.html#l00397">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::equal_range()</a>, <a class="el" href="a00034_source.html#l00510">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase()</a>, <a class="el" href="a00034_source.html#l00504">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::erase_one()</a>, <a class="el" href="a00034_source.html#l00339">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::exists()</a>, <a class="el" href="a00034_source.html#l00346">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::find()</a>, <a class="el" href="a00034_source.html#l00233">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::get_allocator()</a>, <a class="el" href="a00034_source.html#l00329">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::get_stats()</a>, <a class="el" href="a00034_source.html#l00474">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::insert()</a>, <a class="el" href="a00034_source.html#l00217">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::key_comp()</a>, <a class="el" href="a00034_source.html#l00368">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::lower_bound()</a>, <a class="el" href="a00034_source.html#l00323">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::max_size()</a>, <a class="el" href="a00034_source.html#l00419">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator!=()</a>, <a class="el" href="a00034_source.html#l00426">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt;()</a>, <a class="el" href="a00034_source.html#l00438">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&lt;=()</a>, <a class="el" href="a00034_source.html#l00453">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator=()</a>, <a class="el" href="a00034_source.html#l00413">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator==()</a>, <a class="el" href="a00034_source.html#l00432">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt;()</a>, <a class="el" href="a00034_source.html#l00444">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::operator&gt;=()</a>, <a class="el" href="a00034_source.html#l00537">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::print()</a>, <a class="el" href="a00034_source.html#l00543">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::print_leaves()</a>, <a class="el" href="a00034_source.html#l00280">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::rbegin()</a>, <a class="el" href="a00034_source.html#l00287">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::rend()</a>, <a class="el" href="a00034_source.html#l00575">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::restore()</a>, <a class="el" href="a00034_source.html#l00310">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::size()</a>, <a class="el" href="a00034_source.html#l00208">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::swap()</a>, <a class="el" href="a00034_source.html#l00383">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::upper_bound()</a>, <a class="el" href="a00034_source.html#l00224">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::value_comp()</a>, and <a class="el" href="a00034_source.html#l00555">stx::btree_set&lt; _Key, _Compare, _Traits, _Alloc &gt;::verify()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>stx/<a class="el" href="a00034_source.html">btree_set.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed May 18 2011 10:12:05 for STX B+ Tree Template Classes by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
