<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><title>/2007/stx-btree/stx-btree-0.8.6/include/stx/btree.dox - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="http://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="http://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/pt.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body style="background-image: url(/img/bgfractal8.jpg)"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/">Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li></ul></li><li class="top"><a class="ni" href="/tags/">Tags</a><div style="width: 14em; margin-left: -9em; margin-top: 4px"><a style="font-size: 10pt" href="/tags/algebra.html">algebra</a> <a style="font-size: 16pt" href="/tags/c++.html">c++</a> <a style="font-size: 12pt" href="/tags/code-example.html">code-example</a> <a style="font-size: 14pt" href="/tags/code-snippet.html">code-snippet</a> <a style="font-size: 11pt" href="/tags/coding_tricks.html">coding tricks</a> <a style="font-size: 10pt" href="/tags/compsci.html">compsci</a> <a style="font-size: 10pt" href="/tags/compsci_study_thesis.html">compsci study thesis</a> <a style="font-size: 9pt" href="/tags/crypto-speedtest.html">crypto-speedtest</a> <a style="font-size: 10pt" href="/tags/cryptography.html">cryptography</a> <a style="font-size: 9pt" href="/tags/cryptote.html">cryptote</a> <a style="font-size: 12pt" href="/tags/flex-bison-cpp-example.html">flex-bison-cpp-example</a> <a style="font-size: 12pt" href="/tags/fun.html">fun</a> <a style="font-size: 10pt" href="/tags/graphviz.html">graphviz</a> <a style="font-size: 9pt" href="http://www.hmtg.de">hartmetall</a> <a style="font-size: 9pt" href="/tags/helppc.html">helppc</a> <a style="font-size: 9pt" href="/tags/hifi_selbstbau.html">hifi selbstbau</a> <a style="font-size: 10pt" href="/tags/latex.html">latex</a> <a style="font-size: 10pt" href="/tags/librivox.html">librivox</a> <a style="font-size: 10pt" href="/tags/linux.html">linux</a> <a style="font-size: 10pt" href="/tags/maths.html">maths</a> <a style="font-size: 9pt" href="/tags/music.html">music</a> <a style="font-size: 10pt" href="/tags/netfundamentals.html">netfundamentals</a> <a style="font-size: 11pt" href="/tags/ns-3.html">ns-3</a> <a style="font-size: 9pt" href="/tags/parallel-string-sorting.html">parallel-string-sorting</a> <a style="font-size: 9pt" href="/tags/qtsqlview.html">qtsqlview</a> <a style="font-size: 9pt" href="/tags/research.html">research</a> <a style="font-size: 11pt" href="/tags/sdios06.html">sdios06</a> <a style="font-size: 9pt" href="/tags/sdlfractal.html">sdlfractal</a> <a style="font-size: 10pt" href="/tags/sorting.html">sorting</a> <a style="font-size: 9pt" href="/tags/stringology.html">stringology</a> <a style="font-size: 16pt" href="/tags/stx-btree.html">stx-btree</a> <a style="font-size: 9pt" href="/tags/stx-exparser.html">stx-exparser</a> <a style="font-size: 14pt" href="/tags/talk.html">talk</a> <a style="font-size: 10pt" href="/tags/tutorium.html">tutorium</a> <a style="font-size: 16pt" href="/tags/university.html">university</a> <a style="font-size: 13pt" href="/tags/utilities.html">utilities</a> <a style="font-size: 9pt" href="/tags/webdesign.html">webdesign</a> </div></li><li class="top"><a class="ni" href="#">Projects</a> <ul style="margin-left: -8em; margin-top: 4px" class="nx"> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2013/parallel-string-sorting/">parallel-string-sorting</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li class="nt"><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"><a class="ni" href="/about/timo.html">About Me</a></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2007/">2007</a> / <a href="/2007/stx-btree/">stx-btree</a> / <a href="/2007/stx-btree/stx-btree-0.8.6/">stx-btree-0.8.6</a> / <a href="/2007/stx-btree/stx-btree-0.8.6/include/">include</a> / <a href="/2007/stx-btree/stx-btree-0.8.6/include/stx/">stx</a> / <a href="/2007/stx-btree/stx-btree-0.8.6/include/stx/btree.dox.html">btree.dox</a> (<a href="/2007/stx-btree/stx-btree-0.8.6/include/stx/btree.dox">Download File</a>)</div></div><div class="ptfullwidth"><pre class="codesnippet" style="font-family: monospace"><tt>// $Id: btree.dox 128 2011-05-18 07:23:35Z tb $ -*- fill-column: 79 -*-
/** \file btree.dox
 * Contains the doxygen comments. This header is not needed to compile the B+
 * tree.
 */

/*
 * STX B+ Tree Template Classes v0.8.6
 * Copyright (C) 2008-2011 Timo Bingmann
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

/** \mainpage STX B+ Tree Template Classes README

\author Timo Bingmann (Mail: tb a-with-circle idlebox dot net)
\date 2008-09-07 and 2011-05-17

\section sec1 Summary

The STX B+ Tree package is a set of C++ template classes implementing a B+ tree
key/data container in main memory. The classes are designed as drop-in
replacements of the STL containers &lt;tt&gt;set&lt;/tt&gt;, &lt;tt&gt;map&lt;/tt&gt;,
&lt;tt&gt;multiset&lt;/tt&gt; and &lt;tt&gt;multimap&lt;/tt&gt; and follow their interfaces very
closely. By packing multiple value pairs into each node of the tree the B+ tree
reduces heap fragmentation and utilizes cache-line effects better than the
standard red-black binary tree. The tree algorithms are based on the
implementation in Cormen, Leiserson and Rivest&apos;s Introduction into Algorithms,
Jan Jannink&apos;s paper and other algorithm resources. The classes contain
extensive assertion and verification mechanisms to ensure the implementation&apos;s
correctness by testing the tree invariants. To illustrate the B+ tree&apos;s
structure a wxWidgets demo program is included in the source package.

\section sec2 Website / API Docs / Bugs / License

The current source package can be downloaded from
http://idlebox.net/2007/stx-btree/

The include files are extensively documented using doxygen. The compiled
doxygen html documentation is included in the source package. It can also be
viewed online at
http://idlebox.net/2007/stx-btree/stx-btree-0.8.6/doxygen-html/ (if you are not
reading it right now).

The wxWidgets B+ tree demo program is located in the directory
wxbtreedemo. Compiled binary versions can be found on the package web page
mentioned above.

If bugs should become known they will be posted on the above web page together
with patches or corrected versions.

The complete source code is released under the GNU Lesser General Public
License v2.1 (LGPL) which can be found in the file COPYING.

\section sec3 Original Application

The idea originally arose while coding a read-only database, which used a huge
map of millions of non-sequential integer keys to 8-byte file offsets. When
using the standard STL red-black tree implementation this would yield millions
of 20-byte heap allocations and very slow search times due to the tree&apos;s
height. So the original intention was to reduce memory fragmentation and
improve search times. The B+ tree solves this by packing multiple data pairs
into one node with a large number of descendant nodes.

In computer science lectures it is often stated that using consecutive bytes in
memory would be more cache-efficient, because the CPU&apos;s cache levels always
fetch larger blocks from main memory. So it would be best to store the keys of
a node in one continuous array. This way the inner scanning loop would be
accelerated by benefiting from cache effects and pipelining speed-ups. Thus the
cost of scanning for a matching key would be lower than in a red-black tree,
even though the number of key comparisons are theoretically larger. This second
aspect aroused my academic interest and resulted in the
\ref speedtest &quot;speed test experiments&quot;.

A third inspiration was that no working C++ template implementation of a B+
tree could be found on the Internet. Now this one can be found.

\section sec4 Implementation Overview

This implementation contains five main classes within the \ref stx namespace
(blandly named Some Template eXtensions). The base class \ref stx::btree
&quot;btree&quot; implements the B+ tree algorithms using inner and leaf nodes in main
memory. Almost all STL-required function calls are implemented (see below for
the exceptions). The asymptotic time requirements of the STL standard are
theoretically not always fulfilled. However in practice this B+ tree performs
better than the STL&apos;s red-black tree at the cost of using more memory. See the
\ref speedtest &quot;speed test results&quot; for details.

The base class is then specialized into \ref stx::btree_set &quot;btree_set&quot;, \ref
stx::btree_multiset &quot;btree_multiset&quot;, \ref stx::btree_map &quot;btree_map&quot; and \ref
stx::btree_multimap &quot;btree_multimap&quot; using default template parameters and
facade functions. These classes are designed to be drop-in replacements for the
corresponding STL containers.

The insertion function splits the nodes on recursion unroll. Erase is largely
based on Jannink&apos;s ideas. See http://dbpubs.stanford.edu:8090/pub/1995-19 for
his paper on &quot;Implementing Deletion in B+-trees&quot;.

The two set classes (\ref stx::btree_set &quot;btree_set&quot; and \ref
stx::btree_multiset &quot;btree_multiset&quot;) are derived from the base implementation
\ref stx::btree &quot;class btree&quot; by specifying an empty struct as data_type. All
functions are adapted to provide the base class with empty placeholder
objects. Note that it is somewhat inefficient to implement a set or multiset
using a B+ tree: a plain B tree (without +) would hold no extra copies of the
keys. The main focus was on implementing the maps.

\section sec5 Problem with Separated Key/Data Arrays

The most noteworthy difference to the default red-black tree implementation of
std::map is that the B+ tree does not hold key/data pairs together in memory.
Instead each B+ tree node has two separate arrays containing keys and data
values. This design was chosen to utilize cache-line effects while scanning the
key array.

However it also directly generates many problems in implementing the iterators&apos;
operators. These return a (writable) reference or pointer to a value_type,
which is a std::pair composition. These data/key pairs however are not stored
together and thus a temporary copy must be constructed. This copy should not be
written to, because it is not stored back into the B+ tree. This effectively
prohibits use of many STL algorithms which writing to the B+ tree&apos;s
iterators. I would be grateful for hints on how to resolve this problem without
folding the key and data arrays.

\section sec6 Test Suite

The B+ tree distribution contains an extensive test suite using
cppunit. According to gcov 91.9% of the btree.h implementation is covered.

\section sec7 STL Incompatibilities

\subsection sec7-1 Key and Data Type Requirements

The tree algorithms currently do not use copy-construction. All key/data items
are allocated in the nodes using the default-constructor and are subsequently
only assigned new data (using &lt;tt&gt;operator=&lt;/tt&gt;).

\subsection sec7-2 Iterators&apos; Operators

The most important incompatibility are the non-writable &lt;tt&gt;operator*&lt;/tt&gt; and
&lt;tt&gt;operator-&gt;&lt;/tt&gt; of the \ref stx::btree::iterator &quot;iterator&quot;. See above for
a discussion of the problem on separated key/data arrays.  Instead of
&lt;tt&gt;*iter&lt;/tt&gt; and &lt;tt&gt;iter-&gt;&lt;/tt&gt; use the new function &lt;tt&gt;iter.data()&lt;/tt&gt;
which returns a writable reference to the data value in the tree.

\subsection sec7-3 Erase Functions

The B+ tree supports three erase functions:

\code
size_type erase(const key_type &amp;key); // erase all data pairs matching key
bool erase_one(const key_type &amp;key);  // erase one data pair matching key
void erase(iterator iter);	      // erase pair referenced by iter
\endcode

The following STL-required function is currently not supported:

\code
void erase(iterator first, iterator last);
\endcode

\section sec8 Extensions

Beyond the usual STL interface the B+ tree classes support some extra goodies.

\code
// Output the tree in a pseudo-hierarchical text dump to std::cout. This
// function requires that BTREE_DEBUG is defined prior to including the btree
// headers. Furthermore the key and data types must be std::ostream printable.
void print() const;

// Run extensive checks of the tree invariants. If a corruption in found the
// program will abort via assert(). See below on enabling auto-verification.
void verify() const;

// Serialize and restore the B+ tree nodes and data into/from a binary image.
// This requires that the key and data types are integral and contain no
// outside pointers or references.
void dump(std::ostream &amp;os) const;
bool restore(std::istream &amp;is);
\endcode

\section sec9 B+ Tree Traits

All tree template classes take a template parameter structure which holds
important options of the implementation. The following structure shows which
static variables specify the options and the corresponding defaults:

\code
struct btree_default_map_traits
{
    // If true, the tree will self verify it&apos;s invariants after each insert()
    // or erase(). The header must have been compiled with BTREE_DEBUG
    // defined.
    static const bool   selfverify = false;

    // If true, the tree will print out debug information and a tree dump
    // during insert() or erase() operation. The header must have been
    // compiled with BTREE_DEBUG defined and key_type must be std::ostream
    // printable.
    static const bool   debug = false;

    // Number of slots in each leaf of the tree. Estimated so that each node
    // has a size of about 256 bytes.
    static const int    leafslots =
                             MAX( 8, 256 / (sizeof(_Key) + sizeof(_Data)) );

    // Number of slots in each inner node of the tree. Estimated so that each
    // node has a size of about 256 bytes.
    static const int    innerslots =
                             MAX( 8, 256 / (sizeof(_Key) + sizeof(void*)) );
};
\endcode

\section sec10 Speed Tests

See the extra page \ref speedtest &quot;Speed Test Results&quot;.

*/

/** \page speedtest Speed Test Results

\section sec11 Speed Test Experiments

The B+ tree source package contains a speedtest program which compares the
libstdc++ STL red-black tree with the implemented B+ tree with many different
parameters. The newer STL hash table container from the __gnu_cxx namespace is
also tested against the two trees. To keep focus on the algorithms and reduce
data copying the multiset specializations were chosen. Note that the comparison
between hash table and trees is somewhat unfair, because the hash table does
not keep the keys sorted, and thus cannot be used for all applications.

Three set of test procedures are used: the first only inserts \a n random
integers into the tree / hash table. The second test first inserts \a n random
integers, then performs \a n lookups for those integers and finally erases all
\a n integers. The last test only performs \a n lookups on a tree pre-filled
with \a n integers. All lookups are successful.

These three test sequences are preformed for \a n from 125 to 4,096,000 or
32,768,000 where \a n is doubled after each test run. For each \a n the test
procedure is repeated until at least one second execution time elapses during
the repeated cycle. This way the measured speed for small \a n is averaged over
up to 65,536 repetitions.

Lastly, it is purpose of the test to determine a good node size for the B+
tree. Therefore the test runs are performed on different slot sizes; both inner
and leaf nodes hold the same number of items. The number of slots tested ranges
from 4 to 256 slots and therefore yields node sizes from about 50 to 2,048
bytes. This requires that the B+ tree template is instantiated for each of the
probed node sizes! In the 2011 test, only every other slot size is actually
tested.

Two test results are included in the package: one done in
\ref sec12 &quot;2007 with version 0.7&quot; and another done in
\ref sec13 &quot;2011 with version 0.8.6&quot;.

\section sec12 Results 2007

The speed test source code was compiled with g++ 4.1.2 -O3 -fomit-frame-pointer

\attention Compilation of the speed test with -O3 takes very long and requires
much RAM. It is not automatically built when running &quot;make all&quot;.

Some non-exhaustive tests with the Intel C++ Compiler showed drastically
different results. It optimized the B+ tree algorithms much better than
gcc. More work is needed to get g++ to optimize as well as icc.

The results are be displayed below using gnuplot. All tests were run on a
Pentium4 3.2 GHz with 2 GB RAM. A high-resolution PDF plot of the following
images can be found in the package at speedtest/results-2007/speedtest.pdf

\image html speedtest-2007-01.png
\image html speedtest-2007-02.png

The first two plots above show the absolute time measured for inserting \a n
items into seven different tree variants. For small \a n (the first plot) the
speed of red-black tree and B+ tree are very similar. For large \a n the
red-black tree slows down, and for \a n &gt; 1,024,000 items the red-black tree
requires almost twice as much time as a B+ tree with 32 slots. The STL hash
table performs better than the STL map but not as good as the B+ tree
implementations with higher slot counts.

The next plot shows the insertion time per item, which is calculated by
dividing the absolute time by the number of inserted items. Notice that
insertion time is now in microseconds. The plot shows that the red-black tree
reaches some limitation at about \a n = 16,000 items. Beyond this item count
the B+ tree (with 32 slots) performs much better than the STL multiset. The STL
hash table resizes itself in defined intervals, which leads to non-linearly
increasing insert times.

\image html speedtest-2007-03.png

\image html speedtest-2007-04.png

The last plots goal is to find the best node size for the B+ tree. It displays
the total measured time of the insertion test depending on the number of slots
in inner and leaf nodes. Only runs with more than 1 million inserted items are
plotted. One can see that the minimum is around 65 slots for each of the
curves. However to reduce unused memory in the nodes the most practical slot
size is around 35. This amounts to total node sizes of about 280 bytes. Thus in
the implementation a target size of 256 bytes was chosen.

The following two plots show the same aspects as above, except that not only
insertion time was measured. Instead in the first plot a whole
insert/find/delete cycle was performed and measured. The second plot is
restricted to the lookup / find part.

\image html speedtest-2007-07.png

\image html speedtest-2007-11.png

The results for the trees are in general accordance to those of only
insertion. However the hash table implementation performs much faster in both
tests. This is expected, because hash table lookup (and deletion) requires
fewer memory accesses than tree traversal. Thus a hash table implementation
will always be faster than trees. But of course hash tables do not store items
in sorted order. Interestingly the hash table&apos;s performance is not linear in
the number of items: it&apos;s peak performance is not with small number of items,
but with around 10,000 items. And for item counts larger than 100,000 the hash
table slows down: lookup time more than doubles. However, after doubling, the
lookup time does not change much: lookup on tables with 1 million items takes
approximately the same time as with 4 million items.

\section sec13 Results 2011

In 2011, after some smaller patches and fixes to the main code, I decided to
rerun the old speed test on my new hardware and with up-to-date compilers.

The speedtest source code was compiled on a x86_64 architecture using gcc 4.4.5
with flags -O3 -fomit-frame-pointer. It was run in an Intel Core i7 950 clocked at 3,07 GHz. According to cpuinfo, this processor contains 8 MB L2 cache.

The full results of the newly run tests are found in the package at
speedtest/results-2011/speedtest.pdf

\image html speedtest-2011-03.png

This plot is maybe the most interesting, especially compared with the old run
from 2007. Again the B+ tree multiset implementation is faster than the
red-black tree for large number of items in the tree. However, due to the
faster hardware and larger cache sizes, the average insertion speed plots
diverge notable at around 100,000 items instead of at 16,000 items for the
older Pentium 4 CPU. Nevertheless, the graphs diverge for larger \a n in
approximately the same fashion as in the older plots.

This lets one assume that the basic cache hierarchy architecture has not
changed and the B+ tree implementation still works much better for larger item
counts than the red-black tree.

*/
</tt></pre></div><div style="text-align: left; padding: 8pt"><a href="/xmlfeed/weblog-rss20.xml"><img src="/img/xmlfeed-rss20.png" alt="RSS 2.0 Weblog Feed" height="15" width="80" /></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="/img/xmlfeed-atom10.png" alt="Atom 1.0 Weblog Feed" height="15" width="80" /></a> <a href="http://validator.w3.org/check?uri=referer"><img src="/img/w3c-xhtml10.png" alt="Valid XHTML 1.1" height="15" width="80" /></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="/img/w3c-css.png" alt="Valid CSS (2.1)" height="15" width="80" /></a></div></body></html>