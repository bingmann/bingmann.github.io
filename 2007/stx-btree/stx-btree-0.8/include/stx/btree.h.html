<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><meta name="viewport" content="initial-scale=1"><title>/2007/stx-btree/stx-btree-0.8/include/stx/btree.h - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="stylesheet" type="text/css" href="/css/fonts.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="http://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="http://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/js/base.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body style="background-image: url(/img/bgfractal1.jpg)" lang="en"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/"><i class="icon-book"></i> Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2020/">2020</a></li><li><a href="/2019/">2019</a></li><li><a href="/2018/">2018</a></li><li><a href="/2017/">2017</a></li><li><a href="/2016/">2016</a></li><li><a href="/2015/">2015</a></li><li><a href="/2014/">2014</a></li><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li class="nt"><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li><li class="ns"><a href="/search.html">Search</a></li></ul></li><li class="top"><a class="ni" href="/tags/"><i class="icon-tags"></i> Tags</a><div style="width: 14em; margin-left: -9em; margin-top: 4px"><a style="font-size: 10pt" href="/tags/algebra.html">algebra</a> <a style="font-size: 10pt" href="/tags/blinken-algorithms.html">blinken-algorithms</a> <a style="font-size: 16pt" href="/tags/c++.html">c++</a> <a style="font-size: 12pt" href="/tags/code-example.html">code-example</a> <a style="font-size: 14pt" href="/tags/code-snippet.html">code-snippet</a> <a style="font-size: 11pt" href="/tags/coding_tricks.html">coding tricks</a> <a style="font-size: 10pt" href="/tags/compsci.html">compsci</a> <a style="font-size: 10pt" href="/tags/compsci_study_thesis.html">compsci study thesis</a> <a style="font-size: 9pt" href="/tags/crypto-speedtest.html">crypto-speedtest</a> <a style="font-size: 10pt" href="/tags/cryptography.html">cryptography</a> <a style="font-size: 9pt" href="/tags/cryptote.html">cryptote</a> <a style="font-size: 11pt" href="/tags/dissertation.html">dissertation</a> <a style="font-size: 10pt" href="/tags/electronics.html">electronics</a> <a style="font-size: 12pt" href="/tags/flex-bison-cpp-example.html">flex-bison-cpp-example</a> <a style="font-size: 16pt" href="/tags/frontpage.html">frontpage</a> <a style="font-size: 15pt" href="/tags/fun.html">fun</a> <a style="font-size: 10pt" href="/tags/graphviz.html">graphviz</a> <a style="font-size: 9pt" href="http://www.hmtg.de">hartmetall</a> <a style="font-size: 9pt" href="/tags/helppc.html">helppc</a> <a style="font-size: 9pt" href="/tags/hifi_selbstbau.html">hifi selbstbau</a> <a style="font-size: 10pt" href="/tags/latex.html">latex</a> <a style="font-size: 10pt" href="/tags/LEDs.html">LEDs</a> <a style="font-size: 10pt" href="/tags/librivox.html">librivox</a> <a style="font-size: 10pt" href="/tags/linux.html">linux</a> <a style="font-size: 9pt" href="/tags/market.html">market</a> <a style="font-size: 9pt" href="/tags/massive-sorting.html">massive-sorting</a> <a style="font-size: 11pt" href="/tags/maths.html">maths</a> <a style="font-size: 9pt" href="/tags/music.html">music</a> <a style="font-size: 10pt" href="/tags/netfundamentals.html">netfundamentals</a> <a style="font-size: 11pt" href="/tags/ns-3.html">ns-3</a> <a style="font-size: 10pt" href="/tags/parallel-string-sorting.html">parallel-string-sorting</a> <a style="font-size: 14pt" href="/tags/parsing.html">parsing</a> <a style="font-size: 9pt" href="/tags/qtsqlview.html">qtsqlview</a> <a style="font-size: 14pt" href="/tags/research.html">research</a> <a style="font-size: 11pt" href="/tags/sdios06.html">sdios06</a> <a style="font-size: 9pt" href="/tags/sdlfractal.html">sdlfractal</a> <a style="font-size: 16pt" href="/tags/sorting.html">sorting</a> <a style="font-size: 13pt" href="/tags/sound_of_sorting.html">sound of sorting</a> <a style="font-size: 10pt" href="/tags/stringology.html">stringology</a> <a style="font-size: 16pt" href="/tags/stx-btree.html">stx-btree</a> <a style="font-size: 16pt" href="/tags/stxxl.html">stxxl</a> <a style="font-size: 16pt" href="/tags/talk.html">talk</a> <a style="font-size: 16pt" href="/tags/thrill.html">thrill</a> <a style="font-size: 10pt" href="/tags/tutorium.html">tutorium</a> <a style="font-size: 16pt" href="/tags/university.html">university</a> <a style="font-size: 14pt" href="/tags/utilities.html">utilities</a> <a style="font-size: 10pt" href="/tags/vncrec.html">vncrec</a> <a style="font-size: 9pt" href="/tags/webdesign.html">webdesign</a> </div></li><li class="top"> <a class="ni" href="#"><i class="icon-cubes"></i> Projects</a> <ul style="margin-left: -8em; margin-top: 4px;" class="nx"> <li><a href="/2019/1008-COBS-A-Compact-Bit-Sliced-Signature-Index/">COBS</a></li> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2016/0114-diploma-thesis/">On Bispanning Graphs</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2013/parallel-string-sorting/">Parallel String Sorting</a></li> <li><a href="/2014/sqlplot-tools/">SqlPlotTools</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li><a href="/tags/stxxl.html">STXXL 1.4</a></li> <li><a href="/tags/thrill.html">Thrill - Big Data Framework</a></li> <li class="nt"><a href="/2014/vncrec-rgb/">VNCrec RGB 0.4</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="/publications.html"><i class="icon-graduation-cap"></i> Publications</a></li><li class="top"> <a class="ni" href="/search.html"><i class="icon-search"></i> Search</a></li><li class="top"> <a class="ni" href="/subscribe.html"><i class="icon-rss-squared"></i> Subscribe</a></li><li class="top"> <a class="ni" href="/about/"><i class="icon-info-circled"></i> About</a> <ul style="margin-left: -6em; margin-top: 4px" class="nx"> <li><a href="/about/">Timo Bingmann</a></li> <li><a href="/about/impressum.html">Impressum</a></li> </ul></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2007/">2007</a> / <a href="/2007/stx-btree/">stx-btree</a> / <a href="/2007/stx-btree/stx-btree-0.8/">stx-btree-0.8</a> / <a href="/2007/stx-btree/stx-btree-0.8/include/">include</a> / <a href="/2007/stx-btree/stx-btree-0.8/include/stx/">stx</a> / <a href="/2007/stx-btree/stx-btree-0.8/include/stx/btree.h.html">btree.h</a> (<a href="/2007/stx-btree/stx-btree-0.8/include/stx/btree.h">Download File</a>)</div></div><div class="ptfullwidth"><pre class="codesnippet" style="font-family: monospace"><tt><span class="comment">// $Id: btree.h 59 2007-05-13 11:08:30Z tb $</span>
<span class="comment">/** \file btree.h</span>
<span class="comment"> * Contains the main B+ tree implementation template class btree.</span>
<span class="comment"> */</span>

<span class="comment">/*</span>
<span class="comment"> * STX B+ Tree Template Classes v0.8</span>
<span class="comment"> * Copyright (C) 2007 Timo Bingmann</span>
<span class="comment"> *</span>
<span class="comment"> * This library is free software; you can redistribute it and/or modify it</span>
<span class="comment"> * under the terms of the GNU Lesser General Public License as published by the</span>
<span class="comment"> * Free Software Foundation; either version 2.1 of the License, or (at your</span>
<span class="comment"> * option) any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This library is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License</span>
<span class="comment"> * for more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU Lesser General Public License</span>
<span class="comment"> * along with this library; if not, write to the Free Software Foundation,</span>
<span class="comment"> * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="comment"> */</span>

<span class="preproc">#ifndef</span><span class="normal"> _STX_BTREE_H_</span>
<span class="preproc">#define</span><span class="normal"> _STX_BTREE_H_</span>

<span class="comment">// *** Required Headers from the STL</span>

<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;algorithm&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;functional&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;istream&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;ostream&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;assert.h&gt;</span>

<span class="comment">// *** Debugging Macros</span>

<span class="preproc">#ifdef</span><span class="normal"> BTREE_DEBUG</span>

<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;iostream&gt;</span>

<span class="comment">/// Print out debug information to std::cout if BTREE_DE</span><span class="todo">BUG</span><span class="comment"> is defined.</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">		</span><span class="keyword">do</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> x</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">while</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>

<span class="comment">/// Assertion only if BTREE_DE</span><span class="todo">BUG</span><span class="comment"> is defined. This is not used in verify().</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">		</span><span class="keyword">do</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">while</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>

<span class="preproc">#else</span>

<span class="comment">/// Print out debug information to std::cout if BTREE_DE</span><span class="todo">BUG</span><span class="comment"> is defined.</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">		</span><span class="keyword">do</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">while</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>

<span class="comment">/// Assertion only if BTREE_DE</span><span class="todo">BUG</span><span class="comment"> is defined. This is not used in verify().</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">		</span><span class="keyword">do</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">while</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>

<span class="preproc">#endif</span>

<span class="comment">/// The maximum of a and b. Used in some compile-time formulas.</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">BTREE_MAX</span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">,</span><span class="normal">b</span><span class="symbol">)</span><span class="normal">		</span><span class="symbol">((</span><span class="normal">a</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">))</span>

<span class="preproc">#ifndef</span><span class="normal"> BTREE_FRIENDS</span>
<span class="comment">/// The macro BTREE_FRIENDS can be used by outside class to access the B+</span>
<span class="comment">/// tree internals. This was added for wxBTreeDemo to be able to draw the</span>
<span class="comment">/// tree.</span>
<span class="preproc">#define</span><span class="normal"> BTREE_FRIENDS		</span><span class="keyword">friend</span><span class="normal"> </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">btree_friend</span><span class="symbol">;</span>
<span class="preproc">#endif</span>

<span class="comment">/// STX - Some Template Extensions namespace</span>
<span class="keyword">namespace</span><span class="normal"> stx </span><span class="cbracket">{</span>

<span class="comment">/** Generates default traits for a B+ tree used as a set. It estimates leaf and</span>
<span class="comment"> * inner node sizes by assuming a cache line size of 256 bytes. */</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">_Key</span><span class="symbol">&gt;</span>
<span class="keyword">struct</span><span class="normal"> </span><span class="classname">btree_default_set_traits</span>
<span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/// If true, the tree will self verify it's invariants after each insert()</span>
<span class="normal">    </span><span class="comment">/// or erase(). The header must have been compiled with BTREE_DE</span><span class="todo">BUG</span><span class="comment"> defined.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal">	selfverify </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// If true, the tree will print out debug information and a tree dump</span>
<span class="normal">    </span><span class="comment">/// during insert() or erase() operation. The header must have been</span>
<span class="normal">    </span><span class="comment">/// compiled with BTREE_DE</span><span class="todo">BUG</span><span class="comment"> defined and key_type must be std::ostream</span>
<span class="normal">    </span><span class="comment">/// printable.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal">	debug </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Number of slots in each leaf of the tree. Estimated so that each node</span>
<span class="normal">    </span><span class="comment">/// has a size of about 256 bytes.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">int</span><span class="normal"> 	leafslots </span><span class="symbol">=</span><span class="normal"> </span><span class="function">BTREE_MAX</span><span class="symbol">(</span><span class="normal"> </span><span class="number">8</span><span class="symbol">,</span><span class="normal"> </span><span class="number">256</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">_Key</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/// Number of slots in each inner node of the tree. Estimated so that each node</span>
<span class="normal">    </span><span class="comment">/// has a size of about 256 bytes.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">int</span><span class="normal">	innerslots </span><span class="symbol">=</span><span class="normal"> </span><span class="function">BTREE_MAX</span><span class="symbol">(</span><span class="normal"> </span><span class="number">8</span><span class="symbol">,</span><span class="normal"> </span><span class="number">256</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">_Key</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*))</span><span class="normal"> </span><span class="symbol">);</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">/** Generates default traits for a B+ tree used as a map. It estimates leaf and</span>
<span class="comment"> * inner node sizes by assuming a cache line size of 256 bytes. */</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">_Key</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">_Data</span><span class="symbol">&gt;</span>
<span class="keyword">struct</span><span class="normal"> </span><span class="classname">btree_default_map_traits</span>
<span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/// If true, the tree will self verify it's invariants after each insert()</span>
<span class="normal">    </span><span class="comment">/// or erase(). The header must have been compiled with BTREE_DE</span><span class="todo">BUG</span><span class="comment"> defined.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal">	selfverify </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// If true, the tree will print out debug information and a tree dump</span>
<span class="normal">    </span><span class="comment">/// during insert() or erase() operation. The header must have been</span>
<span class="normal">    </span><span class="comment">/// compiled with BTREE_DE</span><span class="todo">BUG</span><span class="comment"> defined and key_type must be std::ostream</span>
<span class="normal">    </span><span class="comment">/// printable.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal">	debug </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Number of slots in each leaf of the tree. Estimated so that each node</span>
<span class="normal">    </span><span class="comment">/// has a size of about 256 bytes.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">int</span><span class="normal"> 	leafslots </span><span class="symbol">=</span><span class="normal"> </span><span class="function">BTREE_MAX</span><span class="symbol">(</span><span class="normal"> </span><span class="number">8</span><span class="symbol">,</span><span class="normal"> </span><span class="number">256</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">_Key</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">_Data</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/// Number of slots in each inner node of the tree. Estimated so that each node</span>
<span class="normal">    </span><span class="comment">/// has a size of about 256 bytes.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">int</span><span class="normal">	innerslots </span><span class="symbol">=</span><span class="normal"> </span><span class="function">BTREE_MAX</span><span class="symbol">(</span><span class="normal"> </span><span class="number">8</span><span class="symbol">,</span><span class="normal"> </span><span class="number">256</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">_Key</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*))</span><span class="normal"> </span><span class="symbol">);</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">/** </span><span class="type">@brief</span><span class="comment"> Basic class implementing a base B+ tree data structure in memory.</span>
<span class="comment"> *</span>
<span class="comment"> * The base implementation of a memory B+ tree. It is based on the</span>
<span class="comment"> * implementation in Cormen's Introduction into Algorithms, Jan Jannink's paper</span>
<span class="comment"> * and other algorithm resources. Almost all STL-required function calls are</span>
<span class="comment"> * implemented. The asymptotic time requirements of the STL are not always</span>
<span class="comment"> * fulfilled in theory, however in practice this B+ tree performs better than a</span>
<span class="comment"> * red-black tree by using more memory. The insertion function splits the nodes</span>
<span class="comment"> * on the recursion unroll. Erase is largely based on Jannink's ideas.</span>
<span class="comment"> *</span>
<span class="comment"> * This class is specialized into btree_set, btree_multiset, btree_map and</span>
<span class="comment"> * btree_multimap using default template parameters and facade functions.</span>
<span class="comment"> */</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">_Key</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">_Data</span><span class="symbol">,</span>
<span class="normal">	  </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">_Value</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">pair</span><span class="symbol">&lt;</span><span class="normal">_Key</span><span class="symbol">,</span><span class="normal"> _Data</span><span class="symbol">&gt;,</span>
<span class="normal">	  </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">_Compare</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">less</span><span class="symbol">&lt;</span><span class="normal">_Key</span><span class="symbol">&gt;,</span>
<span class="normal">	  </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">_Traits</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> btree_default_map_traits</span><span class="symbol">&lt;</span><span class="normal">_Key</span><span class="symbol">,</span><span class="normal"> _Data</span><span class="symbol">&gt;,</span>
<span class="normal">	  </span><span class="type">bool</span><span class="normal"> _Duplicates </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">&gt;</span>
<span class="keyword">class</span><span class="normal"> </span><span class="classname">btree</span>
<span class="cbracket">{</span>
<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Template Parameter Types</span>

<span class="normal">    </span><span class="comment">/// First template parameter: The key type of the B+ tree. This is stored</span>
<span class="normal">    </span><span class="comment">/// in inner nodes and leaves</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">_Key</span><span class="normal">			key_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Second template parameter: The data type associated with each</span>
<span class="normal">    </span><span class="comment">/// key. Stored in the B+ tree's leaves</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">_Data</span><span class="normal">			data_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Third template parameter: Composition pair of key and data types, this</span>
<span class="normal">    </span><span class="comment">/// is required by the STL standard. The B+ tree does not store key and</span>
<span class="normal">    </span><span class="comment">/// data together. If value_type == key_type then the B+ tree implements a</span>
<span class="normal">    </span><span class="comment">/// set.</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">_Value</span><span class="normal">			value_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Fourth template parameter: Key comparison function object</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">_Compare</span><span class="normal">			key_compare</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Fifth template parameter: Traits object used to define more parameters</span>
<span class="normal">    </span><span class="comment">/// of the B+ tree</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">_Traits</span><span class="normal">			traits</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Sixth template parameter: Allow duplicate keys in the B+ tree. Used to</span>
<span class="normal">    </span><span class="comment">/// implement multiset and multimap.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal">			allow_duplicates </span><span class="symbol">=</span><span class="normal"> _Duplicates</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// The macro BTREE_FRIENDS can be used by outside class to access the B+</span>
<span class="normal">    </span><span class="comment">// tree internals. This was added for wxBTreeDemo to be able to draw the</span>
<span class="normal">    </span><span class="comment">// tree.</span>
<span class="normal">    BTREE_FRIENDS</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Constructed Types</span>

<span class="normal">    </span><span class="comment">/// Typedef of our own type</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> btree</span><span class="symbol">&lt;</span><span class="normal">key_type</span><span class="symbol">,</span><span class="normal"> data_type</span><span class="symbol">,</span><span class="normal"> value_type</span><span class="symbol">,</span>
<span class="normal">		  key_compare</span><span class="symbol">,</span><span class="normal"> traits</span><span class="symbol">,</span><span class="normal"> allow_duplicates</span><span class="symbol">&gt;</span><span class="normal">	btree_self</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Size type used to count keys</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal">				size_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// The pair of key_type and data_type, this may be different from value_type.</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">pair&lt;key_type, data_type&gt;</span><span class="normal">	pair_type</span><span class="symbol">;</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Static Constant Options and Values of the B+ Tree</span>

<span class="normal">    </span><span class="comment">/// Base B+ tree parameter: The number of key/data slots in each leaf</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">		leafslotmax </span><span class="symbol">=</span><span class="normal">  traits</span><span class="symbol">::</span><span class="normal">leafslots</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Base B+ tree parameter: The number of key slots in each inner node,</span>
<span class="normal">    </span><span class="comment">/// this can differ from slots in each leaf.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">		innerslotmax </span><span class="symbol">=</span><span class="normal">  traits</span><span class="symbol">::</span><span class="normal">innerslots</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Computed B+ tree parameter: The minimum number of key/data slots used</span>
<span class="normal">    </span><span class="comment">/// in a leaf. If fewer slots are used, the leaf will be merged or slots</span>
<span class="normal">    </span><span class="comment">/// shifted from it's siblings.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> 	minleafslots </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leafslotmax </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/// Computed B+ tree parameter: The minimum number of key slots used</span>
<span class="normal">    </span><span class="comment">/// in an inner node. If fewer slots are used, the inner node will be</span>
<span class="normal">    </span><span class="comment">/// merged or slots shifted from it's siblings.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> 	mininnerslots </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">innerslotmax </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/// Debug parameter: Enables expensive and thorough checking of the B+ tree</span>
<span class="normal">    </span><span class="comment">/// invariants after each insert/erase operation.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> 			selfverify </span><span class="symbol">=</span><span class="normal"> traits</span><span class="symbol">::</span><span class="normal">selfverify</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Debug parameter: Prints out lots of debug information about how the</span>
<span class="normal">    </span><span class="comment">/// algorithms change the tree. Requires the header file to be compiled</span>
<span class="normal">    </span><span class="comment">/// with BTREE_DE</span><span class="todo">BUG</span><span class="comment"> and the key type must be std::ostream printable.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> 			debug </span><span class="symbol">=</span><span class="normal"> traits</span><span class="symbol">::</span><span class="normal">debug</span><span class="symbol">;</span>

<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Node Classes for In-Memory Nodes</span>

<span class="normal">    </span><span class="comment">/// The header structure of each node in-memory. This structure is extended</span>
<span class="normal">    </span><span class="comment">/// by inner_node or leaf_node.</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">node</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="comment">/// Level in the b-tree, if level == 0 -&gt; leaf node</span>
<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">	level</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Number of key slotuse use, so number of valid children or data</span>
<span class="normal">	</span><span class="comment">/// pointers</span>
<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> 	slotuse</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Delayed initialisation of constructed node</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">initialize</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> l</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    level </span><span class="symbol">=</span><span class="normal"> l</span><span class="symbol">;</span>
<span class="normal">	    slotuse </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span>
<span class="normal">	</span><span class="comment">/// True if this is a leaf node</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">isleafnode</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Extended structure of a inner node in-memory. Contains only keys and no</span>
<span class="normal">    </span><span class="comment">/// data items.</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">inner_node</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">public</span><span class="normal"> node</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="comment">/// Keys of children or data pointers</span>
<span class="normal">	</span><span class="usertype">key_type</span><span class="normal">	slotkey</span><span class="symbol">[</span><span class="normal">innerslotmax</span><span class="symbol">];</span>

<span class="normal">	</span><span class="comment">/// Pointers to children</span>
<span class="normal">	node</span><span class="symbol">*</span><span class="normal">		childid</span><span class="symbol">[</span><span class="normal">innerslotmax</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">];</span>

<span class="normal">	</span><span class="comment">/// Set variables to initial values</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">initialize</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> l</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    node</span><span class="symbol">::</span><span class="function">initialize</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// True if the node's slots are full</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">isfull</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">node</span><span class="symbol">::</span><span class="normal">slotuse </span><span class="symbol">==</span><span class="normal"> innerslotmax</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// True if few used entries, less than half full</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">isfew</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">node</span><span class="symbol">::</span><span class="normal">slotuse </span><span class="symbol">&lt;=</span><span class="normal"> mininnerslots</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// True if node has too few entries</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">isunderflow</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">node</span><span class="symbol">::</span><span class="normal">slotuse </span><span class="symbol">&lt;</span><span class="normal"> mininnerslots</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Extended structure of a leaf node in memory. Contains pairs of keys and</span>
<span class="normal">    </span><span class="comment">/// data items. Key and data slots are kept in separate arrays, because the</span>
<span class="normal">    </span><span class="comment">/// key array is traversed very often compared to accessing the data items.</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">leaf_node</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">public</span><span class="normal"> node</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="comment">/// Double linked list pointers to traverse the leaves</span>
<span class="normal">	</span><span class="usertype">leaf_node</span><span class="normal">	</span><span class="symbol">*</span><span class="normal">prevleaf</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Double linked list pointers to traverse the leaves</span>
<span class="normal">	</span><span class="usertype">leaf_node</span><span class="normal">	</span><span class="symbol">*</span><span class="normal">nextleaf</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Keys of children or data pointers</span>
<span class="normal">	</span><span class="usertype">key_type</span><span class="normal">	slotkey</span><span class="symbol">[</span><span class="normal">leafslotmax</span><span class="symbol">];</span>

<span class="normal">	</span><span class="comment">/// Array of data</span>
<span class="normal">	</span><span class="usertype">data_type</span><span class="normal">	slotdata</span><span class="symbol">[</span><span class="normal">leafslotmax</span><span class="symbol">];</span>

<span class="normal">	</span><span class="comment">/// Set variables to initial values</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">initialize</span><span class="symbol">()</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    node</span><span class="symbol">::</span><span class="function">initialize</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">	    prevleaf </span><span class="symbol">=</span><span class="normal"> nextleaf </span><span class="symbol">=</span><span class="normal"> NULL</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// True if the node's slots are full</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">isfull</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">node</span><span class="symbol">::</span><span class="normal">slotuse </span><span class="symbol">==</span><span class="normal"> leafslotmax</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// True if few used entries, less than half full</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">isfew</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">node</span><span class="symbol">::</span><span class="normal">slotuse </span><span class="symbol">&lt;=</span><span class="normal"> minleafslots</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// True if node has too few entries</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">isunderflow</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">node</span><span class="symbol">::</span><span class="normal">slotuse </span><span class="symbol">&lt;</span><span class="normal"> minleafslots</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Template Magic to Convert a pair or key/data types to a value_type</span>

<span class="normal">    </span><span class="comment">/// \internal For sets the second pair_type is an empty struct, so the</span>
<span class="normal">    </span><span class="comment">/// value_type should only be the first.</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">value_type</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">pair_type</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">btree_pair_to_value</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="comment">/// Convert a fake pair type to just the first component</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">value_type</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="normal">pair_type</span><span class="symbol">&amp;</span><span class="normal"> p</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> p</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="comment">/// Convert a fake pair type to just the first component</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">value_type</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="keyword">const</span><span class="normal"> pair_type</span><span class="symbol">&amp;</span><span class="normal"> p</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> p</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// \internal For maps value_type is the same as the pair_type</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">value_type</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">btree_pair_to_value</span><span class="symbol">&lt;</span><span class="normal">value_type</span><span class="symbol">,</span><span class="normal"> value_type</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="comment">/// Identity "convert" a real pair type to just the first component</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">value_type</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="normal">pair_type</span><span class="symbol">&amp;</span><span class="normal"> p</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> p</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="comment">/// Identity "convert" a real pair type to just the first component</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">value_type</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="keyword">const</span><span class="normal"> pair_type</span><span class="symbol">&amp;</span><span class="normal"> p</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> p</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Using template specialization select the correct converter used by the</span>
<span class="normal">    </span><span class="comment">/// iterators</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">btree_pair_to_value&lt;value_type, pair_type&gt;</span><span class="normal"> pair_to_value_type</span><span class="symbol">;</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Iterators and Reverse Iterators</span>

<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">iterator</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">const_iterator</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// STL-like iterator object for B+ tree items. The iterator points to a</span>
<span class="normal">    </span><span class="comment">/// specific slot number in a leaf.</span>
<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">iterator</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">	</span><span class="comment">// *** Types</span>

<span class="normal">	</span><span class="comment">/// The key type of the btree. Returned by key().</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="usertype">key_type</span><span class="normal">		key_type</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// The data type of the btree. Returned by data().</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="usertype">data_type</span><span class="normal">		data_type</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// The value type of the btree. Returned by operator*().</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="usertype">value_type</span><span class="normal">		value_type</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// The pair type of the btree.</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="usertype">pair_type</span><span class="normal">		pair_type</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Reference to the value_type. Required by the reverse_iterator.</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal">		reference</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Pointer to the value_type. Required by the reverse_iterator.</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> value_type</span><span class="symbol">*</span><span class="normal">		pointer</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// STL-magic iterator category</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">bidirectional_iterator_tag</span><span class="normal"> iterator_category</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// STL-magic</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">ptrdiff_t</span><span class="normal">               difference_type</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Our own type</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">iterator</span><span class="normal">		self</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">	</span><span class="comment">// *** Members</span>

<span class="normal">	</span><span class="comment">/// The currently referenced leaf node of the tree</span>
<span class="normal">	</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="normal">leaf_node</span><span class="symbol">*</span><span class="normal">	currnode</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Current key/data slot referenced</span>
<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">	currslot</span><span class="symbol">;</span>
<span class="normal">    </span>
<span class="normal">	</span><span class="comment">/// Friendly to the const_iterator, so it may access the two data items directly</span>
<span class="normal">	</span><span class="keyword">friend</span><span class="normal"> </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">&lt;</span><span class="normal">key_type</span><span class="symbol">,</span><span class="normal"> data_type</span><span class="symbol">,</span><span class="normal"> value_type</span><span class="symbol">,</span><span class="normal"> key_compare</span><span class="symbol">,</span><span class="normal"> traits</span><span class="symbol">,</span><span class="normal"> allow_duplicates</span><span class="symbol">&gt;::</span><span class="normal">const_iterator</span><span class="symbol">;</span>
<span class="normal">	</span>
<span class="normal">	</span><span class="comment">/// Evil! A temporary value_type to STL-correctly deliver operator* and</span>
<span class="normal">	</span><span class="comment">/// operator-&gt;</span>
<span class="normal">	</span><span class="keyword">mutable</span><span class="normal"> </span><span class="usertype">value_type</span><span class="normal">		temp_value</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">// The macro BTREE_FRIENDS can be used by outside class to access the B+</span>
<span class="normal">	</span><span class="comment">// tree internals. This was added for wxBTreeDemo to be able to draw the</span>
<span class="normal">	</span><span class="comment">// tree.</span>
<span class="normal">	BTREE_FRIENDS</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">	</span><span class="comment">// *** Methods</span>

<span class="normal">	</span><span class="comment">/// Constructor of a mutable iterator</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="function">iterator</span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">l</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> s</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="symbol">:</span><span class="normal"> </span><span class="function">currnode</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">),</span><span class="normal"> </span><span class="function">currslot</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Dereference the iterator, this is not a value_type&amp; because key and</span>
<span class="normal">	</span><span class="comment">/// value are not stored together</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">reference</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">*()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    temp_value </span><span class="symbol">=</span><span class="normal"> </span><span class="function">pair_to_value_type</span><span class="symbol">()(</span><span class="normal"> </span><span class="function">pair_type</span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">],</span>
<span class="normal">							 currnode</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> temp_value</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Dereference the iterator. Do not use this if possible, use key()</span>
<span class="normal">	</span><span class="comment">/// and data() instead. The B+ tree does not stored key and data</span>
<span class="normal">	</span><span class="comment">/// together.</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">pointer</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">-&gt;()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    temp_value </span><span class="symbol">=</span><span class="normal"> </span><span class="function">pair_to_value_type</span><span class="symbol">()(</span><span class="normal"> </span><span class="function">pair_type</span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">],</span>
<span class="normal">							 currnode</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">temp_value</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Key of the current slot</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">key</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Writable reference to the current data object</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> data_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">data</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Prefix++ advance the iterator to the next slot</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> self</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++()</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currslot </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="symbol">++</span><span class="normal">currslot</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">!=</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		currnode </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">;</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// this is end()</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Postfix++ advance the iterator to the next slot</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">self</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++(</span><span class="type">int</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">self</span><span class="normal"> tmp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">// copy ourselves</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currslot </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="symbol">++</span><span class="normal">currslot</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">!=</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		currnode </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">;</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// this is end()</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> tmp</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Prefix-- backstep the iterator to the last slot</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> self</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">--()</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currslot </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="symbol">--</span><span class="normal">currslot</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">!=</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		currnode </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">prevleaf</span><span class="symbol">;</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// this is begin()</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Postfix-- backstep the iterator to the last slot</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">self</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">--(</span><span class="type">int</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">self</span><span class="normal"> tmp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">// copy ourselves</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currslot </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="symbol">--</span><span class="normal">currslot</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">!=</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		currnode </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">prevleaf</span><span class="symbol">;</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// this is begin()</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> tmp</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Equality of iterators</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">==(</span><span class="keyword">const</span><span class="normal"> self</span><span class="symbol">&amp;</span><span class="normal"> x</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">currnode </span><span class="symbol">==</span><span class="normal"> currnode</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">currslot </span><span class="symbol">==</span><span class="normal"> currslot</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Inequality of iterators</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">!=(</span><span class="keyword">const</span><span class="normal"> self</span><span class="symbol">&amp;</span><span class="normal"> x</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">currnode </span><span class="symbol">!=</span><span class="normal"> currnode</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">currslot </span><span class="symbol">!=</span><span class="normal"> currslot</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span><span class="normal">    </span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// STL-like read-only iterator object for B+ tree items. The iterator</span>
<span class="normal">    </span><span class="comment">/// points to a specific slot number in a leaf.</span>
<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">const_iterator</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">	</span><span class="comment">// *** Types</span>

<span class="normal">	</span><span class="comment">/// The key type of the btree. Returned by key().</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="usertype">key_type</span><span class="normal">		key_type</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// The data type of the btree. Returned by data().</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="usertype">data_type</span><span class="normal">		data_type</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// The value type of the btree. Returned by operator*().</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="usertype">value_type</span><span class="normal">		value_type</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// The pair type of the btree.</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="usertype">pair_type</span><span class="normal">		pair_type</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Reference to the value_type. Required by the reverse_iterator.</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal">	reference</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Pointer to the value_type. Required by the reverse_iterator.</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">*</span><span class="normal">	pointer</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// STL-magic iterator category</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">bidirectional_iterator_tag</span><span class="normal"> iterator_category</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// STL-magic</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">ptrdiff_t</span><span class="normal">         	difference_type</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Our own type</span>
<span class="normal">	</span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">const_iterator</span><span class="normal">		self</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">	</span><span class="comment">// *** Members</span>

<span class="normal">	</span><span class="comment">/// The currently referenced leaf node of the tree</span>
<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="normal">leaf_node</span><span class="symbol">*</span><span class="normal">	currnode</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Current key/data slot referenced</span>
<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">	currslot</span><span class="symbol">;</span>
<span class="normal">    </span>
<span class="normal">	</span><span class="comment">/// Evil! A temporary value_type to STL-correctly deliver operator* and</span>
<span class="normal">	</span><span class="comment">/// operator-&gt;</span>
<span class="normal">	</span><span class="keyword">mutable</span><span class="normal"> </span><span class="usertype">value_type</span><span class="normal">		temp_value</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">// The macro BTREE_FRIENDS can be used by outside class to access the B+</span>
<span class="normal">	</span><span class="comment">// tree internals. This was added for wxBTreeDemo to be able to draw the</span>
<span class="normal">	</span><span class="comment">// tree.</span>
<span class="normal">	BTREE_FRIENDS</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">	</span><span class="comment">// *** Methods</span>

<span class="normal">	</span><span class="comment">/// Constructor of a const iterator</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="function">const_iterator</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">::</span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">l</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> s</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="symbol">:</span><span class="normal"> </span><span class="function">currnode</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">),</span><span class="normal"> </span><span class="function">currslot</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Copy-constructor from a mutable const iterator</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="function">const_iterator</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">iterator</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">it</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="symbol">:</span><span class="normal"> </span><span class="function">currnode</span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">.</span><span class="normal">currnode</span><span class="symbol">),</span><span class="normal"> </span><span class="function">currslot</span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">.</span><span class="normal">currslot</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Dereference the iterator. Do not use this if possible, use key()</span>
<span class="normal">	</span><span class="comment">/// and data() instead. The B+ tree does not stored key and data</span>
<span class="normal">	</span><span class="comment">/// together.</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">reference</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">*()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    temp_value </span><span class="symbol">=</span><span class="normal"> </span><span class="function">pair_to_value_type</span><span class="symbol">()(</span><span class="normal"> </span><span class="function">pair_type</span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">],</span>
<span class="normal">							 currnode</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> temp_value</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Dereference the iterator. Do not use this if possible, use key()</span>
<span class="normal">	</span><span class="comment">/// and data() instead. The B+ tree does not stored key and data</span>
<span class="normal">	</span><span class="comment">/// together.</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">pointer</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">-&gt;()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    temp_value </span><span class="symbol">=</span><span class="normal"> </span><span class="function">pair_to_value_type</span><span class="symbol">()(</span><span class="normal"> </span><span class="function">pair_type</span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">],</span>
<span class="normal">							 currnode</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">temp_value</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Key of the current slot</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">key</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Read-only reference to the current data object</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> data_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">data</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">currslot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Prefix++ advance the iterator to the next slot</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> self</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++()</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currslot </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="symbol">++</span><span class="normal">currslot</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">!=</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		currnode </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">;</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// this is end()</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Postfix++ advance the iterator to the next slot</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">self</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++(</span><span class="type">int</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">self</span><span class="normal"> tmp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">// copy ourselves</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currslot </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="symbol">++</span><span class="normal">currslot</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">!=</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		currnode </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">;</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// this is end()</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> tmp</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Prefix-- backstep the iterator to the last slot</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> self</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">--()</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currslot </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="symbol">--</span><span class="normal">currslot</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">!=</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		currnode </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">prevleaf</span><span class="symbol">;</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// this is begin()</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Postfix-- backstep the iterator to the last slot</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">self</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">--(</span><span class="type">int</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">self</span><span class="normal"> tmp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">// copy ourselves</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currslot </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="symbol">--</span><span class="normal">currslot</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">currnode</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">!=</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		currnode </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">prevleaf</span><span class="symbol">;</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> currnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// this is begin()</span>
<span class="normal">		currslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> tmp</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Equality of iterators</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">==(</span><span class="keyword">const</span><span class="normal"> self</span><span class="symbol">&amp;</span><span class="normal"> x</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">currnode </span><span class="symbol">==</span><span class="normal"> currnode</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">currslot </span><span class="symbol">==</span><span class="normal"> currslot</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Inequality of iterators</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">!=(</span><span class="keyword">const</span><span class="normal"> self</span><span class="symbol">&amp;</span><span class="normal"> x</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">currnode </span><span class="symbol">!=</span><span class="normal"> currnode</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">currslot </span><span class="symbol">!=</span><span class="normal"> currslot</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span><span class="normal">    </span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// create mutable reverse iterator by using STL magic</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">reverse_iterator&lt;iterator&gt;</span><span class="normal">       reverse_iterator</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// create constant reverse iterator by using STL magic</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">reverse_iterator&lt;const_iterator&gt;</span><span class="normal"> const_reverse_iterator</span><span class="symbol">;</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Small Statistics Structure</span>

<span class="normal">    </span><span class="comment">/** A small struct containing basic statistics about the B+ tree. It can be</span>
<span class="comment">     * fetched using get_stats(). */</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">tree_stats</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="comment">/// Number of items in the B+ tree</span>
<span class="normal">	</span><span class="usertype">size_type</span><span class="normal">	itemcount</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Number of leaves in the B+ tree</span>
<span class="normal">	</span><span class="usertype">size_type</span><span class="normal">	leaves</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Number of inner nodes in the B+ tree</span>
<span class="normal">	</span><span class="usertype">size_type</span><span class="normal">	innernodes</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Base B+ tree parameter: The number of key/data slots in each leaf</span>
<span class="normal">	</span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">	leafslots </span><span class="symbol">=</span><span class="normal"> btree_self</span><span class="symbol">::</span><span class="normal">leafslotmax</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Base B+ tree parameter: The number of key slots in each inner node.</span>
<span class="normal">	</span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">	innerslots </span><span class="symbol">=</span><span class="normal"> btree_self</span><span class="symbol">::</span><span class="normal">innerslotmax</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Zero initialized</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="function">tree_stats</span><span class="symbol">()</span>
<span class="normal">	    </span><span class="symbol">:</span><span class="normal"> </span><span class="function">itemcount</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">),</span>
<span class="normal">	      </span><span class="function">leaves</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">),</span><span class="normal"> </span><span class="function">innernodes</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Return the total number of nodes</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">size_type</span><span class="normal"> </span><span class="function">nodes</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> innernodes </span><span class="symbol">+</span><span class="normal"> leaves</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Return the average fill of leaves</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">double</span><span class="normal"> </span><span class="function">avgfill_leaves</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="type">double</span><span class="symbol">&gt;(</span><span class="normal">itemcount</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leaves </span><span class="symbol">*</span><span class="normal"> leafslots</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Tree Object Data Members</span>

<span class="normal">    </span><span class="comment">/// Pointer to the B+ tree's root node, either leaf or inner node</span>
<span class="normal">    node</span><span class="symbol">*</span><span class="normal">	root</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Pointer to first leaf in the double linked leaf chain</span>
<span class="normal">    </span><span class="usertype">leaf_node</span><span class="normal">	</span><span class="symbol">*</span><span class="normal">headleaf</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Pointer to last leaf in the double linked leaf chain</span>
<span class="normal">    </span><span class="usertype">leaf_node</span><span class="normal">	</span><span class="symbol">*</span><span class="normal">tailleaf</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Other small statistics about the B+ tree</span>
<span class="normal">    </span><span class="usertype">tree_stats</span><span class="normal">	stats</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Key comparison object. More comparison functions are generated from</span>
<span class="normal">    </span><span class="comment">/// this &lt; relation.</span>
<span class="normal">    </span><span class="usertype">key_compare</span><span class="normal">	key_less</span><span class="symbol">;</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Constructors and Destructor</span>

<span class="normal">    </span><span class="comment">/// Default constructor initializing an empty B+ tree with the standard key</span>
<span class="normal">    </span><span class="comment">/// comparison function</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="function">btree</span><span class="symbol">()</span>
<span class="normal">	</span><span class="symbol">:</span><span class="normal"> </span><span class="function">root</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span><span class="normal"> </span><span class="function">headleaf</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span><span class="normal"> </span><span class="function">tailleaf</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Constructor initializing an empty B+ tree with a special key</span>
<span class="normal">    </span><span class="comment">/// comparison object</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="function">btree</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_compare</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">kcf</span><span class="symbol">)</span>
<span class="normal">	</span><span class="symbol">:</span><span class="normal"> </span><span class="function">root</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span><span class="normal"> </span><span class="function">headleaf</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span><span class="normal"> </span><span class="function">tailleaf</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span>
<span class="normal">	  </span><span class="function">key_less</span><span class="symbol">(</span><span class="normal">kcf</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Constructor initializing a B+ tree with the range [first,last)</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">InputIterator</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="function">btree</span><span class="symbol">(</span><span class="usertype">InputIterator</span><span class="normal"> first</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">InputIterator</span><span class="normal"> last</span><span class="symbol">)</span>
<span class="normal">	</span><span class="symbol">:</span><span class="normal"> </span><span class="function">root</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span><span class="normal"> </span><span class="function">headleaf</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span><span class="normal"> </span><span class="function">tailleaf</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">first</span><span class="symbol">,</span><span class="normal"> last</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Constructor initializing a B+ tree with the range [first,last) and a</span>
<span class="normal">    </span><span class="comment">/// special key comparison object</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">InputIterator</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="function">btree</span><span class="symbol">(</span><span class="usertype">InputIterator</span><span class="normal"> first</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">InputIterator</span><span class="normal"> last</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_compare</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">kcf</span><span class="symbol">)</span>
<span class="normal">	</span><span class="symbol">:</span><span class="normal"> </span><span class="function">root</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span><span class="normal"> </span><span class="function">headleaf</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span><span class="normal"> </span><span class="function">tailleaf</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span>
<span class="normal">	  </span><span class="function">key_less</span><span class="symbol">(</span><span class="normal">kcf</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">first</span><span class="symbol">,</span><span class="normal"> last</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Frees up all used B+ tree memory pages</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="symbol">~</span><span class="function">btree</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Fast swapping of two identical B+ tree objects.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">swap</span><span class="symbol">(</span><span class="normal">btree_self</span><span class="symbol">&amp;</span><span class="normal"> from</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	std</span><span class="symbol">::</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">root</span><span class="symbol">,</span><span class="normal"> from</span><span class="symbol">.</span><span class="normal">root</span><span class="symbol">);</span>
<span class="normal">	std</span><span class="symbol">::</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">headleaf</span><span class="symbol">,</span><span class="normal"> from</span><span class="symbol">.</span><span class="normal">headleaf</span><span class="symbol">);</span>
<span class="normal">	std</span><span class="symbol">::</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">tailleaf</span><span class="symbol">,</span><span class="normal"> from</span><span class="symbol">.</span><span class="normal">tailleaf</span><span class="symbol">);</span>
<span class="normal">	std</span><span class="symbol">::</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">stats</span><span class="symbol">,</span><span class="normal"> from</span><span class="symbol">.</span><span class="normal">stats</span><span class="symbol">);</span>
<span class="normal">	std</span><span class="symbol">::</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">key_less</span><span class="symbol">,</span><span class="normal"> from</span><span class="symbol">.</span><span class="normal">key_less</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Key and Value Comparison Function Objects</span>

<span class="normal">    </span><span class="comment">/// Function class to compare value_type objects. Required by the STL</span>
<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">value_compare</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">	</span><span class="comment">/// Key comparison function from the template parameter</span>
<span class="normal">	</span><span class="usertype">key_compare</span><span class="normal">	key_comp</span><span class="symbol">;</span>
<span class="normal"> </span>
<span class="normal">	</span><span class="comment">/// Constructor called from btree::value_comp()</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="function">value_compare</span><span class="symbol">(</span><span class="usertype">key_compare</span><span class="normal"> kc</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="symbol">:</span><span class="normal"> </span><span class="function">key_comp</span><span class="symbol">(</span><span class="normal">kc</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Friendly to the btree class so it may call the constructor</span>
<span class="normal">	</span><span class="keyword">friend</span><span class="normal"> </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">btree</span><span class="symbol">&lt;</span><span class="normal">key_type</span><span class="symbol">,</span><span class="normal"> data_type</span><span class="symbol">,</span><span class="normal"> value_type</span><span class="symbol">,</span><span class="normal"> key_compare</span><span class="symbol">,</span><span class="normal"> traits</span><span class="symbol">,</span><span class="normal"> allow_duplicates</span><span class="symbol">&gt;;</span>
<span class="normal"> </span>
<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">	</span><span class="comment">/// Function call "less"-operator resulting in true if x &lt; y.</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal"> x</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal"> y</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="function">key_comp</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">,</span><span class="normal"> y</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Constant access to the key comparison object sorting the B+ tree</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">key_compare</span><span class="normal"> </span><span class="function">key_comp</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> key_less</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Constant access to a constructed value_type comparison object. Required</span>
<span class="normal">    </span><span class="comment">/// by the STL</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">value_compare</span><span class="normal"> </span><span class="function">value_comp</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">value_compare</span><span class="symbol">(</span><span class="normal">key_less</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Convenient Key Comparison Functions Generated From key_less</span>

<span class="normal">    </span><span class="comment">/// True if a &lt;= b ? constructed from key_less()</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">key_lessequal</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">!</span><span class="function">key_less</span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">,</span><span class="normal"> a</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// True if a &gt; b ? constructed from key_less()</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">key_greater</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">key_less</span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">,</span><span class="normal"> a</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// True if a &gt;= b ? constructed from key_less()</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">key_greaterequal</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">!</span><span class="function">key_less</span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// True if a == b ? constructed from key_less(). This requires the &lt;</span>
<span class="normal">    </span><span class="comment">/// relation to be a total order, otherwise the B+ tree cannot be sorted.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">key_equal</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">!</span><span class="function">key_less</span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">key_less</span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">,</span><span class="normal"> a</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Node Object Allocation and Deallocation Functions</span>

<span class="normal">    </span><span class="comment">/// Allocate and initialize a leaf node</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> leaf_node</span><span class="symbol">*</span><span class="normal"> </span><span class="function">allocate_leaf</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	leaf_node</span><span class="symbol">*</span><span class="normal"> n </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> leaf_node</span><span class="symbol">;</span>
<span class="normal">	n</span><span class="symbol">-&gt;</span><span class="function">initialize</span><span class="symbol">();</span>
<span class="normal">	stats</span><span class="symbol">.</span><span class="normal">leaves</span><span class="symbol">++;</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> n</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Allocate and initialize an inner node</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> inner_node</span><span class="symbol">*</span><span class="normal"> </span><span class="function">allocate_inner</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> l</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	inner_node</span><span class="symbol">*</span><span class="normal"> n </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> inner_node</span><span class="symbol">;</span>
<span class="normal">	n</span><span class="symbol">-&gt;</span><span class="function">initialize</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">);</span>
<span class="normal">	stats</span><span class="symbol">.</span><span class="normal">innernodes</span><span class="symbol">++;</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> n</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span>
<span class="normal">    </span><span class="comment">/// Correctly free either inner or leaf node, destructs all contained key</span>
<span class="normal">    </span><span class="comment">/// and value objects</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">free_node</span><span class="symbol">(</span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">delete</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    stats</span><span class="symbol">.</span><span class="normal">leaves</span><span class="symbol">--;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">delete</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    stats</span><span class="symbol">.</span><span class="normal">innernodes</span><span class="symbol">--;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Fast Destruction of the B+ Tree</span>

<span class="normal">    </span><span class="comment">/// Frees all key/data pairs and all nodes of the tree</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">clear</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">root</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="function">clear_recursive</span><span class="symbol">(</span><span class="normal">root</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">free_node</span><span class="symbol">(</span><span class="normal">root</span><span class="symbol">);</span>

<span class="normal">	    root </span><span class="symbol">=</span><span class="normal"> NULL</span><span class="symbol">;</span>
<span class="normal">	    headleaf </span><span class="symbol">=</span><span class="normal"> tailleaf </span><span class="symbol">=</span><span class="normal"> NULL</span><span class="symbol">;</span>

<span class="normal">	    stats </span><span class="symbol">=</span><span class="normal"> </span><span class="function">tree_stats</span><span class="symbol">();</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">stats</span><span class="symbol">.</span><span class="normal">itemcount </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">/// Recursively free up nodes</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">clear_recursive</span><span class="symbol">(</span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leafnode </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> leafnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// data objects are deleted by leaf_node's destructor</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">innernode </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> innernode</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="function">clear_recursive</span><span class="symbol">(</span><span class="normal">innernode</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]);</span>
<span class="normal">		</span><span class="function">free_node</span><span class="symbol">(</span><span class="normal">innernode</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]);</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** STL Iterator Construction Functions</span>

<span class="normal">    </span><span class="comment">/// Constructs a read/data-write iterator that points to the first slot in</span>
<span class="normal">    </span><span class="comment">/// the first leaf of the B+ tree.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">iterator</span><span class="normal"> </span><span class="function">begin</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">iterator</span><span class="symbol">(</span><span class="normal">headleaf</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Constructs a read/data-write iterator that points to the first invalid</span>
<span class="normal">    </span><span class="comment">/// slot in the last leaf of the B+ tree.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">iterator</span><span class="normal"> </span><span class="function">end</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">iterator</span><span class="symbol">(</span><span class="normal">tailleaf</span><span class="symbol">,</span><span class="normal"> tailleaf </span><span class="symbol">?</span><span class="normal"> tailleaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Constructs a read-only constant iterator that points to the first slot</span>
<span class="normal">    </span><span class="comment">/// in the first leaf of the B+ tree.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">const_iterator</span><span class="normal"> </span><span class="function">begin</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">const_iterator</span><span class="symbol">(</span><span class="normal">headleaf</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Constructs a read-only constant iterator that points to the first</span>
<span class="normal">    </span><span class="comment">/// invalid slot in the last leaf of the B+ tree.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">const_iterator</span><span class="normal"> </span><span class="function">end</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">const_iterator</span><span class="symbol">(</span><span class="normal">tailleaf</span><span class="symbol">,</span><span class="normal"> tailleaf </span><span class="symbol">?</span><span class="normal"> tailleaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Constructs a read/data-write reverse iterator that points to the first</span>
<span class="normal">    </span><span class="comment">/// invalid slot in the last leaf of the B+ tree. Uses STL magic.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">reverse_iterator</span><span class="normal"> </span><span class="function">rbegin</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">reverse_iterator</span><span class="symbol">(</span><span class="function">end</span><span class="symbol">());</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Constructs a read/data-write reverse iterator that points to the first</span>
<span class="normal">    </span><span class="comment">/// slot in the first leaf of the B+ tree. Uses STL magic.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">reverse_iterator</span><span class="normal"> </span><span class="function">rend</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">reverse_iterator</span><span class="symbol">(</span><span class="function">begin</span><span class="symbol">());</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Constructs a read-only reverse iterator that points to the first</span>
<span class="normal">    </span><span class="comment">/// invalid slot in the last leaf of the B+ tree. Uses STL magic.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">const_reverse_iterator</span><span class="normal"> </span><span class="function">rbegin</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">const_reverse_iterator</span><span class="symbol">(</span><span class="function">end</span><span class="symbol">());</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Constructs a read-only reverse iterator that points to the first slot</span>
<span class="normal">    </span><span class="comment">/// in the first leaf of the B+ tree. Uses STL magic.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">const_reverse_iterator</span><span class="normal"> </span><span class="function">rend</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">const_reverse_iterator</span><span class="symbol">(</span><span class="function">begin</span><span class="symbol">());</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** B+ Tree Node Binary Search Functions</span>

<span class="normal">    </span><span class="comment">/// Searches for the first key in the node n less or equal to key. Uses</span>
<span class="normal">    </span><span class="comment">/// binary search with an optional linear self-verification. This is a</span>
<span class="normal">    </span><span class="comment">/// template function, because the slotkey array is located at different</span>
<span class="normal">    </span><span class="comment">/// places in leaf_node and inner_node.</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">node_type</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">node_type</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">	</span><span class="type">int</span><span class="normal"> lo </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span>
<span class="normal">	    hi </span><span class="symbol">=</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">lo </span><span class="symbol">&lt;</span><span class="normal"> hi</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> mid </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lo </span><span class="symbol">+</span><span class="normal"> hi</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">key_lessequal</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">mid</span><span class="symbol">]))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		hi </span><span class="symbol">=</span><span class="normal"> mid </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		lo </span><span class="symbol">=</span><span class="normal"> mid </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">hi </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">key_less</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">hi</span><span class="symbol">],</span><span class="normal"> key</span><span class="symbol">))</span>
<span class="normal">	    hi</span><span class="symbol">++;</span>

<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::find_lower: on "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> n </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" key "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> key </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" -&gt; ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> lo </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> hi </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">", "</span><span class="symbol">);</span>

<span class="normal">	</span><span class="comment">// verify result using simple linear search</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">key_lessequal</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]))</span>
<span class="normal">		i</span><span class="symbol">--;</span>
<span class="normal">	    i</span><span class="symbol">++;</span>

<span class="normal">	    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"testfind: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">==</span><span class="normal"> hi</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> hi</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Searches for the first key in the node n greater than key. Uses binary</span>
<span class="normal">    </span><span class="comment">/// search with an optional linear self-verification. This is a template</span>
<span class="normal">    </span><span class="comment">/// function, because the slotkey array is located at different places in</span>
<span class="normal">    </span><span class="comment">/// leaf_node and inner_node.</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">node_type</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">find_upper</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">node_type</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">	</span><span class="type">int</span><span class="normal"> lo </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span>
<span class="normal">	    hi </span><span class="symbol">=</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">lo </span><span class="symbol">&lt;</span><span class="normal"> hi</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> mid </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lo </span><span class="symbol">+</span><span class="normal"> hi</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">key_less</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">mid</span><span class="symbol">]))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		hi </span><span class="symbol">=</span><span class="normal"> mid </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		lo </span><span class="symbol">=</span><span class="normal"> mid </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">hi </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">key_lessequal</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">hi</span><span class="symbol">],</span><span class="normal"> key</span><span class="symbol">))</span>
<span class="normal">	    hi</span><span class="symbol">++;</span>

<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::find_upper: on "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> n </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" key "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> key </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" -&gt; ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> lo </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> hi </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">", "</span><span class="symbol">);</span>

<span class="normal">	</span><span class="comment">// verify result using simple linear search</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">key_less</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]))</span>
<span class="normal">		i</span><span class="symbol">--;</span>
<span class="normal">	    i</span><span class="symbol">++;</span>

<span class="normal">	    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::find_upper testfind: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">==</span><span class="normal"> hi</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> hi</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Access Functions to the Item Count</span>

<span class="normal">    </span><span class="comment">/// Return the number of key/data pairs in the B+ tree</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">size_type</span><span class="normal"> </span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> stats</span><span class="symbol">.</span><span class="normal">itemcount</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Returns true if there is at least one key/data pair in the B+ tree</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="function">size_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">));</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span>
<span class="normal">    </span><span class="comment">/// Returns the largest possible size of the B+ Tree. This is just a</span>
<span class="normal">    </span><span class="comment">/// function required by the STL standard, the B+ Tree can hold more items.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">size_type</span><span class="normal"> </span><span class="function">max_size</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">size_type</span><span class="symbol">(-</span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Return a const reference to the current statistics.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">tree_stats</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">get_stats</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> stats</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Standard Access Functions Querying the Tree by Descending to a Leaf</span>

<span class="normal">    </span><span class="comment">/// Non-STL function checking whether a key is in the B+ tree. The same as</span>
<span class="normal">    </span><span class="comment">/// (find(k) != end()) or (count() != 0).</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">exists</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">key</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n </span><span class="symbol">=</span><span class="normal"> root</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    n </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">key_equal</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Tries to locate a key in the B+ tree and returns an iterator to the</span>
<span class="normal">    </span><span class="comment">/// key/data slot if found. If unsuccessful it returns end().</span>
<span class="normal">    </span><span class="usertype">iterator</span><span class="normal"> </span><span class="function">find</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">key</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n </span><span class="symbol">=</span><span class="normal"> root</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="function">end</span><span class="symbol">();</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    n </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">key_equal</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="function">iterator</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> slot</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="function">end</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Tries to locate a key in the B+ tree and returns an constant iterator</span>
<span class="normal">    </span><span class="comment">/// to the key/data slot if found. If unsuccessful it returns end().</span>
<span class="normal">    </span><span class="usertype">const_iterator</span><span class="normal"> </span><span class="function">find</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">key</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n </span><span class="symbol">=</span><span class="normal"> root</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="function">end</span><span class="symbol">();</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    n </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">key_equal</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="function">const_iterator</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> slot</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="function">end</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Tries to locate a key in the B+ tree and returns the number of</span>
<span class="normal">    </span><span class="comment">/// identical key entries found.    </span>
<span class="normal">    </span><span class="usertype">size_type</span><span class="normal"> </span><span class="function">count</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">key</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n </span><span class="symbol">=</span><span class="normal"> root</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    n </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>
<span class="normal">	</span><span class="usertype">size_type</span><span class="normal"> num </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leaf </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">key_equal</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]))</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="symbol">++</span><span class="normal">num</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(++</span><span class="normal">slot </span><span class="symbol">&gt;=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		leaf </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">;</span>
<span class="normal">		slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">return</span><span class="normal"> num</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Searches the B+ tree and returns an iterator to the first key less or</span>
<span class="normal">    </span><span class="comment">/// equal to the parameter. If unsuccessful it returns end().</span>
<span class="normal">    </span><span class="usertype">iterator</span><span class="normal"> </span><span class="function">lower_bound</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n </span><span class="symbol">=</span><span class="normal"> root</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="function">end</span><span class="symbol">();</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    n </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">iterator</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> slot</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Searches the B+ tree and returns an constant iterator to the first key less or</span>
<span class="normal">    </span><span class="comment">/// equal to the parameter. If unsuccessful it returns end().</span>
<span class="normal">    </span><span class="usertype">const_iterator</span><span class="normal"> </span><span class="function">lower_bound</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n </span><span class="symbol">=</span><span class="normal"> root</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="function">end</span><span class="symbol">();</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    n </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">const_iterator</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> slot</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Searches the B+ tree and returns an iterator to the first key greater</span>
<span class="normal">    </span><span class="comment">/// than the parameter. If unsuccessful it returns end().</span>
<span class="normal">    </span><span class="usertype">iterator</span><span class="normal"> </span><span class="function">upper_bound</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n </span><span class="symbol">=</span><span class="normal"> root</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="function">end</span><span class="symbol">();</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_upper</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    n </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_upper</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">iterator</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> slot</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Searches the B+ tree and returns an constant iterator to the first key</span>
<span class="normal">    </span><span class="comment">/// greater than the parameter. If unsuccessful it returns end().</span>
<span class="normal">    </span><span class="usertype">const_iterator</span><span class="normal"> </span><span class="function">upper_bound</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n </span><span class="symbol">=</span><span class="normal"> root</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="function">end</span><span class="symbol">();</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_upper</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    n </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_upper</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">const_iterator</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> slot</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Searches the B+ tree and returns both lower_bound() and upper_bound().</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">pair&lt;iterator, iterator&gt;</span><span class="normal"> </span><span class="function">equal_range</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">pair</span><span class="symbol">&lt;</span><span class="normal">iterator</span><span class="symbol">,</span><span class="normal"> iterator</span><span class="symbol">&gt;(</span><span class="function">lower_bound</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">),</span><span class="normal"> </span><span class="function">upper_bound</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">));</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Searches the B+ tree and returns both lower_bound() and upper_bound().</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">pair&lt;const_iterator, const_iterator&gt;</span><span class="normal"> </span><span class="function">equal_range</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">pair</span><span class="symbol">&lt;</span><span class="normal">const_iterator</span><span class="symbol">,</span><span class="normal"> const_iterator</span><span class="symbol">&gt;(</span><span class="function">lower_bound</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">),</span><span class="normal"> </span><span class="function">upper_bound</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">));</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** B+ Tree Object Comparison Functions</span>

<span class="normal">    </span><span class="comment">/// Equality relation of B+ trees of the same type. B+ trees of the same</span>
<span class="normal">    </span><span class="comment">/// size and equal elements (both key and data) are considered</span>
<span class="normal">    </span><span class="comment">/// equal. Beware of the random ordering of duplicate keys.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">==(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">btree_self</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">other</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> other</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">equal</span><span class="symbol">(</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> </span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> other</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">());</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Inequality relation. Based on operator==.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">!=(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">btree_self</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">other</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">!(*</span><span class="keyword">this</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> other</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Total ordering relation of B+ trees of the same type. It uses</span>
<span class="normal">    </span><span class="comment">/// std::lexicographical_compare() for the actual comparison of elements.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">btree_self</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">other</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">lexicographical_compare</span><span class="symbol">(</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> </span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> other</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> other</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Greater relation. Based on operator&lt;.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&gt;(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">btree_self</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">other</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> other </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Less-equal relation. Based on operator&lt;.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;=(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">btree_self</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">other</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">!(</span><span class="normal">other </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Greater-equal relation. Based on operator&lt;.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&gt;=(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">btree_self</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">other</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">!(*</span><span class="keyword">this</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> other</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">/// *** Fast Copy: Assign Operator and Copy Constructors</span>

<span class="normal">    </span><span class="comment">/// Assignment operator. All the key/data pairs are copied</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> btree_self</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">btree_self</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">other</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">this</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">other</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="function">clear</span><span class="symbol">();</span>

<span class="normal">	    key_less </span><span class="symbol">=</span><span class="normal"> other</span><span class="symbol">.</span><span class="function">key_comp</span><span class="symbol">();</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">other</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		stats</span><span class="symbol">.</span><span class="normal">leaves </span><span class="symbol">=</span><span class="normal"> stats</span><span class="symbol">.</span><span class="normal">innernodes </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">		root </span><span class="symbol">=</span><span class="normal"> </span><span class="function">copy_recursive</span><span class="symbol">(</span><span class="normal">other</span><span class="symbol">.</span><span class="normal">root</span><span class="symbol">);</span>
<span class="normal">		stats </span><span class="symbol">=</span><span class="normal"> other</span><span class="symbol">.</span><span class="normal">stats</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span><span class="normal"> </span><span class="function">verify</span><span class="symbol">();</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Copy constructor. The newly initialized B+ tree object will contain a</span>
<span class="normal">    </span><span class="comment">/// copy of all key/data pairs.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="function">btree</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">btree_self</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">other</span><span class="symbol">)</span>
<span class="normal">	</span><span class="symbol">:</span><span class="normal"> </span><span class="function">root</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span><span class="normal"> </span><span class="function">headleaf</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span><span class="normal"> </span><span class="function">tailleaf</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">),</span>
<span class="normal">	  </span><span class="function">stats</span><span class="symbol">(</span><span class="normal"> other</span><span class="symbol">.</span><span class="normal">stats </span><span class="symbol">),</span>
<span class="normal">	  </span><span class="function">key_less</span><span class="symbol">(</span><span class="normal"> other</span><span class="symbol">.</span><span class="function">key_comp</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    stats</span><span class="symbol">.</span><span class="normal">leaves </span><span class="symbol">=</span><span class="normal"> stats</span><span class="symbol">.</span><span class="normal">innernodes </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    root </span><span class="symbol">=</span><span class="normal"> </span><span class="function">copy_recursive</span><span class="symbol">(</span><span class="normal">other</span><span class="symbol">.</span><span class="normal">root</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span><span class="normal"> </span><span class="function">verify</span><span class="symbol">();</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span>
<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">/// Recursively copy nodes from another B+ tree object</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">node</span><span class="symbol">*</span><span class="normal"> </span><span class="function">copy_recursive</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">newleaf </span><span class="symbol">=</span><span class="normal"> </span><span class="function">allocate_leaf</span><span class="symbol">();</span>

<span class="normal">	    newleaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>
<span class="normal">	    std</span><span class="symbol">::</span><span class="function">copy</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey </span><span class="symbol">+</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">,</span><span class="normal"> newleaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">);</span>
<span class="normal">	    std</span><span class="symbol">::</span><span class="function">copy</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotdata </span><span class="symbol">+</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">,</span><span class="normal"> newleaf</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">headleaf </span><span class="symbol">==</span><span class="normal"> NULL</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		headleaf </span><span class="symbol">=</span><span class="normal"> tailleaf </span><span class="symbol">=</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">		newleaf</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">=</span><span class="normal"> newleaf</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">=</span><span class="normal"> NULL</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		newleaf</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">=</span><span class="normal"> tailleaf</span><span class="symbol">;</span>
<span class="normal">		tailleaf</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">=</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">		tailleaf </span><span class="symbol">=</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">newinner </span><span class="symbol">=</span><span class="normal"> </span><span class="function">allocate_inner</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">level</span><span class="symbol">);</span>

<span class="normal">	    newinner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>
<span class="normal">	    std</span><span class="symbol">::</span><span class="function">copy</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">,</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey </span><span class="symbol">+</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">,</span><span class="normal"> newinner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		newinner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="function">copy_recursive</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]);</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> newinner</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Public Insertion Functions</span>

<span class="normal">    </span><span class="comment">/// Attempt to insert a key/data pair into the B+ tree. If the tree does not</span>
<span class="normal">    </span><span class="comment">/// allow duplicate keys, then the insert may fail if it is already</span>
<span class="normal">    </span><span class="comment">/// present.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">pair&lt;iterator, bool&gt;</span><span class="normal"> </span><span class="function">insert</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> pair_type</span><span class="symbol">&amp;</span><span class="normal"> x</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">insert_start</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">,</span><span class="normal"> x</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span>
<span class="normal">    </span><span class="comment">/// Attempt to insert a key/data pair into the B+ tree. Beware that if</span>
<span class="normal">    </span><span class="comment">/// key_type == data_type, then the template iterator insert() is called</span>
<span class="normal">    </span><span class="comment">/// instead. If the tree does not allow duplicate keys, then the insert may</span>
<span class="normal">    </span><span class="comment">/// fail if it is already present.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">pair&lt;iterator, bool&gt;</span><span class="normal"> </span><span class="function">insert</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> data_type</span><span class="symbol">&amp;</span><span class="normal"> data</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">insert_start</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> data</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Attempt to insert a key/data pair into the B+ tree. This function is the</span>
<span class="normal">    </span><span class="comment">/// same as the other insert, however if key_type == data_type then the</span>
<span class="normal">    </span><span class="comment">/// non-template function cannot be called. If the tree does not allow</span>
<span class="normal">    </span><span class="comment">/// duplicate keys, then the insert may fail if it is already present.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">pair&lt;iterator, bool&gt;</span><span class="normal"> </span><span class="function">insert2</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> data_type</span><span class="symbol">&amp;</span><span class="normal"> data</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">insert_start</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> data</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Attempt to insert a key/data pair into the B+ tree. The iterator hint</span>
<span class="normal">    </span><span class="comment">/// is currently ignored by the B+ tree insertion routine.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">iterator</span><span class="normal"> </span><span class="function">insert</span><span class="symbol">(</span><span class="normal">iterator </span><span class="comment">/* hint */</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">pair_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">x</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">insert_start</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">,</span><span class="normal"> x</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">).</span><span class="normal">first</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Attempt to insert a key/data pair into the B+ tree. The iterator hint is</span>
<span class="normal">    </span><span class="comment">/// currently ignored by the B+ tree insertion routine.</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="usertype">iterator</span><span class="normal"> </span><span class="function">insert2</span><span class="symbol">(</span><span class="normal">iterator </span><span class="comment">/* hint */</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> data_type</span><span class="symbol">&amp;</span><span class="normal"> data</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="function">insert_start</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> data</span><span class="symbol">).</span><span class="normal">first</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Attempt to insert the range [first,last) of value_type pairs into the B+</span>
<span class="normal">    </span><span class="comment">/// tree. Each key/data pair is inserted individually.</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">InputIterator</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">insert</span><span class="symbol">(</span><span class="usertype">InputIterator</span><span class="normal"> first</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">InputIterator</span><span class="normal"> last</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">InputIterator</span><span class="normal"> iter </span><span class="symbol">=</span><span class="normal"> first</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">iter </span><span class="symbol">!=</span><span class="normal"> last</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="function">insert</span><span class="symbol">(*</span><span class="normal">iter</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="symbol">++</span><span class="normal">iter</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Private Insertion Functions</span>

<span class="normal">    </span><span class="comment">/// Start the insertion descent at the current root and handle root</span>
<span class="normal">    </span><span class="comment">/// splits. Returns true if the item was inserted</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="usertype">pair&lt;iterator, bool&gt;</span><span class="normal"> </span><span class="function">insert_start</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> data_type</span><span class="symbol">&amp;</span><span class="normal"> value</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">newchild </span><span class="symbol">=</span><span class="normal"> NULL</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">key_type</span><span class="normal"> newkey </span><span class="symbol">=</span><span class="normal"> </span><span class="function">key_type</span><span class="symbol">();</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">root</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    root </span><span class="symbol">=</span><span class="normal"> headleaf </span><span class="symbol">=</span><span class="normal"> tailleaf </span><span class="symbol">=</span><span class="normal"> </span><span class="function">allocate_leaf</span><span class="symbol">();</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	std</span><span class="symbol">::</span><span class="usertype">pair&lt;iterator, bool&gt;</span><span class="normal"> r </span><span class="symbol">=</span><span class="normal"> </span><span class="function">insert_descend</span><span class="symbol">(</span><span class="normal">root</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">,</span><span class="normal"> value</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">newkey</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">newchild</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">newchild</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">newroot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">allocate_inner</span><span class="symbol">(</span><span class="normal">root</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">	    newroot</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> newkey</span><span class="symbol">;</span>

<span class="normal">	    newroot</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> root</span><span class="symbol">;</span>
<span class="normal">	    newroot</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> newchild</span><span class="symbol">;</span>

<span class="normal">	    newroot</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>

<span class="normal">	    root </span><span class="symbol">=</span><span class="normal"> newroot</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">// increment itemcount if the item was inserted</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">r</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">stats</span><span class="symbol">.</span><span class="normal">itemcount</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="function">print</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">cout</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="function">verify</span><span class="symbol">();</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="function">exists</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">));</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">return</span><span class="normal"> r</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/**</span>
<span class="comment">     * </span><span class="type">@brief</span><span class="comment"> Insert an item into the B+ tree.</span>
<span class="comment">     *</span>
<span class="comment">     * Descend down the nodes to a leaf, insert the key/data pair in a free</span>
<span class="comment">     * slot. If the node overflows, then it must be split and the new split</span>
<span class="comment">     * node inserted into the parent. Unroll / this splitting up to the root.</span>
<span class="comment">    */</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="usertype">pair&lt;iterator, bool&gt;</span><span class="normal"> </span><span class="function">insert_descend</span><span class="symbol">(</span><span class="normal">node</span><span class="symbol">*</span><span class="normal"> n</span><span class="symbol">,</span>
<span class="normal">					     </span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> data_type</span><span class="symbol">&amp;</span><span class="normal"> value</span><span class="symbol">,</span>
<span class="normal">					     key_type</span><span class="symbol">*</span><span class="normal"> splitkey</span><span class="symbol">,</span><span class="normal"> node</span><span class="symbol">**</span><span class="normal"> splitnode</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="usertype">key_type</span><span class="normal"> newkey </span><span class="symbol">=</span><span class="normal"> </span><span class="function">key_type</span><span class="symbol">();</span>
<span class="normal">	    </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">newchild </span><span class="symbol">=</span><span class="normal"> NULL</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::insert_descend into "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	    std</span><span class="symbol">::</span><span class="usertype">pair&lt;iterator, bool&gt;</span><span class="normal"> r </span><span class="symbol">=</span><span class="normal"> </span><span class="function">insert_descend</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">],</span>
<span class="normal">							 key</span><span class="symbol">,</span><span class="normal"> value</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">newkey</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">newchild</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">newchild</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::insert_descend newchild with key "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> newkey </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" node "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> newchild </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" at slot "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> slot </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="function">isfull</span><span class="symbol">())</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="function">split_inner_node</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> splitkey</span><span class="symbol">,</span><span class="normal"> splitnode</span><span class="symbol">,</span><span class="normal"> slot</span><span class="symbol">);</span>

<span class="normal">		    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::insert_descend done split_inner: putslot: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> slot </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" putkey: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> newkey </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" upkey: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">splitkey </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">)</span>
<span class="normal">		    </span><span class="cbracket">{</span>
<span class="normal">			</span><span class="function">print_node</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">cout</span><span class="symbol">,</span><span class="normal"> inner</span><span class="symbol">);</span>
<span class="normal">			</span><span class="function">print_node</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">cout</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">splitnode</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="cbracket">}</span>

<span class="normal">		    </span><span class="comment">// check if insert slot is in the split sibling node</span>
<span class="normal">		    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::insert_descend switch: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> slot </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" &gt; "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">slot </span><span class="symbol">==</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">splitnode</span><span class="symbol">)-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span>
<span class="normal">		    </span><span class="cbracket">{</span>
<span class="normal">			</span><span class="comment">// special case when the insert slot matches the split</span>
<span class="normal">			</span><span class="comment">// place between the two nodes, then the insert key</span>
<span class="normal">			</span><span class="comment">// becomes the split key.</span>

<span class="normal">			</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> innerslotmax</span><span class="symbol">);</span>

<span class="normal">			</span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">splitinner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">inner_node</span><span class="symbol">*&gt;(*</span><span class="normal">splitnode</span><span class="symbol">);</span>

<span class="normal">			</span><span class="comment">// move the split key and it's datum into the left node</span>
<span class="normal">			inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">splitkey</span><span class="symbol">;</span>
<span class="normal">			inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> splitinner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">];</span>
<span class="normal">			inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">++;</span>

<span class="normal">			</span><span class="comment">// set new split key and move corresponding datum into right node</span>
<span class="normal">			splitinner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> newchild</span><span class="symbol">;</span>
<span class="normal">			</span><span class="symbol">*</span><span class="normal">splitkey </span><span class="symbol">=</span><span class="normal"> newkey</span><span class="symbol">;</span>

<span class="normal">			</span><span class="keyword">return</span><span class="normal"> r</span><span class="symbol">;</span>
<span class="normal">		    </span><span class="cbracket">}</span>
<span class="normal">		    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">slot </span><span class="symbol">&gt;=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">)</span>
<span class="normal">		    </span><span class="cbracket">{</span>
<span class="normal">			</span><span class="comment">// in case the insert slot is in the newly create split</span>
<span class="normal">			</span><span class="comment">// node, we reuse the code below.</span>

<span class="normal">			slot </span><span class="symbol">-=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">			inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">inner_node</span><span class="symbol">*&gt;(*</span><span class="normal">splitnode</span><span class="symbol">);</span>
<span class="normal">			</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::insert_descend switching to splitted node "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> inner </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" slot "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> slot </span><span class="symbol">&lt;&lt;</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="cbracket">}</span>
<span class="normal">		</span><span class="cbracket">}</span>

<span class="normal">		</span><span class="comment">// put pointer to child node into correct slot</span>
<span class="normal">		</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">slot </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> slot </span><span class="symbol">&lt;=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">);</span>

<span class="normal">		</span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>

<span class="normal">		</span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">&gt;</span><span class="normal"> slot</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		    inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">		    inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">		    i</span><span class="symbol">--;</span>
<span class="normal">		</span><span class="cbracket">}</span>

<span class="normal">		inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> newkey</span><span class="symbol">;</span>
<span class="normal">		inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> newchild</span><span class="symbol">;</span>
<span class="normal">		inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">++;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> r</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="comment">// n-&gt;isleafnode() == true</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">allow_duplicates </span><span class="symbol">&amp;&amp;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">key_equal</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="keyword">return</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">pair</span><span class="symbol">&lt;</span><span class="normal">iterator</span><span class="symbol">,</span><span class="normal"> </span><span class="type">bool</span><span class="symbol">&gt;(</span><span class="function">iterator</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> slot</span><span class="symbol">),</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="function">isfull</span><span class="symbol">())</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="function">split_leaf_node</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> splitkey</span><span class="symbol">,</span><span class="normal"> splitnode</span><span class="symbol">);</span>

<span class="normal">		</span><span class="comment">// check if insert slot is in the split sibling node</span>
<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">slot </span><span class="symbol">&gt;=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    slot </span><span class="symbol">-=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>
<span class="normal">		    leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">leaf_node</span><span class="symbol">*&gt;(*</span><span class="normal">splitnode</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="comment">// put data item into correct data slot</span>

<span class="normal">	    </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> leafslotmax</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">key_less</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">		leaf</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">		i</span><span class="symbol">--;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span>
<span class="normal">	    leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> key</span><span class="symbol">;</span>
<span class="normal">	    leaf</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> value</span><span class="symbol">;</span>
<span class="normal">	    leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">++;</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">splitnode </span><span class="symbol">&amp;&amp;</span><span class="normal"> leaf </span><span class="symbol">!=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">splitnode </span><span class="symbol">&amp;&amp;</span><span class="normal"> slot </span><span class="symbol">==</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// special case: the node was split, and the insert is at the</span>
<span class="normal">		</span><span class="comment">// last slot of the old node. then the splitkey must be</span>
<span class="normal">		</span><span class="comment">// updated.</span>
<span class="normal">		</span><span class="symbol">*</span><span class="normal">splitkey </span><span class="symbol">=</span><span class="normal"> key</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">pair</span><span class="symbol">&lt;</span><span class="normal">iterator</span><span class="symbol">,</span><span class="normal"> </span><span class="type">bool</span><span class="symbol">&gt;(</span><span class="function">iterator</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">),</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Split up a leaf node into two equally-filled sibling leaves. Returns</span>
<span class="normal">    </span><span class="comment">/// the new nodes and it's insertion key in the two parameters.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">split_leaf_node</span><span class="symbol">(</span><span class="normal">leaf_node</span><span class="symbol">*</span><span class="normal"> leaf</span><span class="symbol">,</span><span class="normal"> key_type</span><span class="symbol">*</span><span class="normal"> _newkey</span><span class="symbol">,</span><span class="normal"> node</span><span class="symbol">**</span><span class="normal"> _newleaf</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="function">isfull</span><span class="symbol">());</span>

<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> mid </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>

<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::split_leaf_node on "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> leaf </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">newleaf </span><span class="symbol">=</span><span class="normal"> </span><span class="function">allocate_leaf</span><span class="symbol">();</span>

<span class="normal">	newleaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> mid</span><span class="symbol">;</span>

<span class="normal">	newleaf</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">newleaf</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">==</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">leaf </span><span class="symbol">==</span><span class="normal"> tailleaf</span><span class="symbol">);</span>
<span class="normal">	    tailleaf </span><span class="symbol">=</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    newleaf</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">=</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> mid</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> ni </span><span class="symbol">=</span><span class="normal"> slot </span><span class="symbol">-</span><span class="normal"> mid</span><span class="symbol">;</span>
<span class="normal">	    newleaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">ni</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	    newleaf</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">ni</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	    </span>
<span class="normal">	leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">=</span><span class="normal"> mid</span><span class="symbol">;</span>
<span class="normal">	leaf</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">=</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">	newleaf</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">;</span>

<span class="normal">	</span><span class="symbol">*</span><span class="normal">_newkey </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">	</span><span class="symbol">*</span><span class="normal">_newleaf </span><span class="symbol">=</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Split up an inner node into two equally-filled sibling nodes. Returns</span>
<span class="normal">    </span><span class="comment">/// the new nodes and it's insertion key in the two parameters. Requires</span>
<span class="normal">    </span><span class="comment">/// the slot of the item will be inserted, so the nodes will be the same</span>
<span class="normal">    </span><span class="comment">/// size after the insert.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">split_inner_node</span><span class="symbol">(</span><span class="normal">inner_node</span><span class="symbol">*</span><span class="normal"> inner</span><span class="symbol">,</span><span class="normal"> key_type</span><span class="symbol">*</span><span class="normal"> _newkey</span><span class="symbol">,</span><span class="normal"> node</span><span class="symbol">**</span><span class="normal"> _newinner</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> addslot</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="function">isfull</span><span class="symbol">());</span>

<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> mid </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>

<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::split_inner: mid "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> mid </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" addslot "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> addslot </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="comment">// if the split is uneven and the overflowing item will be put into the</span>
<span class="normal">	</span><span class="comment">// larger node, then the smaller split node may underflow</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">addslot </span><span class="symbol">&lt;=</span><span class="normal"> mid </span><span class="symbol">&amp;&amp;</span><span class="normal"> mid </span><span class="symbol">&gt;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mid </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">))</span>
<span class="normal">	    mid</span><span class="symbol">--;</span>

<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::split_inner: mid "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> mid </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" addslot "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> addslot </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::split_inner_node on "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> inner </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into two nodes "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> mid </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mid </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" sized"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">newinner </span><span class="symbol">=</span><span class="normal"> </span><span class="function">allocate_inner</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">level</span><span class="symbol">);</span>

<span class="normal">	newinner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mid </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> mid </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> ni </span><span class="symbol">=</span><span class="normal"> slot </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mid </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">	    newinner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">ni</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	    newinner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">ni</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	newinner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">newinner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">];</span>
<span class="normal">	    </span>
<span class="normal">	inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">=</span><span class="normal"> mid</span><span class="symbol">;</span>

<span class="normal">	</span><span class="symbol">*</span><span class="normal">_newkey </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">mid</span><span class="symbol">];</span>
<span class="normal">	</span><span class="symbol">*</span><span class="normal">_newinner </span><span class="symbol">=</span><span class="normal"> newinner</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Support Class Encapsulating Deletion Results</span>

<span class="normal">    </span><span class="comment">/// Result flags of recursive deletion.</span>
<span class="normal">    </span><span class="keyword">enum</span><span class="normal"> result_flags_t</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="comment">/// Deletion successful and no fix-ups necessary.</span>
<span class="normal">	btree_ok </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span>

<span class="normal">	</span><span class="comment">/// Deletion not successful because key was not found.</span>
<span class="normal">	btree_not_found </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">,</span>

<span class="normal">	</span><span class="comment">/// Deletion successful, the last key was updated so parent slotkeys</span>
<span class="normal">	</span><span class="comment">/// need updates.</span>
<span class="normal">	btree_update_lastkey </span><span class="symbol">=</span><span class="normal"> </span><span class="number">2</span><span class="symbol">,</span>

<span class="normal">	</span><span class="comment">/// Deletion successful, children nodes were merged and the parent</span>
<span class="normal">	</span><span class="comment">/// needs to remove the empty node.</span>
<span class="normal">	btree_fixmerge </span><span class="symbol">=</span><span class="normal"> </span><span class="number">4</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// \internal B+ tree recursive deletion has much information which is</span>
<span class="normal">    </span><span class="comment">/// needs to be passed upward.</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">result_t</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="comment">/// Merged result flags</span>
<span class="normal">	</span><span class="usertype">result_flags_t</span><span class="normal">	flags</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// The key to be updated at the parent's slot</span>
<span class="normal">	</span><span class="usertype">key_type</span><span class="normal">	lastkey</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Constructor of a result with a specific flag, this can also be used</span>
<span class="normal">	</span><span class="comment">/// as for implicit conversion.</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="function">result_t</span><span class="symbol">(</span><span class="usertype">result_flags_t</span><span class="normal"> f </span><span class="symbol">=</span><span class="normal"> btree_ok</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="symbol">:</span><span class="normal"> </span><span class="function">flags</span><span class="symbol">(</span><span class="normal">f</span><span class="symbol">),</span><span class="normal"> </span><span class="function">lastkey</span><span class="symbol">()</span>
<span class="normal">	</span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Constructor with a lastkey value.</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="function">result_t</span><span class="symbol">(</span><span class="usertype">result_flags_t</span><span class="normal"> f</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">k</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="symbol">:</span><span class="normal"> </span><span class="function">flags</span><span class="symbol">(</span><span class="normal">f</span><span class="symbol">),</span><span class="normal"> </span><span class="function">lastkey</span><span class="symbol">(</span><span class="normal">k</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Test if this result object has a given flag set.</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">has</span><span class="symbol">(</span><span class="usertype">result_flags_t</span><span class="normal"> f</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">flags </span><span class="symbol">&amp;</span><span class="normal"> f</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Merge two results OR-ing the result flags and overwriting lastkeys.</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> result_t</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">|=</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">result_t</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">other</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    flags </span><span class="symbol">=</span><span class="normal"> </span><span class="function">result_flags_t</span><span class="symbol">(</span><span class="normal">flags </span><span class="symbol">|</span><span class="normal"> other</span><span class="symbol">.</span><span class="normal">flags</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="comment">// we overwrite existing lastkeys on purpose</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">other</span><span class="symbol">.</span><span class="function">has</span><span class="symbol">(</span><span class="normal">btree_update_lastkey</span><span class="symbol">))</span>
<span class="normal">		lastkey </span><span class="symbol">=</span><span class="normal"> other</span><span class="symbol">.</span><span class="normal">lastkey</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Public Erase Functions</span>

<span class="normal">    </span><span class="comment">/// Erases one (the first) of the key/data pairs associated with the given</span>
<span class="normal">    </span><span class="comment">/// key.</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">erase_one</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">key</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::erase_one("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> key </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") on btree size "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span><span class="normal"> </span><span class="function">verify</span><span class="symbol">();</span>
<span class="normal">	</span>
<span class="normal">	</span><span class="usertype">result_t</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> </span><span class="function">erase_one_descend</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> root</span><span class="symbol">,</span><span class="normal"> NULL</span><span class="symbol">,</span><span class="normal"> NULL</span><span class="symbol">,</span><span class="normal"> NULL</span><span class="symbol">,</span><span class="normal"> NULL</span><span class="symbol">,</span><span class="normal"> NULL</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">result</span><span class="symbol">.</span><span class="function">has</span><span class="symbol">(</span><span class="normal">btree_not_found</span><span class="symbol">))</span>
<span class="normal">	    </span><span class="symbol">--</span><span class="normal">stats</span><span class="symbol">.</span><span class="normal">itemcount</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">)</span><span class="normal"> </span><span class="function">print</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">cout</span><span class="symbol">);</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span><span class="normal"> </span><span class="function">verify</span><span class="symbol">();</span>

<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">result</span><span class="symbol">.</span><span class="function">has</span><span class="symbol">(</span><span class="normal">btree_not_found</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Erases all the key/data pairs associated with the given key. This is</span>
<span class="normal">    </span><span class="comment">/// implemented using erase_one().</span>
<span class="normal">    </span><span class="usertype">size_type</span><span class="normal"> </span><span class="function">erase</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">key_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">key</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">size_type</span><span class="normal"> c </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> </span><span class="function">erase_one</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="symbol">++</span><span class="normal">c</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">allow_duplicates</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">return</span><span class="normal"> c</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="preproc">#ifdef</span><span class="normal"> BTREE_TODO</span>
<span class="normal">    </span><span class="comment">/// Erase the key/data pair referenced by the iterator.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">erase</span><span class="symbol">(</span><span class="usertype">iterator</span><span class="normal"> iter</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>

<span class="normal">    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span>

<span class="preproc">#ifdef</span><span class="normal"> BTREE_TODO</span>
<span class="normal">    </span><span class="comment">/// Erase all key/data pairs in the range [first,last). This function is</span>
<span class="normal">    </span><span class="comment">/// currently not implemented by the B+ Tree.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">erase</span><span class="symbol">(</span><span class="normal">iterator </span><span class="comment">/* first */</span><span class="symbol">,</span><span class="normal"> iterator </span><span class="comment">/* last */</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">abort</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span>

<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Private Erase Functions</span>

<span class="normal">    </span><span class="comment">/** </span><span class="type">@brief</span><span class="comment"> Erase one (the first) key/data pair in the B+ tree matching key.</span>
<span class="comment">     *</span>
<span class="comment">     * Descends down the tree in search of key. During the descent the parent,</span>
<span class="comment">     * left and right siblings and their parents are computed and passed</span>
<span class="comment">     * down. Once the key/data pair is found, it is removed from the leaf. If</span>
<span class="comment">     * the leaf underflows 6 different cases are handled. These cases resolve</span>
<span class="comment">     * the underflow by shifting key/data pairs from adjacent sibling nodes,</span>
<span class="comment">     * merging two sibling nodes or trimming the tree.</span>
<span class="comment">     */</span>
<span class="normal">    </span><span class="usertype">result_t</span><span class="normal"> </span><span class="function">erase_one_descend</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> key_type</span><span class="symbol">&amp;</span><span class="normal"> key</span><span class="symbol">,</span>
<span class="normal">			       </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">curr</span><span class="symbol">,</span>
<span class="normal">			       </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">left</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">right</span><span class="symbol">,</span>
<span class="normal">			       </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leftparent</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">rightparent</span><span class="symbol">,</span>
<span class="normal">			       </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">parent</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> parentslot</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">curr</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">curr</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leftleaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">left</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">rightleaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">right</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">key_equal</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]))</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"Could not find key "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> key </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" to erase."</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">		</span><span class="keyword">return</span><span class="normal"> btree_not_found</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"Found key in leaf "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> curr </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" at slot "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> slot </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> slot</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">		leaf</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">--;</span>

<span class="normal">	    </span><span class="usertype">result_t</span><span class="normal"> myres </span><span class="symbol">=</span><span class="normal"> btree_ok</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="comment">// if the last key of the leaf was changed, the parent is notified</span>
<span class="normal">	    </span><span class="comment">// and updates the key of this leaf</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">slot </span><span class="symbol">==</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">parent </span><span class="symbol">&amp;&amp;</span><span class="normal"> parentslot </span><span class="symbol">&lt;</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> curr</span><span class="symbol">);</span>
<span class="normal">		    parent</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="keyword">else</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"Scheduling lastkeyupdate: key "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>
<span class="normal">		    myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">result_t</span><span class="symbol">(</span><span class="normal">btree_update_lastkey</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="function">isunderflow</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!(</span><span class="normal">leaf </span><span class="symbol">==</span><span class="normal"> root </span><span class="symbol">&amp;&amp;</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">))</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// determine what to do about the underflow</span>

<span class="normal">		</span><span class="comment">// case : if this empty leaf is the root, there is no way to</span>
<span class="normal">		</span><span class="comment">// correct underflow</span>
<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftleaf </span><span class="symbol">==</span><span class="normal"> NULL </span><span class="symbol">&amp;&amp;</span><span class="normal"> rightleaf </span><span class="symbol">==</span><span class="normal"> NULL</span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">return</span><span class="normal"> btree_ok</span><span class="symbol">;</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="comment">// case : if both left and right leaves would underflow in case of</span>
<span class="normal">		</span><span class="comment">// a shift, then merging is necessary. choose the more local merger</span>
<span class="normal">		</span><span class="comment">// with our parent</span>
<span class="normal">		</span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftleaf </span><span class="symbol">==</span><span class="normal"> NULL </span><span class="symbol">||</span><span class="normal"> leftleaf</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rightleaf </span><span class="symbol">==</span><span class="normal"> NULL </span><span class="symbol">||</span><span class="normal"> rightleaf</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftparent </span><span class="symbol">==</span><span class="normal"> parent</span><span class="symbol">)</span>
<span class="normal">			myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">merge_leaves</span><span class="symbol">(</span><span class="normal">leftleaf</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">,</span><span class="normal"> leftparent</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="keyword">else</span>
<span class="normal">			myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">merge_leaves</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> rightleaf</span><span class="symbol">,</span><span class="normal"> rightparent</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="comment">// case : the right leaf has extra data, so balance right with current</span>
<span class="normal">		</span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftleaf </span><span class="symbol">!=</span><span class="normal"> NULL </span><span class="symbol">&amp;&amp;</span><span class="normal"> leftleaf</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rightleaf </span><span class="symbol">!=</span><span class="normal"> NULL </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">rightleaf</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rightparent </span><span class="symbol">==</span><span class="normal"> parent</span><span class="symbol">)</span>
<span class="normal">			myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">shift_left_leaf</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> rightleaf</span><span class="symbol">,</span><span class="normal"> rightparent</span><span class="symbol">,</span><span class="normal"> parentslot</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="keyword">else</span>
<span class="normal">			myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">merge_leaves</span><span class="symbol">(</span><span class="normal">leftleaf</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">,</span><span class="normal"> leftparent</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="comment">// case : the left leaf has extra data, so balance left with current</span>
<span class="normal">		</span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftleaf </span><span class="symbol">!=</span><span class="normal"> NULL </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">leftleaf</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rightleaf </span><span class="symbol">!=</span><span class="normal"> NULL </span><span class="symbol">&amp;&amp;</span><span class="normal"> rightleaf</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftparent </span><span class="symbol">==</span><span class="normal"> parent</span><span class="symbol">)</span>
<span class="normal">			</span><span class="function">shift_right_leaf</span><span class="symbol">(</span><span class="normal">leftleaf</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">,</span><span class="normal"> leftparent</span><span class="symbol">,</span><span class="normal"> parentslot </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="keyword">else</span>
<span class="normal">			myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">merge_leaves</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> rightleaf</span><span class="symbol">,</span><span class="normal"> rightparent</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="comment">// case : both the leaf and right leaves have extra data and our</span>
<span class="normal">		</span><span class="comment">// parent, choose the leaf with more data</span>
<span class="normal">		</span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftparent </span><span class="symbol">==</span><span class="normal"> rightparent</span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftleaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&lt;=</span><span class="normal"> rightleaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span>
<span class="normal">			myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">shift_left_leaf</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> rightleaf</span><span class="symbol">,</span><span class="normal"> rightparent</span><span class="symbol">,</span><span class="normal"> parentslot</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="keyword">else</span>
<span class="normal">			</span><span class="function">shift_right_leaf</span><span class="symbol">(</span><span class="normal">leftleaf</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">,</span><span class="normal"> leftparent</span><span class="symbol">,</span><span class="normal"> parentslot </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="keyword">else</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftparent </span><span class="symbol">==</span><span class="normal"> parent</span><span class="symbol">)</span>
<span class="normal">			</span><span class="function">shift_right_leaf</span><span class="symbol">(</span><span class="normal">leftleaf</span><span class="symbol">,</span><span class="normal"> leaf</span><span class="symbol">,</span><span class="normal"> leftparent</span><span class="symbol">,</span><span class="normal"> parentslot </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="keyword">else</span>
<span class="normal">			myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">shift_left_leaf</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">,</span><span class="normal"> rightleaf</span><span class="symbol">,</span><span class="normal"> rightparent</span><span class="symbol">,</span><span class="normal"> parentslot</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> myres</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span><span class="normal"> </span><span class="comment">// !curr-&gt;isleafnode()</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">inner_node</span><span class="symbol">*&gt;(</span><span class="normal">curr</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leftinner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">inner_node</span><span class="symbol">*&gt;(</span><span class="normal">left</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">rightinner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">inner_node</span><span class="symbol">*&gt;(</span><span class="normal">right</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">myleft</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">myright</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">myleftparent</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">myrightparent</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="function">find_lower</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">slot </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		myleft </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">left </span><span class="symbol">==</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> NULL </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">inner_node</span><span class="symbol">*&gt;(</span><span class="normal">left</span><span class="symbol">))-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">		myleftparent </span><span class="symbol">=</span><span class="normal"> leftparent</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		myleft </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">		myleftparent </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">slot </span><span class="symbol">==</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		myright </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">right </span><span class="symbol">==</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> NULL </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">inner_node</span><span class="symbol">*&gt;(</span><span class="normal">right</span><span class="symbol">))-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">];</span>
<span class="normal">		myrightparent </span><span class="symbol">=</span><span class="normal"> rightparent</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		myright </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">		myrightparent </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"erase_one_descend into "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="usertype">result_t</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> </span><span class="function">erase_one_descend</span><span class="symbol">(</span><span class="normal">key</span><span class="symbol">,</span>
<span class="normal">						inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">],</span>
<span class="normal">						myleft</span><span class="symbol">,</span><span class="normal"> myright</span><span class="symbol">,</span>
<span class="normal">						myleftparent</span><span class="symbol">,</span><span class="normal"> myrightparent</span><span class="symbol">,</span>
<span class="normal">						inner</span><span class="symbol">,</span><span class="normal"> slot</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="usertype">result_t</span><span class="normal"> myres </span><span class="symbol">=</span><span class="normal"> btree_ok</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">result</span><span class="symbol">.</span><span class="function">has</span><span class="symbol">(</span><span class="normal">btree_not_found</span><span class="symbol">))</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="keyword">return</span><span class="normal"> result</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">result</span><span class="symbol">.</span><span class="function">has</span><span class="symbol">(</span><span class="normal">btree_update_lastkey</span><span class="symbol">))</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">parent </span><span class="symbol">&amp;&amp;</span><span class="normal"> parentslot </span><span class="symbol">&lt;</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"Fixing lastkeyupdate: key "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> result</span><span class="symbol">.</span><span class="normal">lastkey </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into parent "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> parent </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" at parentslot "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> parentslot </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">		    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> curr</span><span class="symbol">);</span>
<span class="normal">		    parent</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> result</span><span class="symbol">.</span><span class="normal">lastkey</span><span class="symbol">;</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="keyword">else</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"Forwarding lastkeyupdate: key "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> result</span><span class="symbol">.</span><span class="normal">lastkey </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>
<span class="normal">		    myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">result_t</span><span class="symbol">(</span><span class="normal">btree_update_lastkey</span><span class="symbol">,</span><span class="normal"> result</span><span class="symbol">.</span><span class="normal">lastkey</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">result</span><span class="symbol">.</span><span class="function">has</span><span class="symbol">(</span><span class="normal">btree_fixmerge</span><span class="symbol">))</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// either the current node or the next is empty and should be removed</span>
<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]-&gt;</span><span class="normal">slotuse </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">		    slot</span><span class="symbol">++;</span>

<span class="normal">		</span><span class="comment">// this is the child slot invalidated by the merge</span>
<span class="normal">		</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]-&gt;</span><span class="normal">slotuse </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>

<span class="normal">		</span><span class="function">free_node</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]);</span>

<span class="normal">		</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> slot</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">		    inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">--;</span>

<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="comment">// fix split key for children leaves</span>
<span class="normal">		    slot</span><span class="symbol">--;</span>
<span class="normal">		    </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">child </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="normal">leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]);</span>
<span class="normal">		    inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> child</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal"> child</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">];</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="function">isunderflow</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!(</span><span class="normal">inner </span><span class="symbol">==</span><span class="normal"> root </span><span class="symbol">&amp;&amp;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">))</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="comment">// case: the inner node is the root and has just one child. that child becomes the new root</span>
<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftinner </span><span class="symbol">==</span><span class="normal"> NULL </span><span class="symbol">&amp;&amp;</span><span class="normal"> rightinner </span><span class="symbol">==</span><span class="normal"> NULL</span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">inner </span><span class="symbol">==</span><span class="normal"> root</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>

<span class="normal">		    root </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">];</span>

<span class="normal">		    inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">		    </span><span class="function">free_node</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">);</span>

<span class="normal">		    </span><span class="keyword">return</span><span class="normal"> btree_ok</span><span class="symbol">;</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="comment">// case : if both left and right leaves would underflow in case of</span>
<span class="normal">		</span><span class="comment">// a shift, then merging is necessary. choose the more local merger</span>
<span class="normal">		</span><span class="comment">// with our parent</span>
<span class="normal">		</span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftinner </span><span class="symbol">==</span><span class="normal"> NULL </span><span class="symbol">||</span><span class="normal"> leftinner</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rightinner </span><span class="symbol">==</span><span class="normal"> NULL </span><span class="symbol">||</span><span class="normal"> rightinner</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftparent </span><span class="symbol">==</span><span class="normal"> parent</span><span class="symbol">)</span>
<span class="normal">			myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">merge_inner</span><span class="symbol">(</span><span class="normal">leftinner</span><span class="symbol">,</span><span class="normal"> inner</span><span class="symbol">,</span><span class="normal"> leftparent</span><span class="symbol">,</span><span class="normal"> parentslot </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="keyword">else</span>
<span class="normal">			myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">merge_inner</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> rightinner</span><span class="symbol">,</span><span class="normal"> rightparent</span><span class="symbol">,</span><span class="normal"> parentslot</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="comment">// case : the right leaf has extra data, so balance right with current</span>
<span class="normal">		</span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftinner </span><span class="symbol">!=</span><span class="normal"> NULL </span><span class="symbol">&amp;&amp;</span><span class="normal"> leftinner</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rightinner </span><span class="symbol">!=</span><span class="normal"> NULL </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">rightinner</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rightparent </span><span class="symbol">==</span><span class="normal"> parent</span><span class="symbol">)</span>
<span class="normal">			</span><span class="function">shift_left_inner</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> rightinner</span><span class="symbol">,</span><span class="normal"> rightparent</span><span class="symbol">,</span><span class="normal"> parentslot</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="keyword">else</span>
<span class="normal">			myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">merge_inner</span><span class="symbol">(</span><span class="normal">leftinner</span><span class="symbol">,</span><span class="normal"> inner</span><span class="symbol">,</span><span class="normal"> leftparent</span><span class="symbol">,</span><span class="normal"> parentslot </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="comment">// case : the left leaf has extra data, so balance left with current</span>
<span class="normal">		</span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftinner </span><span class="symbol">!=</span><span class="normal"> NULL </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">leftinner</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rightinner </span><span class="symbol">!=</span><span class="normal"> NULL </span><span class="symbol">&amp;&amp;</span><span class="normal"> rightinner</span><span class="symbol">-&gt;</span><span class="function">isfew</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftparent </span><span class="symbol">==</span><span class="normal"> parent</span><span class="symbol">)</span>
<span class="normal">			</span><span class="function">shift_right_inner</span><span class="symbol">(</span><span class="normal">leftinner</span><span class="symbol">,</span><span class="normal"> inner</span><span class="symbol">,</span><span class="normal"> leftparent</span><span class="symbol">,</span><span class="normal"> parentslot </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="keyword">else</span>
<span class="normal">			myres </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">merge_inner</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> rightinner</span><span class="symbol">,</span><span class="normal"> rightparent</span><span class="symbol">,</span><span class="normal"> parentslot</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="comment">// case : both the leaf and right leaves have extra data and our</span>
<span class="normal">		</span><span class="comment">// parent, choose the leaf with more data</span>
<span class="normal">		</span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftparent </span><span class="symbol">==</span><span class="normal"> rightparent</span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftinner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&lt;=</span><span class="normal"> rightinner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span>
<span class="normal">			</span><span class="function">shift_left_inner</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> rightinner</span><span class="symbol">,</span><span class="normal"> rightparent</span><span class="symbol">,</span><span class="normal"> parentslot</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="keyword">else</span>
<span class="normal">			</span><span class="function">shift_right_inner</span><span class="symbol">(</span><span class="normal">leftinner</span><span class="symbol">,</span><span class="normal"> inner</span><span class="symbol">,</span><span class="normal"> leftparent</span><span class="symbol">,</span><span class="normal"> parentslot </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="keyword">else</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftparent </span><span class="symbol">==</span><span class="normal"> parent</span><span class="symbol">)</span>
<span class="normal">			</span><span class="function">shift_right_inner</span><span class="symbol">(</span><span class="normal">leftinner</span><span class="symbol">,</span><span class="normal"> inner</span><span class="symbol">,</span><span class="normal"> leftparent</span><span class="symbol">,</span><span class="normal"> parentslot </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="keyword">else</span>
<span class="normal">			</span><span class="function">shift_left_inner</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">,</span><span class="normal"> rightinner</span><span class="symbol">,</span><span class="normal"> rightparent</span><span class="symbol">,</span><span class="normal"> parentslot</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> myres</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Merge two leaf nodes. The function moves all key/data pairs from right</span>
<span class="normal">    </span><span class="comment">/// to left and sets right's slotuse to zero. The right slot is then</span>
<span class="normal">    </span><span class="comment">/// removed by the calling parent node.</span>
<span class="normal">    </span><span class="usertype">result_t</span><span class="normal"> </span><span class="function">merge_leaves</span><span class="symbol">(</span><span class="normal">leaf_node</span><span class="symbol">*</span><span class="normal"> left</span><span class="symbol">,</span><span class="normal"> leaf_node</span><span class="symbol">*</span><span class="normal"> right</span><span class="symbol">,</span><span class="normal"> inner_node</span><span class="symbol">*</span><span class="normal"> parent</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"Merge leaf nodes "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> left </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> right </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" with common parent "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> parent </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"."</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>
<span class="normal">	</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">)</span><span class="normal">parent</span><span class="symbol">;</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">());</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&lt;</span><span class="normal"> leafslotmax</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	    left</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>

<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">)</span>
<span class="normal">	    left</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">=</span><span class="normal"> left</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">else</span>
<span class="normal">	    tailleaf </span><span class="symbol">=</span><span class="normal"> left</span><span class="symbol">;</span>

<span class="normal">	right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">return</span><span class="normal"> btree_fixmerge</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Merge two inner nodes. The function moves all key/childid pairs from</span>
<span class="normal">    </span><span class="comment">/// right to left and sets right's slotuse to zero. The right slot is then</span>
<span class="normal">    </span><span class="comment">/// removed by the calling parent node.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">result_t</span><span class="normal"> </span><span class="function">merge_inner</span><span class="symbol">(</span><span class="normal">inner_node</span><span class="symbol">*</span><span class="normal"> left</span><span class="symbol">,</span><span class="normal"> inner_node</span><span class="symbol">*</span><span class="normal"> right</span><span class="symbol">,</span><span class="normal"> inner_node</span><span class="symbol">*</span><span class="normal"> parent</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> parentslot</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"Merge inner nodes "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> left </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> right </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" with common parent "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> parent </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"."</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">level</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&lt;</span><span class="normal"> innerslotmax</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="comment">// find the left node's slot in the parent's children</span>
<span class="normal">	    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> leftslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">leftslot </span><span class="symbol">&lt;=</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&amp;&amp;</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> left</span><span class="symbol">)</span>
<span class="normal">		</span><span class="symbol">++</span><span class="normal">leftslot</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">leftslot </span><span class="symbol">&lt;</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> right</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parentslot </span><span class="symbol">==</span><span class="normal"> leftslot</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">// retrieve the decision key from parent</span>
<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">];</span>
<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">++;</span>

<span class="normal">        </span><span class="comment">// copy over keys and children from right</span>
<span class="normal">	</span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	    left</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>

<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">];</span>

<span class="normal">	right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">return</span><span class="normal"> btree_fixmerge</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Balance two leaf nodes. The function moves key/data pairs from right to</span>
<span class="normal">    </span><span class="comment">/// left so that both nodes are equally filled. The parent node is updated</span>
<span class="normal">    </span><span class="comment">/// if possible.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">result_t</span><span class="normal"> </span><span class="function">shift_left_leaf</span><span class="symbol">(</span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">left</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">right</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">parent</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> parentslot</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">());</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">==</span><span class="normal"> right</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left </span><span class="symbol">==</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">prevleaf</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&lt;</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> shiftnum </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>

<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"Shifting (leaf) "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> shiftnum </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" entries to left "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> left </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" from right "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> right </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" with common parent "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> parent </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"."</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> shiftnum </span><span class="symbol">&lt;</span><span class="normal"> leafslotmax</span><span class="symbol">);</span>

<span class="normal">	</span><span class="comment">// copy the first items from the right node to the last slot in the left node.</span>
<span class="normal">	</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> shiftnum</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	    left</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+=</span><span class="normal"> shiftnum</span><span class="symbol">;</span>
<span class="normal">	</span>
<span class="normal">	</span><span class="comment">// shift all slots in the right node to the left</span>
<span class="normal">    </span>
<span class="normal">	right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-=</span><span class="normal"> shiftnum</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> shiftnum</span><span class="symbol">];</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> shiftnum</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">// fixup parent</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">parentslot </span><span class="symbol">&lt;</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    parent</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> btree_ok</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">// the update is further up the tree</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="function">result_t</span><span class="symbol">(</span><span class="normal">btree_update_lastkey</span><span class="symbol">,</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Balance two inner nodes. The function moves key/data pairs from right</span>
<span class="normal">    </span><span class="comment">/// to left so that both nodes are equally filled. The parent node is</span>
<span class="normal">    </span><span class="comment">/// updated if possible.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">shift_left_inner</span><span class="symbol">(</span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">left</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">right</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">parent</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> parentslot</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">level</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&lt;</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> shiftnum </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>

<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"Shifting (inner) "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> shiftnum </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" entries to left "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> left </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" from right "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> right </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" with common parent "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> parent </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"."</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> shiftnum </span><span class="symbol">&lt;</span><span class="normal"> innerslotmax</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="comment">// find the left node's slot in the parent's children and compare to parentslot</span>

<span class="normal">	    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> leftslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">leftslot </span><span class="symbol">&lt;=</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&amp;&amp;</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> left</span><span class="symbol">)</span>
<span class="normal">		</span><span class="symbol">++</span><span class="normal">leftslot</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">leftslot </span><span class="symbol">&lt;</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> right</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">leftslot </span><span class="symbol">==</span><span class="normal"> parentslot</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">// copy the parent's decision slotkey and childid to the first new key on the left</span>
<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">];</span>
<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">++;</span>

<span class="normal">	</span><span class="comment">// copy the other items from the right node to the last slots in the left node.</span>
<span class="normal">	</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> shiftnum </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	    left</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+=</span><span class="normal"> shiftnum </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">// fixup parent</span>
<span class="normal">	parent</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">shiftnum </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">	</span><span class="comment">// last pointer in left</span>
<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">shiftnum </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">	</span>
<span class="normal">	</span><span class="comment">// shift all slots in the right node</span>
<span class="normal">    </span>
<span class="normal">	right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-=</span><span class="normal"> shiftnum</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> shiftnum</span><span class="symbol">];</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> shiftnum</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> shiftnum</span><span class="symbol">];</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Balance two leaf nodes. The function moves key/data pairs from left to</span>
<span class="normal">    </span><span class="comment">/// right so that both nodes are equally filled. The parent node is updated</span>
<span class="normal">    </span><span class="comment">/// if possible.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">shift_right_leaf</span><span class="symbol">(</span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">left</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">right</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">parent</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> parentslot</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">());</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">==</span><span class="normal"> right</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left </span><span class="symbol">==</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">prevleaf</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&gt;</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> shiftnum </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>

<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"Shifting (leaf) "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> shiftnum </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" entries to right "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> right </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" from left "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> left </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" with common parent "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> parent </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"."</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="comment">// find the left node's slot in the parent's children</span>
<span class="normal">	    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> leftslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">leftslot </span><span class="symbol">&lt;=</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&amp;&amp;</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> left</span><span class="symbol">)</span>
<span class="normal">		</span><span class="symbol">++</span><span class="normal">leftslot</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">leftslot </span><span class="symbol">&lt;</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> right</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">leftslot </span><span class="symbol">==</span><span class="normal"> parentslot</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">// shift all slots in the right node</span>
<span class="normal">    </span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> shiftnum </span><span class="symbol">&lt;</span><span class="normal"> leafslotmax</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">--)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> shiftnum</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> shiftnum</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+=</span><span class="normal"> shiftnum</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">// copy the last items from the left node to the first slot in the right node.</span>
<span class="normal">    	</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> shiftnum</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> shiftnum </span><span class="symbol">+</span><span class="normal"> i</span><span class="symbol">];</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">slotdata</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> shiftnum </span><span class="symbol">+</span><span class="normal"> i</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-=</span><span class="normal"> shiftnum</span><span class="symbol">;</span>

<span class="normal">	parent</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Balance two inner nodes. The function moves key/data pairs from left to</span>
<span class="normal">    </span><span class="comment">/// right so that both nodes are equally filled. The parent node is updated</span>
<span class="normal">    </span><span class="comment">/// if possible.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">shift_right_inner</span><span class="symbol">(</span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">left</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">right</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">parent</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> parentslot</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">level</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&gt;</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> shiftnum </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>

<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"Shifting (leaf) "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> shiftnum </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" entries to right "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> right </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" from left "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> left </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" with common parent "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> parent </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"."</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="comment">// find the left node's slot in the parent's children</span>
<span class="normal">	    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> leftslot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">leftslot </span><span class="symbol">&lt;=</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&amp;&amp;</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> left</span><span class="symbol">)</span>
<span class="normal">		</span><span class="symbol">++</span><span class="normal">leftslot</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">leftslot </span><span class="symbol">&lt;</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> left</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">leftslot</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> right</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">leftslot </span><span class="symbol">==</span><span class="normal"> parentslot</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">// shift all slots in the right node</span>

<span class="normal">	</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> shiftnum </span><span class="symbol">&lt;</span><span class="normal"> innerslotmax</span><span class="symbol">);</span>
<span class="normal">    </span>
<span class="normal">	right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> shiftnum</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">];</span>
<span class="normal">	</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">--)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> shiftnum</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">i </span><span class="symbol">+</span><span class="normal"> shiftnum</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	right</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+=</span><span class="normal"> shiftnum</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">// copy the parent's decision slotkey and childid to the last new key on the right</span>
<span class="normal">	right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">shiftnum </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> parent</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">];</span>
<span class="normal">	right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">shiftnum </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">];</span>

<span class="normal">	</span><span class="comment">// copy the remaining last items from the left node to the first slot in the right node.</span>
<span class="normal">    	</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> shiftnum </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> shiftnum </span><span class="symbol">+</span><span class="normal"> i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">	    right</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> shiftnum </span><span class="symbol">+</span><span class="normal"> i </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">// copy the first to-be-removed key from the left node to the parent's decision slot</span>
<span class="normal">	parent</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">parentslot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> left</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> shiftnum</span><span class="symbol">];</span>

<span class="normal">	left</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-=</span><span class="normal"> shiftnum</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="preproc">#ifdef</span><span class="normal"> BTREE_DEBUG</span>
<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Debug Printing</span>

<span class="normal">    </span><span class="comment">/// Print out the B+ tree structure with keys onto the given ostream. This</span>
<span class="normal">    </span><span class="comment">/// function requires that the header is compiled with BTREE_DE</span><span class="todo">BUG</span><span class="comment"> and that</span>
<span class="normal">    </span><span class="comment">/// key_type is printable via std::ostream.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">print</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="usertype">ostream</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">os</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">root</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="function">print_node</span><span class="symbol">(</span><span class="normal">os</span><span class="symbol">,</span><span class="normal"> root</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Print out only the leaves via the double linked list.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">print_leaves</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="usertype">ostream</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">os</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"leaves:"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n </span><span class="symbol">=</span><span class="normal"> headleaf</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"  "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> n </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">;</span>

<span class="normal">	    n </span><span class="symbol">=</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">private</span><span class="symbol">:</span>

<span class="normal">    </span><span class="comment">/// Recursively descend down the tree and print out nodes.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">print_node</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="usertype">ostream</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> node</span><span class="symbol">*</span><span class="normal"> node</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> depth</span><span class="symbol">=</span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> recursive</span><span class="symbol">=</span><span class="keyword">false</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> depth</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"  "</span><span class="symbol">;</span>
<span class="normal">	    </span>
<span class="normal">	os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"node "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> node </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" level "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> node</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" slotuse "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> node</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">node</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leafnode </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">node</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> depth</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"  "</span><span class="symbol">;</span>
<span class="normal">	    os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"  leaf prev "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> leafnode</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" next "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> leafnode</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> depth</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"  "</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> leafnode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		os </span><span class="symbol">&lt;&lt;</span><span class="normal"> leafnode</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"  "</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// &lt;&lt; "(data: " &lt;&lt; leafnode-&gt;slotdata[slot] &lt;&lt; ") ";</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    os </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">innernode </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">node</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> depth</span><span class="symbol">;</span><span class="normal"> i</span><span class="symbol">++)</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"  "</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> innernode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> innernode</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> innernode</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" "</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> innernode</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">innernode</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">recursive</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> innernode</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="function">print_node</span><span class="symbol">(</span><span class="normal">os</span><span class="symbol">,</span><span class="normal"> innernode</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">],</span><span class="normal"> depth </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">,</span><span class="normal"> recursive</span><span class="symbol">);</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="preproc">#else</span>
<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Dummy Debug Printing Functions</span>

<span class="normal">    </span><span class="comment">/// Print out the B+ tree structure with keys onto the given ostream. This</span>
<span class="normal">    </span><span class="comment">/// function requires that the header is compiled with BTREE_DE</span><span class="todo">BUG</span><span class="comment"> and that</span>
<span class="normal">    </span><span class="comment">/// key_type is printable via std::ostream.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">print</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Print out only the leaves via the double linked list.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">print_leaves</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">private</span><span class="symbol">:</span>

<span class="normal">    </span><span class="comment">/// Recursively descend down the tree and print out nodes.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">print_node</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream </span><span class="symbol">&amp;,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> node</span><span class="symbol">*,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="symbol">=</span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="symbol">=</span><span class="keyword">false</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Verification of B+ Tree Invariants</span>

<span class="normal">    </span><span class="comment">/// Run a thorough verification of all B+ tree invariants. The program</span>
<span class="normal">    </span><span class="comment">/// aborts via assert() if something is wrong.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">verify</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">key_type</span><span class="normal"> minkey</span><span class="symbol">,</span><span class="normal"> maxkey</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">tree_stats</span><span class="normal"> vstats</span><span class="symbol">;</span>
<span class="normal">	</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">root</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="function">verify_node</span><span class="symbol">(</span><span class="normal">root</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">minkey</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">maxkey</span><span class="symbol">,</span><span class="normal"> vstats</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> vstats</span><span class="symbol">.</span><span class="normal">itemcount </span><span class="symbol">==</span><span class="normal"> stats</span><span class="symbol">.</span><span class="normal">itemcount </span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> vstats</span><span class="symbol">.</span><span class="normal">leaves </span><span class="symbol">==</span><span class="normal"> stats</span><span class="symbol">.</span><span class="normal">leaves </span><span class="symbol">);</span>
<span class="normal">	    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> vstats</span><span class="symbol">.</span><span class="normal">innernodes </span><span class="symbol">==</span><span class="normal"> stats</span><span class="symbol">.</span><span class="normal">innernodes </span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="function">verify_leaflinks</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">private</span><span class="symbol">:</span>

<span class="normal">    </span><span class="comment">/// Recursively descend down the tree and verify each node</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">verify_node</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> node</span><span class="symbol">*</span><span class="normal"> n</span><span class="symbol">,</span><span class="normal"> key_type</span><span class="symbol">*</span><span class="normal"> minkey</span><span class="symbol">,</span><span class="normal"> key_type</span><span class="symbol">*</span><span class="normal"> maxkey</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">tree_stats</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">vstats</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"verifynode "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> n </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">leaf </span><span class="symbol">==</span><span class="normal"> root </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="function">isunderflow</span><span class="symbol">());</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="function">assert</span><span class="symbol">(</span><span class="function">key_lessequal</span><span class="symbol">(</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">],</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]));</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="symbol">*</span><span class="normal">minkey </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">];</span>
<span class="normal">	    </span><span class="symbol">*</span><span class="normal">maxkey </span><span class="symbol">=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>

<span class="normal">	    vstats</span><span class="symbol">.</span><span class="normal">leaves</span><span class="symbol">++;</span>
<span class="normal">	    vstats</span><span class="symbol">.</span><span class="normal">itemcount </span><span class="symbol">+=</span><span class="normal"> leaf</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span><span class="normal"> </span><span class="comment">// !n-&gt;isleafnode()</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>
<span class="normal">	    vstats</span><span class="symbol">.</span><span class="normal">innernodes</span><span class="symbol">++;</span>

<span class="normal">	    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">inner </span><span class="symbol">==</span><span class="normal"> root </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="function">isunderflow</span><span class="symbol">());</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="function">assert</span><span class="symbol">(</span><span class="function">key_lessequal</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">],</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]));</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">subnode </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">		</span><span class="usertype">key_type</span><span class="normal"> subminkey </span><span class="symbol">=</span><span class="normal"> </span><span class="function">key_type</span><span class="symbol">();</span>
<span class="normal">		</span><span class="usertype">key_type</span><span class="normal"> submaxkey </span><span class="symbol">=</span><span class="normal"> </span><span class="function">key_type</span><span class="symbol">();</span>

<span class="normal">		</span><span class="function">assert</span><span class="symbol">(</span><span class="normal">subnode</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">level</span><span class="symbol">);</span>
<span class="normal">		</span><span class="function">verify_node</span><span class="symbol">(</span><span class="normal">subnode</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">subminkey</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">submaxkey</span><span class="symbol">,</span><span class="normal"> vstats</span><span class="symbol">);</span>

<span class="normal">		</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"verify subnode "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> subnode </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">": "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> subminkey </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> submaxkey </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">slot </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">		    </span><span class="symbol">*</span><span class="normal">minkey </span><span class="symbol">=</span><span class="normal"> subminkey</span><span class="symbol">;</span>
<span class="normal">		</span><span class="keyword">else</span>
<span class="normal">		    </span><span class="function">assert</span><span class="symbol">(</span><span class="function">key_greaterequal</span><span class="symbol">(</span><span class="normal">subminkey</span><span class="symbol">,</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">]));</span>

<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">slot </span><span class="symbol">==</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span>
<span class="normal">		    </span><span class="symbol">*</span><span class="normal">maxkey </span><span class="symbol">=</span><span class="normal"> submaxkey</span><span class="symbol">;</span>
<span class="normal">		</span><span class="keyword">else</span>
<span class="normal">		    </span><span class="function">assert</span><span class="symbol">(</span><span class="function">key_equal</span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">],</span><span class="normal"> submaxkey</span><span class="symbol">));</span>

<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="comment">// children are leaves and must be linked together in the</span>
<span class="normal">		    </span><span class="comment">// correct order</span>
<span class="normal">		    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leafa </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]);</span>
<span class="normal">		    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leafb </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]);</span>

<span class="normal">		    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">leafa</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">==</span><span class="normal"> leafb</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">leafa </span><span class="symbol">==</span><span class="normal"> leafb</span><span class="symbol">-&gt;</span><span class="normal">prevleaf</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="symbol">(</span><span class="type">void</span><span class="symbol">)</span><span class="normal">leafa</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">(</span><span class="type">void</span><span class="symbol">)</span><span class="normal">leafb</span><span class="symbol">;</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">)</span>
<span class="normal">		</span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="comment">// verify leaf links between the adjacent inner nodes</span>
<span class="normal">		    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">parenta </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]);</span>
<span class="normal">		    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">parentb </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">]);</span>

<span class="normal">		    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leafa </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">parenta</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">parenta</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">]);</span>
<span class="normal">		    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leafb </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">parentb</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]);</span>

<span class="normal">		    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">leafa</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">==</span><span class="normal"> leafb</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">leafa </span><span class="symbol">==</span><span class="normal"> leafb</span><span class="symbol">-&gt;</span><span class="normal">prevleaf</span><span class="symbol">);</span>
<span class="normal">		    </span><span class="symbol">(</span><span class="type">void</span><span class="symbol">)</span><span class="normal">leafa</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">(</span><span class="type">void</span><span class="symbol">)</span><span class="normal">leafb</span><span class="symbol">;</span>
<span class="normal">		</span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Verify the double linked list of leaves.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">verify_leaflinks</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">n </span><span class="symbol">=</span><span class="normal"> headleaf</span><span class="symbol">;</span>

<span class="normal">	</span><span class="function">assert</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">assert</span><span class="symbol">(!</span><span class="normal">n </span><span class="symbol">||</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">==</span><span class="normal"> NULL</span><span class="symbol">);</span>

<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> testcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="normal">level </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">slotuse </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="function">assert</span><span class="symbol">(</span><span class="function">key_lessequal</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">],</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">slot </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]));</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    testcount </span><span class="symbol">+=</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="function">assert</span><span class="symbol">(</span><span class="function">key_lessequal</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">],</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">-&gt;</span><span class="normal">slotkey</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]));</span>

<span class="normal">		</span><span class="function">assert</span><span class="symbol">(</span><span class="normal">n </span><span class="symbol">==</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">-&gt;</span><span class="normal">prevleaf</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="function">assert</span><span class="symbol">(</span><span class="normal">tailleaf </span><span class="symbol">==</span><span class="normal"> n</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    n </span><span class="symbol">=</span><span class="normal"> n</span><span class="symbol">-&gt;</span><span class="normal">nextleaf</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="function">assert</span><span class="symbol">(</span><span class="normal">testcount </span><span class="symbol">==</span><span class="normal"> </span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// *** Dump and Restore of B+ Trees</span>

<span class="normal">    </span><span class="comment">/// \internal A header for the binary image containing the base properties</span>
<span class="normal">    </span><span class="comment">/// of the B+ tree. These properties have to match the current template</span>
<span class="normal">    </span><span class="comment">/// instantiation.</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">dump_header</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="comment">/// "stx-btree", just to stop the restore() function from loading garbage</span>
<span class="normal">	</span><span class="type">char</span><span class="normal"> 		signature</span><span class="symbol">[</span><span class="number">12</span><span class="symbol">];</span>

<span class="normal">	</span><span class="comment">/// Currently 0</span>
<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">	version</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// sizeof(key_type)</span>
<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">	key_type_size</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// sizeof(data_type)</span>
<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">	data_type_size</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Number of slots in the leaves</span>
<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">	leafslots</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Number of slots in the inner nodes</span>
<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal">	innerslots</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Allow duplicates</span>
<span class="normal">	</span><span class="type">bool</span><span class="normal">		allow_duplicates</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// The item count of the tree</span>
<span class="normal">	</span><span class="usertype">size_type</span><span class="normal">	itemcount</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/// Fill the struct with the current B+ tree's properties, itemcount is</span>
<span class="normal">	</span><span class="comment">/// not filled.</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">fill</span><span class="symbol">()</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="comment">// don't want to include string.h just for this signature</span>
<span class="normal">	    </span><span class="symbol">*</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">*&gt;(</span><span class="normal">signature</span><span class="symbol">+</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0x2d787473</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="symbol">*</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">*&gt;(</span><span class="normal">signature</span><span class="symbol">+</span><span class="number">4</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0x65727462</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="symbol">*</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">*&gt;(</span><span class="normal">signature</span><span class="symbol">+</span><span class="number">8</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0x00000065</span><span class="symbol">;</span>

<span class="normal">	    version </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">	    key_type_size </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree_self</span><span class="symbol">::</span><span class="normal">key_type</span><span class="symbol">);</span>
<span class="normal">	    data_type_size </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">btree_self</span><span class="symbol">::</span><span class="normal">data_type</span><span class="symbol">);</span>
<span class="normal">	    leafslots </span><span class="symbol">=</span><span class="normal"> btree_self</span><span class="symbol">::</span><span class="normal">leafslotmax</span><span class="symbol">;</span>
<span class="normal">	    innerslots </span><span class="symbol">=</span><span class="normal"> btree_self</span><span class="symbol">::</span><span class="normal">innerslotmax</span><span class="symbol">;</span>
<span class="normal">	    allow_duplicates </span><span class="symbol">=</span><span class="normal"> btree_self</span><span class="symbol">::</span><span class="normal">allow_duplicates</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="comment">/// Returns true if the headers have the same vital properties</span>
<span class="normal">	</span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">same</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">dump_header</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">o</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(*</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">*&gt;(</span><span class="normal">signature</span><span class="symbol">+</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span>
<span class="normal">		    </span><span class="symbol">*</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">*&gt;(</span><span class="normal">o</span><span class="symbol">.</span><span class="normal">signature</span><span class="symbol">+</span><span class="number">0</span><span class="symbol">))</span>
<span class="normal">		</span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(*</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">*&gt;(</span><span class="normal">signature</span><span class="symbol">+</span><span class="number">4</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span>
<span class="normal">		    </span><span class="symbol">*</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">*&gt;(</span><span class="normal">o</span><span class="symbol">.</span><span class="normal">signature</span><span class="symbol">+</span><span class="number">4</span><span class="symbol">))</span>
<span class="normal">		</span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(*</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">*&gt;(</span><span class="normal">signature</span><span class="symbol">+</span><span class="number">8</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span>
<span class="normal">		    </span><span class="symbol">*</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">*&gt;(</span><span class="normal">o</span><span class="symbol">.</span><span class="normal">signature</span><span class="symbol">+</span><span class="number">8</span><span class="symbol">))</span>

<span class="normal">		</span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">version </span><span class="symbol">==</span><span class="normal"> o</span><span class="symbol">.</span><span class="normal">version</span><span class="symbol">)</span>
<span class="normal">		</span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">key_type_size </span><span class="symbol">==</span><span class="normal"> o</span><span class="symbol">.</span><span class="normal">key_type_size</span><span class="symbol">)</span>
<span class="normal">		</span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">data_type_size </span><span class="symbol">==</span><span class="normal"> o</span><span class="symbol">.</span><span class="normal">data_type_size</span><span class="symbol">)</span>
<span class="normal">		</span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leafslots </span><span class="symbol">==</span><span class="normal"> o</span><span class="symbol">.</span><span class="normal">leafslots</span><span class="symbol">)</span>
<span class="normal">		</span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">innerslots </span><span class="symbol">==</span><span class="normal"> o</span><span class="symbol">.</span><span class="normal">innerslots</span><span class="symbol">)</span>
<span class="normal">		</span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">allow_duplicates </span><span class="symbol">==</span><span class="normal"> o</span><span class="symbol">.</span><span class="normal">allow_duplicates</span><span class="symbol">);</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">    </span><span class="comment">/// Dump the contents of the B+ tree out onto an ostream as a binary</span>
<span class="normal">    </span><span class="comment">/// image. The image contains memory pointers which will be fixed when the</span>
<span class="normal">    </span><span class="comment">/// image is restored. For this to work your key_type and data_type must be</span>
<span class="normal">    </span><span class="comment">/// integral types and contain no pointers or references.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">dump</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="usertype">ostream</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">os</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">dump_header</span><span class="normal"> header</span><span class="symbol">;</span>
<span class="normal">	header</span><span class="symbol">.</span><span class="function">fill</span><span class="symbol">();</span>
<span class="normal">	header</span><span class="symbol">.</span><span class="normal">itemcount </span><span class="symbol">=</span><span class="normal"> </span><span class="function">size</span><span class="symbol">();</span>

<span class="normal">	os</span><span class="symbol">.</span><span class="function">write</span><span class="symbol">(</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="type">char</span><span class="symbol">*&gt;(&amp;</span><span class="normal">header</span><span class="symbol">),</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">header</span><span class="symbol">));</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">root</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="function">dump_node</span><span class="symbol">(</span><span class="normal">os</span><span class="symbol">,</span><span class="normal"> root</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Restore a binary image of a dumped B+ tree from an istream. The B+ tree</span>
<span class="normal">    </span><span class="comment">/// pointers are fixed using the dump order. For dump and restore to work</span>
<span class="normal">    </span><span class="comment">/// your key_type and data_type must be integral types and contain no</span>
<span class="normal">    </span><span class="comment">/// pointers or references. Returns true if the restore was successful.</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">restore</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="usertype">istream</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">is</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">dump_header</span><span class="normal"> fileheader</span><span class="symbol">;</span>
<span class="normal">	is</span><span class="symbol">.</span><span class="function">read</span><span class="symbol">(</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="type">char</span><span class="symbol">*&gt;(&amp;</span><span class="normal">fileheader</span><span class="symbol">),</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">fileheader</span><span class="symbol">));</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">is</span><span class="symbol">.</span><span class="function">good</span><span class="symbol">())</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">dump_header</span><span class="normal"> myheader</span><span class="symbol">;</span>
<span class="normal">	myheader</span><span class="symbol">.</span><span class="function">fill</span><span class="symbol">();</span>
<span class="normal">	myheader</span><span class="symbol">.</span><span class="normal">itemcount </span><span class="symbol">=</span><span class="normal"> fileheader</span><span class="symbol">.</span><span class="normal">itemcount</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">myheader</span><span class="symbol">.</span><span class="function">same</span><span class="symbol">(</span><span class="normal">fileheader</span><span class="symbol">))</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"btree::restore: file header does not match instantiation signature."</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="function">clear</span><span class="symbol">();</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">fileheader</span><span class="symbol">.</span><span class="normal">itemcount </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    root </span><span class="symbol">=</span><span class="normal"> </span><span class="function">restore_node</span><span class="symbol">(</span><span class="normal">is</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">root </span><span class="symbol">==</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>

<span class="normal">	    stats</span><span class="symbol">.</span><span class="normal">itemcount </span><span class="symbol">=</span><span class="normal"> fileheader</span><span class="symbol">.</span><span class="normal">itemcount</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">)</span><span class="normal"> </span><span class="function">print</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">cout</span><span class="symbol">);</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">selfverify</span><span class="symbol">)</span><span class="normal"> </span><span class="function">verify</span><span class="symbol">();</span>

<span class="normal">	</span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">private</span><span class="symbol">:</span>

<span class="normal">    </span><span class="comment">/// Recursively descend down the tree and dump each node in a precise order</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">dump_node</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="usertype">ostream</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> node</span><span class="symbol">*</span><span class="normal"> n</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="function">BTREE_PRINT</span><span class="symbol">(</span><span class="string">"dump_node "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> n </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">);</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">-&gt;</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">leaf </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> leaf_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	    os</span><span class="symbol">.</span><span class="function">write</span><span class="symbol">(</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*&gt;(</span><span class="normal">leaf</span><span class="symbol">),</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(*</span><span class="normal">leaf</span><span class="symbol">));</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span><span class="normal"> </span><span class="comment">// !n-&gt;isleafnode()</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inner </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">static_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> inner_node</span><span class="symbol">*&gt;(</span><span class="normal">n</span><span class="symbol">);</span>

<span class="normal">	    os</span><span class="symbol">.</span><span class="function">write</span><span class="symbol">(</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*&gt;(</span><span class="normal">inner</span><span class="symbol">),</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(*</span><span class="normal">inner</span><span class="symbol">));</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">subnode </span><span class="symbol">=</span><span class="normal"> inner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">];</span>
<span class="normal">		</span>
<span class="normal">		</span><span class="function">dump_node</span><span class="symbol">(</span><span class="normal">os</span><span class="symbol">,</span><span class="normal"> subnode</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Read the dump image and construct a tree from the node order in the</span>
<span class="normal">    </span><span class="comment">/// serialization.</span>
<span class="normal">    node</span><span class="symbol">*</span><span class="normal"> </span><span class="function">restore_node</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="usertype">istream</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">is</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="keyword">union</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="usertype">node</span><span class="normal"> 	top</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="usertype">leaf_node</span><span class="normal"> 	leaf</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="usertype">inner_node</span><span class="normal"> 	inner</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span><span class="normal"> nu</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">// first read only the top of the node</span>
<span class="normal">	is</span><span class="symbol">.</span><span class="function">read</span><span class="symbol">(</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="type">char</span><span class="symbol">*&gt;(&amp;</span><span class="normal">nu</span><span class="symbol">.</span><span class="normal">top</span><span class="symbol">),</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">nu</span><span class="symbol">.</span><span class="normal">top</span><span class="symbol">));</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">is</span><span class="symbol">.</span><span class="function">good</span><span class="symbol">())</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> NULL</span><span class="symbol">;</span>

<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">nu</span><span class="symbol">.</span><span class="normal">top</span><span class="symbol">.</span><span class="function">isleafnode</span><span class="symbol">())</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="comment">// read remaining data of leaf node</span>
<span class="normal">	    is</span><span class="symbol">.</span><span class="function">read</span><span class="symbol">(</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="type">char</span><span class="symbol">*&gt;(&amp;</span><span class="normal">nu</span><span class="symbol">.</span><span class="normal">leaf</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">nu</span><span class="symbol">.</span><span class="normal">top</span><span class="symbol">),</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">nu</span><span class="symbol">.</span><span class="normal">leaf</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">nu</span><span class="symbol">.</span><span class="normal">top</span><span class="symbol">));</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">is</span><span class="symbol">.</span><span class="function">good</span><span class="symbol">())</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> NULL</span><span class="symbol">;</span>
<span class="normal">	    </span>
<span class="normal">	    </span><span class="usertype">leaf_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">newleaf </span><span class="symbol">=</span><span class="normal"> </span><span class="function">allocate_leaf</span><span class="symbol">();</span>

<span class="normal">	    </span><span class="comment">// copy over all data, the leaf nodes contain only their double linked list pointers</span>
<span class="normal">	    </span><span class="symbol">*</span><span class="normal">newleaf </span><span class="symbol">=</span><span class="normal"> nu</span><span class="symbol">.</span><span class="normal">leaf</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="comment">// reconstruct the linked list from the order in the file</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">headleaf </span><span class="symbol">==</span><span class="normal"> NULL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		</span><span class="function">BTREE_ASSERT</span><span class="symbol">(</span><span class="normal">newleaf</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">==</span><span class="normal"> NULL</span><span class="symbol">);</span>
<span class="normal">		headleaf </span><span class="symbol">=</span><span class="normal"> tailleaf </span><span class="symbol">=</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		newleaf</span><span class="symbol">-&gt;</span><span class="normal">prevleaf </span><span class="symbol">=</span><span class="normal"> tailleaf</span><span class="symbol">;</span>
<span class="normal">		tailleaf</span><span class="symbol">-&gt;</span><span class="normal">nextleaf </span><span class="symbol">=</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">		tailleaf </span><span class="symbol">=</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> newleaf</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	</span><span class="keyword">else</span>
<span class="normal">	</span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="comment">// read remaining data of inner node</span>
<span class="normal">	    is</span><span class="symbol">.</span><span class="function">read</span><span class="symbol">(</span><span class="keyword">reinterpret_cast</span><span class="symbol">&lt;</span><span class="type">char</span><span class="symbol">*&gt;(&amp;</span><span class="normal">nu</span><span class="symbol">.</span><span class="normal">inner</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">nu</span><span class="symbol">.</span><span class="normal">top</span><span class="symbol">),</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">nu</span><span class="symbol">.</span><span class="normal">inner</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">nu</span><span class="symbol">.</span><span class="normal">top</span><span class="symbol">));</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">is</span><span class="symbol">.</span><span class="function">good</span><span class="symbol">())</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> NULL</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="usertype">inner_node</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">newinner </span><span class="symbol">=</span><span class="normal"> </span><span class="function">allocate_inner</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">);</span>

<span class="normal">	    </span><span class="comment">// copy over all data, the inner nodes contain only pointers to their children</span>
<span class="normal">	    </span><span class="symbol">*</span><span class="normal">newinner </span><span class="symbol">=</span><span class="normal"> nu</span><span class="symbol">.</span><span class="normal">inner</span><span class="symbol">;</span>

<span class="normal">	    </span><span class="keyword">for</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> slot </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> slot </span><span class="symbol">&lt;=</span><span class="normal"> newinner</span><span class="symbol">-&gt;</span><span class="normal">slotuse</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">slot</span><span class="symbol">)</span>
<span class="normal">	    </span><span class="cbracket">{</span>
<span class="normal">		newinner</span><span class="symbol">-&gt;</span><span class="normal">childid</span><span class="symbol">[</span><span class="normal">slot</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="function">restore_node</span><span class="symbol">(</span><span class="normal">is</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="cbracket">}</span>

<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> newinner</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="cbracket">}</span><span class="normal"> </span><span class="comment">// namespace stx</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// _STX_BTREE_H_</span>
</tt></pre></div><footer><div style="text-align: right; padding: 8pt; font-size: 13px"><a href="/xmlfeed/weblog-rss20.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABQAAAADwCexKkxAAAAWUlEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMCt0ZdTU/F/7/+1HEkydFpoKVPn+93sUlUujQvP/7UcRTAuNDJ2a//s/imDqtKVZofm/1qGYSZk7sfodGwAAiobBJtffoNAAAAAASUVORK5CYII=" alt="RSS 2.0 Weblog Feed" width="80" height="15"/></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAAaklEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMDV16rTQ/H/7V//69+//v/3/9oMEI6cuAwr+fv/+/b5d///v//0eJBgWOhMo+Gs9UPAdXDBy6lSYyn9wQZCZS0GCYDPXQcykzJ1Y/Y4NAABKvL80wyoMPgAAAABJRU5ErkJggg==" alt="Atom 1.0 Weblog Feed" width="80" height="15"/></a> <a href="http://validator.w3.org/check?uri=referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABKklEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6qIGzIRiKZs9GFoEaMRuZhhrYqqJXy8uZYauRxC/VHew7e3YTPAxnI5swG6JxNrKBNjB1EFmIgV0+HA6C8pqqzhXG7BbJJROQIwViMYQ7G2oDQQNn57JyG7kxiCfObrBmS5+BHMuYLkTzMnYDm5WY4lOZZRPKZocxes+aPbuwCFsYohiICLvZsKBAMrDTQ7K/StveU8icTzrOL8JdLpOyWJ49u8Bx9ozw8DY7UYW03hhdxZAOSg2c3jN79rSJs1vSKmfOnpFXNJmynELlvExlAADnaZpLFGEC2wAAAABJRU5ErkJggg==" alt="Valid XHTML 1.1" width="80" height="15"/></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABEUlEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6mIEQCsIjwhKoga0qerW8nBm2Gkn8Ut3BvrNnN8HCcDYM2cBIogzs8uFwEJTXVHWuMGa3SC6ZgIgUqCEwdxJr4OxcVm4jNwbxxNkN1mzpM2ajGIjsPGK9PLtZiSk+lVk2oWx2GKP3rNmzC4tQwpDoIIQb2Okh2V+lbe8pZM4nHecX4S6XSVksz55d4Dh7Rnh4m52oQlpvjK5iSAelBk7vmT172sTZLWmVM2fPyCuaTFlOoXJepjIAANlljDGY/l5pAAAAAElFTkSuQmCC" alt="Valid CSS (2.1)" width="80" height="15"/></a><br/>Copyright 2005-2020 <a href="/about/">Timo Bingmann</a> - <a href="/about/impressum.html">Impressum</a></div></footer></body></html>