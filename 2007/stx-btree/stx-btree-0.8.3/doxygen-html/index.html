<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>STX B+ Tree Template Classes: STX B+ Tree Template Classes README</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>STX B+ Tree Template Classes README</h1>
<p>
<h3 align="center">0.8.3 </h3><dl class="author" compact><dt><b>Author:</b></dt><dd>Timo Bingmann (Mail: tb a-with-circle idlebox dot net) </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>2008-09-07</dd></dl>
<h2><a class="anchor" name="sec1">
Summary</a></h2>
The STX B+ Tree package is a set of C++ template classes implementing a B+ tree key/data container in main memory. The classes are designed as drop-in replacements of the STL containers <code>set</code>, <code>map</code>, <code>multiset</code> and <code>multimap</code> and follow their interfaces very closely. By packing multiple value pairs into each node of the tree the B+ tree reduces heap fragmentation and utilizes cache-line effects better than the standard red-black binary tree. The tree algorithms are based on the implementation in Cormen, Leiserson and Rivest's Introduction into Algorithms, Jan Jannink's paper and other algorithm resources. The classes contain extensive assertion and verification mechanisms to ensure the implementation's correctness by testing the tree invariants. To illustrate the B+ tree's structure a wxWidgets demo program is included in the source package.<h2><a class="anchor" name="sec2">
Website / API Docs / Bugs / License</a></h2>
The current source package can be downloaded from <a href="http://idlebox.net/2007/stx-btree/">http://idlebox.net/2007/stx-btree/</a><p>
The include files are extensively documented using doxygen. The compiled doxygen html documentation is included in the source package. It can also be viewed online at <a href="http://idlebox.net/2007/stx-btree/stx-btree-0.8.3/doxygen-html/">http://idlebox.net/2007/stx-btree/stx-btree-0.8.3/doxygen-html/</a> (if you are not reading it right now).<p>
The wxWidgets B+ tree demo program is located in the directory wxbtreedemo. Compiled binary versions can be found on the package web page mentioned above.<p>
If bugs should become known they will be posted on the above web page together with patches or corrected versions.<p>
The complete source code is released under the GNU Lesser General Public License v2.1 (LGPL) which can be found in the file COPYING.<h2><a class="anchor" name="sec3">
Original Application</a></h2>
The idea originally arose while coding a read-only database, which used a huge map of millions of non-sequential integer keys to 8-byte file offsets. When using the standard STL red-black tree implementation this would yield millions of 20-byte heap allocations and very slow search times due to the tree's height. So the original intension was to reduce memory fragmentation and improve search times. The B+ tree solves this by packing multiple data pairs into one node with a large number of descendant nodes.<p>
In computer science lectures it is often stated that using consecutive bytes in memory would be more cache-efficient, because the CPU's cache levels always fetch larger blocks from main memory. So it would be best to store the keys of a node in one continuous array. This way the inner scanning loop would be accelerated by benefiting from cache effects and pipelining speed-ups. Thus the cost of scanning for a matching key would be lower than in a red-black tree, even though the number of key comparisons are theoretically larger. This second aspect aroused my academic interest and resulted in the <a class="el" href="speedtest.html">speed test experiments</a>.<p>
A third inspiration was that no working C++ template implementation of a B+ tree could be found on the Internet. Now this one can be found.<h2><a class="anchor" name="sec4">
Implementation Overview</a></h2>
This implementation contains five main classes within the <a class="el" href="namespacestx.html">stx</a> namespace (blandly named Some Template eXtensions). The base class <a class="el" href="classstx_1_1btree.html">btree</a> implements the B+ tree algorithms using inner and leaf nodes in main memory. Almost all STL-required function calls are implemented (see below for the exceptions). The asymptotic time requirements of the STL standard are theoretically not always fulfilled. However in practice this B+ tree performs better than the STL's red-black tree at the cost of using more memory. See the <a class="el" href="speedtest.html">speed test results</a> for details.<p>
The base class is then specialized into <a class="el" href="classstx_1_1btree__set.html">btree_set</a>, <a class="el" href="classstx_1_1btree__multiset.html">btree_multiset</a>, <a class="el" href="classstx_1_1btree__map.html">btree_map</a> and <a class="el" href="classstx_1_1btree__multimap.html">btree_multimap</a> using default template parameters and facade functions. These classes are designed to be drop-in replacements for the corresponding STL containers.<p>
The insertion function splits the nodes on recursion unroll. Erase is largely based on Jannink's ideas. See <a href="http://dbpubs.stanford.edu:8090/pub/1995-19">http://dbpubs.stanford.edu:8090/pub/1995-19</a> for his paper on "Implementing Deletion in B+-trees".<p>
The two set classes (<a class="el" href="classstx_1_1btree__set.html">btree_set</a> and <a class="el" href="classstx_1_1btree__multiset.html">btree_multiset</a>) are derived from the base implementation <a class="el" href="classstx_1_1btree.html">class btree</a> by specifying an empty struct as data_type. All functions are adapted to provide the base class with empty placeholder objects. Note that it is somewhat inefficient to implement a set or multiset using a B+ tree: a plain B tree (without +) would hold no extra copies of the keys. The main focus was on implementing the maps.<h2><a class="anchor" name="sec5">
Problem with Separated Key/Data Arrays</a></h2>
The most noteworthy difference to the default red-black tree implementation of std::map is that the B+ tree does not hold key/data pairs together in memory. Instead each B+ tree node has two separate arrays containing keys and data values. This design was chosen to utilize cache-line effects while scanning the key array.<p>
However it also directly generates many problems in implementing the iterators' operators. These return a (writable) reference or pointer to a value_type, which is a std::pair composition. These data/key pairs however are not stored together and thus a temporary copy must be constructed. This copy should not be written to, because it is not stored back into the B+ tree. This effectively prohibits use of many STL algorithms which writing to the B+ tree's iterators. I would be grateful for hints on how to resolve this problem without folding the key and data arrays.<h2><a class="anchor" name="sec6">
Test Suite</a></h2>
The B+ tree distribution contains an extensive test suite using cppunit. According to gcov 91.9% of the <a class="el" href="btree_8h.html" title="Contains the main B+ tree implementation template class btree.">btree.h</a> implementation is covered.<h2><a class="anchor" name="sec7">
STL Incompatibilities</a></h2>
<h3><a class="anchor" name="sec7-1">
Key and Data Type Requirements</a></h3>
The tree algorithms currently do not use copy-construction. All key/data items are allocated in the nodes using the default-constructor and are subsequently only assigned new data (using <code>operator=</code>).<h3><a class="anchor" name="sec7-2">
Iterators' Operators</a></h3>
The most important incompatibility are the non-writable <code>operator*</code> and <code>operator-&gt;</code> of the <a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>. See above for a discussion of the problem on separated key/data arrays. Instead of <code>*iter</code> and <code>iter-&gt;</code> use the new function <code>iter.data()</code> which returns a writable reference to the data value in the tree.<h3><a class="anchor" name="sec7-3">
Erase Functions</a></h3>
The B+ tree supports only two erase functions:<p>
<div class="fragment"><pre class="fragment">size_type erase(<span class="keyword">const</span> key_type &amp;key); <span class="comment">// erase all data pairs matching key</span>
<span class="keywordtype">bool</span> erase_one(<span class="keyword">const</span> key_type &amp;key);  <span class="comment">// erase one data pair matching key</span>
</pre></div><p>
The following STL-required functions are not supported:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> erase(iterator iter);
<span class="keywordtype">void</span> erase(iterator first, iterator last);
</pre></div><h2><a class="anchor" name="sec8">
Extensions</a></h2>
Beyond the usual STL interface the B+ tree classes support some extra goodies.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Output the tree in a pseudo-hierarchical text dump to std::cout. This</span>
<span class="comment">// function requires that BTREE_DEBUG is defined prior to including the btree</span>
<span class="comment">// headers. Furthermore the key and data types must be std::ostream printable.</span>
<span class="keywordtype">void</span> print() <span class="keyword">const</span>;

<span class="comment">// Run extensive checks of the tree invariants. If a corruption in found the</span>
<span class="comment">// program will abort via assert(). See below on enabling auto-verification.</span>
<span class="keywordtype">void</span> verify() <span class="keyword">const</span>;

<span class="comment">// Serialize and restore the B+ tree nodes and data into/from a binary image.</span>
<span class="comment">// This requires that the key and data types are integral and contain no</span>
<span class="comment">// outside pointers or references.</span>
<span class="keywordtype">void</span> dump(std::ostream &amp;os) <span class="keyword">const</span>;
<span class="keywordtype">bool</span> restore(std::istream &amp;is);
</pre></div><h2><a class="anchor" name="sec9">
B+ Tree Traits</a></h2>
All tree template classes take a template parameter structure which holds important options of the implementation. The following structure shows which static variables specify the options and the corresponding defaults:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>btree_default_map_traits
{
    <span class="comment">// If true, the tree will self verify it's invariants after each insert()</span>
    <span class="comment">// or erase(). The header must have been compiled with BTREE_DEBUG</span>
    <span class="comment">// defined.</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span>   selfverify = <span class="keyword">false</span>;

    <span class="comment">// If true, the tree will print out debug information and a tree dump</span>
    <span class="comment">// during insert() or erase() operation. The header must have been</span>
    <span class="comment">// compiled with BTREE_DEBUG defined and key_type must be std::ostream</span>
    <span class="comment">// printable.</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span>   debug = <span class="keyword">false</span>;

    <span class="comment">// Number of slots in each leaf of the tree. Estimated so that each node</span>
    <span class="comment">// has a size of about 256 bytes.</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span>    leafslots =
                             MAX( 8, 256 / (<span class="keyword">sizeof</span>(_Key) + <span class="keyword">sizeof</span>(_Data)) );

    <span class="comment">// Number of slots in each inner node of the tree. Estimated so that each</span>
    <span class="comment">// node has a size of about 256 bytes.</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span>    innerslots =
                             MAX( 8, 256 / (<span class="keyword">sizeof</span>(_Key) + <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*)) );
};
</pre></div><h2><a class="anchor" name="sec10">
Speed Tests</a></h2>
See the extra page <a class="el" href="speedtest.html">Speed Test Results</a>. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Sep 7 17:32:38 2008 for STX B+ Tree Template Classes by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
