<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>STX B+ Tree Template Classes: stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacestx.html">stx</a>::<a class="el" href="classstx_1_1btree.html">btree</a>
  </div>
</div>
<div class="contents">
<h1>stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt; Class Template Reference</h1><!-- doxytag: class="stx::btree" -->Basic class implementing a base B+ tree data structure in memory.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="btree_8h-source.html">btree.h</a>&gt;</code>
<p>

<p>
<a href="classstx_1_1btree-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef _Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">First template parameter: The key type of the B+ tree.  <a href="#2054714c400894aa8822f0f52bc120cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef _Data&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Second template parameter: The data type associated with each key.  <a href="#ca29ad902418d86eeb9b9379a38e5fcd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef _Value&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#84c95e7319c922fe297b4acdf2e0910c">value_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Third template parameter: Composition pair of key and data types, this is required by the STL standard.  <a href="#84c95e7319c922fe297b4acdf2e0910c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef _Compare&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fourth template parameter: Key comparison function object.  <a href="#8f75664f479fc4ca3f54a3a5757d98a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef _Traits&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#a84bef0ec11542ba1f9c49566d653629">traits</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fifth template parameter: Traits object used to define more parameters of the B+ tree.  <a href="#a84bef0ec11542ba1f9c49566d653629"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classstx_1_1btree.html">btree</a>&lt; <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a>, <br>
<a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a>, <a class="el" href="classstx_1_1btree.html#84c95e7319c922fe297b4acdf2e0910c">value_type</a>, <br>
<a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a>, <a class="el" href="classstx_1_1btree.html#a84bef0ec11542ba1f9c49566d653629">traits</a>, <br>
<a class="el" href="classstx_1_1btree.html#35378979c13861883affefda9ad95df7">allow_duplicates</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#4f87f5cc9f7bb6ab9d00b7f72bfda460">btree_self</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef of our own type.  <a href="#4f87f5cc9f7bb6ab9d00b7f72bfda460"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#973470864b67129983ea4e1aa2132ac5">size_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size type used to count keys.  <a href="#973470864b67129983ea4e1aa2132ac5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::pair&lt; <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a>, <br>
<a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#f7a75a733f8547491913b0e5b8d11a4e">pair_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The pair of key_type and data_type, this may be different from value_type.  <a href="#f7a75a733f8547491913b0e5b8d11a4e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#ecde28ffeec27607c2fb56192d95f607">btree</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor initializing an empty B+ tree with the standard key comparison function.  <a href="#ecde28ffeec27607c2fb56192d95f607"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#ffc730f1b3d3a21347248970eeba2af5">btree</a> (const <a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a> &amp;kcf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor initializing an empty B+ tree with a special key comparison object.  <a href="#ffc730f1b3d3a21347248970eeba2af5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#6124edb5dc3280e48dea9323a2a1891f">btree</a> (InputIterator first, InputIterator last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor initializing a B+ tree with the range [first,last).  <a href="#6124edb5dc3280e48dea9323a2a1891f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#e1f4c758cb4c693f94709bf009587315">btree</a> (InputIterator first, InputIterator last, const <a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a> &amp;kcf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor initializing a B+ tree with the range [first,last) and a special key comparison object.  <a href="#e1f4c758cb4c693f94709bf009587315"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#3ae99b2caa919248a9ab8a7c7fddec6f">~btree</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees up all used B+ tree memory pages.  <a href="#3ae99b2caa919248a9ab8a7c7fddec6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#aab71acf938da1bfc93698b3236bb1ae">swap</a> (<a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;from)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast swapping of two identical B+ tree objects.  <a href="#aab71acf938da1bfc93698b3236bb1ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#43d1c2683f2dc078aa25e49820e9c237">key_comp</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant access to the key comparison object sorting the B+ tree.  <a href="#43d1c2683f2dc078aa25e49820e9c237"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1value__compare.html">value_compare</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#94273af1fe4b9e2e0c0b6daeaa5f5950">value_comp</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant access to a constructed value_type comparison object.  <a href="#94273af1fe4b9e2e0c0b6daeaa5f5950"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#cf6ccb1acc05ef2845dfa97c81b1be9f">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees all key/data pairs and all nodes of the tree.  <a href="#cf6ccb1acc05ef2845dfa97c81b1be9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#6551b60cb8a2f717555ceac61f34b957">begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a read/data-write <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first slot in the first leaf of the B+ tree.  <a href="#6551b60cb8a2f717555ceac61f34b957"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#14f8bf63680c8950aab8c5d54e580a14">end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a read/data-write <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#14f8bf63680c8950aab8c5d54e580a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#ea7a998112824a28d930bf324eedf60d">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a read-only constant <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first slot in the first leaf of the B+ tree.  <a href="#ea7a998112824a28d930bf324eedf60d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#c1378c6f8b3473b4bd4c175dba5dbb7b">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a read-only constant <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#c1378c6f8b3473b4bd4c175dba5dbb7b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1reverse__iterator.html">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#4d3a4b24d8cc56c589800655cf83c806">rbegin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a read/data-write reverse <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#4d3a4b24d8cc56c589800655cf83c806"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1reverse__iterator.html">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#6d9e5a5b0ec598a76e602aa6a19900ff">rend</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a read/data-write reverse <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first slot in the first leaf of the B+ tree.  <a href="#6d9e5a5b0ec598a76e602aa6a19900ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1const__reverse__iterator.html">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#38a7bfd129ae2a39f228f53c39561bf8">rbegin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a read-only reverse <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first invalid slot in the last leaf of the B+ tree.  <a href="#38a7bfd129ae2a39f228f53c39561bf8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1const__reverse__iterator.html">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#c925da8e9151dbecdf063dc5af78a903">rend</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a read-only reverse <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first slot in the first leaf of the B+ tree.  <a href="#c925da8e9151dbecdf063dc5af78a903"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree.html#973470864b67129983ea4e1aa2132ac5">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#5e32032d192795a5f25b49e23e3ef1a1">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of key/data pairs in the B+ tree.  <a href="#5e32032d192795a5f25b49e23e3ef1a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#ee6ae1b8d5832d3cd829a3962b776cd5">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if there is at least one key/data pair in the B+ tree.  <a href="#ee6ae1b8d5832d3cd829a3962b776cd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree.html#973470864b67129983ea4e1aa2132ac5">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#ae330348c9f4b6051864da4ebd157662">max_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the largest possible size of the B+ Tree.  <a href="#ae330348c9f4b6051864da4ebd157662"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structstx_1_1btree_1_1tree__stats.html">tree_stats</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#8748bb3788c1e1d65dbfe9500d33a134">get_stats</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const reference to the current statistics.  <a href="#8748bb3788c1e1d65dbfe9500d33a134"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#9405c7a274bcc76f27b4e84c49fcaa0d">exists</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-STL function checking whether a key is in the B+ tree.  <a href="#9405c7a274bcc76f27b4e84c49fcaa0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#2be7e3a978a71f86e433a0244c7414c6">find</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns an <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the key/data slot if found.  <a href="#2be7e3a978a71f86e433a0244c7414c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#fcda5e66264982ba77eaebaf665763f9">find</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns an constant <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the key/data slot if found.  <a href="#fcda5e66264982ba77eaebaf665763f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree.html#973470864b67129983ea4e1aa2132ac5">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#36754fc4a90de86806a91cc22eafbe78">count</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to locate a key in the B+ tree and returns the number of identical key entries found.  <a href="#36754fc4a90de86806a91cc22eafbe78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#74e859adf01a516a382579a614f12673">lower_bound</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches the B+ tree and returns an <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the first key less or equal to the parameter.  <a href="#74e859adf01a516a382579a614f12673"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#1a68298c1097edde3820d2be1b5e8966">lower_bound</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches the B+ tree and returns an constant <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the first key less or equal to the parameter.  <a href="#1a68298c1097edde3820d2be1b5e8966"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#789cbe4a94251e756041c5504127ac50">upper_bound</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches the B+ tree and returns an <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the first key greater than the parameter.  <a href="#789cbe4a94251e756041c5504127ac50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#1c04d1a6c7d3be8979a7ab9057da1174">upper_bound</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches the B+ tree and returns an constant <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the first key greater than the parameter.  <a href="#1c04d1a6c7d3be8979a7ab9057da1174"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, <a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#598ffaab5e27bf4e10de0f757938744c">equal_range</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches the B+ tree and returns both <a class="el" href="classstx_1_1btree.html#74e859adf01a516a382579a614f12673" title="Searches the B+ tree and returns an iterator to the first key less or equal to the...">lower_bound()</a> and <a class="el" href="classstx_1_1btree.html#789cbe4a94251e756041c5504127ac50" title="Searches the B+ tree and returns an iterator to the first key greater than the parameter...">upper_bound()</a>.  <a href="#598ffaab5e27bf4e10de0f757938744c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a>, <br>
<a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#6c0e42e4d10e1ed6af48d449a7a8345f">equal_range</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches the B+ tree and returns both <a class="el" href="classstx_1_1btree.html#74e859adf01a516a382579a614f12673" title="Searches the B+ tree and returns an iterator to the first key less or equal to the...">lower_bound()</a> and <a class="el" href="classstx_1_1btree.html#789cbe4a94251e756041c5504127ac50" title="Searches the B+ tree and returns an iterator to the first key greater than the parameter...">upper_bound()</a>.  <a href="#6c0e42e4d10e1ed6af48d449a7a8345f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#081621ee81f875602a1788690879e7f9">operator==</a> (const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality relation of B+ trees of the same type.  <a href="#081621ee81f875602a1788690879e7f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#8bd8cb1bed1ba5ad6224d7f0220d1cad">operator!=</a> (const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality relation. Based on operator==.  <a href="#8bd8cb1bed1ba5ad6224d7f0220d1cad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#2ece54f92f9376137a29dc08a7d2efc9">operator&lt;</a> (const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Total ordering relation of B+ trees of the same type.  <a href="#2ece54f92f9376137a29dc08a7d2efc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#c36903fff62279a5052287c8b1ee38b2">operator&gt;</a> (const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Greater relation. Based on operator&lt;.  <a href="#c36903fff62279a5052287c8b1ee38b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#2acd154e278f971fca7da303366e528b">operator&lt;=</a> (const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Less-equal relation. Based on operator&lt;.  <a href="#2acd154e278f971fca7da303366e528b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#3e0185adba298bb184103a1975b3cbe4">operator&gt;=</a> (const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Greater-equal relation. Based on operator&lt;.  <a href="#3e0185adba298bb184103a1975b3cbe4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#bc9ee03092fc58297b2d2c87199a0f66">operator=</a> (const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">*** Fast Copy: Assign Operator and Copy Constructors  <a href="#bc9ee03092fc58297b2d2c87199a0f66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#af4b2be231fb3cb4c365c516115ed5bf">btree</a> (const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#af4b2be231fb3cb4c365c516115ed5bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#6a96ea1453ad3392ad4722265ceae976">insert</a> (const <a class="el" href="classstx_1_1btree.html#f7a75a733f8547491913b0e5b8d11a4e">pair_type</a> &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to insert a key/data pair into the B+ tree.  <a href="#6a96ea1453ad3392ad4722265ceae976"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#63cf076cefd57cdc773170e8f7dc0b41">insert</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key, const <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a> &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to insert a key/data pair into the B+ tree.  <a href="#63cf076cefd57cdc773170e8f7dc0b41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#45d95a83fbbfa0211a972b8f7451a19c">insert2</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key, const <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a> &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to insert a key/data pair into the B+ tree.  <a href="#45d95a83fbbfa0211a972b8f7451a19c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#19879710dc73555397fc83acf1d00328">insert</a> (<a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, const <a class="el" href="classstx_1_1btree.html#f7a75a733f8547491913b0e5b8d11a4e">pair_type</a> &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to insert a key/data pair into the B+ tree.  <a href="#19879710dc73555397fc83acf1d00328"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#21daa4ef5ae703f189ec3c917113b780">insert2</a> (<a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key, const <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a> &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to insert a key/data pair into the B+ tree.  <a href="#21daa4ef5ae703f189ec3c917113b780"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#0c47337c74d366a69ba38131be49e6fa">insert</a> (InputIterator first, InputIterator last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to insert the range [first,last) of value_type pairs into the B+ tree.  <a href="#0c47337c74d366a69ba38131be49e6fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#c01d4b6b26e5c8447e92651168b006d4">erase_one</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases one (the first) of the key/data pairs associated with the given key.  <a href="#c01d4b6b26e5c8447e92651168b006d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree.html#973470864b67129983ea4e1aa2132ac5">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#97f6c7874f508e5d1498161a0181606e">erase</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases all the key/data pairs associated with the given key.  <a href="#97f6c7874f508e5d1498161a0181606e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#b006ef721a55f2e6eaee5d4b22cc2ebc">erase</a> (<a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a> iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase the key/data pair referenced by the <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a>.  <a href="#b006ef721a55f2e6eaee5d4b22cc2ebc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#20393dc10d658f3e7883bb69aa9cdde8">erase</a> (<a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, <a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all key/data pairs in the range [first,last).  <a href="#20393dc10d658f3e7883bb69aa9cdde8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#97664fdfb85917808eee2aa8487c5e39">print</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print out the B+ tree structure with keys onto the given ostream.  <a href="#97664fdfb85917808eee2aa8487c5e39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#8270dcc972930a6f2c9f112af8b65075">print_leaves</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print out only the leaves via the double linked list.  <a href="#8270dcc972930a6f2c9f112af8b65075"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#e382217f25916442745eb83520b20c12">verify</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run a thorough verification of all B+ tree invariants.  <a href="#e382217f25916442745eb83520b20c12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#4d83f35e94a64b82ca3648d40fb31507">dump</a> (std::ostream &amp;os) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump the contents of the B+ tree out onto an ostream as a binary image.  <a href="#4d83f35e94a64b82ca3648d40fb31507"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#f386da3ca44e31b73f68b50630df3ab9">restore</a> (std::istream &amp;is)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore a binary image of a dumped B+ tree from an istream.  <a href="#f386da3ca44e31b73f68b50630df3ab9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#35378979c13861883affefda9ad95df7">allow_duplicates</a> = _Duplicates</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sixth template parameter: Allow duplicate keys in the B+ tree.  <a href="#35378979c13861883affefda9ad95df7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#12a39ca671e962924f4acf879a44eafc">leafslotmax</a> = traits::leafslots</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base B+ tree parameter: The number of key/data slots in each leaf.  <a href="#12a39ca671e962924f4acf879a44eafc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#83a18c2fb7f4e9cfd47ce7545d004324">innerslotmax</a> = traits::innerslots</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base B+ tree parameter: The number of key slots in each inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>, this can differ from slots in each leaf.  <a href="#83a18c2fb7f4e9cfd47ce7545d004324"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#c53c2fe18cd06916a25c3b2a6e0486eb">minleafslots</a> = (<a class="el" href="classstx_1_1btree.html#12a39ca671e962924f4acf879a44eafc">leafslotmax</a> / 2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computed B+ tree parameter: The minimum number of key/data slots used in a leaf.  <a href="#c53c2fe18cd06916a25c3b2a6e0486eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#14312352a7289cee65f1793b0183f60e">mininnerslots</a> = (<a class="el" href="classstx_1_1btree.html#83a18c2fb7f4e9cfd47ce7545d004324">innerslotmax</a> / 2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computed B+ tree parameter: The minimum number of key slots used in an inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>.  <a href="#14312352a7289cee65f1793b0183f60e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#ee2e25b0fccc7147fd8be0bcf8630b5b">selfverify</a> = traits::selfverify</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug parameter: Enables expensive and thorough checking of the B+ tree invariants after each insert/erase operation.  <a href="#ee2e25b0fccc7147fd8be0bcf8630b5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#ac6ff74fe9fb9e87958d73c28cb9eef4">debug</a> = traits::debug</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Debug parameter: Prints out lots of debug information about how the algorithms change the tree.  <a href="#ac6ff74fe9fb9e87958d73c28cb9eef4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#971345163fcd46bfd726cb31ad5cd02b">result_flags_t</a> { <a class="el" href="classstx_1_1btree.html#971345163fcd46bfd726cb31ad5cd02b76e78fd0f7a6075c905f3ef9581c1ee1">btree_ok</a> =  0, 
<a class="el" href="classstx_1_1btree.html#971345163fcd46bfd726cb31ad5cd02b6137f9692d832a3df82f0d2139d00c6b">btree_not_found</a> =  1, 
<a class="el" href="classstx_1_1btree.html#971345163fcd46bfd726cb31ad5cd02bfa91b1cf87110d0008592aeb78ce65e7">btree_update_lastkey</a> =  2, 
<a class="el" href="classstx_1_1btree.html#971345163fcd46bfd726cb31ad5cd02b6ad2378afb40ca40049df5f0ec3a0647">btree_fixmerge</a> =  4
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Result flags of recursive deletion.  <a href="classstx_1_1btree.html#971345163fcd46bfd726cb31ad5cd02b">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef btree_pair_to_value<br>
&lt; <a class="el" href="classstx_1_1btree.html#84c95e7319c922fe297b4acdf2e0910c">value_type</a>, <a class="el" href="classstx_1_1btree.html#f7a75a733f8547491913b0e5b8d11a4e">pair_type</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#d00ea2b529c201236f4c79cd50acf42e">pair_to_value_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Using template specialization select the correct converter used by the iterators.  <a href="#d00ea2b529c201236f4c79cd50acf42e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#b20b48ee5b3b4a1d4e216d5948f8c1a0">key_lessequal</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;a, const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if a &lt;= b ? constructed from <a class="el" href="classstx_1_1btree.html#5e618ec38c852d5b81d997bdc932d592" title="Key comparison object.">key_less()</a>.  <a href="#b20b48ee5b3b4a1d4e216d5948f8c1a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#7bb87c4c13cd7a4412da72ef93ab082e">key_greater</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;a, const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if a &gt; b ? constructed from <a class="el" href="classstx_1_1btree.html#5e618ec38c852d5b81d997bdc932d592" title="Key comparison object.">key_less()</a>.  <a href="#7bb87c4c13cd7a4412da72ef93ab082e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#0571b5b68a6ef06b7606975a7176867c">key_greaterequal</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;a, const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if a &gt;= b ? constructed from <a class="el" href="classstx_1_1btree.html#5e618ec38c852d5b81d997bdc932d592" title="Key comparison object.">key_less()</a>.  <a href="#0571b5b68a6ef06b7606975a7176867c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#f09828d360e903d40c9f8c77183bea0e">key_equal</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;a, const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if a == b ? constructed from <a class="el" href="classstx_1_1btree.html#5e618ec38c852d5b81d997bdc932d592" title="Key comparison object.">key_less()</a>.  <a href="#f09828d360e903d40c9f8c77183bea0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#359771538c203e0e8e301135783fa4a4">allocate_leaf</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize a leaf <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>.  <a href="#359771538c203e0e8e301135783fa4a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#48afc242f523282f8833580a5370ff81">allocate_inner</a> (unsigned short l)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize an inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>.  <a href="#48afc242f523282f8833580a5370ff81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#0bbb2111654adc0acbd302488c602ad1">free_node</a> (<a class="el" href="structstx_1_1btree_1_1node.html">node</a> *n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Correctly free either inner or leaf <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>, destructs all contained key and value objects.  <a href="#0bbb2111654adc0acbd302488c602ad1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#e5b3a26d39b65796596a6210b397e393">clear_recursive</a> (<a class="el" href="structstx_1_1btree_1_1node.html">node</a> *n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively free up nodes.  <a href="#e5b3a26d39b65796596a6210b397e393"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename node_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#a25d79d1749e5eb8a81a103534707a77">find_lower</a> (const node_type *n, const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the first key in the <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> n less or equal to key.  <a href="#a25d79d1749e5eb8a81a103534707a77"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename node_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#43f2350acdc804684ddefe3ee1271978">find_upper</a> (const node_type *n, const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the first key in the <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> n greater than key.  <a href="#43f2350acdc804684ddefe3ee1271978"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#f398f002480cf8a7d5c67fd3d2c33a4d">copy_recursive</a> (const <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively copy nodes from another B+ tree object.  <a href="#f398f002480cf8a7d5c67fd3d2c33a4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#754a5b04887a9df1cb0e51afffc36bfd">insert_start</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key, const <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a> &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the insertion descent at the current root and handle root splits.  <a href="#754a5b04887a9df1cb0e51afffc36bfd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#9f24e411dd05b99edb58935389c1664d">insert_descend</a> (<a class="el" href="structstx_1_1btree_1_1node.html">node</a> *n, const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key, const <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a> &amp;value, <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> *splitkey, <a class="el" href="structstx_1_1btree_1_1node.html">node</a> **splitnode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an item into the B+ tree.  <a href="#9f24e411dd05b99edb58935389c1664d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#65184b7ff0a48d7c013041dac45ddab9">split_leaf_node</a> (<a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *leaf, <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> *_newkey, <a class="el" href="structstx_1_1btree_1_1node.html">node</a> **_newleaf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split up a leaf <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> into two equally-filled sibling leaves.  <a href="#65184b7ff0a48d7c013041dac45ddab9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#bba0627e1a8a9fa86ff1b44e6c8f8dea">split_inner_node</a> (<a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *inner, <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> *_newkey, <a class="el" href="structstx_1_1btree_1_1node.html">node</a> **_newinner, unsigned int addslot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split up an inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> into two equally-filled sibling nodes.  <a href="#bba0627e1a8a9fa86ff1b44e6c8f8dea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">result_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#40e3e935186128e71b90ad2482fc73a7">erase_one_descend</a> (const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;key, <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *curr, <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *left, <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *right, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *leftparent, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *rightparent, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *parent, unsigned int parentslot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase one (the first) key/data pair in the B+ tree matching key.  <a href="#40e3e935186128e71b90ad2482fc73a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">result_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#d3713fe9737e461701b4fe44a829df50">merge_leaves</a> (<a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *left, <a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *right, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge two leaf nodes.  <a href="#d3713fe9737e461701b4fe44a829df50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#a801e588f707be300927cf0c5bbd0f24">verify_node</a> (const <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *n, <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> *minkey, <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> *maxkey, <a class="el" href="structstx_1_1btree_1_1tree__stats.html">tree_stats</a> &amp;vstats) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively descend down the tree and verify each <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>.  <a href="#a801e588f707be300927cf0c5bbd0f24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#2acaf6a7e8ad48bd1c73e9b3b2f2fb18">verify_leaflinks</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verify the double linked list of leaves.  <a href="#2acaf6a7e8ad48bd1c73e9b3b2f2fb18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#62b6b49019ad87ed911e6786bf3cc26a">dump_node</a> (std::ostream &amp;os, const <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *n) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively descend down the tree and dump each <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> in a precise order.  <a href="#62b6b49019ad87ed911e6786bf3cc26a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#0ff07bf2c03e4a11ef365ba475cb004b">restore_node</a> (std::istream &amp;is)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the dump image and construct a tree from the <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> order in the serialization.  <a href="#0ff07bf2c03e4a11ef365ba475cb004b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static result_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#ba98442f1692cc1c7b4f5ed52f67a186">merge_inner</a> (<a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *left, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *right, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *parent, unsigned int parentslot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge two inner nodes.  <a href="#ba98442f1692cc1c7b4f5ed52f67a186"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static result_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#0475590170b5e17b990ab5d5bd95c4f6">shift_left_leaf</a> (<a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *left, <a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *right, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *parent, unsigned int parentslot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Balance two leaf nodes.  <a href="#0475590170b5e17b990ab5d5bd95c4f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#f9728e843262c62d97dec3aaa5203382">shift_left_inner</a> (<a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *left, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *right, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *parent, unsigned int parentslot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Balance two inner nodes.  <a href="#f9728e843262c62d97dec3aaa5203382"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#68ca0e18a5d87ac38f651df2120ac8a6">shift_right_leaf</a> (<a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *left, <a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *right, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *parent, unsigned int parentslot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Balance two leaf nodes.  <a href="#68ca0e18a5d87ac38f651df2120ac8a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#fd62fa2daf91ddd8848022df7d4e4179">shift_right_inner</a> (<a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *left, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *right, <a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *parent, unsigned int parentslot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Balance two inner nodes.  <a href="#fd62fa2daf91ddd8848022df7d4e4179"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#197122d34fc70adfd60219a98bbbb489">print_node</a> (std::ostream &amp;os, const <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *<a class="el" href="structstx_1_1btree_1_1node.html">node</a>, unsigned int depth=0, bool recursive=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively descend down the tree and print out nodes.  <a href="#197122d34fc70adfd60219a98bbbb489"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#83837b81c8d30c09c4e91d9921efd4a0">root</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the B+ tree's root <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>, either leaf or inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>.  <a href="#83837b81c8d30c09c4e91d9921efd4a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#de7d8981baba296625eae14006d2c760">headleaf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to first leaf in the double linked leaf chain.  <a href="#de7d8981baba296625eae14006d2c760"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#84f024ba0a8d91eb94571092bec9fb96">tailleaf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to last leaf in the double linked leaf chain.  <a href="#84f024ba0a8d91eb94571092bec9fb96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structstx_1_1btree_1_1tree__stats.html">tree_stats</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#191ecb365eda1096adef4cb7ae223606">stats</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Other small statistics about the B+ tree.  <a href="#191ecb365eda1096adef4cb7ae223606"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree.html#5e618ec38c852d5b81d997bdc932d592">key_less</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Key comparison object.  <a href="#5e618ec38c852d5b81d997bdc932d592"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>btree_pair_to_value</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>btree_pair_to_value&lt; value_type, value_type &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like read-only <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> object for B+ tree items.  <a href="classstx_1_1btree_1_1const__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree_1_1const__reverse__iterator.html">const_reverse_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like read-only reverse <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> object for B+ tree items.  <a href="classstx_1_1btree_1_1const__reverse__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>dump_header</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended structure of a inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> in-memory.  <a href="structstx_1_1btree_1_1inner__node.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> object for B+ tree items.  <a href="classstx_1_1btree_1_1iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended structure of a leaf <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> in memory.  <a href="structstx_1_1btree_1_1leaf__node.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstx_1_1btree_1_1node.html">node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The header structure of each <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> in-memory.  <a href="structstx_1_1btree_1_1node.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>result_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree_1_1reverse__iterator.html">reverse_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like mutable reverse <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> object for B+ tree items.  <a href="classstx_1_1btree_1_1reverse__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstx_1_1btree_1_1tree__stats.html">tree_stats</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A small struct containing basic statistics about the B+ tree.  <a href="structstx_1_1btree_1_1tree__stats.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1btree_1_1value__compare.html">value_compare</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function class to compare value_type objects. Required by the STL.  <a href="classstx_1_1btree_1_1value__compare.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt;<br>
 class stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;</h3>

Basic class implementing a base B+ tree data structure in memory. 
<p>
The base implementation of a memory B+ tree. It is based on the implementation in Cormen's Introduction into Algorithms, Jan Jannink's paper and other algorithm resources. Almost all STL-required function calls are implemented. The asymptotic time requirements of the STL are not always fulfilled in theory, however in practice this B+ tree performs better than a red-black tree by using more memory. The insertion function splits the nodes on the recursion unroll. Erase is largely based on Jannink's ideas.<p>
This class is specialized into <a class="el" href="classstx_1_1btree__set.html" title="Specialized B+ tree template class implementing STL&#39;s set container.">btree_set</a>, <a class="el" href="classstx_1_1btree__multiset.html" title="Specialized B+ tree template class implementing STL&#39;s multiset container.">btree_multiset</a>, <a class="el" href="classstx_1_1btree__map.html" title="Specialized B+ tree template class implementing STL&#39;s map container.">btree_map</a> and <a class="el" href="classstx_1_1btree__multimap.html" title="Specialized B+ tree template class implementing STL&#39;s multimap container.">btree_multimap</a> using default template parameters and facade functions. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l00137">137</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="2054714c400894aa8822f0f52bc120cf"></a><!-- doxytag: member="stx::btree::key_type" ref="2054714c400894aa8822f0f52bc120cf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Key <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
First template parameter: The key type of the B+ tree. 
<p>
This is stored in inner nodes and leaves 
<p>Definition at line <a class="el" href="btree_8h-source.html#l00144">144</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="ca29ad902418d86eeb9b9379a38e5fcd"></a><!-- doxytag: member="stx::btree::data_type" ref="ca29ad902418d86eeb9b9379a38e5fcd" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Data <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Second template parameter: The data type associated with each key. 
<p>
Stored in the B+ tree's leaves 
<p>Definition at line <a class="el" href="btree_8h-source.html#l00148">148</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="84c95e7319c922fe297b4acdf2e0910c"></a><!-- doxytag: member="stx::btree::value_type" ref="84c95e7319c922fe297b4acdf2e0910c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Value <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#84c95e7319c922fe297b4acdf2e0910c">value_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Third template parameter: Composition pair of key and data types, this is required by the STL standard. 
<p>
The B+ tree does not store key and data together. If value_type == key_type then the B+ tree implements a set. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l00154">154</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8f75664f479fc4ca3f54a3a5757d98a7"></a><!-- doxytag: member="stx::btree::key_compare" ref="8f75664f479fc4ca3f54a3a5757d98a7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Compare <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fourth template parameter: Key comparison function object. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l00157">157</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a84bef0ec11542ba1f9c49566d653629"></a><!-- doxytag: member="stx::btree::traits" ref="a84bef0ec11542ba1f9c49566d653629" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Traits <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#a84bef0ec11542ba1f9c49566d653629">traits</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fifth template parameter: Traits object used to define more parameters of the B+ tree. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l00161">161</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4f87f5cc9f7bb6ab9d00b7f72bfda460"></a><!-- doxytag: member="stx::btree::btree_self" ref="4f87f5cc9f7bb6ab9d00b7f72bfda460" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classstx_1_1btree.html">btree</a>&lt;<a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a>, <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a>, <a class="el" href="classstx_1_1btree.html#84c95e7319c922fe297b4acdf2e0910c">value_type</a>, <a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a>, <a class="el" href="classstx_1_1btree.html#a84bef0ec11542ba1f9c49566d653629">traits</a>, <a class="el" href="classstx_1_1btree.html#35378979c13861883affefda9ad95df7">allow_duplicates</a>&gt; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html">btree_self</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Typedef of our own type. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l00177">177</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="973470864b67129983ea4e1aa2132ac5"></a><!-- doxytag: member="stx::btree::size_type" ref="973470864b67129983ea4e1aa2132ac5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#973470864b67129983ea4e1aa2132ac5">size_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size type used to count keys. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l00180">180</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f7a75a733f8547491913b0e5b8d11a4e"></a><!-- doxytag: member="stx::btree::pair_type" ref="f7a75a733f8547491913b0e5b8d11a4e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a>, <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a>&gt; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#f7a75a733f8547491913b0e5b8d11a4e">pair_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The pair of key_type and data_type, this may be different from value_type. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l00183">183</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d00ea2b529c201236f4c79cd50acf42e"></a><!-- doxytag: member="stx::btree::pair_to_value_type" ref="d00ea2b529c201236f4c79cd50acf42e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef btree_pair_to_value&lt;<a class="el" href="classstx_1_1btree.html#84c95e7319c922fe297b4acdf2e0910c">value_type</a>, <a class="el" href="classstx_1_1btree.html#f7a75a733f8547491913b0e5b8d11a4e">pair_type</a>&gt; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#d00ea2b529c201236f4c79cd50acf42e">pair_to_value_type</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Using template specialization select the correct converter used by the iterators. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l00354">354</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="971345163fcd46bfd726cb31ad5cd02b"></a><!-- doxytag: member="stx::btree::result_flags_t" ref="971345163fcd46bfd726cb31ad5cd02b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classstx_1_1btree.html#971345163fcd46bfd726cb31ad5cd02b">stx::btree::result_flags_t</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Result flags of recursive deletion. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="971345163fcd46bfd726cb31ad5cd02b76e78fd0f7a6075c905f3ef9581c1ee1"></a><!-- doxytag: member="btree_ok" ref="971345163fcd46bfd726cb31ad5cd02b76e78fd0f7a6075c905f3ef9581c1ee1" args="" -->btree_ok</em>&nbsp;</td><td>
Deletion successful and no fix-ups necessary. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="971345163fcd46bfd726cb31ad5cd02b6137f9692d832a3df82f0d2139d00c6b"></a><!-- doxytag: member="btree_not_found" ref="971345163fcd46bfd726cb31ad5cd02b6137f9692d832a3df82f0d2139d00c6b" args="" -->btree_not_found</em>&nbsp;</td><td>
Deletion not successful because key was not found. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="971345163fcd46bfd726cb31ad5cd02bfa91b1cf87110d0008592aeb78ce65e7"></a><!-- doxytag: member="btree_update_lastkey" ref="971345163fcd46bfd726cb31ad5cd02bfa91b1cf87110d0008592aeb78ce65e7" args="" -->btree_update_lastkey</em>&nbsp;</td><td>
Deletion successful, the last key was updated so parent slotkeys need updates. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="971345163fcd46bfd726cb31ad5cd02b6ad2378afb40ca40049df5f0ec3a0647"></a><!-- doxytag: member="btree_fixmerge" ref="971345163fcd46bfd726cb31ad5cd02b6ad2378afb40ca40049df5f0ec3a0647" args="" -->btree_fixmerge</em>&nbsp;</td><td>
Deletion successful, children nodes were merged and the parent needs to remove the empty <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>. 
<p>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="btree_8h-source.html#l02273">2273</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="ecde28ffeec27607c2fb56192d95f607"></a><!-- doxytag: member="stx::btree::btree" ref="ecde28ffeec27607c2fb56192d95f607" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html">btree</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor initializing an empty B+ tree with the standard key comparison function. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01244">1244</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="ffc730f1b3d3a21347248970eeba2af5"></a><!-- doxytag: member="stx::btree::btree" ref="ffc730f1b3d3a21347248970eeba2af5" args="(const key_compare &amp;kcf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html">btree</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>kcf</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor initializing an empty B+ tree with a special key comparison object. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01251">1251</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="6124edb5dc3280e48dea9323a2a1891f"></a><!-- doxytag: member="stx::btree::btree" ref="6124edb5dc3280e48dea9323a2a1891f" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html">btree</a>           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor initializing a B+ tree with the range [first,last). 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01259">1259</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e1f4c758cb4c693f94709bf009587315"></a><!-- doxytag: member="stx::btree::btree" ref="e1f4c758cb4c693f94709bf009587315" args="(InputIterator first, InputIterator last, const key_compare &amp;kcf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html">btree</a>           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>kcf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor initializing a B+ tree with the range [first,last) and a special key comparison object. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01268">1268</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3ae99b2caa919248a9ab8a7c7fddec6f"></a><!-- doxytag: member="stx::btree::~btree" ref="3ae99b2caa919248a9ab8a7c7fddec6f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::~<a class="el" href="classstx_1_1btree.html">btree</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees up all used B+ tree memory pages. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01276">1276</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="af4b2be231fb3cb4c365c516115ed5bf"></a><!-- doxytag: member="stx::btree::btree" ref="af4b2be231fb3cb4c365c516115ed5bf" args="(const btree_self &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html">btree</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
The newly initialized B+ tree object will contain a copy of all key/data pairs. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01888">1888</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="aab71acf938da1bfc93698b3236bb1ae"></a><!-- doxytag: member="stx::btree::swap" ref="aab71acf938da1bfc93698b3236bb1ae" args="(btree_self &amp;from)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fast swapping of two identical B+ tree objects. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01282">1282</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="43d1c2683f2dc078aa25e49820e9c237"></a><!-- doxytag: member="stx::btree::key_comp" ref="43d1c2683f2dc078aa25e49820e9c237" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::key_comp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constant access to the key comparison object sorting the B+ tree. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01318">1318</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00209">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::key_comp()</a>, <a class="el" href="btree__multiset_8h-source.html#l00210">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::key_comp()</a>, <a class="el" href="btree__multimap_8h-source.html#l00198">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::key_comp()</a>, <a class="el" href="btree__map_8h-source.html#l00197">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::key_comp()</a>, and <a class="el" href="btree_8h-source.html#l01865">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator=()</a>.</p>

</div>
</div><p>
<a class="anchor" name="94273af1fe4b9e2e0c0b6daeaa5f5950"></a><!-- doxytag: member="stx::btree::value_comp" ref="94273af1fe4b9e2e0c0b6daeaa5f5950" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1value__compare.html">value_compare</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::value_comp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constant access to a constructed value_type comparison object. 
<p>
Required by the STL 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01325">1325</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00216">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::value_comp()</a>, <a class="el" href="btree__multiset_8h-source.html#l00217">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::value_comp()</a>, <a class="el" href="btree__multimap_8h-source.html#l00205">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::value_comp()</a>, and <a class="el" href="btree__map_8h-source.html#l00204">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::value_comp()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b20b48ee5b3b4a1d4e216d5948f8c1a0"></a><!-- doxytag: member="stx::btree::key_lessequal" ref="b20b48ee5b3b4a1d4e216d5948f8c1a0" args="(const key_type &amp;a, const key_type b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::key_lessequal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a>&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True if a &lt;= b ? constructed from <a class="el" href="classstx_1_1btree.html#5e618ec38c852d5b81d997bdc932d592" title="Key comparison object.">key_less()</a>. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01334">1334</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01505">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::find_lower()</a>, <a class="el" href="btree_8h-source.html#l01552">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::find_upper()</a>, <a class="el" href="btree_8h-source.html#l03158">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify_leaflinks()</a>, and <a class="el" href="btree_8h-source.html#l03073">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify_node()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7bb87c4c13cd7a4412da72ef93ab082e"></a><!-- doxytag: member="stx::btree::key_greater" ref="7bb87c4c13cd7a4412da72ef93ab082e" args="(const key_type &amp;a, const key_type &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::key_greater           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True if a &gt; b ? constructed from <a class="el" href="classstx_1_1btree.html#5e618ec38c852d5b81d997bdc932d592" title="Key comparison object.">key_less()</a>. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01340">1340</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0571b5b68a6ef06b7606975a7176867c"></a><!-- doxytag: member="stx::btree::key_greaterequal" ref="0571b5b68a6ef06b7606975a7176867c" args="(const key_type &amp;a, const key_type b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::key_greaterequal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a>&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True if a &gt;= b ? constructed from <a class="el" href="classstx_1_1btree.html#5e618ec38c852d5b81d997bdc932d592" title="Key comparison object.">key_less()</a>. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01346">1346</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l03073">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify_node()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f09828d360e903d40c9f8c77183bea0e"></a><!-- doxytag: member="stx::btree::key_equal" ref="f09828d360e903d40c9f8c77183bea0e" args="(const key_type &amp;a, const key_type &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::key_equal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True if a == b ? constructed from <a class="el" href="classstx_1_1btree.html#5e618ec38c852d5b81d997bdc932d592" title="Key comparison object.">key_less()</a>. 
<p>
This requires the &lt; relation to be a total order, otherwise the B+ tree cannot be sorted. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01353">1353</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01692">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::count()</a>, <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>, <a class="el" href="btree_8h-source.html#l01627">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::exists()</a>, <a class="el" href="btree_8h-source.html#l01648">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::find()</a>, <a class="el" href="btree_8h-source.html#l02054">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_descend()</a>, and <a class="el" href="btree_8h-source.html#l03073">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify_node()</a>.</p>

</div>
</div><p>
<a class="anchor" name="359771538c203e0e8e301135783fa4a4"></a><!-- doxytag: member="stx::btree::allocate_leaf" ref="359771538c203e0e8e301135783fa4a4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a>* <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::allocate_leaf           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate and initialize a leaf <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01362">1362</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01905">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::copy_recursive()</a>, <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>, <a class="el" href="btree_8h-source.html#l03351">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore_node()</a>, and <a class="el" href="btree_8h-source.html#l02194">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::split_leaf_node()</a>.</p>

</div>
</div><p>
<a class="anchor" name="48afc242f523282f8833580a5370ff81"></a><!-- doxytag: member="stx::btree::allocate_inner" ref="48afc242f523282f8833580a5370ff81" args="(unsigned short l)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a>* <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::allocate_inner           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate and initialize an inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01371">1371</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01905">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::copy_recursive()</a>, <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>, <a class="el" href="btree_8h-source.html#l03351">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore_node()</a>, and <a class="el" href="btree_8h-source.html#l02234">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::split_inner_node()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0bbb2111654adc0acbd302488c602ad1"></a><!-- doxytag: member="stx::btree::free_node" ref="0bbb2111654adc0acbd302488c602ad1" args="(node *n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::free_node           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Correctly free either inner or leaf <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>, destructs all contained key and value objects. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01381">1381</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01397">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::clear()</a>, <a class="el" href="btree_8h-source.html#l01415">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::clear_recursive()</a>, and <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="cf6ccb1acc05ef2845dfa97c81b1be9f"></a><!-- doxytag: member="stx::btree::clear" ref="cf6ccb1acc05ef2845dfa97c81b1be9f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees all key/data pairs and all nodes of the tree. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01397">1397</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00225">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::clear()</a>, <a class="el" href="btree__multiset_8h-source.html#l00226">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::clear()</a>, <a class="el" href="btree__multimap_8h-source.html#l00214">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::clear()</a>, <a class="el" href="btree__map_8h-source.html#l00213">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::clear()</a>, <a class="el" href="btree_8h-source.html#l01865">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator=()</a>, <a class="el" href="btree_8h-source.html#l03287">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore()</a>, and <a class="el" href="btree_8h-source.html#l01276">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::~btree()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e5b3a26d39b65796596a6210b397e393"></a><!-- doxytag: member="stx::btree::clear_recursive" ref="e5b3a26d39b65796596a6210b397e393" args="(node *n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::clear_recursive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively free up nodes. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01415">1415</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01397">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::clear()</a>, and <a class="el" href="btree_8h-source.html#l01415">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::clear_recursive()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6551b60cb8a2f717555ceac61f34b957"></a><!-- doxytag: member="stx::btree::begin" ref="6551b60cb8a2f717555ceac61f34b957" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a read/data-write <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first slot in the first leaf of the B+ tree. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01443">1443</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00235">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::begin()</a>, <a class="el" href="btree__multiset_8h-source.html#l00236">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::begin()</a>, <a class="el" href="btree__multimap_8h-source.html#l00224">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::begin()</a>, <a class="el" href="btree__map_8h-source.html#l00223">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::begin()</a>, <a class="el" href="btree_8h-source.html#l01838">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator&lt;()</a>, <a class="el" href="btree_8h-source.html#l01825">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator==()</a>, and <a class="el" href="btree_8h-source.html#l01478">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::rend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="14f8bf63680c8950aab8c5d54e580a14"></a><!-- doxytag: member="stx::btree::end" ref="14f8bf63680c8950aab8c5d54e580a14" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a read/data-write <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first invalid slot in the last leaf of the B+ tree. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01450">1450</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00242">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::end()</a>, <a class="el" href="btree__multiset_8h-source.html#l00243">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::end()</a>, <a class="el" href="btree__multimap_8h-source.html#l00231">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::end()</a>, <a class="el" href="btree__map_8h-source.html#l00230">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::end()</a>, <a class="el" href="btree_8h-source.html#l01648">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::find()</a>, <a class="el" href="btree_8h-source.html#l01725">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::lower_bound()</a>, <a class="el" href="btree_8h-source.html#l01838">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator&lt;()</a>, <a class="el" href="btree_8h-source.html#l01825">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator==()</a>, <a class="el" href="btree_8h-source.html#l01471">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::rbegin()</a>, and <a class="el" href="btree_8h-source.html#l01767">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::upper_bound()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ea7a998112824a28d930bf324eedf60d"></a><!-- doxytag: member="stx::btree::begin" ref="ea7a998112824a28d930bf324eedf60d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a read-only constant <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first slot in the first leaf of the B+ tree. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01457">1457</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c1378c6f8b3473b4bd4c175dba5dbb7b"></a><!-- doxytag: member="stx::btree::end" ref="c1378c6f8b3473b4bd4c175dba5dbb7b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a read-only constant <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first invalid slot in the last leaf of the B+ tree. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01464">1464</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4d3a4b24d8cc56c589800655cf83c806"></a><!-- doxytag: member="stx::btree::rbegin" ref="4d3a4b24d8cc56c589800655cf83c806" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1reverse__iterator.html">reverse_iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::rbegin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a read/data-write reverse <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first invalid slot in the last leaf of the B+ tree. 
<p>
Uses STL magic. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01471">1471</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00263">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::rbegin()</a>, <a class="el" href="btree__multiset_8h-source.html#l00264">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::rbegin()</a>, <a class="el" href="btree__multimap_8h-source.html#l00252">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::rbegin()</a>, and <a class="el" href="btree__map_8h-source.html#l00251">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::rbegin()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6d9e5a5b0ec598a76e602aa6a19900ff"></a><!-- doxytag: member="stx::btree::rend" ref="6d9e5a5b0ec598a76e602aa6a19900ff" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1reverse__iterator.html">reverse_iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::rend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a read/data-write reverse <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first slot in the first leaf of the B+ tree. 
<p>
Uses STL magic. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01478">1478</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00270">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::rend()</a>, <a class="el" href="btree__multiset_8h-source.html#l00271">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::rend()</a>, <a class="el" href="btree__multimap_8h-source.html#l00259">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::rend()</a>, and <a class="el" href="btree__map_8h-source.html#l00258">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::rend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="38a7bfd129ae2a39f228f53c39561bf8"></a><!-- doxytag: member="stx::btree::rbegin" ref="38a7bfd129ae2a39f228f53c39561bf8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1const__reverse__iterator.html">const_reverse_iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::rbegin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a read-only reverse <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first invalid slot in the last leaf of the B+ tree. 
<p>
Uses STL magic. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01485">1485</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c925da8e9151dbecdf063dc5af78a903"></a><!-- doxytag: member="stx::btree::rend" ref="c925da8e9151dbecdf063dc5af78a903" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1const__reverse__iterator.html">const_reverse_iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::rend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a read-only reverse <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> that points to the first slot in the first leaf of the B+ tree. 
<p>
Uses STL magic. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01492">1492</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a25d79d1749e5eb8a81a103534707a77"></a><!-- doxytag: member="stx::btree::find_lower" ref="a25d79d1749e5eb8a81a103534707a77" args="(const node_type *n, const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
<div class="memtemplate">
template&lt;typename node_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::find_lower           </td>
          <td>(</td>
          <td class="paramtype">const node_type *&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the first key in the <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> n less or equal to key. 
<p>
Uses binary search with an optional linear self-verification. This is a template function, because the slotkey array is located at different places in <a class="el" href="structstx_1_1btree_1_1leaf__node.html" title="Extended structure of a leaf node in memory.">leaf_node</a> and <a class="el" href="structstx_1_1btree_1_1inner__node.html" title="Extended structure of a inner node in-memory.">inner_node</a>. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01505">1505</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01692">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::count()</a>, <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>, <a class="el" href="btree_8h-source.html#l01627">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::exists()</a>, <a class="el" href="btree_8h-source.html#l01648">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::find()</a>, <a class="el" href="btree_8h-source.html#l02054">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_descend()</a>, and <a class="el" href="btree_8h-source.html#l01725">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::lower_bound()</a>.</p>

</div>
</div><p>
<a class="anchor" name="43f2350acdc804684ddefe3ee1271978"></a><!-- doxytag: member="stx::btree::find_upper" ref="43f2350acdc804684ddefe3ee1271978" args="(const node_type *n, const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
<div class="memtemplate">
template&lt;typename node_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::find_upper           </td>
          <td>(</td>
          <td class="paramtype">const node_type *&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the first key in the <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> n greater than key. 
<p>
Uses binary search with an optional linear self-verification. This is a template function, because the slotkey array is located at different places in <a class="el" href="structstx_1_1btree_1_1leaf__node.html" title="Extended structure of a leaf node in memory.">leaf_node</a> and <a class="el" href="structstx_1_1btree_1_1inner__node.html" title="Extended structure of a inner node in-memory.">inner_node</a>. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01552">1552</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01767">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::upper_bound()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5e32032d192795a5f25b49e23e3ef1a1"></a><!-- doxytag: member="stx::btree::size" ref="5e32032d192795a5f25b49e23e3ef1a1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html#973470864b67129983ea4e1aa2132ac5">size_type</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of key/data pairs in the B+ tree. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01598">1598</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01888">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::btree()</a>, <a class="el" href="btree_8h-source.html#l03270">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::dump()</a>, <a class="el" href="btree_8h-source.html#l01604">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::empty()</a>, <a class="el" href="btree_8h-source.html#l02335">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one()</a>, <a class="el" href="btree_8h-source.html#l01865">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator=()</a>, <a class="el" href="btree_8h-source.html#l01825">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator==()</a>, <a class="el" href="btree__set_8h-source.html#l00293">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::size()</a>, <a class="el" href="btree__multiset_8h-source.html#l00294">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::size()</a>, <a class="el" href="btree__multimap_8h-source.html#l00282">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::size()</a>, <a class="el" href="btree__map_8h-source.html#l00281">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::size()</a>, and <a class="el" href="btree_8h-source.html#l03158">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify_leaflinks()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ee6ae1b8d5832d3cd829a3962b776cd5"></a><!-- doxytag: member="stx::btree::empty" ref="ee6ae1b8d5832d3cd829a3962b776cd5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if there is at least one key/data pair in the B+ tree. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01604">1604</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00299">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::empty()</a>, <a class="el" href="btree__multiset_8h-source.html#l00300">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::empty()</a>, <a class="el" href="btree__multimap_8h-source.html#l00288">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::empty()</a>, and <a class="el" href="btree__map_8h-source.html#l00287">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::empty()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ae330348c9f4b6051864da4ebd157662"></a><!-- doxytag: member="stx::btree::max_size" ref="ae330348c9f4b6051864da4ebd157662" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html#973470864b67129983ea4e1aa2132ac5">size_type</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::max_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the largest possible size of the B+ Tree. 
<p>
This is just a function required by the STL standard, the B+ Tree can hold more items. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01611">1611</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00306">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::max_size()</a>, <a class="el" href="btree__multiset_8h-source.html#l00307">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::max_size()</a>, <a class="el" href="btree__multimap_8h-source.html#l00295">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::max_size()</a>, and <a class="el" href="btree__map_8h-source.html#l00294">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::max_size()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8748bb3788c1e1d65dbfe9500d33a134"></a><!-- doxytag: member="stx::btree::get_stats" ref="8748bb3788c1e1d65dbfe9500d33a134" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstx_1_1btree_1_1tree__stats.html">tree_stats</a>&amp; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::get_stats           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a const reference to the current statistics. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01617">1617</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00312">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::get_stats()</a>, <a class="el" href="btree__multiset_8h-source.html#l00313">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::get_stats()</a>, <a class="el" href="btree__multimap_8h-source.html#l00301">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::get_stats()</a>, and <a class="el" href="btree__map_8h-source.html#l00300">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::get_stats()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9405c7a274bcc76f27b4e84c49fcaa0d"></a><!-- doxytag: member="stx::btree::exists" ref="9405c7a274bcc76f27b4e84c49fcaa0d" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::exists           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Non-STL function checking whether a key is in the B+ tree. 
<p>
The same as (find(k) != <a class="el" href="classstx_1_1btree.html#14f8bf63680c8950aab8c5d54e580a14" title="Constructs a read/data-write iterator that points to the first invalid slot in the...">end()</a>) or (<a class="el" href="classstx_1_1btree.html#36754fc4a90de86806a91cc22eafbe78" title="Tries to locate a key in the B+ tree and returns the number of identical key entries...">count()</a> != 0). 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01627">1627</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00322">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::exists()</a>, <a class="el" href="btree__multiset_8h-source.html#l00323">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::exists()</a>, <a class="el" href="btree__multimap_8h-source.html#l00311">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::exists()</a>, <a class="el" href="btree__map_8h-source.html#l00310">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::exists()</a>, and <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2be7e3a978a71f86e433a0244c7414c6"></a><!-- doxytag: member="stx::btree::find" ref="2be7e3a978a71f86e433a0244c7414c6" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::find           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to locate a key in the B+ tree and returns an <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the key/data slot if found. 
<p>
If unsuccessful it returns <a class="el" href="classstx_1_1btree.html#14f8bf63680c8950aab8c5d54e580a14" title="Constructs a read/data-write iterator that points to the first invalid slot in the...">end()</a>. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01648">1648</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00329">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::find()</a>, <a class="el" href="btree__multiset_8h-source.html#l00330">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::find()</a>, <a class="el" href="btree__multimap_8h-source.html#l00318">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::find()</a>, and <a class="el" href="btree__map_8h-source.html#l00317">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::find()</a>.</p>

</div>
</div><p>
<a class="anchor" name="fcda5e66264982ba77eaebaf665763f9"></a><!-- doxytag: member="stx::btree::find" ref="fcda5e66264982ba77eaebaf665763f9" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::find           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to locate a key in the B+ tree and returns an constant <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the key/data slot if found. 
<p>
If unsuccessful it returns <a class="el" href="classstx_1_1btree.html#14f8bf63680c8950aab8c5d54e580a14" title="Constructs a read/data-write iterator that points to the first invalid slot in the...">end()</a>. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01670">1670</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="36754fc4a90de86806a91cc22eafbe78"></a><!-- doxytag: member="stx::btree::count" ref="36754fc4a90de86806a91cc22eafbe78" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html#973470864b67129983ea4e1aa2132ac5">size_type</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::count           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to locate a key in the B+ tree and returns the number of identical key entries found. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01692">1692</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00344">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::count()</a>, <a class="el" href="btree__multiset_8h-source.html#l00344">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::count()</a>, <a class="el" href="btree__multimap_8h-source.html#l00332">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::count()</a>, and <a class="el" href="btree__map_8h-source.html#l00332">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::count()</a>.</p>

</div>
</div><p>
<a class="anchor" name="74e859adf01a516a382579a614f12673"></a><!-- doxytag: member="stx::btree::lower_bound" ref="74e859adf01a516a382579a614f12673" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::lower_bound           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the B+ tree and returns an <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the first key less or equal to the parameter. 
<p>
If unsuccessful it returns <a class="el" href="classstx_1_1btree.html#14f8bf63680c8950aab8c5d54e580a14" title="Constructs a read/data-write iterator that points to the first invalid slot in the...">end()</a>. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01725">1725</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01808">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::equal_range()</a>, <a class="el" href="btree__set_8h-source.html#l00351">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::lower_bound()</a>, <a class="el" href="btree__multiset_8h-source.html#l00351">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::lower_bound()</a>, <a class="el" href="btree__multimap_8h-source.html#l00339">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::lower_bound()</a>, and <a class="el" href="btree__map_8h-source.html#l00339">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::lower_bound()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1a68298c1097edde3820d2be1b5e8966"></a><!-- doxytag: member="stx::btree::lower_bound" ref="1a68298c1097edde3820d2be1b5e8966" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::lower_bound           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the B+ tree and returns an constant <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the first key less or equal to the parameter. 
<p>
If unsuccessful it returns <a class="el" href="classstx_1_1btree.html#14f8bf63680c8950aab8c5d54e580a14" title="Constructs a read/data-write iterator that points to the first invalid slot in the...">end()</a>. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01746">1746</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="789cbe4a94251e756041c5504127ac50"></a><!-- doxytag: member="stx::btree::upper_bound" ref="789cbe4a94251e756041c5504127ac50" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::upper_bound           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the B+ tree and returns an <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the first key greater than the parameter. 
<p>
If unsuccessful it returns <a class="el" href="classstx_1_1btree.html#14f8bf63680c8950aab8c5d54e580a14" title="Constructs a read/data-write iterator that points to the first invalid slot in the...">end()</a>. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01767">1767</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01808">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::equal_range()</a>, <a class="el" href="btree__set_8h-source.html#l00365">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::upper_bound()</a>, <a class="el" href="btree__multiset_8h-source.html#l00365">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::upper_bound()</a>, <a class="el" href="btree__multimap_8h-source.html#l00353">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::upper_bound()</a>, and <a class="el" href="btree__map_8h-source.html#l00353">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::upper_bound()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c04d1a6c7d3be8979a7ab9057da1174"></a><!-- doxytag: member="stx::btree::upper_bound" ref="1c04d1a6c7d3be8979a7ab9057da1174" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::upper_bound           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the B+ tree and returns an constant <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> to the first key greater than the parameter. 
<p>
If unsuccessful it returns <a class="el" href="classstx_1_1btree.html#14f8bf63680c8950aab8c5d54e580a14" title="Constructs a read/data-write iterator that points to the first invalid slot in the...">end()</a>. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01788">1788</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="598ffaab5e27bf4e10de0f757938744c"></a><!-- doxytag: member="stx::btree::equal_range" ref="598ffaab5e27bf4e10de0f757938744c" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, <a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&gt; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::equal_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the B+ tree and returns both <a class="el" href="classstx_1_1btree.html#74e859adf01a516a382579a614f12673" title="Searches the B+ tree and returns an iterator to the first key less or equal to the...">lower_bound()</a> and <a class="el" href="classstx_1_1btree.html#789cbe4a94251e756041c5504127ac50" title="Searches the B+ tree and returns an iterator to the first key greater than the parameter...">upper_bound()</a>. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01808">1808</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00378">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::equal_range()</a>, <a class="el" href="btree__multiset_8h-source.html#l00378">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::equal_range()</a>, <a class="el" href="btree__multimap_8h-source.html#l00366">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::equal_range()</a>, and <a class="el" href="btree__map_8h-source.html#l00366">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::equal_range()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6c0e42e4d10e1ed6af48d449a7a8345f"></a><!-- doxytag: member="stx::btree::equal_range" ref="6c0e42e4d10e1ed6af48d449a7a8345f" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a>, <a class="el" href="classstx_1_1btree_1_1const__iterator.html">const_iterator</a>&gt; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::equal_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the B+ tree and returns both <a class="el" href="classstx_1_1btree.html#74e859adf01a516a382579a614f12673" title="Searches the B+ tree and returns an iterator to the first key less or equal to the...">lower_bound()</a> and <a class="el" href="classstx_1_1btree.html#789cbe4a94251e756041c5504127ac50" title="Searches the B+ tree and returns an iterator to the first key greater than the parameter...">upper_bound()</a>. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01814">1814</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="081621ee81f875602a1788690879e7f9"></a><!-- doxytag: member="stx::btree::operator==" ref="081621ee81f875602a1788690879e7f9" args="(const btree_self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality relation of B+ trees of the same type. 
<p>
B+ trees of the same size and equal elements (both key and data) are considered equal. Beware of the random ordering of duplicate keys. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01825">1825</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8bd8cb1bed1ba5ad6224d7f0220d1cad"></a><!-- doxytag: member="stx::btree::operator!=" ref="8bd8cb1bed1ba5ad6224d7f0220d1cad" args="(const btree_self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality relation. Based on operator==. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01831">1831</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2ece54f92f9376137a29dc08a7d2efc9"></a><!-- doxytag: member="stx::btree::operator&lt;" ref="2ece54f92f9376137a29dc08a7d2efc9" args="(const btree_self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Total ordering relation of B+ trees of the same type. 
<p>
It uses std::lexicographical_compare() for the actual comparison of elements. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01838">1838</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c36903fff62279a5052287c8b1ee38b2"></a><!-- doxytag: member="stx::btree::operator&gt;" ref="c36903fff62279a5052287c8b1ee38b2" args="(const btree_self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::operator&gt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Greater relation. Based on operator&lt;. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01844">1844</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2acd154e278f971fca7da303366e528b"></a><!-- doxytag: member="stx::btree::operator&lt;=" ref="2acd154e278f971fca7da303366e528b" args="(const btree_self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Less-equal relation. Based on operator&lt;. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01850">1850</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3e0185adba298bb184103a1975b3cbe4"></a><!-- doxytag: member="stx::btree::operator&gt;=" ref="3e0185adba298bb184103a1975b3cbe4" args="(const btree_self &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Greater-equal relation. Based on operator&lt;. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01856">1856</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="bc9ee03092fc58297b2d2c87199a0f66"></a><!-- doxytag: member="stx::btree::operator=" ref="bc9ee03092fc58297b2d2c87199a0f66" args="(const btree_self &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html">btree_self</a>&amp; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html">btree_self</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
*** Fast Copy: Assign Operator and Copy Constructors 
<p>
Assignment operator. All the key/data pairs are copied 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01865">1865</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f398f002480cf8a7d5c67fd3d2c33a4d"></a><!-- doxytag: member="stx::btree::copy_recursive" ref="f398f002480cf8a7d5c67fd3d2c33a4d" args="(const node *n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstx_1_1btree_1_1node.html">node</a>* <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::copy_recursive           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, read, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively copy nodes from another B+ tree object. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01905">1905</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01888">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::btree()</a>, <a class="el" href="btree_8h-source.html#l01905">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::copy_recursive()</a>, and <a class="el" href="btree_8h-source.html#l01865">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator=()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6a96ea1453ad3392ad4722265ceae976"></a><!-- doxytag: member="stx::btree::insert" ref="6a96ea1453ad3392ad4722265ceae976" args="(const pair_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#f7a75a733f8547491913b0e5b8d11a4e">pair_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to insert a key/data pair into the B+ tree. 
<p>
If the tree does not allow duplicate keys, then the insert may fail if it is already present. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01953">1953</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01259">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::btree()</a>, <a class="el" href="btree__multimap_8h-source.html#l00483">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::insert()</a>, <a class="el" href="btree__map_8h-source.html#l00492">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::insert()</a>, and <a class="el" href="btree_8h-source.html#l01993">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert()</a>.</p>

</div>
</div><p>
<a class="anchor" name="63cf076cefd57cdc773170e8f7dc0b41"></a><!-- doxytag: member="stx::btree::insert" ref="63cf076cefd57cdc773170e8f7dc0b41" args="(const key_type &amp;key, const data_type &amp;data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to insert a key/data pair into the B+ tree. 
<p>
Beware that if key_type == data_type, then the template <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> <a class="el" href="classstx_1_1btree.html#6a96ea1453ad3392ad4722265ceae976" title="Attempt to insert a key/data pair into the B+ tree.">insert()</a> is called instead. If the tree does not allow duplicate keys, then the insert may fail if it is already present. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01962">1962</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="45d95a83fbbfa0211a972b8f7451a19c"></a><!-- doxytag: member="stx::btree::insert2" ref="45d95a83fbbfa0211a972b8f7451a19c" args="(const key_type &amp;key, const data_type &amp;data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::insert2           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to insert a key/data pair into the B+ tree. 
<p>
This function is the same as the other insert, however if key_type == data_type then the non-template function cannot be called. If the tree does not allow duplicate keys, then the insert may fail if it is already present. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01971">1971</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00455">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::insert()</a>, <a class="el" href="btree__multiset_8h-source.html#l00455">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::insert()</a>, <a class="el" href="btree__multimap_8h-source.html#l00444">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::insert()</a>, <a class="el" href="btree__map_8h-source.html#l00444">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::insert()</a>, <a class="el" href="btree__multimap_8h-source.html#l00461">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::insert2()</a>, and <a class="el" href="btree__map_8h-source.html#l00461">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::insert2()</a>.</p>

</div>
</div><p>
<a class="anchor" name="19879710dc73555397fc83acf1d00328"></a><!-- doxytag: member="stx::btree::insert" ref="19879710dc73555397fc83acf1d00328" args="(iterator, const pair_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#f7a75a733f8547491913b0e5b8d11a4e">pair_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to insert a key/data pair into the B+ tree. 
<p>
The <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> hint is currently ignored by the B+ tree insertion routine. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01978">1978</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="21daa4ef5ae703f189ec3c917113b780"></a><!-- doxytag: member="stx::btree::insert2" ref="21daa4ef5ae703f189ec3c917113b780" args="(iterator, const key_type &amp;key, const data_type &amp;data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::insert2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to insert a key/data pair into the B+ tree. 
<p>
The <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a> hint is currently ignored by the B+ tree insertion routine. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01985">1985</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0c47337c74d366a69ba38131be49e6fa"></a><!-- doxytag: member="stx::btree::insert" ref="0c47337c74d366a69ba38131be49e6fa" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to insert the range [first,last) of value_type pairs into the B+ tree. 
<p>
Each key/data pair is inserted individually. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01993">1993</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="754a5b04887a9df1cb0e51afffc36bfd"></a><!-- doxytag: member="stx::btree::insert_start" ref="754a5b04887a9df1cb0e51afffc36bfd" args="(const key_type &amp;key, const data_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::insert_start           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start the insertion descent at the current root and handle root splits. 
<p>
Returns true if the item was inserted 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02008">2008</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01953">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert()</a>, and <a class="el" href="btree_8h-source.html#l01971">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert2()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9f24e411dd05b99edb58935389c1664d"></a><!-- doxytag: member="stx::btree::insert_descend" ref="9f24e411dd05b99edb58935389c1664d" args="(node *n, const key_type &amp;key, const data_type &amp;value, key_type *splitkey, node **splitnode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::insert_descend           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#ca29ad902418d86eeb9b9379a38e5fcd">data_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> *&nbsp;</td>
          <td class="paramname"> <em>splitkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1node.html">node</a> **&nbsp;</td>
          <td class="paramname"> <em>splitnode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert an item into the B+ tree. 
<p>
Descend down the nodes to a leaf, insert the key/data pair in a free slot. If the <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> overflows, then it must be split and the new split <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> inserted into the parent. Unroll / this splitting up to the root. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02054">2054</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02054">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_descend()</a>, and <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>.</p>

</div>
</div><p>
<a class="anchor" name="65184b7ff0a48d7c013041dac45ddab9"></a><!-- doxytag: member="stx::btree::split_leaf_node" ref="65184b7ff0a48d7c013041dac45ddab9" args="(leaf_node *leaf, key_type *_newkey, node **_newleaf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::split_leaf_node           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *&nbsp;</td>
          <td class="paramname"> <em>leaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> *&nbsp;</td>
          <td class="paramname"> <em>_newkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1node.html">node</a> **&nbsp;</td>
          <td class="paramname"> <em>_newleaf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Split up a leaf <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> into two equally-filled sibling leaves. 
<p>
Returns the new nodes and it's insertion key in the two parameters. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02194">2194</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02054">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_descend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="bba0627e1a8a9fa86ff1b44e6c8f8dea"></a><!-- doxytag: member="stx::btree::split_inner_node" ref="bba0627e1a8a9fa86ff1b44e6c8f8dea" args="(inner_node *inner, key_type *_newkey, node **_newinner, unsigned int addslot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::split_inner_node           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> *&nbsp;</td>
          <td class="paramname"> <em>_newkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1node.html">node</a> **&nbsp;</td>
          <td class="paramname"> <em>_newinner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>addslot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Split up an inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> into two equally-filled sibling nodes. 
<p>
Returns the new nodes and it's insertion key in the two parameters. Requires the slot of the item will be inserted, so the nodes will be the same size after the insert. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02234">2234</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02054">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_descend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c01d4b6b26e5c8447e92651168b006d4"></a><!-- doxytag: member="stx::btree::erase_one" ref="c01d4b6b26e5c8447e92651168b006d4" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::erase_one           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases one (the first) of the key/data pairs associated with the given key. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l02335">2335</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02358">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase()</a>, <a class="el" href="btree__set_8h-source.html#l00485">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::erase_one()</a>, <a class="el" href="btree__multiset_8h-source.html#l00484">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::erase_one()</a>, <a class="el" href="btree__multimap_8h-source.html#l00493">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::erase_one()</a>, and <a class="el" href="btree__map_8h-source.html#l00502">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::erase_one()</a>.</p>

</div>
</div><p>
<a class="anchor" name="97f6c7874f508e5d1498161a0181606e"></a><!-- doxytag: member="stx::btree::erase" ref="97f6c7874f508e5d1498161a0181606e" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html#973470864b67129983ea4e1aa2132ac5">size_type</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases all the key/data pairs associated with the given key. 
<p>
This is implemented using <a class="el" href="classstx_1_1btree.html#c01d4b6b26e5c8447e92651168b006d4" title="Erases one (the first) of the key/data pairs associated with the given key.">erase_one()</a>. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02358">2358</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00491">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::erase()</a>, <a class="el" href="btree__multiset_8h-source.html#l00491">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::erase()</a>, <a class="el" href="btree__multimap_8h-source.html#l00500">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::erase()</a>, and <a class="el" href="btree__map_8h-source.html#l00509">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::erase()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b006ef721a55f2e6eaee5d4b22cc2ebc"></a><!-- doxytag: member="stx::btree::erase" ref="b006ef721a55f2e6eaee5d4b22cc2ebc" args="(iterator iter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase the key/data pair referenced by the <a class="el" href="classstx_1_1btree_1_1iterator.html" title="STL-like iterator object for B+ tree items.">iterator</a>. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l02373">2373</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="20393dc10d658f3e7883bb69aa9cdde8"></a><!-- doxytag: member="stx::btree::erase" ref="20393dc10d658f3e7883bb69aa9cdde8" args="(iterator, iterator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstx_1_1btree_1_1iterator.html">iterator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase all key/data pairs in the range [first,last). 
<p>
This function is currently not implemented by the B+ Tree. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02382">2382</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="40e3e935186128e71b90ad2482fc73a7"></a><!-- doxytag: member="stx::btree::erase_one_descend" ref="40e3e935186128e71b90ad2482fc73a7" args="(const key_type &amp;key, node *curr, node *left, node *right, inner_node *leftparent, inner_node *rightparent, inner_node *parent, unsigned int parentslot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">result_t <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::erase_one_descend           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td>
          <td class="paramname"> <em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>leftparent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>rightparent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>parentslot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase one (the first) key/data pair in the B+ tree matching key. 
<p>
Descends down the tree in search of key. During the descent the parent, left and right siblings and their parents are computed and passed down. Once the key/data pair is found, it is removed from the leaf. If the leaf underflows 6 different cases are handled. These cases resolve the underflow by shifting key/data pairs from adjacent sibling nodes, merging two sibling nodes or trimming the tree. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02400">2400</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02335">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one()</a>, and <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d3713fe9737e461701b4fe44a829df50"></a><!-- doxytag: member="stx::btree::merge_leaves" ref="d3713fe9737e461701b4fe44a829df50" args="(leaf_node *left, leaf_node *right, inner_node *parent)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">result_t <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::merge_leaves           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merge two leaf nodes. 
<p>
The function moves all key/data pairs from right to left and sets right's slotuse to zero. The right slot is then removed by the calling parent <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02677">2677</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ba98442f1692cc1c7b4f5ed52f67a186"></a><!-- doxytag: member="stx::btree::merge_inner" ref="ba98442f1692cc1c7b4f5ed52f67a186" args="(inner_node *left, inner_node *right, inner_node *parent, unsigned int parentslot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static result_t <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::merge_inner           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>parentslot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merge two inner nodes. 
<p>
The function moves all key/childid pairs from right to left and sets right's slotuse to zero. The right slot is then removed by the calling parent <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02708">2708</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0475590170b5e17b990ab5d5bd95c4f6"></a><!-- doxytag: member="stx::btree::shift_left_leaf" ref="0475590170b5e17b990ab5d5bd95c4f6" args="(leaf_node *left, leaf_node *right, inner_node *parent, unsigned int parentslot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static result_t <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::shift_left_leaf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>parentslot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Balance two leaf nodes. 
<p>
The function moves key/data pairs from right to left so that both nodes are equally filled. The parent <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> is updated if possible. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02755">2755</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f9728e843262c62d97dec3aaa5203382"></a><!-- doxytag: member="stx::btree::shift_left_inner" ref="f9728e843262c62d97dec3aaa5203382" args="(inner_node *left, inner_node *right, inner_node *parent, unsigned int parentslot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::shift_left_inner           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>parentslot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Balance two inner nodes. 
<p>
The function moves key/data pairs from right to left so that both nodes are equally filled. The parent <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> is updated if possible. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02802">2802</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="68ca0e18a5d87ac38f651df2120ac8a6"></a><!-- doxytag: member="stx::btree::shift_right_leaf" ref="68ca0e18a5d87ac38f651df2120ac8a6" args="(leaf_node *left, leaf_node *right, inner_node *parent, unsigned int parentslot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::shift_right_leaf           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a> *&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>parentslot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Balance two leaf nodes. 
<p>
The function moves key/data pairs from left to right so that both nodes are equally filled. The parent <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> is updated if possible. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02862">2862</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="fd62fa2daf91ddd8848022df7d4e4179"></a><!-- doxytag: member="stx::btree::shift_right_inner" ref="fd62fa2daf91ddd8848022df7d4e4179" args="(inner_node *left, inner_node *right, inner_node *parent, unsigned int parentslot)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::shift_right_inner           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1inner__node.html">inner_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>parentslot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Balance two inner nodes. 
<p>
The function moves key/data pairs from left to right so that both nodes are equally filled. The parent <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> is updated if possible. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02916">2916</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="97664fdfb85917808eee2aa8487c5e39"></a><!-- doxytag: member="stx::btree::print" ref="97664fdfb85917808eee2aa8487c5e39" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::print           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print out the B+ tree structure with keys onto the given ostream. 
<p>
This function requires that the header is compiled with BTREE_DEBUG and that key_type is printable via std::ostream. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l02979">2979</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02335">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one()</a>, <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>, <a class="el" href="btree__set_8h-source.html#l00520">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::print()</a>, <a class="el" href="btree__multiset_8h-source.html#l00520">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::print()</a>, <a class="el" href="btree__multimap_8h-source.html#l00529">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::print()</a>, <a class="el" href="btree__map_8h-source.html#l00538">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::print()</a>, and <a class="el" href="btree_8h-source.html#l03287">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8270dcc972930a6f2c9f112af8b65075"></a><!-- doxytag: member="stx::btree::print_leaves" ref="8270dcc972930a6f2c9f112af8b65075" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::print_leaves           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print out only the leaves via the double linked list. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l02987">2987</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00526">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::print_leaves()</a>, <a class="el" href="btree__multiset_8h-source.html#l00526">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::print_leaves()</a>, <a class="el" href="btree__multimap_8h-source.html#l00535">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::print_leaves()</a>, and <a class="el" href="btree__map_8h-source.html#l00544">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::print_leaves()</a>.</p>

</div>
</div><p>
<a class="anchor" name="197122d34fc70adfd60219a98bbbb489"></a><!-- doxytag: member="stx::btree::print_node" ref="197122d34fc70adfd60219a98bbbb489" args="(std::ostream &amp;os, const node *node, unsigned int depth=0, bool recursive=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::print_node           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>recursive</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively descend down the tree and print out nodes. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l03004">3004</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02054">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_descend()</a>, <a class="el" href="btree_8h-source.html#l02979">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::print()</a>, and <a class="el" href="btree_8h-source.html#l03004">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::print_node()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e382217f25916442745eb83520b20c12"></a><!-- doxytag: member="stx::btree::verify" ref="e382217f25916442745eb83520b20c12" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::verify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Run a thorough verification of all B+ tree invariants. 
<p>
The program aborts via assert() if something is wrong. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l03053">3053</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01888">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::btree()</a>, <a class="el" href="btree_8h-source.html#l02335">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one()</a>, <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>, <a class="el" href="btree_8h-source.html#l01865">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator=()</a>, <a class="el" href="btree_8h-source.html#l03287">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore()</a>, <a class="el" href="btree__set_8h-source.html#l00538">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::verify()</a>, <a class="el" href="btree__multiset_8h-source.html#l00537">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::verify()</a>, <a class="el" href="btree__multimap_8h-source.html#l00546">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::verify()</a>, and <a class="el" href="btree__map_8h-source.html#l00555">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::verify()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a801e588f707be300927cf0c5bbd0f24"></a><!-- doxytag: member="stx::btree::verify_node" ref="a801e588f707be300927cf0c5bbd0f24" args="(const node *n, key_type *minkey, key_type *maxkey, tree_stats &amp;vstats) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::verify_node           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> *&nbsp;</td>
          <td class="paramname"> <em>minkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstx_1_1btree.html#2054714c400894aa8822f0f52bc120cf">key_type</a> *&nbsp;</td>
          <td class="paramname"> <em>maxkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstx_1_1btree_1_1tree__stats.html">tree_stats</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vstats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively descend down the tree and verify each <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l03073">3073</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l03053">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify()</a>, and <a class="el" href="btree_8h-source.html#l03073">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify_node()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2acaf6a7e8ad48bd1c73e9b3b2f2fb18"></a><!-- doxytag: member="stx::btree::verify_leaflinks" ref="2acaf6a7e8ad48bd1c73e9b3b2f2fb18" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::verify_leaflinks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Verify the double linked list of leaves. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l03158">3158</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l03053">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4d83f35e94a64b82ca3648d40fb31507"></a><!-- doxytag: member="stx::btree::dump" ref="4d83f35e94a64b82ca3648d40fb31507" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::dump           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dump the contents of the B+ tree out onto an ostream as a binary image. 
<p>
The image contains memory pointers which will be fixed when the image is restored. For this to work your key_type and data_type must be integral types and contain no pointers or references. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l03270">3270</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00549">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::dump()</a>, <a class="el" href="btree__multiset_8h-source.html#l00548">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::dump()</a>, <a class="el" href="btree__multimap_8h-source.html#l00557">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::dump()</a>, and <a class="el" href="btree__map_8h-source.html#l00566">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::dump()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f386da3ca44e31b73f68b50630df3ab9"></a><!-- doxytag: member="stx::btree::restore" ref="f386da3ca44e31b73f68b50630df3ab9" args="(std::istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::restore           </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restore a binary image of a dumped B+ tree from an istream. 
<p>
The B+ tree pointers are fixed using the dump order. For dump and restore to work your key_type and data_type must be integral types and contain no pointers or references. Returns true if the restore was successful. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l03287">3287</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree__set_8h-source.html#l00558">stx::btree_set&lt; _Key, _Compare, _Traits &gt;::restore()</a>, <a class="el" href="btree__multiset_8h-source.html#l00557">stx::btree_multiset&lt; _Key, _Compare, _Traits &gt;::restore()</a>, <a class="el" href="btree__multimap_8h-source.html#l00566">stx::btree_multimap&lt; _Key, _Data, _Compare, _Traits &gt;::restore()</a>, and <a class="el" href="btree__map_8h-source.html#l00575">stx::btree_map&lt; _Key, _Data, _Compare, _Traits &gt;::restore()</a>.</p>

</div>
</div><p>
<a class="anchor" name="62b6b49019ad87ed911e6786bf3cc26a"></a><!-- doxytag: member="stx::btree::dump_node" ref="62b6b49019ad87ed911e6786bf3cc26a" args="(std::ostream &amp;os, const node *n) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::dump_node           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstx_1_1btree_1_1node.html">node</a> *&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recursively descend down the tree and dump each <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> in a precise order. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l03324">3324</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l03270">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::dump()</a>, and <a class="el" href="btree_8h-source.html#l03324">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::dump_node()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0ff07bf2c03e4a11ef365ba475cb004b"></a><!-- doxytag: member="stx::btree::restore_node" ref="0ff07bf2c03e4a11ef365ba475cb004b" args="(std::istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1btree_1_1node.html">node</a>* <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::restore_node           </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read the dump image and construct a tree from the <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> order in the serialization. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l03351">3351</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l03287">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore()</a>, and <a class="el" href="btree_8h-source.html#l03351">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore_node()</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="35378979c13861883affefda9ad95df7"></a><!-- doxytag: member="stx::btree::allow_duplicates" ref="35378979c13861883affefda9ad95df7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#35378979c13861883affefda9ad95df7">allow_duplicates</a> = _Duplicates<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sixth template parameter: Allow duplicate keys in the B+ tree. 
<p>
Used to implement multiset and multimap. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l00165">165</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02358">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase()</a>, and <a class="el" href="btree_8h-source.html#l02054">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_descend()</a>.</p>

</div>
</div><p>
<a class="anchor" name="12a39ca671e962924f4acf879a44eafc"></a><!-- doxytag: member="stx::btree::leafslotmax" ref="12a39ca671e962924f4acf879a44eafc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#12a39ca671e962924f4acf879a44eafc">leafslotmax</a> = traits::leafslots<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Base B+ tree parameter: The number of key/data slots in each leaf. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l00189">189</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02054">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_descend()</a>, <a class="el" href="btree_8h-source.html#l00302">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::leaf_node::isfull()</a>, <a class="el" href="btree_8h-source.html#l02677">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::merge_leaves()</a>, <a class="el" href="btree_8h-source.html#l02755">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::shift_left_leaf()</a>, and <a class="el" href="btree_8h-source.html#l02862">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::shift_right_leaf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="83a18c2fb7f4e9cfd47ce7545d004324"></a><!-- doxytag: member="stx::btree::innerslotmax" ref="83a18c2fb7f4e9cfd47ce7545d004324" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#83a18c2fb7f4e9cfd47ce7545d004324">innerslotmax</a> = traits::innerslots<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Base B+ tree parameter: The number of key slots in each inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>, this can differ from slots in each leaf. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l00193">193</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02054">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_descend()</a>, <a class="el" href="btree_8h-source.html#l00259">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::inner_node::isfull()</a>, <a class="el" href="btree_8h-source.html#l02708">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::merge_inner()</a>, <a class="el" href="btree_8h-source.html#l02802">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::shift_left_inner()</a>, and <a class="el" href="btree_8h-source.html#l02916">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::shift_right_inner()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c53c2fe18cd06916a25c3b2a6e0486eb"></a><!-- doxytag: member="stx::btree::minleafslots" ref="c53c2fe18cd06916a25c3b2a6e0486eb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#c53c2fe18cd06916a25c3b2a6e0486eb">minleafslots</a> = (<a class="el" href="classstx_1_1btree.html#12a39ca671e962924f4acf879a44eafc">leafslotmax</a> / 2)<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computed B+ tree parameter: The minimum number of key/data slots used in a leaf. 
<p>
If fewer slots are used, the leaf will be merged or slots shifted from it's siblings. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l00198">198</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l00308">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::leaf_node::isfew()</a>, and <a class="el" href="btree_8h-source.html#l00314">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::leaf_node::isunderflow()</a>.</p>

</div>
</div><p>
<a class="anchor" name="14312352a7289cee65f1793b0183f60e"></a><!-- doxytag: member="stx::btree::mininnerslots" ref="14312352a7289cee65f1793b0183f60e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#14312352a7289cee65f1793b0183f60e">mininnerslots</a> = (<a class="el" href="classstx_1_1btree.html#83a18c2fb7f4e9cfd47ce7545d004324">innerslotmax</a> / 2)<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computed B+ tree parameter: The minimum number of key slots used in an inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>. 
<p>
If fewer slots are used, the inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a> will be merged or slots shifted from it's siblings. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l00203">203</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l00265">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::inner_node::isfew()</a>, and <a class="el" href="btree_8h-source.html#l00271">stx::btree&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::inner_node::isunderflow()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ee2e25b0fccc7147fd8be0bcf8630b5b"></a><!-- doxytag: member="stx::btree::selfverify" ref="ee2e25b0fccc7147fd8be0bcf8630b5b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#ee2e25b0fccc7147fd8be0bcf8630b5b">selfverify</a> = traits::selfverify<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Debug parameter: Enables expensive and thorough checking of the B+ tree invariants after each insert/erase operation. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l00207">207</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01888">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::btree()</a>, <a class="el" href="btree_8h-source.html#l02335">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one()</a>, <a class="el" href="btree_8h-source.html#l01505">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::find_lower()</a>, <a class="el" href="btree_8h-source.html#l01552">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::find_upper()</a>, <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>, <a class="el" href="btree_8h-source.html#l02708">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::merge_inner()</a>, <a class="el" href="btree_8h-source.html#l01865">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator=()</a>, <a class="el" href="btree_8h-source.html#l03287">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore()</a>, <a class="el" href="btree_8h-source.html#l02802">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::shift_left_inner()</a>, <a class="el" href="btree_8h-source.html#l02916">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::shift_right_inner()</a>, and <a class="el" href="btree_8h-source.html#l02862">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::shift_right_leaf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ac6ff74fe9fb9e87958d73c28cb9eef4"></a><!-- doxytag: member="stx::btree::debug" ref="ac6ff74fe9fb9e87958d73c28cb9eef4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#ac6ff74fe9fb9e87958d73c28cb9eef4">debug</a> = traits::debug<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Debug parameter: Prints out lots of debug information about how the algorithms change the tree. 
<p>
Requires the header file to be compiled with BTREE_DEBUG and the key type must be std::ostream printable. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l00212">212</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l02335">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one()</a>, <a class="el" href="btree_8h-source.html#l02054">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_descend()</a>, <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>, and <a class="el" href="btree_8h-source.html#l03287">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore()</a>.</p>

</div>
</div><p>
<a class="anchor" name="83837b81c8d30c09c4e91d9921efd4a0"></a><!-- doxytag: member="stx::btree::root" ref="83837b81c8d30c09c4e91d9921efd4a0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1btree_1_1node.html">node</a>* <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#83837b81c8d30c09c4e91d9921efd4a0">root</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to the B+ tree's root <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>, either leaf or inner <a class="el" href="structstx_1_1btree_1_1node.html" title="The header structure of each node in-memory.">node</a>. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01224">1224</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01888">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::btree()</a>, <a class="el" href="btree_8h-source.html#l01397">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::clear()</a>, <a class="el" href="btree_8h-source.html#l01692">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::count()</a>, <a class="el" href="btree_8h-source.html#l03270">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::dump()</a>, <a class="el" href="btree_8h-source.html#l02335">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one()</a>, <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>, <a class="el" href="btree_8h-source.html#l01627">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::exists()</a>, <a class="el" href="btree_8h-source.html#l01648">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::find()</a>, <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>, <a class="el" href="btree_8h-source.html#l01725">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::lower_bound()</a>, <a class="el" href="btree_8h-source.html#l01865">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator=()</a>, <a class="el" href="btree_8h-source.html#l02979">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::print()</a>, <a class="el" href="btree_8h-source.html#l03287">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore()</a>, <a class="el" href="btree_8h-source.html#l01282">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::swap()</a>, <a class="el" href="btree_8h-source.html#l01767">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::upper_bound()</a>, <a class="el" href="btree_8h-source.html#l03053">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify()</a>, and <a class="el" href="btree_8h-source.html#l03073">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify_node()</a>.</p>

</div>
</div><p>
<a class="anchor" name="de7d8981baba296625eae14006d2c760"></a><!-- doxytag: member="stx::btree::headleaf" ref="de7d8981baba296625eae14006d2c760" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a>* <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#de7d8981baba296625eae14006d2c760">headleaf</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to first leaf in the double linked leaf chain. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01227">1227</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01443">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::begin()</a>, <a class="el" href="btree_8h-source.html#l01397">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::clear()</a>, <a class="el" href="btree_8h-source.html#l01905">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::copy_recursive()</a>, <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>, <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>, <a class="el" href="btree_8h-source.html#l02987">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::print_leaves()</a>, <a class="el" href="btree_8h-source.html#l03351">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore_node()</a>, <a class="el" href="btree_8h-source.html#l01282">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::swap()</a>, and <a class="el" href="btree_8h-source.html#l03158">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify_leaflinks()</a>.</p>

</div>
</div><p>
<a class="anchor" name="84f024ba0a8d91eb94571092bec9fb96"></a><!-- doxytag: member="stx::btree::tailleaf" ref="84f024ba0a8d91eb94571092bec9fb96" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1btree_1_1leaf__node.html">leaf_node</a>* <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#84f024ba0a8d91eb94571092bec9fb96">tailleaf</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pointer to last leaf in the double linked leaf chain. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01230">1230</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01397">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::clear()</a>, <a class="el" href="btree_8h-source.html#l01905">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::copy_recursive()</a>, <a class="el" href="btree_8h-source.html#l01450">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::end()</a>, <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>, <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>, <a class="el" href="btree_8h-source.html#l02677">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::merge_leaves()</a>, <a class="el" href="btree_8h-source.html#l03351">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore_node()</a>, <a class="el" href="btree_8h-source.html#l02194">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::split_leaf_node()</a>, <a class="el" href="btree_8h-source.html#l01282">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::swap()</a>, and <a class="el" href="btree_8h-source.html#l03158">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify_leaflinks()</a>.</p>

</div>
</div><p>
<a class="anchor" name="191ecb365eda1096adef4cb7ae223606"></a><!-- doxytag: member="stx::btree::stats" ref="191ecb365eda1096adef4cb7ae223606" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstx_1_1btree_1_1tree__stats.html">tree_stats</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#191ecb365eda1096adef4cb7ae223606">stats</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Other small statistics about the B+ tree. 
<p>

<p>Definition at line <a class="el" href="btree_8h-source.html#l01233">1233</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01371">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::allocate_inner()</a>, <a class="el" href="btree_8h-source.html#l01362">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::allocate_leaf()</a>, <a class="el" href="btree_8h-source.html#l01888">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::btree()</a>, <a class="el" href="btree_8h-source.html#l01397">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::clear()</a>, <a class="el" href="btree_8h-source.html#l02335">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one()</a>, <a class="el" href="btree_8h-source.html#l02400">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::erase_one_descend()</a>, <a class="el" href="btree_8h-source.html#l01381">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::free_node()</a>, <a class="el" href="btree_8h-source.html#l01617">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::get_stats()</a>, <a class="el" href="btree_8h-source.html#l02008">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_start()</a>, <a class="el" href="btree_8h-source.html#l01865">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator=()</a>, <a class="el" href="btree_8h-source.html#l03287">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::restore()</a>, <a class="el" href="btree_8h-source.html#l01598">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::size()</a>, <a class="el" href="btree_8h-source.html#l01282">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::swap()</a>, and <a class="el" href="btree_8h-source.html#l03053">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::verify()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5e618ec38c852d5b81d997bdc932d592"></a><!-- doxytag: member="stx::btree::key_less" ref="5e618ec38c852d5b81d997bdc932d592" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Data, typename _Value = std::pair&lt;_Key, _Data&gt;, typename _Compare = std::less&lt;_Key&gt;, typename _Traits = btree_default_map_traits&lt;_Key, _Data&gt;, bool _Duplicates = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstx_1_1btree.html#8f75664f479fc4ca3f54a3a5757d98a7">key_compare</a> <a class="el" href="classstx_1_1btree.html">stx::btree</a>&lt; _Key, _Data, _Value, _Compare, _Traits, _Duplicates &gt;::<a class="el" href="classstx_1_1btree.html#5e618ec38c852d5b81d997bdc932d592">key_less</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Key comparison object. 
<p>
More comparison functions are generated from this &lt; relation. 
<p>Definition at line <a class="el" href="btree_8h-source.html#l01237">1237</a> of file <a class="el" href="btree_8h-source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="btree_8h-source.html#l01505">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::find_lower()</a>, <a class="el" href="btree_8h-source.html#l01552">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::find_upper()</a>, <a class="el" href="btree_8h-source.html#l02054">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::insert_descend()</a>, <a class="el" href="btree_8h-source.html#l01318">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::key_comp()</a>, <a class="el" href="btree_8h-source.html#l01353">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::key_equal()</a>, <a class="el" href="btree_8h-source.html#l01340">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::key_greater()</a>, <a class="el" href="btree_8h-source.html#l01346">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::key_greaterequal()</a>, <a class="el" href="btree_8h-source.html#l01334">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::key_lessequal()</a>, <a class="el" href="btree_8h-source.html#l01865">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::operator=()</a>, <a class="el" href="btree_8h-source.html#l01282">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::swap()</a>, and <a class="el" href="btree_8h-source.html#l01325">stx::btree&lt; _Key, _Data, std::pair&lt; key_type, data_type &gt;, _Compare, _Traits, true &gt;::value_comp()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>stx/<a class="el" href="btree_8h-source.html">btree.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Sep 7 17:32:39 2008 for STX B+ Tree Template Classes by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
