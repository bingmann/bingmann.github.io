<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>STX Expression Parser: Example Application: Simple Expression Calculator</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="example_exprcalc">Example Application: Simple Expression Calculator</a></h1>The first example application is a simple calculator.<p>
It takes the arguments on the command line as an expresssion string, parses it and evaluates the resulting tree using a <a class="el" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">stx::BasicSymbolTable</a>. This page will guide you through the workings of the example.<h2><a class="anchor" name="sec1">
Detailed Example Code Guide</a></h2>
<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="ExpressionParser_8h.html" title="Definition of a the public interface of the STX Expression Parser.">ExpressionParser.h</a>"</span>
</pre></div><p>
The include file <a class="el" href="ExpressionParser_8h.html" title="Definition of a the public interface of the STX Expression Parser.">ExpressionParser.h</a> contains the required classes and also includes <a class="el" href="AnyScalar_8h.html" title="Definition of a typed scalar value class AnyScalar used by the parser to represent...">AnyScalar.h</a><p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// collect expression by joining all input arguments</span>
    std::string args;
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; argc; i++) {
        <span class="keywordflow">if</span> (!args.empty()) args += <span class="stringliteral">" "</span>;
        args += argv[i];
    }
</pre></div><p>
The first step in main is to collect all command line parameters into a single std::string. When invoking the exprcalc program from the command line it is better to quote the whole expression into one argument: <code>./exprcalc "4 + 19 2"</code>. This will work correctly with special symbols processed by the shell like <code>&lt;</code>, <code>&gt;</code> or <code>!</code>.<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// parse expression into a parse tree</span>
    <a class="code" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">stx::ParseTree</a> pt;
    <span class="keywordflow">try</span>
    {
        pt = <a class="code" href="namespacestx.html#7a6901ec05156cf3aa6a60bde61f15ca" title="Parse the given input expression into a parse tree.">stx::parseExpression</a>(args);
        std::cout &lt;&lt; <span class="stringliteral">"parsed: "</span> &lt;&lt; pt.<a class="code" href="classstx_1_1ParseTree.html#d0638a2ab646e0cd68c6d371f6e33fb5" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() &lt;&lt; <span class="stringliteral">"\n"</span>;
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">stx::ExpressionParserException</a> &amp;e)
    {
        std::cout &lt;&lt; <span class="stringliteral">"ExpressionParserException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        <span class="keywordflow">return</span> 0;
    }
</pre></div><p>
Next the concatenated arguments are parsed by the expression parser using <a class="el" href="namespacestx.html#7a6901ec05156cf3aa6a60bde61f15ca" title="Parse the given input expression into a parse tree.">stx::parseExpression(const std::string&amp;)</a>. The parse function returns a <a class="el" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">stx::ParseTree</a> object by value; the <a class="el" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">stx::ParseTree</a> object is actually a pimpl front-end to the top-most <a class="el" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">stx::ParseNode</a> of the tree.<p>
Many thing can go wrong while parsing the user input string and will result in parseExpression throwing an exception. The top exception class used by the parser is <a class="el" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">stx::ExpressionParserException</a>. If the user enters an invalid expression like <code>"3 + "</code> then a <a class="el" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">stx::BadSyntaxException</a> is thrown and will be caught by the catch-block and the application terminated after printing an error.<p>
If the input could successfully be parsed then the program prints the resulting parse tree using <a class="el" href="classstx_1_1ParseTree.html#d0638a2ab646e0cd68c6d371f6e33fb5" title="Return the parsed expression as a string, which can be parsed again.">stx::ParseTree::toString()</a>. This function converts the internal tree structure back to a string, which can be re-parsed into the same tree. Usually this string will include extra brackets like <code>"(4 + (19 * x))"</code>.<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// evaluate the expression with a very simple symbol table</span>
    <a class="code" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">stx::BasicSymbolTable</a> bst;
    bst.<a class="code" href="classstx_1_1BasicSymbolTable.html#69cc26322a17a19a3fec86c866afd5fe" title="Add or replace a variable to the symbol table.">setVariable</a>(<span class="stringliteral">"x"</span>, 42);
</pre></div><p>
Then an instance of <a class="el" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">stx::BasicSymbolTable</a> is created. <a class="el" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">stx::BasicSymbolTable</a> is a derivative of the abstract <a class="el" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">stx::SymbolTable</a> which is used by the evaluation functions to fill in variables and functions. The <a class="el" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">stx::BasicSymbolTable</a> includes some basic mathematical functions like sin() and exp().<p>
For our simple calculator we define a single variable: <code>x</code> is set to <code>42</code>.<p>
<div class="fragment"><pre class="fragment">
    <span class="keywordflow">try</span>
    {
        <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> val = pt.<a class="code" href="classstx_1_1ParseTree.html#8fad810eb5af360f69e2624a53f678fb" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>(bst);

        std::cout &lt;&lt; <span class="stringliteral">"evaluated: "</span> &lt;&lt; val &lt;&lt; <span class="stringliteral">"\n"</span>;
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1UnknownSymbolException.html" title="Exception class thrown when the symbol table cannot find a variable or function.">stx::UnknownSymbolException</a> &amp;e)
    {
        std::cout &lt;&lt; <span class="stringliteral">"UnknownSymbolException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        <span class="keywordflow">return</span> 0;
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">stx::ExpressionParserException</a> &amp;e)
    {
        std::cout &lt;&lt; <span class="stringliteral">"ExpressionParserException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        <span class="keywordflow">return</span> 0;
    }

    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
Once the symbol table is filled in, the parse tree is evaluated using it. The evaluation result is returned as a <a class="el" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> and printed out to the user.<p>
During evaluation variable placeholders are filled in. If the expression requires a non-existing variable of function, then the standard behaviour of <a class="el" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">stx::BasicSymbolTable</a> is to throw a <a class="el" href="classstx_1_1UnknownSymbolException.html" title="Exception class thrown when the symbol table cannot find a variable or function.">stx::UnknownSymbolException</a>.<p>
Further exceptions can be thrown during different operations on the <a class="el" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> objects. These operators will throw a <a class="el" href="classstx_1_1ConversionException.html" title="ConversionException is an exception class thrown by some combinations of get and...">stx::ConversionException</a> if incompatible types are used. For example boolean + integer is not allowed and will throw.<h2><a class="anchor" name="sec1_complete">
Complete Example Source Code</a></h2>
The example can be found in the distribution in examples/simple/<p>
<div class="fragment"><pre class="fragment"><span class="comment">// $Id: exprcalc.cc 59 2007-07-17 14:43:23Z tb $</span>

<span class="comment">/*</span>
<span class="comment"> * STX Expression Parser C++ Framework v0.7</span>
<span class="comment"> * Copyright (C) 2007 Timo Bingmann</span>
<span class="comment"> *</span>
<span class="comment"> * This library is free software; you can redistribute it and/or modify it</span>
<span class="comment"> * under the terms of the GNU Lesser General Public License as published by the</span>
<span class="comment"> * Free Software Foundation; either version 2.1 of the License, or (at your</span>
<span class="comment"> * option) any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This library is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License</span>
<span class="comment"> * for more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU Lesser General Public License</span>
<span class="comment"> * along with this library; if not, write to the Free Software Foundation,</span>
<span class="comment"> * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="comment"> */</span>

<span class="comment">// Simple Expression Calculator Example</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
 
<span class="preprocessor">#include "<a class="code" href="ExpressionParser_8h.html" title="Definition of a the public interface of the STX Expression Parser.">ExpressionParser.h</a>"</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// collect expression by joining all input arguments</span>
    std::string args;
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; argc; i++) {
        <span class="keywordflow">if</span> (!args.empty()) args += <span class="stringliteral">" "</span>;
        args += argv[i];
    }

    std::cout &lt;&lt; <span class="stringliteral">"input string: "</span> &lt;&lt; args &lt;&lt; <span class="stringliteral">"\n"</span>;

    <span class="comment">// parse expression into a parse tree</span>
    <a class="code" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">stx::ParseTree</a> pt;
    <span class="keywordflow">try</span>
    {
        pt = <a class="code" href="namespacestx.html#7a6901ec05156cf3aa6a60bde61f15ca" title="Parse the given input expression into a parse tree.">stx::parseExpression</a>(args);
        std::cout &lt;&lt; <span class="stringliteral">"parsed: "</span> &lt;&lt; pt.<a class="code" href="classstx_1_1ParseTree.html#d0638a2ab646e0cd68c6d371f6e33fb5" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() &lt;&lt; <span class="stringliteral">"\n"</span>;
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">stx::ExpressionParserException</a> &amp;e)
    {
        std::cout &lt;&lt; <span class="stringliteral">"ExpressionParserException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        <span class="keywordflow">return</span> 0;
    }

    <span class="comment">// evaluate the expression with a very simple symbol table</span>
    <a class="code" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">stx::BasicSymbolTable</a> bst;
    bst.<a class="code" href="classstx_1_1BasicSymbolTable.html#69cc26322a17a19a3fec86c866afd5fe" title="Add or replace a variable to the symbol table.">setVariable</a>(<span class="stringliteral">"x"</span>, 42);

    <span class="keywordflow">try</span>
    {
        <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> val = pt.<a class="code" href="classstx_1_1ParseTree.html#8fad810eb5af360f69e2624a53f678fb" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>(bst);

        std::cout &lt;&lt; <span class="stringliteral">"evaluated: "</span> &lt;&lt; val &lt;&lt; <span class="stringliteral">"\n"</span>;
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1UnknownSymbolException.html" title="Exception class thrown when the symbol table cannot find a variable or function.">stx::UnknownSymbolException</a> &amp;e)
    {
        std::cout &lt;&lt; <span class="stringliteral">"UnknownSymbolException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        <span class="keywordflow">return</span> 0;
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">stx::ExpressionParserException</a> &amp;e)
    {
        std::cout &lt;&lt; <span class="stringliteral">"ExpressionParserException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        <span class="keywordflow">return</span> 0;
    }

    <span class="keywordflow">return</span> 0;
}
</pre></div> <hr size="1"><address style="text-align: right;"><small>Generated on Tue Jul 17 16:51:58 2007 for STX Expression Parser by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
