<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>STX Expression Parser: libstx-exparser/ExpressionParser.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>libstx-exparser/ExpressionParser.cc</h1><a href="ExpressionParser_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// $Id: ExpressionParser.cc 59 2007-07-17 14:43:23Z tb $</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="comment">/*</span>
<a name="l00004"></a>00004 <span class="comment"> * STX Expression Parser C++ Framework v0.7</span>
<a name="l00005"></a>00005 <span class="comment"> * Copyright (C) 2007 Timo Bingmann</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * This library is free software; you can redistribute it and/or modify it</span>
<a name="l00008"></a>00008 <span class="comment"> * under the terms of the GNU Lesser General Public License as published by the</span>
<a name="l00009"></a>00009 <span class="comment"> * Free Software Foundation; either version 2.1 of the License, or (at your</span>
<a name="l00010"></a>00010 <span class="comment"> * option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> * This library is distributed in the hope that it will be useful, but WITHOUT</span>
<a name="l00013"></a>00013 <span class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<a name="l00014"></a>00014 <span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License</span>
<a name="l00015"></a>00015 <span class="comment"> * for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> * You should have received a copy of the GNU Lesser General Public License</span>
<a name="l00018"></a>00018 <span class="comment"> * along with this library; if not, write to the Free Software Foundation,</span>
<a name="l00019"></a>00019 <span class="comment"> * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</span>
<a name="l00020"></a>00020 <span class="comment"> */</span>
<a name="l00021"></a>00021 
<a name="l00027"></a>00027 <span class="preprocessor">#include "<a class="code" href="ExpressionParser_8h.html" title="Definition of a the public interface of the STX Expression Parser.">ExpressionParser.h</a>"</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;boost/spirit/core.hpp&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;boost/spirit/tree/ast.hpp&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;boost/spirit/tree/tree_to_xml.hpp&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;boost/spirit/utility/lists.hpp&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;boost/spirit/utility/distinct.hpp&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;boost/spirit/utility/escape_char.hpp&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;boost/spirit/utility/grammar_def.hpp&gt;</span> 
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="comment">// #define STX_DEBUG_PARSER</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="keyword">namespace </span>stx {
<a name="l00046"></a>00046 
<a name="l00049"></a><a class="code" href="namespacestx_1_1Grammar.html">00049</a> <span class="keyword">namespace </span>Grammar {
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="keyword">using namespace </span>boost::spirit;
<a name="l00052"></a>00052 
<a name="l00054"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9">00054</a> <span class="keyword">enum</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9" title="This enum specifies ids for the parse tree nodes created for each rule.">parser_ids</a>
<a name="l00055"></a>00055 {
<a name="l00056"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d96b5de61b6b955e03df9bb7b5cfc1cdbd">00056</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d96b5de61b6b955e03df9bb7b5cfc1cdbd">boolean_const_id</a> = 1,
<a name="l00057"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d90c8d12e62036bd5405d74ae3884e853c">00057</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d90c8d12e62036bd5405d74ae3884e853c">integer_const_id</a>,
<a name="l00058"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d99149bee656d51b707a8d9d17d63c5512">00058</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d99149bee656d51b707a8d9d17d63c5512">long_const_id</a>,
<a name="l00059"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9c269493fa64c6557037f16f92e7dd236">00059</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9c269493fa64c6557037f16f92e7dd236">double_const_id</a>,
<a name="l00060"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d93234711296d0db18f9e08a73ea0bd7b2">00060</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d93234711296d0db18f9e08a73ea0bd7b2">string_const_id</a>,
<a name="l00061"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d967309c293874c11524743d2293a9a4be">00061</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d967309c293874c11524743d2293a9a4be">constant_id</a>,
<a name="l00062"></a>00062 
<a name="l00063"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9729ced2f13b7afea76602294f73375a7">00063</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9729ced2f13b7afea76602294f73375a7">function_call_id</a>,
<a name="l00064"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9c6c960472ca5db496d2ab39a26c673cc">00064</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9c6c960472ca5db496d2ab39a26c673cc">function_identifier_id</a>,
<a name="l00065"></a>00065 
<a name="l00066"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d92036f53edd07ee94c05ef7547292f8ff">00066</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d92036f53edd07ee94c05ef7547292f8ff">varname_id</a>,
<a name="l00067"></a>00067 
<a name="l00068"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d903cedffaea8b395f7ea17e68e65ccc2c">00068</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d903cedffaea8b395f7ea17e68e65ccc2c">atom_expr_id</a>,
<a name="l00069"></a>00069 
<a name="l00070"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d920e16b73c807ad3b36fb65022c054ce9">00070</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d920e16b73c807ad3b36fb65022c054ce9">unary_expr_id</a>,
<a name="l00071"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9cf1954fe04fb757c20f333350e3900ee">00071</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9cf1954fe04fb757c20f333350e3900ee">mul_expr_id</a>,
<a name="l00072"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9358561b4291b403350f0487aedd34632">00072</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9358561b4291b403350f0487aedd34632">add_expr_id</a>,
<a name="l00073"></a>00073 
<a name="l00074"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9d0210e4d83663e3b488fe5b12cd9c0d3">00074</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9d0210e4d83663e3b488fe5b12cd9c0d3">cast_expr_id</a>,
<a name="l00075"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d94a990578c59110c910c1182c4b5dd5f7">00075</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d94a990578c59110c910c1182c4b5dd5f7">cast_spec_id</a>,
<a name="l00076"></a>00076 
<a name="l00077"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d94af2653c49220c268287f93ae89fd87e">00077</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d94af2653c49220c268287f93ae89fd87e">comp_expr_id</a>,
<a name="l00078"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9db4864f8124fa8887057d4f196e2a9ac">00078</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9db4864f8124fa8887057d4f196e2a9ac">and_expr_id</a>,
<a name="l00079"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9891a237d94aa87d7db6912d816a17adc">00079</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9891a237d94aa87d7db6912d816a17adc">or_expr_id</a>,
<a name="l00080"></a>00080 
<a name="l00081"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d92f300e7fe1da5ac640663145bab77d22">00081</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d92f300e7fe1da5ac640663145bab77d22">expr_id</a>,
<a name="l00082"></a><a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9ba405d3bcd2ccc7a20b192490e0c0c80">00082</a>     <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9ba405d3bcd2ccc7a20b192490e0c0c80">exprlist_id</a>,
<a name="l00083"></a>00083 };
<a name="l00084"></a>00084 
<a name="l00086"></a>00086 distinct_parser&lt;&gt; <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"a-zA-Z0-9_"</span>);
<a name="l00087"></a>00087 
<a name="l00089"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar.html">00089</a> <span class="keyword">struct </span><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar.html" title="The boost::spirit expression parser grammar.">ExpressionGrammar</a> : <span class="keyword">public</span> grammar&lt;ExpressionGrammar&gt;
<a name="l00090"></a>00090 {
<a name="l00093"></a>00093     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ScannerT&gt;
<a name="l00094"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html">00094</a>     <span class="keyword">struct </span><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html" title="The boost::spirit expression parser grammar definition (for a specific scanner) with...">definition</a> : <span class="keyword">public</span> grammar_def&lt;rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;expr_id&gt; &gt;,
<a name="l00095"></a>00095                                            rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;exprlist_id&gt; &gt; &gt;
<a name="l00096"></a>00096     {
<a name="l00098"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#95299ad6f58c8f37d517fd7829177176">00098</a>         <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#95299ad6f58c8f37d517fd7829177176" title="Real definition function of the grammar.">definition</a>(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar.html" title="The boost::spirit expression parser grammar.">ExpressionGrammar</a> <span class="keyword">const</span>&amp; <span class="comment">/*self*/</span>)
<a name="l00099"></a>00099         {
<a name="l00100"></a>00100             <span class="comment">// *** Constants</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#939cc826c618bb3146fa1e469146f8ef" title="Rule for a constant: one of the three scalar types integer_const, double_const or...">constant</a>
<a name="l00103"></a>00103                 = <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#291c95e0eadb598314158aa9f1ffede9" title="Float constant rule: "1234.3".">double_const</a>
<a name="l00104"></a>00104                 | <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#79d8acc5fa92dda21d04bb432bd60967" title="Integer constant rule: "1234".">integer_const</a>
<a name="l00105"></a>00105                 | <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#69b20f93ca66a8bae75af45a2d12b4dc" title="Long integer constant rule: "12345452154".">long_const</a>
<a name="l00106"></a>00106                 | <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bef2f9f89fa691be97687335c07d5f4b" title="Boolean value constant rule: "true" or "false".">boolean_const</a>
<a name="l00107"></a>00107                 | <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#9e1419370fc7b2a0e6f088965d991809" title="String constant rule: with quotes "abc".">string_const</a>
<a name="l00108"></a>00108                 ;
<a name="l00109"></a>00109             
<a name="l00110"></a>00110             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bef2f9f89fa691be97687335c07d5f4b" title="Boolean value constant rule: "true" or "false".">boolean_const</a>
<a name="l00111"></a>00111                 = as_lower_d[<a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"true"</span>) | <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"false"</span>)]
<a name="l00112"></a>00112                 ;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#79d8acc5fa92dda21d04bb432bd60967" title="Integer constant rule: "1234".">integer_const</a>
<a name="l00115"></a>00115                 = int_p
<a name="l00116"></a>00116                 ;
<a name="l00117"></a>00117 
<a name="l00118"></a>00118             <span class="comment">// this is needed because spirit's int_parsers don't work with</span>
<a name="l00119"></a>00119             <span class="comment">// these long numbers</span>
<a name="l00120"></a>00120             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#69b20f93ca66a8bae75af45a2d12b4dc" title="Long integer constant rule: "12345452154".">long_const</a>
<a name="l00121"></a>00121                 = token_node_d[ lexeme_d[ !( ch_p(<span class="charliteral">'+'</span>) | ch_p(<span class="charliteral">'-'</span> ) ) &gt;&gt; +( range_p(<span class="charliteral">'0'</span>,<span class="charliteral">'9'</span>) ) ] ]
<a name="l00122"></a>00122                 ;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#291c95e0eadb598314158aa9f1ffede9" title="Float constant rule: "1234.3".">double_const</a>
<a name="l00125"></a>00125                 = strict_real_p
<a name="l00126"></a>00126                 ;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#9e1419370fc7b2a0e6f088965d991809" title="String constant rule: with quotes "abc".">string_const</a>
<a name="l00129"></a>00129                 = lexeme_d[
<a name="l00130"></a>00130                     token_node_d[ <span class="charliteral">'"'</span> &gt;&gt; *(c_escape_ch_p - <span class="charliteral">'"'</span>) &gt;&gt; <span class="charliteral">'"'</span> ]
<a name="l00131"></a>00131                     ]
<a name="l00132"></a>00132                 ;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134             <span class="comment">// *** Function call and function identifier</span>
<a name="l00135"></a>00135 
<a name="l00136"></a>00136             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e2018755c707c8afa00485b90f0b5f2f" title="Function call rule: func1(a,b,c) where a,b,c is a list of exprs.">function_call</a>
<a name="l00137"></a>00137                 = root_node_d[<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#f3f27ce0c332e16f81f3cacaf8c55247" title="Function rule to match a function identifier: alphanumeric and _ are allowed.">function_identifier</a>]
<a name="l00138"></a>00138                 &gt;&gt; discard_node_d[ ch_p(<span class="charliteral">'('</span>) ] &gt;&gt; <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e116c9d76562575807c727786dd78b27" title="Base rule to match a comma-separated list of expressions (used for function arguments...">exprlist</a> &gt;&gt; discard_node_d[ ch_p(<span class="charliteral">')'</span>) ]
<a name="l00139"></a>00139                 ;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#f3f27ce0c332e16f81f3cacaf8c55247" title="Function rule to match a function identifier: alphanumeric and _ are allowed.">function_identifier</a>
<a name="l00142"></a>00142                 = lexeme_d[ 
<a name="l00143"></a>00143                     token_node_d[ alpha_p &gt;&gt; *(alnum_p | ch_p(<span class="charliteral">'_'</span>)) ]
<a name="l00144"></a>00144                     ]
<a name="l00145"></a>00145                 ;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147             <span class="comment">// *** Expression names</span>
<a name="l00148"></a>00148 
<a name="l00149"></a>00149             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#488e270da0c948c9d93ed0c6237e5b3a" title="Rule to match a variable name: alphanumeric with _.">varname</a>
<a name="l00150"></a>00150                 = lexeme_d[ 
<a name="l00151"></a>00151                     token_node_d[ alpha_p &gt;&gt; *(alnum_p | ch_p(<span class="charliteral">'_'</span>)) ]
<a name="l00152"></a>00152                     ]
<a name="l00153"></a>00153                 ;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155             <span class="comment">// *** Valid Expressions, from small to large</span>
<a name="l00156"></a>00156 
<a name="l00157"></a>00157             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#88455597f5a6fbcab3870603c536b9bc" title="Helper rule which implements () bracket grouping.">atom_expr</a>
<a name="l00158"></a>00158                 = <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#939cc826c618bb3146fa1e469146f8ef" title="Rule for a constant: one of the three scalar types integer_const, double_const or...">constant</a>
<a name="l00159"></a>00159                 | inner_node_d[ ch_p(<span class="charliteral">'('</span>) &gt;&gt; <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#5bbb44cda29ef21cc2301ffd95794fc9" title="Base rule to match an expression.">expr</a> &gt;&gt; ch_p(<span class="charliteral">')'</span>) ]
<a name="l00160"></a>00160                 | function_call
<a name="l00161"></a>00161                 | varname
<a name="l00162"></a>00162                 ;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e8a9418306fb25dbe59b18aef1cf848e" title="Unary operator rule: recognizes + - ! and "not".">unary_expr</a>
<a name="l00165"></a>00165                 = !( root_node_d[ as_lower_d[ch_p(<span class="charliteral">'+'</span>) | ch_p(<span class="charliteral">'-'</span>) | ch_p(<span class="charliteral">'!'</span>) | str_p(<span class="stringliteral">"not"</span>)] ] )
<a name="l00166"></a>00166                 &gt;&gt; atom_expr
<a name="l00167"></a>00167                 ;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#ef1b5493af4a10d8988f9b5f79929470" title="Match all the allowed cast types: short, double, etc.">cast_spec</a>
<a name="l00170"></a>00170                 = discard_node_d[ ch_p(<span class="charliteral">'('</span>) ]
<a name="l00171"></a>00171                 &gt;&gt; (
<a name="l00172"></a>00172                     <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"bool"</span>) |
<a name="l00173"></a>00173                     <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"char"</span>) | <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"short"</span>) | <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"int"</span>) | <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"integer"</span>) | <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"long"</span>) |
<a name="l00174"></a>00174                     <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"byte"</span>) | <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"word"</span>) | <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"dword"</span>) | <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"qword"</span>) |
<a name="l00175"></a>00175                     <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"float"</span>) | <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"double"</span>) |
<a name="l00176"></a>00176                     <a class="code" href="namespacestx_1_1Grammar.html#3b4e985aa91fb55fd9bb9d4c3444283b" title="Keyword parser used for matching words with () and spaces as separators.">keyword_p</a>(<span class="stringliteral">"string"</span>)
<a name="l00177"></a>00177                     )
<a name="l00178"></a>00178                 &gt;&gt; discard_node_d[ ch_p(<span class="charliteral">')'</span>) ]
<a name="l00179"></a>00179                 ;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bed3498b3183abc32841c24df10b35ef" title="Cast operator written like in C: (short).">cast_expr</a>
<a name="l00182"></a>00182                 = root_node_d[ !<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#ef1b5493af4a10d8988f9b5f79929470" title="Match all the allowed cast types: short, double, etc.">cast_spec</a> ] &gt;&gt; <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e8a9418306fb25dbe59b18aef1cf848e" title="Unary operator rule: recognizes + - ! and "not".">unary_expr</a>
<a name="l00183"></a>00183                 ;
<a name="l00184"></a>00184 
<a name="l00185"></a>00185             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#d6e2f9ffe73c821f58130165dbdfc828" title="Binary operator rule taking precedent before add_expr: recognizes * and /.">mul_expr</a>
<a name="l00186"></a>00186                 = <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bed3498b3183abc32841c24df10b35ef" title="Cast operator written like in C: (short).">cast_expr</a>
<a name="l00187"></a>00187                 &gt;&gt; *( root_node_d[ch_p(<span class="charliteral">'*'</span>) | ch_p(<span class="charliteral">'/'</span>)] &gt;&gt; <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bed3498b3183abc32841c24df10b35ef" title="Cast operator written like in C: (short).">cast_expr</a> )
<a name="l00188"></a>00188                 ;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#3d74c1484115426401a78c42c7854685" title="Binary operator rule: recognizes + and -.">add_expr</a>
<a name="l00191"></a>00191                 = <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#d6e2f9ffe73c821f58130165dbdfc828" title="Binary operator rule taking precedent before add_expr: recognizes * and /.">mul_expr</a>
<a name="l00192"></a>00192                 &gt;&gt; *( root_node_d[ch_p(<span class="charliteral">'+'</span>) | ch_p(<span class="charliteral">'-'</span>)] &gt;&gt; <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#d6e2f9ffe73c821f58130165dbdfc828" title="Binary operator rule taking precedent before add_expr: recognizes * and /.">mul_expr</a> )
<a name="l00193"></a>00193                 ;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bd86ab6f6622bb23234cd879bd8d837b" title="Comparison operator: recognizes == = != &lt;= &gt;= &lt; &gt; =&gt; =&lt;.">comp_expr</a>
<a name="l00196"></a>00196                 = add_expr
<a name="l00197"></a>00197                 &gt;&gt; *( root_node_d[( str_p(<span class="stringliteral">"=="</span>) | str_p(<span class="stringliteral">"!="</span>) |
<a name="l00198"></a>00198                                     str_p(<span class="stringliteral">"&lt;="</span>) | str_p(<span class="stringliteral">"&gt;="</span>) | str_p(<span class="stringliteral">"=&lt;"</span>) | str_p(<span class="stringliteral">"=&gt;"</span>) |
<a name="l00199"></a>00199                                     ch_p(<span class="charliteral">'='</span>) | ch_p(<span class="charliteral">'&lt;'</span>) | ch_p(<span class="charliteral">'&gt;'</span>) )] &gt;&gt; add_expr )
<a name="l00200"></a>00200                 ;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#4b2d8e0d661c7b2a3388df7c03464718" title="Boolean operator: recognizes &amp;&amp; and "and" and works only on boolean values...">and_expr</a>
<a name="l00203"></a>00203                 = comp_expr
<a name="l00204"></a>00204                 &gt;&gt; *( root_node_d[ as_lower_d[str_p(<span class="stringliteral">"and"</span>) | str_p(<span class="stringliteral">"&amp;&amp;"</span>)] ] &gt;&gt; comp_expr )
<a name="l00205"></a>00205                 ;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#0440c07a5878b69c739b16b8e4250a1c" title="Boolean operator: recognizes || and "or" and works only on boolean values.">or_expr</a>
<a name="l00208"></a>00208                 = <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#4b2d8e0d661c7b2a3388df7c03464718" title="Boolean operator: recognizes &amp;&amp; and "and" and works only on boolean values...">and_expr</a>
<a name="l00209"></a>00209                 &gt;&gt; *( root_node_d[ as_lower_d[str_p(<span class="stringliteral">"or"</span>) | str_p(<span class="stringliteral">"||"</span>)] ] &gt;&gt; <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#4b2d8e0d661c7b2a3388df7c03464718" title="Boolean operator: recognizes &amp;&amp; and "and" and works only on boolean values...">and_expr</a> )
<a name="l00210"></a>00210                 ;
<a name="l00211"></a>00211 
<a name="l00212"></a>00212             <span class="comment">// *** Base Expression and List</span>
<a name="l00213"></a>00213 
<a name="l00214"></a>00214             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#5bbb44cda29ef21cc2301ffd95794fc9" title="Base rule to match an expression.">expr</a>
<a name="l00215"></a>00215                 = or_expr
<a name="l00216"></a>00216                 ;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e116c9d76562575807c727786dd78b27" title="Base rule to match a comma-separated list of expressions (used for function arguments...">exprlist</a>
<a name="l00219"></a>00219                 = infix_node_d[ !list_p(expr, ch_p(<span class="charliteral">','</span>)) ]
<a name="l00220"></a>00220                 ;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222             <span class="comment">// Special spirit feature to declare multiple grammar entry points</span>
<a name="l00223"></a>00223             this-&gt;start_parsers(expr, <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e116c9d76562575807c727786dd78b27" title="Base rule to match a comma-separated list of expressions (used for function arguments...">exprlist</a>); 
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="preprocessor">#ifdef STX_DEBUG_PARSER</span>
<a name="l00226"></a>00226 <span class="preprocessor"></span>            BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#939cc826c618bb3146fa1e469146f8ef" title="Rule for a constant: one of the three scalar types integer_const, double_const or...">constant</a>);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228             BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bef2f9f89fa691be97687335c07d5f4b" title="Boolean value constant rule: "true" or "false".">boolean_const</a>);
<a name="l00229"></a>00229             BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#79d8acc5fa92dda21d04bb432bd60967" title="Integer constant rule: "1234".">integer_const</a>);
<a name="l00230"></a>00230             BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#69b20f93ca66a8bae75af45a2d12b4dc" title="Long integer constant rule: "12345452154".">long_const</a>);
<a name="l00231"></a>00231             BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#291c95e0eadb598314158aa9f1ffede9" title="Float constant rule: "1234.3".">double_const</a>);
<a name="l00232"></a>00232             BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#9e1419370fc7b2a0e6f088965d991809" title="String constant rule: with quotes "abc".">string_const</a>);
<a name="l00233"></a>00233 
<a name="l00234"></a>00234             BOOST_SPIRIT_DEBUG_RULE(function_call);
<a name="l00235"></a>00235             BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#f3f27ce0c332e16f81f3cacaf8c55247" title="Function rule to match a function identifier: alphanumeric and _ are allowed.">function_identifier</a>);
<a name="l00236"></a>00236             
<a name="l00237"></a>00237             BOOST_SPIRIT_DEBUG_RULE(varname);
<a name="l00238"></a>00238 
<a name="l00239"></a>00239             BOOST_SPIRIT_DEBUG_RULE(atom_expr);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241             BOOST_SPIRIT_DEBUG_RULE(unary_expr);
<a name="l00242"></a>00242             BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#d6e2f9ffe73c821f58130165dbdfc828" title="Binary operator rule taking precedent before add_expr: recognizes * and /.">mul_expr</a>);
<a name="l00243"></a>00243             BOOST_SPIRIT_DEBUG_RULE(add_expr);
<a name="l00244"></a>00244 
<a name="l00245"></a>00245             BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#ef1b5493af4a10d8988f9b5f79929470" title="Match all the allowed cast types: short, double, etc.">cast_spec</a>);
<a name="l00246"></a>00246             BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bed3498b3183abc32841c24df10b35ef" title="Cast operator written like in C: (short).">cast_expr</a>);
<a name="l00247"></a>00247 
<a name="l00248"></a>00248             BOOST_SPIRIT_DEBUG_RULE(comp_expr);
<a name="l00249"></a>00249             BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#4b2d8e0d661c7b2a3388df7c03464718" title="Boolean operator: recognizes &amp;&amp; and "and" and works only on boolean values...">and_expr</a>);
<a name="l00250"></a>00250             BOOST_SPIRIT_DEBUG_RULE(or_expr);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252             BOOST_SPIRIT_DEBUG_RULE(expr);
<a name="l00253"></a>00253             BOOST_SPIRIT_DEBUG_RULE(<a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e116c9d76562575807c727786dd78b27" title="Base rule to match a comma-separated list of expressions (used for function arguments...">exprlist</a>);
<a name="l00254"></a>00254 <span class="preprocessor">#endif</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>        }
<a name="l00256"></a>00256 
<a name="l00259"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#939cc826c618bb3146fa1e469146f8ef">00259</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;constant_id&gt; &gt;              <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#939cc826c618bb3146fa1e469146f8ef" title="Rule for a constant: one of the three scalar types integer_const, double_const or...">constant</a>;
<a name="l00260"></a>00260 
<a name="l00262"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bef2f9f89fa691be97687335c07d5f4b">00262</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;boolean_const_id&gt; &gt;         <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bef2f9f89fa691be97687335c07d5f4b" title="Boolean value constant rule: "true" or "false".">boolean_const</a>;
<a name="l00264"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#79d8acc5fa92dda21d04bb432bd60967">00264</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;integer_const_id&gt; &gt;         <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#79d8acc5fa92dda21d04bb432bd60967" title="Integer constant rule: "1234".">integer_const</a>;
<a name="l00266"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#69b20f93ca66a8bae75af45a2d12b4dc">00266</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;long_const_id&gt; &gt;            <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#69b20f93ca66a8bae75af45a2d12b4dc" title="Long integer constant rule: "12345452154".">long_const</a>;
<a name="l00268"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#291c95e0eadb598314158aa9f1ffede9">00268</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;double_const_id&gt; &gt;          <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#291c95e0eadb598314158aa9f1ffede9" title="Float constant rule: "1234.3".">double_const</a>;
<a name="l00270"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#9e1419370fc7b2a0e6f088965d991809">00270</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;string_const_id&gt; &gt;          <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#9e1419370fc7b2a0e6f088965d991809" title="String constant rule: with quotes "abc".">string_const</a>;
<a name="l00271"></a>00271 
<a name="l00273"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e2018755c707c8afa00485b90f0b5f2f">00273</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;function_call_id&gt; &gt;         <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e2018755c707c8afa00485b90f0b5f2f" title="Function call rule: func1(a,b,c) where a,b,c is a list of exprs.">function_call</a>;
<a name="l00276"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#f3f27ce0c332e16f81f3cacaf8c55247">00276</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;function_identifier_id&gt; &gt;   <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#f3f27ce0c332e16f81f3cacaf8c55247" title="Function rule to match a function identifier: alphanumeric and _ are allowed.">function_identifier</a>;
<a name="l00277"></a>00277 
<a name="l00279"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#488e270da0c948c9d93ed0c6237e5b3a">00279</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;varname_id&gt; &gt;               <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#488e270da0c948c9d93ed0c6237e5b3a" title="Rule to match a variable name: alphanumeric with _.">varname</a>;
<a name="l00280"></a>00280 
<a name="l00282"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#88455597f5a6fbcab3870603c536b9bc">00282</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;atom_expr_id&gt; &gt;             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#88455597f5a6fbcab3870603c536b9bc" title="Helper rule which implements () bracket grouping.">atom_expr</a>;
<a name="l00283"></a>00283 
<a name="l00285"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e8a9418306fb25dbe59b18aef1cf848e">00285</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;unary_expr_id&gt; &gt;            <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e8a9418306fb25dbe59b18aef1cf848e" title="Unary operator rule: recognizes + - ! and "not".">unary_expr</a>;
<a name="l00288"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#d6e2f9ffe73c821f58130165dbdfc828">00288</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;mul_expr_id&gt; &gt;              <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#d6e2f9ffe73c821f58130165dbdfc828" title="Binary operator rule taking precedent before add_expr: recognizes * and /.">mul_expr</a>;
<a name="l00290"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#3d74c1484115426401a78c42c7854685">00290</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;add_expr_id&gt; &gt;              <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#3d74c1484115426401a78c42c7854685" title="Binary operator rule: recognizes + and -.">add_expr</a>;
<a name="l00291"></a>00291 
<a name="l00293"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#ef1b5493af4a10d8988f9b5f79929470">00293</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;cast_spec_id&gt; &gt;             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#ef1b5493af4a10d8988f9b5f79929470" title="Match all the allowed cast types: short, double, etc.">cast_spec</a>;
<a name="l00295"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bed3498b3183abc32841c24df10b35ef">00295</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;cast_expr_id&gt; &gt;             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bed3498b3183abc32841c24df10b35ef" title="Cast operator written like in C: (short).">cast_expr</a>;
<a name="l00296"></a>00296 
<a name="l00298"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bd86ab6f6622bb23234cd879bd8d837b">00298</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;comp_expr_id&gt; &gt;             <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#bd86ab6f6622bb23234cd879bd8d837b" title="Comparison operator: recognizes == = != &lt;= &gt;= &lt; &gt; =&gt; =&lt;.">comp_expr</a>;
<a name="l00301"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#4b2d8e0d661c7b2a3388df7c03464718">00301</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;and_expr_id&gt; &gt;              <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#4b2d8e0d661c7b2a3388df7c03464718" title="Boolean operator: recognizes &amp;&amp; and "and" and works only on boolean values...">and_expr</a>;
<a name="l00304"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#0440c07a5878b69c739b16b8e4250a1c">00304</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;or_expr_id&gt; &gt;               <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#0440c07a5878b69c739b16b8e4250a1c" title="Boolean operator: recognizes || and "or" and works only on boolean values.">or_expr</a>;
<a name="l00305"></a>00305 
<a name="l00307"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#5bbb44cda29ef21cc2301ffd95794fc9">00307</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;expr_id&gt; &gt;                  <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#5bbb44cda29ef21cc2301ffd95794fc9" title="Base rule to match an expression.">expr</a>;
<a name="l00310"></a><a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e116c9d76562575807c727786dd78b27">00310</a>         rule&lt;ScannerT, parser_context&lt;&gt;, parser_tag&lt;exprlist_id&gt; &gt;              <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar_1_1definition.html#e116c9d76562575807c727786dd78b27" title="Base rule to match a comma-separated list of expressions (used for function arguments...">exprlist</a>;
<a name="l00311"></a>00311     };
<a name="l00312"></a>00312 };
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="comment">// *** Classes representing the nodes in the resulting parse tree, these need</span>
<a name="l00315"></a>00315 <span class="comment">// *** not be publicly available via the header file.</span>
<a name="l00316"></a>00316 
<a name="l00319"></a><a class="code" href="classstx_1_1Grammar_1_1PNConstant.html">00319</a> <span class="keyword">class </span><a class="code" href="classstx_1_1Grammar_1_1PNConstant.html" title="Constant value nodes of the parse tree.">PNConstant</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>
<a name="l00320"></a>00320 {
<a name="l00321"></a>00321 <span class="keyword">private</span>:
<a name="l00323"></a><a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#c0a3dd8fbefa2c60119a7ca5c32d9b1d">00323</a>     <span class="keyword">class </span><a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>     <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#c0a3dd8fbefa2c60119a7ca5c32d9b1d" title="The constant parsed value.">value</a>;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="keyword">public</span>:
<a name="l00327"></a><a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#e220a7b997720fcd1b95e408b92a1ca3">00327</a>     <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#e220a7b997720fcd1b95e408b92a1ca3" title="Assignment from the string received from the parser.">PNConstant</a>(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68" title="Enumeration establishing identifiers for all supported types.">AnyScalar::attrtype_t</a> type, std::string strvalue)
<a name="l00328"></a>00328         : <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>(), <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#c0a3dd8fbefa2c60119a7ca5c32d9b1d" title="The constant parsed value.">value</a>(type)
<a name="l00329"></a>00329     {
<a name="l00330"></a>00330         <span class="comment">// check whether to dequote the incoming string.</span>
<a name="l00331"></a>00331         <span class="keywordflow">if</span> (type == <a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b683c26cd9826905c708c5093e9c700293c" title="String type, variable length.">AnyScalar::ATTRTYPE_STRING</a>)
<a name="l00332"></a>00332             <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#c0a3dd8fbefa2c60119a7ca5c32d9b1d" title="The constant parsed value.">value</a>.<a class="code" href="classstx_1_1AnyScalar.html#410991c92897dc2bb26e392d274ca115" title="Change the value of the current object to s.">setStringQuoted</a>(strvalue);
<a name="l00333"></a>00333         <span class="keywordflow">else</span>
<a name="l00334"></a>00334             <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#c0a3dd8fbefa2c60119a7ca5c32d9b1d" title="The constant parsed value.">value</a>.<a class="code" href="classstx_1_1AnyScalar.html#aaa40ccc7a7b0b28e7b19b356dde364e" title="Change the value of the current object to s.">setString</a>(strvalue); <span class="comment">// not a string, but an integer or double or boolean value</span>
<a name="l00335"></a>00335     }
<a name="l00336"></a>00336 
<a name="l00338"></a><a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#8f6c6ce4ab4c8292471662463548b260">00338</a>     <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#e220a7b997720fcd1b95e408b92a1ca3" title="Assignment from the string received from the parser.">PNConstant</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> &amp;_value)
<a name="l00339"></a>00339         : <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#c0a3dd8fbefa2c60119a7ca5c32d9b1d" title="The constant parsed value.">value</a>(_value)
<a name="l00340"></a>00340     {
<a name="l00341"></a>00341     }
<a name="l00342"></a>00342 
<a name="l00344"></a><a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#8d09415826aa3414668ec599c6cae5b0">00344</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#8d09415826aa3414668ec599c6cae5b0" title="Easiest evaluation: return the constant.">evaluate</a>(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;)<span class="keyword"> const</span>
<a name="l00345"></a>00345 <span class="keyword">    </span>{
<a name="l00346"></a>00346         <span class="keywordflow">return</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#c0a3dd8fbefa2c60119a7ca5c32d9b1d" title="The constant parsed value.">value</a>;
<a name="l00347"></a>00347     }
<a name="l00348"></a>00348 
<a name="l00350"></a><a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#a01ee7fc2b4408c526ff606822c36e77">00350</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#a01ee7fc2b4408c526ff606822c36e77" title="Returns true, because value is constant.">evaluate_const</a>(<a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> *dest)<span class="keyword"> const</span>
<a name="l00351"></a>00351 <span class="keyword">    </span>{
<a name="l00352"></a>00352         <span class="keywordflow">if</span> (dest) *dest = <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#c0a3dd8fbefa2c60119a7ca5c32d9b1d" title="The constant parsed value.">value</a>;
<a name="l00353"></a>00353         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00354"></a>00354     }
<a name="l00355"></a>00355 
<a name="l00357"></a><a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#ccc476ef458a600e4e2e1ab7f3af0657">00357</a>     <span class="keyword">virtual</span> std::string <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#ccc476ef458a600e4e2e1ab7f3af0657" title="String representation of the constant AnyScalar value.">toString</a>()<span class="keyword"> const</span>
<a name="l00358"></a>00358 <span class="keyword">    </span>{
<a name="l00359"></a>00359         <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#c0a3dd8fbefa2c60119a7ca5c32d9b1d" title="The constant parsed value.">value</a>.<a class="code" href="classstx_1_1AnyScalar.html#f4e3136656d9100e1f88356c51cb9817" title="Return the type identifier of the object.">getType</a>() == <a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b683c26cd9826905c708c5093e9c700293c" title="String type, variable length.">AnyScalar::ATTRTYPE_STRING</a>) {
<a name="l00360"></a>00360             <span class="keywordflow">return</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#c0a3dd8fbefa2c60119a7ca5c32d9b1d" title="The constant parsed value.">value</a>.<a class="code" href="classstx_1_1AnyScalar.html#3a84cc0dd97636d83ae9f779576c7539" title="Return the value converted to a quoted string.">getStringQuoted</a>();
<a name="l00361"></a>00361         }
<a name="l00362"></a>00362         <span class="keywordflow">return</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html#c0a3dd8fbefa2c60119a7ca5c32d9b1d" title="The constant parsed value.">value</a>.<a class="code" href="classstx_1_1AnyScalar.html#4cd8cd1546ba59723c31bcc592943420" title="Return the value converted to a string.">getString</a>();
<a name="l00363"></a>00363     }
<a name="l00364"></a>00364 };
<a name="l00365"></a>00365 
<a name="l00368"></a><a class="code" href="classstx_1_1Grammar_1_1PNVariable.html">00368</a> <span class="keyword">class </span><a class="code" href="classstx_1_1Grammar_1_1PNVariable.html" title="Parse tree node representing a variable place-holder.">PNVariable</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>
<a name="l00369"></a>00369 {
<a name="l00370"></a>00370 <span class="keyword">private</span>:
<a name="l00372"></a><a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#86964da2e3f9a3c800d1b9cd1f1dc9d6">00372</a>     std::string         <a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#86964da2e3f9a3c800d1b9cd1f1dc9d6" title="String name of the variable.">varname</a>;
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="keyword">public</span>:
<a name="l00376"></a><a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#f7f9e342d92542f4685acdfe5fae546f">00376</a>     <a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#f7f9e342d92542f4685acdfe5fae546f" title="Constructor from the string received from the parser.">PNVariable</a>(std::string _varname)
<a name="l00377"></a>00377         : <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>(), <a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#86964da2e3f9a3c800d1b9cd1f1dc9d6" title="String name of the variable.">varname</a>(_varname)
<a name="l00378"></a>00378     {
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380 
<a name="l00382"></a><a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#c14d6054cf293d902bcae8ca150a8f30">00382</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#c14d6054cf293d902bcae8ca150a8f30" title="Check the given symbol table for the actual value of this variable.">evaluate</a>(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;st)<span class="keyword"> const</span>
<a name="l00383"></a>00383 <span class="keyword">    </span>{
<a name="l00384"></a>00384         <span class="keywordflow">return</span> st.lookupVariable(<a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#86964da2e3f9a3c800d1b9cd1f1dc9d6" title="String name of the variable.">varname</a>);
<a name="l00385"></a>00385     }
<a name="l00386"></a>00386 
<a name="l00388"></a><a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#764680d56c2e4fa358a405df0e6f9f50">00388</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#764680d56c2e4fa358a405df0e6f9f50" title="Returns false, because value isn't constant.">evaluate_const</a>(<a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> *)<span class="keyword"> const</span>
<a name="l00389"></a>00389 <span class="keyword">    </span>{
<a name="l00390"></a>00390         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00391"></a>00391     }
<a name="l00392"></a>00392 
<a name="l00394"></a><a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#292325648ae0eeceefbc00a1d12ed602">00394</a>     <span class="keyword">virtual</span> std::string <a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#292325648ae0eeceefbc00a1d12ed602" title="Nothing but the variable name.">toString</a>()<span class="keyword"> const</span>
<a name="l00395"></a>00395 <span class="keyword">    </span>{
<a name="l00396"></a>00396         <span class="keywordflow">return</span> <a class="code" href="classstx_1_1Grammar_1_1PNVariable.html#86964da2e3f9a3c800d1b9cd1f1dc9d6" title="String name of the variable.">varname</a>;
<a name="l00397"></a>00397     }
<a name="l00398"></a>00398 };
<a name="l00399"></a>00399 
<a name="l00402"></a><a class="code" href="classstx_1_1Grammar_1_1PNFunction.html">00402</a> <span class="keyword">class </span><a class="code" href="classstx_1_1Grammar_1_1PNFunction.html" title="Parse tree node representing a function place-holder.">PNFunction</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>
<a name="l00403"></a>00403 {
<a name="l00404"></a>00404 <span class="keyword">public</span>:
<a name="l00406"></a><a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#f41fa41d33bcc3f73684d465dc7bf98c">00406</a>     <span class="keyword">typedef</span> std::vector&lt;const class ParseNode*&gt; <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#f41fa41d33bcc3f73684d465dc7bf98c" title="Type of sequence of subtrees to evaluate as function parameters.">paramlist_type</a>;
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 <span class="keyword">private</span>:
<a name="l00410"></a><a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#84f487de29f28a5c8a1e158c3151fca0">00410</a>     std::string         <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#84f487de29f28a5c8a1e158c3151fca0" title="String name of the function.">funcname</a>;
<a name="l00411"></a>00411 
<a name="l00413"></a><a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#ee4a339eb852673b5bc430572dd1ee4e">00413</a>     <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#f41fa41d33bcc3f73684d465dc7bf98c" title="Type of sequence of subtrees to evaluate as function parameters.">paramlist_type</a>      <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#ee4a339eb852673b5bc430572dd1ee4e" title="The array of function parameter subtrees.">paramlist</a>;
<a name="l00414"></a>00414 
<a name="l00415"></a>00415 <span class="keyword">public</span>:
<a name="l00417"></a><a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#5cf7f0e6825c4f52c4c40e6f315b8b1d">00417</a>     <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#5cf7f0e6825c4f52c4c40e6f315b8b1d" title="Constructor from the string received from the parser.">PNFunction</a>(std::string _funcname, <span class="keyword">const</span> <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#f41fa41d33bcc3f73684d465dc7bf98c" title="Type of sequence of subtrees to evaluate as function parameters.">paramlist_type</a>&amp; _paramlist)
<a name="l00418"></a>00418         : <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>(), <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#84f487de29f28a5c8a1e158c3151fca0" title="String name of the function.">funcname</a>(_funcname), <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#ee4a339eb852673b5bc430572dd1ee4e" title="The array of function parameter subtrees.">paramlist</a>(_paramlist)
<a name="l00419"></a>00419     {
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421 
<a name="l00423"></a><a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#f3a943bbab836598d48153d9ae88515d">00423</a>     <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#f3a943bbab836598d48153d9ae88515d" title="Delete the paramlist.">~PNFunction</a>()
<a name="l00424"></a>00424     {
<a name="l00425"></a>00425         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#ee4a339eb852673b5bc430572dd1ee4e" title="The array of function parameter subtrees.">paramlist</a>.size(); ++i)
<a name="l00426"></a>00426             <span class="keyword">delete</span> <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#ee4a339eb852673b5bc430572dd1ee4e" title="The array of function parameter subtrees.">paramlist</a>[i];
<a name="l00427"></a>00427     }
<a name="l00428"></a>00428 
<a name="l00430"></a><a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#1a3c0a9b4dd3a1ec979671b21e0487f0">00430</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#1a3c0a9b4dd3a1ec979671b21e0487f0" title="Check the given symbol table for the actual value of this variable.">evaluate</a>(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;st)<span class="keyword"> const</span>
<a name="l00431"></a>00431 <span class="keyword">    </span>{
<a name="l00432"></a>00432         std::vector&lt;AnyScalar&gt; paramvalues;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#ee4a339eb852673b5bc430572dd1ee4e" title="The array of function parameter subtrees.">paramlist</a>.size(); ++i)
<a name="l00435"></a>00435         {
<a name="l00436"></a>00436             paramvalues.push_back( <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#ee4a339eb852673b5bc430572dd1ee4e" title="The array of function parameter subtrees.">paramlist</a>[i]-&gt;evaluate(st) );
<a name="l00437"></a>00437         }
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         <span class="keywordflow">return</span> st.processFunction(<a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#84f487de29f28a5c8a1e158c3151fca0" title="String name of the function.">funcname</a>, paramvalues);
<a name="l00440"></a>00440     }
<a name="l00441"></a>00441 
<a name="l00443"></a><a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#3d674ea2d8e283be1ec9360bffb2a5c1">00443</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#3d674ea2d8e283be1ec9360bffb2a5c1" title="Returns false, because value isn't constant.">evaluate_const</a>(<a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> *)<span class="keyword"> const</span>
<a name="l00444"></a>00444 <span class="keyword">    </span>{
<a name="l00445"></a>00445         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00446"></a>00446     }
<a name="l00447"></a>00447 
<a name="l00449"></a><a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#04fd211f1071ff6a70372c9900dbdc32">00449</a>     <span class="keyword">virtual</span> std::string <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#04fd211f1071ff6a70372c9900dbdc32" title="Nothing but the function and its parameters.">toString</a>()<span class="keyword"> const</span>
<a name="l00450"></a>00450 <span class="keyword">    </span>{
<a name="l00451"></a>00451         std::string str = <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#84f487de29f28a5c8a1e158c3151fca0" title="String name of the function.">funcname</a> + <span class="stringliteral">"("</span>;
<a name="l00452"></a>00452         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#ee4a339eb852673b5bc430572dd1ee4e" title="The array of function parameter subtrees.">paramlist</a>.size(); ++i)
<a name="l00453"></a>00453         {
<a name="l00454"></a>00454             <span class="keywordflow">if</span> (i != 0) str += <span class="stringliteral">","</span>;
<a name="l00455"></a>00455             str += <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html#ee4a339eb852673b5bc430572dd1ee4e" title="The array of function parameter subtrees.">paramlist</a>[i]-&gt;toString();
<a name="l00456"></a>00456         }
<a name="l00457"></a>00457         <span class="keywordflow">return</span> str + <span class="stringliteral">")"</span>;
<a name="l00458"></a>00458     }
<a name="l00459"></a>00459 };
<a name="l00460"></a>00460 
<a name="l00463"></a><a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html">00463</a> <span class="keyword">class </span><a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html" title="Parse tree node representing an unary operator: '+', '-', '!' or "not".">PNUnaryArithmExpr</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>
<a name="l00464"></a>00464 {
<a name="l00465"></a>00465 <span class="keyword">private</span>:
<a name="l00467"></a><a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#1c8959cffdf6c537cb8d0b35dfd46310">00467</a>     <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>     *<a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#1c8959cffdf6c537cb8d0b35dfd46310" title="Pointer to the single operand.">operand</a>;
<a name="l00468"></a>00468 
<a name="l00471"></a><a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5">00471</a>     <span class="keywordtype">char</span>        <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a>;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="keyword">public</span>:
<a name="l00475"></a><a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#84168d85003832af13ef8a6e10e6a473">00475</a>     <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#84168d85003832af13ef8a6e10e6a473" title="Constructor from the parser: operand subnode and operator id.">PNUnaryArithmExpr</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* _operand, <span class="keywordtype">char</span> _op)
<a name="l00476"></a>00476         : <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>(), <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#1c8959cffdf6c537cb8d0b35dfd46310" title="Pointer to the single operand.">operand</a>(_operand), <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a>(_op)
<a name="l00477"></a>00477     {
<a name="l00478"></a>00478         <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a> == <span class="charliteral">'n'</span> || <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a> == <span class="charliteral">'N'</span>) <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a> = <span class="charliteral">'!'</span>;
<a name="l00479"></a>00479     }
<a name="l00480"></a>00480 
<a name="l00482"></a><a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#ad4cefe10e85a6097e25dde8317f6f68">00482</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#ad4cefe10e85a6097e25dde8317f6f68" title="Recursively delete the parse tree.">~PNUnaryArithmExpr</a>()
<a name="l00483"></a>00483     {
<a name="l00484"></a>00484         <span class="keyword">delete</span> <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#1c8959cffdf6c537cb8d0b35dfd46310" title="Pointer to the single operand.">operand</a>;
<a name="l00485"></a>00485     }
<a name="l00486"></a>00486 
<a name="l00488"></a><a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#409b3d3eb3ce61395b25639c5e807891">00488</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#409b3d3eb3ce61395b25639c5e807891" title="Applies the operator to the recursively calculated value.">evaluate</a>(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;st)<span class="keyword"> const</span>
<a name="l00489"></a>00489 <span class="keyword">    </span>{
<a name="l00490"></a>00490         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> dest = <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#1c8959cffdf6c537cb8d0b35dfd46310" title="Pointer to the single operand.">operand</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#90bed95867ee48bbefed46777aa1580b" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>(st);
<a name="l00491"></a>00491 
<a name="l00492"></a>00492         <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a> == <span class="charliteral">'-'</span>) {
<a name="l00493"></a>00493             dest = -dest;           
<a name="l00494"></a>00494         }
<a name="l00495"></a>00495         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a> == <span class="charliteral">'!'</span>)
<a name="l00496"></a>00496         {
<a name="l00497"></a>00497             <span class="comment">// This should not happend, as types are constant in the parse tree</span>
<a name="l00498"></a>00498             <span class="keywordflow">if</span> (dest.<a class="code" href="classstx_1_1AnyScalar.html#f4e3136656d9100e1f88356c51cb9817" title="Return the type identifier of the object.">getType</a>() != <a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68baf07121e6aecbb26c291f5d92e252ce" title="A boolean type holding only true and false.">AnyScalar::ATTRTYPE_BOOL</a>)
<a name="l00499"></a>00499                 <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(<span class="stringliteral">"Invalid operand for !. Operand must be of type bool."</span>));
<a name="l00500"></a>00500 
<a name="l00501"></a>00501             dest = -dest;
<a name="l00502"></a>00502         }
<a name="l00503"></a>00503         <span class="keywordflow">else</span> {
<a name="l00504"></a>00504             assert(<a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a> == <span class="charliteral">'+'</span>);
<a name="l00505"></a>00505         }
<a name="l00506"></a>00506 
<a name="l00507"></a>00507         <span class="keywordflow">return</span> dest;
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509 
<a name="l00511"></a><a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#3405ea16e99634277cba276f5bc5f3d3">00511</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#3405ea16e99634277cba276f5bc5f3d3" title="Calculates subnodes and returns result if the operator can be applied.">evaluate_const</a>(<a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> *dest)<span class="keyword"> const</span>
<a name="l00512"></a>00512 <span class="keyword">    </span>{
<a name="l00513"></a>00513         <span class="keywordflow">if</span> (!dest) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00514"></a>00514 
<a name="l00515"></a>00515         <span class="keywordtype">bool</span> b = <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#1c8959cffdf6c537cb8d0b35dfd46310" title="Pointer to the single operand.">operand</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#72b521ba0fee0abbc565e35a443dd910" title="(Internal) Function to check if the subtree evaluates to a constant expression.">evaluate_const</a>(dest);
<a name="l00516"></a>00516 
<a name="l00517"></a>00517         <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a> == <span class="charliteral">'-'</span>) {
<a name="l00518"></a>00518             *dest = -(*dest);
<a name="l00519"></a>00519         }
<a name="l00520"></a>00520         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a> == <span class="charliteral">'!'</span>)
<a name="l00521"></a>00521         {
<a name="l00522"></a>00522             <span class="keywordflow">if</span> (dest-&gt;<a class="code" href="classstx_1_1AnyScalar.html#f4e3136656d9100e1f88356c51cb9817" title="Return the type identifier of the object.">getType</a>() != <a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68baf07121e6aecbb26c291f5d92e252ce" title="A boolean type holding only true and false.">AnyScalar::ATTRTYPE_BOOL</a>)
<a name="l00523"></a>00523                 <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(<span class="stringliteral">"Invalid operand for !. Operand must be of type bool."</span>));
<a name="l00524"></a>00524 
<a name="l00525"></a>00525             *dest = -(*dest);
<a name="l00526"></a>00526         }
<a name="l00527"></a>00527         <span class="keywordflow">else</span> {
<a name="l00528"></a>00528             assert(<a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a> == <span class="charliteral">'+'</span>);
<a name="l00529"></a>00529         }
<a name="l00530"></a>00530         
<a name="l00531"></a>00531         <span class="keywordflow">return</span> b;
<a name="l00532"></a>00532     }
<a name="l00533"></a>00533 
<a name="l00535"></a><a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#13785a89ce45a70953e96414a29769ce">00535</a>     <span class="keyword">virtual</span> std::string <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#13785a89ce45a70953e96414a29769ce" title="Return the subnode's string with this operator prepended.">toString</a>()<span class="keyword"> const</span>
<a name="l00536"></a>00536 <span class="keyword">    </span>{
<a name="l00537"></a>00537         <span class="keywordflow">return</span> std::string(<span class="stringliteral">"("</span>) + <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#77ef4e80dfb2ba900c2f05409d8e54e5" title="Arithmetic operation to perform: either '+', '-' or '!'.">op</a> + <span class="stringliteral">" "</span> + <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#1c8959cffdf6c537cb8d0b35dfd46310" title="Pointer to the single operand.">operand</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#7a57a42525ced8566833ce5c774fedf3" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() + <span class="stringliteral">")"</span>;
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539 };
<a name="l00540"></a>00540 
<a name="l00543"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html">00543</a> <span class="keyword">class </span><a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html" title="Parse tree node representing a binary operators: +, -, * and / for numeric values...">PNBinaryArithmExpr</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>
<a name="l00544"></a>00544 {
<a name="l00545"></a>00545 <span class="keyword">private</span>:
<a name="l00547"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#07d5f0ce9a0bba0211e5a72f493cbc50">00547</a>     <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>     *<a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#07d5f0ce9a0bba0211e5a72f493cbc50" title="Pointers to the left of the two child parse trees.">left</a>;
<a name="l00548"></a>00548 
<a name="l00550"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#686574ab15bf84051bad8a2e99f84a4f">00550</a>     <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>     *<a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#686574ab15bf84051bad8a2e99f84a4f" title="Pointers to the right of the two child parse trees.">right</a>;
<a name="l00551"></a>00551 
<a name="l00554"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd">00554</a>     <span class="keywordtype">char</span>        <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd" title="Arithmetic operation to perform: left op right.">op</a>;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 <span class="keyword">public</span>:
<a name="l00558"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#b46561d89d4faec442d791d89301a240">00558</a>     <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#b46561d89d4faec442d791d89301a240" title="Constructor from the parser: both operand subnodes and the operator id.">PNBinaryArithmExpr</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* _left,
<a name="l00559"></a>00559                        <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* _right,
<a name="l00560"></a>00560                        <span class="keywordtype">char</span> _op)
<a name="l00561"></a>00561         : <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>(),
<a name="l00562"></a>00562           <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#07d5f0ce9a0bba0211e5a72f493cbc50" title="Pointers to the left of the two child parse trees.">left</a>(_left), <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#686574ab15bf84051bad8a2e99f84a4f" title="Pointers to the right of the two child parse trees.">right</a>(_right), <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd" title="Arithmetic operation to perform: left op right.">op</a>(_op)
<a name="l00563"></a>00563     { }
<a name="l00564"></a>00564 
<a name="l00566"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#c430dcfa25952d43e1839b1cb320bfa1">00566</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#c430dcfa25952d43e1839b1cb320bfa1" title="Recursively delete parse tree.">~PNBinaryArithmExpr</a>()
<a name="l00567"></a>00567     {
<a name="l00568"></a>00568         <span class="keyword">delete</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#07d5f0ce9a0bba0211e5a72f493cbc50" title="Pointers to the left of the two child parse trees.">left</a>;
<a name="l00569"></a>00569         <span class="keyword">delete</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#686574ab15bf84051bad8a2e99f84a4f" title="Pointers to the right of the two child parse trees.">right</a>;
<a name="l00570"></a>00570     }
<a name="l00571"></a>00571 
<a name="l00574"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#bad9b3c32c8e9563050c67bcd4ba9729">00574</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#bad9b3c32c8e9563050c67bcd4ba9729" title="Applies the operator to the two recursive calculated values.">evaluate</a>(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;st)<span class="keyword"> const</span>
<a name="l00575"></a>00575 <span class="keyword">    </span>{
<a name="l00576"></a>00576         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> vl = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#07d5f0ce9a0bba0211e5a72f493cbc50" title="Pointers to the left of the two child parse trees.">left</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#90bed95867ee48bbefed46777aa1580b" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>(st);
<a name="l00577"></a>00577         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> vr = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#686574ab15bf84051bad8a2e99f84a4f" title="Pointers to the right of the two child parse trees.">right</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#90bed95867ee48bbefed46777aa1580b" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>(st);
<a name="l00578"></a>00578 
<a name="l00579"></a>00579         <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd" title="Arithmetic operation to perform: left op right.">op</a> == <span class="charliteral">'+'</span>) {
<a name="l00580"></a>00580             <span class="keywordflow">return</span> (vl + vr);
<a name="l00581"></a>00581         }
<a name="l00582"></a>00582         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd" title="Arithmetic operation to perform: left op right.">op</a> == <span class="charliteral">'-'</span>) {
<a name="l00583"></a>00583             <span class="keywordflow">return</span> (vl - vr);
<a name="l00584"></a>00584         }
<a name="l00585"></a>00585         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd" title="Arithmetic operation to perform: left op right.">op</a> == <span class="charliteral">'*'</span>) {
<a name="l00586"></a>00586             <span class="keywordflow">return</span> (vl * vr);
<a name="l00587"></a>00587         }
<a name="l00588"></a>00588         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd" title="Arithmetic operation to perform: left op right.">op</a> == <span class="charliteral">'/'</span>) {
<a name="l00589"></a>00589             <span class="keywordflow">return</span> (vl / vr);
<a name="l00590"></a>00590         }
<a name="l00591"></a>00591 
<a name="l00592"></a>00592         assert(0);
<a name="l00593"></a>00593         <span class="keywordflow">return</span> 0;
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595 
<a name="l00598"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#12a0b0f98a8245be1436cc0d0dfc9c8a">00598</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#12a0b0f98a8245be1436cc0d0dfc9c8a" title="Returns false because this node isn't always constant.">evaluate_const</a>(<a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> *dest)<span class="keyword"> const</span>
<a name="l00599"></a>00599 <span class="keyword">    </span>{
<a name="l00600"></a>00600         <span class="keywordflow">if</span> (!dest) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00601"></a>00601 
<a name="l00602"></a>00602         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> vl(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b689ee13e69ddc4aac9c4ed7eb6222ad787" title="Flag identifier for an uninitialized object.">AnyScalar::ATTRTYPE_INVALID</a>), vr(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b689ee13e69ddc4aac9c4ed7eb6222ad787" title="Flag identifier for an uninitialized object.">AnyScalar::ATTRTYPE_INVALID</a>);
<a name="l00603"></a>00603         
<a name="l00604"></a>00604         <span class="keywordtype">bool</span> bl = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#07d5f0ce9a0bba0211e5a72f493cbc50" title="Pointers to the left of the two child parse trees.">left</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#72b521ba0fee0abbc565e35a443dd910" title="(Internal) Function to check if the subtree evaluates to a constant expression.">evaluate_const</a>(&amp;vl);
<a name="l00605"></a>00605         <span class="keywordtype">bool</span> br = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#686574ab15bf84051bad8a2e99f84a4f" title="Pointers to the right of the two child parse trees.">right</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#72b521ba0fee0abbc565e35a443dd910" title="(Internal) Function to check if the subtree evaluates to a constant expression.">evaluate_const</a>(&amp;vr);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607         <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd" title="Arithmetic operation to perform: left op right.">op</a> == <span class="charliteral">'+'</span>) {
<a name="l00608"></a>00608             *dest = vl + vr;
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd" title="Arithmetic operation to perform: left op right.">op</a> == <span class="charliteral">'-'</span>) {
<a name="l00611"></a>00611             *dest = vl - vr;
<a name="l00612"></a>00612         }
<a name="l00613"></a>00613         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd" title="Arithmetic operation to perform: left op right.">op</a> == <span class="charliteral">'*'</span>) {
<a name="l00614"></a>00614             *dest = vl * vr;
<a name="l00615"></a>00615         }
<a name="l00616"></a>00616         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd" title="Arithmetic operation to perform: left op right.">op</a> == <span class="charliteral">'/'</span>) {
<a name="l00617"></a>00617             *dest = vl / vr;
<a name="l00618"></a>00618         }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620         <span class="keywordflow">return</span> (bl &amp;&amp; br);
<a name="l00621"></a>00621     }
<a name="l00622"></a>00622 
<a name="l00624"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#173ccdeecabf3f05320541855fee2c7b">00624</a>     <span class="keyword">virtual</span> std::string <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#173ccdeecabf3f05320541855fee2c7b" title="String representing (operandA op operandB).">toString</a>()<span class="keyword"> const</span>
<a name="l00625"></a>00625 <span class="keyword">    </span>{
<a name="l00626"></a>00626         <span class="keywordflow">return</span> std::string(<span class="stringliteral">"("</span>) + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#07d5f0ce9a0bba0211e5a72f493cbc50" title="Pointers to the left of the two child parse trees.">left</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#7a57a42525ced8566833ce5c774fedf3" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() + <span class="stringliteral">" "</span> + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#3ba3b6eb32822db8d2677ddad69f39cd" title="Arithmetic operation to perform: left op right.">op</a> + <span class="stringliteral">" "</span> + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#686574ab15bf84051bad8a2e99f84a4f" title="Pointers to the right of the two child parse trees.">right</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#7a57a42525ced8566833ce5c774fedf3" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() + <span class="stringliteral">")"</span>;
<a name="l00627"></a>00627     }
<a name="l00628"></a>00628 };
<a name="l00629"></a>00629 
<a name="l00631"></a><a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html">00631</a> <span class="keyword">class </span><a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html" title="Parse tree node handling type conversions within the tree.">PNCastExpr</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>
<a name="l00632"></a>00632 {
<a name="l00633"></a>00633 <span class="keyword">private</span>:
<a name="l00635"></a><a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#d41367bd3eeabf2db7396ead9b9837aa">00635</a>     <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>*    <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#d41367bd3eeabf2db7396ead9b9837aa" title="Child tree of which the return value should be casted.">operand</a>;
<a name="l00636"></a>00636 
<a name="l00638"></a><a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#2a24afbe60bbf62dd30a07964f8d42e5">00638</a>     <a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68" title="Enumeration establishing identifiers for all supported types.">AnyScalar::attrtype_t</a>       <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#2a24afbe60bbf62dd30a07964f8d42e5" title="AnyScalar type to cast the value to.">type</a>;
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 <span class="keyword">public</span>:
<a name="l00643"></a><a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#88ff716c2cd048cb047b2ec62b7a0dce">00643</a>     <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#88ff716c2cd048cb047b2ec62b7a0dce" title="Constructor from the parser: operand subnode and the cast type as recognized by AnyScalar...">PNCastExpr</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* _operand, <a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68" title="Enumeration establishing identifiers for all supported types.">AnyScalar::attrtype_t</a> _type)
<a name="l00644"></a>00644         : <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>(),
<a name="l00645"></a>00645           <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#d41367bd3eeabf2db7396ead9b9837aa" title="Child tree of which the return value should be casted.">operand</a>(_operand), <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#2a24afbe60bbf62dd30a07964f8d42e5" title="AnyScalar type to cast the value to.">type</a>(_type)
<a name="l00646"></a>00646     { }
<a name="l00647"></a>00647 
<a name="l00649"></a><a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#75fa970b1896f97173bee81addb88d1e">00649</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#75fa970b1896f97173bee81addb88d1e" title="Recursively delete parse tree.">~PNCastExpr</a>()
<a name="l00650"></a>00650     {
<a name="l00651"></a>00651         <span class="keyword">delete</span> <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#d41367bd3eeabf2db7396ead9b9837aa" title="Child tree of which the return value should be casted.">operand</a>;
<a name="l00652"></a>00652     }
<a name="l00653"></a>00653 
<a name="l00656"></a><a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#7777631ccb4ff4d7faadb40d670c0b9d">00656</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#7777631ccb4ff4d7faadb40d670c0b9d" title="Recursive calculation of the value and subsequent casting via AnyScalar's convertType...">evaluate</a>(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;st)<span class="keyword"> const</span>
<a name="l00657"></a>00657 <span class="keyword">    </span>{
<a name="l00658"></a>00658         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> val = <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#d41367bd3eeabf2db7396ead9b9837aa" title="Child tree of which the return value should be casted.">operand</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#90bed95867ee48bbefed46777aa1580b" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>(st);
<a name="l00659"></a>00659         val.<a class="code" href="classstx_1_1AnyScalar.html#33b74b0966427eac1c0452d2674e800f" title="Attempts to convert the current type/value into the given type.">convertType</a>(<a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#2a24afbe60bbf62dd30a07964f8d42e5" title="AnyScalar type to cast the value to.">type</a>);
<a name="l00660"></a>00660         <span class="keywordflow">return</span> val;
<a name="l00661"></a>00661     }
<a name="l00662"></a>00662 
<a name="l00664"></a><a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#6a9973ff2e3511d5836f8033e2c35896">00664</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#6a9973ff2e3511d5836f8033e2c35896" title="Returns false because this node isn't always constant.">evaluate_const</a>(<a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> *dest)<span class="keyword"> const</span>
<a name="l00665"></a>00665 <span class="keyword">    </span>{
<a name="l00666"></a>00666         <span class="keywordflow">if</span> (!dest) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00667"></a>00667 
<a name="l00668"></a>00668         <span class="keywordtype">bool</span> b = <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#d41367bd3eeabf2db7396ead9b9837aa" title="Child tree of which the return value should be casted.">operand</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#72b521ba0fee0abbc565e35a443dd910" title="(Internal) Function to check if the subtree evaluates to a constant expression.">evaluate_const</a>(dest);
<a name="l00669"></a>00669         dest-&gt;<a class="code" href="classstx_1_1AnyScalar.html#33b74b0966427eac1c0452d2674e800f" title="Attempts to convert the current type/value into the given type.">convertType</a>(<a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#2a24afbe60bbf62dd30a07964f8d42e5" title="AnyScalar type to cast the value to.">type</a>);
<a name="l00670"></a>00670         <span class="keywordflow">return</span> b;
<a name="l00671"></a>00671     }
<a name="l00672"></a>00672 
<a name="l00674"></a><a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#b3833ffd73c4eddcfd57301f12a48a05">00674</a>     <span class="keyword">virtual</span> std::string <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#b3833ffd73c4eddcfd57301f12a48a05" title="c-like representation of the cast">toString</a>()<span class="keyword"> const</span>
<a name="l00675"></a>00675 <span class="keyword">    </span>{
<a name="l00676"></a>00676         <span class="keywordflow">return</span> std::string(<span class="stringliteral">"(("</span>) + <a class="code" href="classstx_1_1AnyScalar.html#02060a90eeb4b0ad43d50b66cb8e8c82" title="Returns a string for this AnyScalar's type.">AnyScalar::getTypeString</a>(<a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#2a24afbe60bbf62dd30a07964f8d42e5" title="AnyScalar type to cast the value to.">type</a>) + <span class="stringliteral">")"</span> + <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html#d41367bd3eeabf2db7396ead9b9837aa" title="Child tree of which the return value should be casted.">operand</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#7a57a42525ced8566833ce5c774fedf3" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() + <span class="stringliteral">")"</span>;
<a name="l00677"></a>00677     }
<a name="l00678"></a>00678 };
<a name="l00679"></a>00679 
<a name="l00682"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html">00682</a> <span class="keyword">class </span><a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html" title="Parse tree node representing a binary comparison operator: ==, =, !=, &lt;, &gt;...">PNBinaryComparisonExpr</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>
<a name="l00683"></a>00683 {
<a name="l00684"></a>00684 <span class="keyword">private</span>:
<a name="l00686"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#37a11aa27a16f54021a322e4bd174374">00686</a>     <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>     *<a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#37a11aa27a16f54021a322e4bd174374" title="Pointers to the left of the two child parse trees.">left</a>;
<a name="l00687"></a>00687 
<a name="l00689"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#2920f341e878328efa5c55c303df7018">00689</a>     <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>     *<a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#2920f341e878328efa5c55c303df7018" title="Pointers to the right of the two child parse trees.">right</a>;
<a name="l00690"></a>00690 
<a name="l00692"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bc7075aec815ff03045d652f96c70e30e">00692</a>     <span class="keyword">enum</span> { <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bd0d99e660ff5f0119a4717c7371e5b83">EQUAL</a>, <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bc7075aec815ff03045d652f96c70e30e">NOTEQUAL</a>, <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bad992b8edf624abeb7b17157c9dff3ec">LESS</a>, <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49b208d68a7b4c142a2e93733fad6bedcb3">GREATER</a>, <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49b030a69f83d64e8ea8db887a3f57d1d97">LESSEQUAL</a>, <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bc503d44b1d527daa079dc536bf982560">GREATEREQUAL</a> } <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#7c518e6f2bcc0d2d4513b04c4c44b966" title="Comparison operation to perform: left op right.">op</a>;
<a name="l00693"></a>00693 
<a name="l00695"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#b4f1e9827e413e0c27282dd18d8dd110">00695</a>     std::string         <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#b4f1e9827e413e0c27282dd18d8dd110" title="String saved for toString().">opstr</a>;
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 <span class="keyword">public</span>:
<a name="l00699"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#78dcea6075cee048f6651406cf9476ff">00699</a>     <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#78dcea6075cee048f6651406cf9476ff" title="Constructor from the parser: both operand subnodes and the operator id.">PNBinaryComparisonExpr</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* _left,
<a name="l00700"></a>00700                            <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* _right,
<a name="l00701"></a>00701                            std::string _op)
<a name="l00702"></a>00702         : <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>(),
<a name="l00703"></a>00703           <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#37a11aa27a16f54021a322e4bd174374" title="Pointers to the left of the two child parse trees.">left</a>(_left), <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#2920f341e878328efa5c55c303df7018" title="Pointers to the right of the two child parse trees.">right</a>(_right), <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#b4f1e9827e413e0c27282dd18d8dd110" title="String saved for toString().">opstr</a>(_op)
<a name="l00704"></a>00704     {
<a name="l00705"></a>00705         <span class="keywordflow">if</span> (_op == <span class="stringliteral">"=="</span> || _op == <span class="stringliteral">"="</span>)
<a name="l00706"></a>00706             <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#7c518e6f2bcc0d2d4513b04c4c44b966" title="Comparison operation to perform: left op right.">op</a> = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bd0d99e660ff5f0119a4717c7371e5b83">EQUAL</a>;
<a name="l00707"></a>00707         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_op == <span class="stringliteral">"!="</span>)
<a name="l00708"></a>00708             <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#7c518e6f2bcc0d2d4513b04c4c44b966" title="Comparison operation to perform: left op right.">op</a> = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bc7075aec815ff03045d652f96c70e30e">NOTEQUAL</a>;
<a name="l00709"></a>00709         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_op == <span class="stringliteral">"&lt;"</span>)
<a name="l00710"></a>00710             <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#7c518e6f2bcc0d2d4513b04c4c44b966" title="Comparison operation to perform: left op right.">op</a> = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bad992b8edf624abeb7b17157c9dff3ec">LESS</a>;
<a name="l00711"></a>00711         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_op == <span class="stringliteral">"&gt;"</span>)
<a name="l00712"></a>00712             <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#7c518e6f2bcc0d2d4513b04c4c44b966" title="Comparison operation to perform: left op right.">op</a> = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49b208d68a7b4c142a2e93733fad6bedcb3">GREATER</a>;
<a name="l00713"></a>00713         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_op == <span class="stringliteral">"&lt;="</span> || _op == <span class="stringliteral">"=&lt;"</span>)
<a name="l00714"></a>00714             <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#7c518e6f2bcc0d2d4513b04c4c44b966" title="Comparison operation to perform: left op right.">op</a> = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49b030a69f83d64e8ea8db887a3f57d1d97">LESSEQUAL</a>;
<a name="l00715"></a>00715         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_op == <span class="stringliteral">"&gt;="</span> || _op == <span class="stringliteral">"=&gt;"</span>)
<a name="l00716"></a>00716             <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#7c518e6f2bcc0d2d4513b04c4c44b966" title="Comparison operation to perform: left op right.">op</a> = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bc503d44b1d527daa079dc536bf982560">GREATEREQUAL</a>;
<a name="l00717"></a>00717         <span class="keywordflow">else</span>
<a name="l00718"></a>00718             <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(<span class="stringliteral">"Program Error: invalid binary comparision operator."</span>));
<a name="l00719"></a>00719     }
<a name="l00720"></a>00720 
<a name="l00722"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#309018a68a3285db65d108dbfb20e4d6">00722</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#309018a68a3285db65d108dbfb20e4d6" title="Recursively delete parse tree.">~PNBinaryComparisonExpr</a>()
<a name="l00723"></a>00723     {
<a name="l00724"></a>00724         <span class="keyword">delete</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#37a11aa27a16f54021a322e4bd174374" title="Pointers to the left of the two child parse trees.">left</a>;
<a name="l00725"></a>00725         <span class="keyword">delete</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#2920f341e878328efa5c55c303df7018" title="Pointers to the right of the two child parse trees.">right</a>;
<a name="l00726"></a>00726     }
<a name="l00727"></a>00727 
<a name="l00731"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#1bd4a28349c469ad1587c5d1e67f204a">00731</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#1bd4a28349c469ad1587c5d1e67f204a" title="Applies the operator to the two recursive calculated values.">evaluate</a>(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;st)<span class="keyword"> const</span>
<a name="l00732"></a>00732 <span class="keyword">    </span>{
<a name="l00733"></a>00733         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> vl = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#37a11aa27a16f54021a322e4bd174374" title="Pointers to the left of the two child parse trees.">left</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#90bed95867ee48bbefed46777aa1580b" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>(st);
<a name="l00734"></a>00734         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> vr = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#2920f341e878328efa5c55c303df7018" title="Pointers to the right of the two child parse trees.">right</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#90bed95867ee48bbefed46777aa1580b" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>(st);
<a name="l00735"></a>00735 
<a name="l00736"></a>00736         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> dest(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68baf07121e6aecbb26c291f5d92e252ce" title="A boolean type holding only true and false.">AnyScalar::ATTRTYPE_BOOL</a>);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         <span class="keywordflow">switch</span>(<a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#7c518e6f2bcc0d2d4513b04c4c44b966" title="Comparison operation to perform: left op right.">op</a>)
<a name="l00739"></a>00739         {
<a name="l00740"></a>00740         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bd0d99e660ff5f0119a4717c7371e5b83">EQUAL</a>:
<a name="l00741"></a>00741             dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.<a class="code" href="classstx_1_1AnyScalar.html#c4e0a03acbce52916d110aa8af5050d5" title="Instantiation of binary_comp_op for "==" equality.">equal_to</a>(vr) );
<a name="l00742"></a>00742             <span class="keywordflow">break</span>;
<a name="l00743"></a>00743 
<a name="l00744"></a>00744         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bc7075aec815ff03045d652f96c70e30e">NOTEQUAL</a>:
<a name="l00745"></a>00745             dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.<a class="code" href="classstx_1_1AnyScalar.html#b5e3388e4de27b2f50b98506f430f11d" title="Instantiation of binary_comp_op for "!=" inequality.">not_equal_to</a>(vr) );
<a name="l00746"></a>00746             <span class="keywordflow">break</span>;
<a name="l00747"></a>00747 
<a name="l00748"></a>00748         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bad992b8edf624abeb7b17157c9dff3ec">LESS</a>:
<a name="l00749"></a>00749             dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.<a class="code" href="classstx_1_1AnyScalar.html#1ad87eb187d5813e777d205e27f9d663" title="Instantiation of binary_comp_op for "<" less-than.">less</a>(vr) );
<a name="l00750"></a>00750             <span class="keywordflow">break</span>;
<a name="l00751"></a>00751 
<a name="l00752"></a>00752         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49b208d68a7b4c142a2e93733fad6bedcb3">GREATER</a>:
<a name="l00753"></a>00753             dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.<a class="code" href="classstx_1_1AnyScalar.html#e9eceec38ecc184130385003a0c72242" title="Instantiation of binary_comp_op for ">" greater-than.">greater</a>(vr) );
<a name="l00754"></a>00754             <span class="keywordflow">break</span>;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49b030a69f83d64e8ea8db887a3f57d1d97">LESSEQUAL</a>:
<a name="l00757"></a>00757             dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.<a class="code" href="classstx_1_1AnyScalar.html#69ae376856a6c3dd78897948b364d42d" title="Instantiation of binary_comp_op for "<=" less-or-equal-than.">less_equal</a>(vr) );
<a name="l00758"></a>00758             <span class="keywordflow">break</span>;
<a name="l00759"></a>00759 
<a name="l00760"></a>00760         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bc503d44b1d527daa079dc536bf982560">GREATEREQUAL</a>:
<a name="l00761"></a>00761             dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.<a class="code" href="classstx_1_1AnyScalar.html#76baeefa38fce44c581f0808db0d1927" title="Instantiation of binary_comp_op for ">=" greater-or-equal-than.">greater_equal</a>(vr) );
<a name="l00762"></a>00762             <span class="keywordflow">break</span>;
<a name="l00763"></a>00763 
<a name="l00764"></a>00764         <span class="keywordflow">default</span>:
<a name="l00765"></a>00765             assert(0);
<a name="l00766"></a>00766         }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768         <span class="keywordflow">return</span> dest;
<a name="l00769"></a>00769     }
<a name="l00770"></a>00770 
<a name="l00772"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#de3500549d846289b5496250fac20259">00772</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#de3500549d846289b5496250fac20259" title="Returns false because this node isn't always constant.">evaluate_const</a>(<a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> *dest)<span class="keyword"> const</span>
<a name="l00773"></a>00773 <span class="keyword">    </span>{
<a name="l00774"></a>00774         <span class="keywordflow">if</span> (!dest) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00775"></a>00775 
<a name="l00776"></a>00776         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> vl(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b689ee13e69ddc4aac9c4ed7eb6222ad787" title="Flag identifier for an uninitialized object.">AnyScalar::ATTRTYPE_INVALID</a>), vr(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b689ee13e69ddc4aac9c4ed7eb6222ad787" title="Flag identifier for an uninitialized object.">AnyScalar::ATTRTYPE_INVALID</a>);
<a name="l00777"></a>00777         
<a name="l00778"></a>00778         <span class="keywordtype">bool</span> bl = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#37a11aa27a16f54021a322e4bd174374" title="Pointers to the left of the two child parse trees.">left</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#72b521ba0fee0abbc565e35a443dd910" title="(Internal) Function to check if the subtree evaluates to a constant expression.">evaluate_const</a>(&amp;vl);
<a name="l00779"></a>00779         <span class="keywordtype">bool</span> br = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#2920f341e878328efa5c55c303df7018" title="Pointers to the right of the two child parse trees.">right</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#72b521ba0fee0abbc565e35a443dd910" title="(Internal) Function to check if the subtree evaluates to a constant expression.">evaluate_const</a>(&amp;vr);
<a name="l00780"></a>00780 
<a name="l00781"></a>00781         <span class="keywordflow">switch</span>(<a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#7c518e6f2bcc0d2d4513b04c4c44b966" title="Comparison operation to perform: left op right.">op</a>)
<a name="l00782"></a>00782         {
<a name="l00783"></a>00783         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bd0d99e660ff5f0119a4717c7371e5b83">EQUAL</a>:
<a name="l00784"></a>00784             *dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.equal_to(vr) );
<a name="l00785"></a>00785             <span class="keywordflow">break</span>;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bc7075aec815ff03045d652f96c70e30e">NOTEQUAL</a>:
<a name="l00788"></a>00788             *dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.not_equal_to(vr) );
<a name="l00789"></a>00789             <span class="keywordflow">break</span>;
<a name="l00790"></a>00790 
<a name="l00791"></a>00791         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bad992b8edf624abeb7b17157c9dff3ec">LESS</a>:
<a name="l00792"></a>00792             *dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.less(vr) );
<a name="l00793"></a>00793             <span class="keywordflow">break</span>;
<a name="l00794"></a>00794 
<a name="l00795"></a>00795         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49b208d68a7b4c142a2e93733fad6bedcb3">GREATER</a>:
<a name="l00796"></a>00796             *dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.greater(vr) );
<a name="l00797"></a>00797             <span class="keywordflow">break</span>;
<a name="l00798"></a>00798 
<a name="l00799"></a>00799         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49b030a69f83d64e8ea8db887a3f57d1d97">LESSEQUAL</a>:
<a name="l00800"></a>00800             *dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.less_equal(vr) );
<a name="l00801"></a>00801             <span class="keywordflow">break</span>;
<a name="l00802"></a>00802 
<a name="l00803"></a>00803         <span class="keywordflow">case</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#3628f4bb06daa081ac85f9a86b57a49bc503d44b1d527daa079dc536bf982560">GREATEREQUAL</a>:
<a name="l00804"></a>00804             *dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( vl.greater_equal(vr) );
<a name="l00805"></a>00805             <span class="keywordflow">break</span>;
<a name="l00806"></a>00806 
<a name="l00807"></a>00807         <span class="keywordflow">default</span>:
<a name="l00808"></a>00808             assert(0);
<a name="l00809"></a>00809         }
<a name="l00810"></a>00810 
<a name="l00811"></a>00811         <span class="keywordflow">return</span> (bl &amp;&amp; br);
<a name="l00812"></a>00812     }
<a name="l00813"></a>00813 
<a name="l00815"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#e8c1224b27729728a0cbe7ae9ddc5bbc">00815</a>     <span class="keyword">virtual</span> std::string <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#e8c1224b27729728a0cbe7ae9ddc5bbc" title="String (operandA op operandB).">toString</a>()<span class="keyword"> const</span>
<a name="l00816"></a>00816 <span class="keyword">    </span>{
<a name="l00817"></a>00817         <span class="keywordflow">return</span> std::string(<span class="stringliteral">"("</span>) + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#37a11aa27a16f54021a322e4bd174374" title="Pointers to the left of the two child parse trees.">left</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#7a57a42525ced8566833ce5c774fedf3" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() + <span class="stringliteral">" "</span> + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#b4f1e9827e413e0c27282dd18d8dd110" title="String saved for toString().">opstr</a> + <span class="stringliteral">" "</span> + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#2920f341e878328efa5c55c303df7018" title="Pointers to the right of the two child parse trees.">right</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#7a57a42525ced8566833ce5c774fedf3" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() + <span class="stringliteral">")"</span>;
<a name="l00818"></a>00818     }
<a name="l00819"></a>00819 };
<a name="l00820"></a>00820 
<a name="l00823"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html">00823</a> <span class="keyword">class </span><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html" title="Parse tree node representing a binary logic operator: and, or, &amp;&amp;, ||.">PNBinaryLogicExpr</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>
<a name="l00824"></a>00824 {
<a name="l00825"></a>00825 <span class="keyword">private</span>:
<a name="l00827"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#848829b7036e19b353a4de2eddebe0d8">00827</a>     <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>*          <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#848829b7036e19b353a4de2eddebe0d8" title="Pointers to the left of the two child parse trees.">left</a>;
<a name="l00828"></a>00828 
<a name="l00830"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#f4367b4fa2ff6d26366d16b90bc24f87">00830</a>     <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>*          <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#f4367b4fa2ff6d26366d16b90bc24f87" title="Pointers to the right of the two child parse trees.">right</a>;
<a name="l00831"></a>00831 
<a name="l00833"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#0d97e460dac918ff3fba2156a121a5ac0facc5c00b8ffa53f83b6755072d4776">00833</a>     <span class="keyword">enum</span> { <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#0d97e460dac918ff3fba2156a121a5acbcbd80ca43a8c83ee513e3989e379b5c">OP_AND</a>, <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#0d97e460dac918ff3fba2156a121a5ac0facc5c00b8ffa53f83b6755072d4776">OP_OR</a> } <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#ce3b2883a75fb243a2a7e7fdda9badfd" title="Comparison operation to perform: left op right.">op</a>;
<a name="l00834"></a>00834 
<a name="l00835"></a>00835 <span class="keyword">public</span>:
<a name="l00837"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#2212c689c039f0c7be8a5bec64e9999d">00837</a>     <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#2212c689c039f0c7be8a5bec64e9999d" title="Constructor from the parser: both operand subnodes and the operator id.">PNBinaryLogicExpr</a>(<a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* _left,
<a name="l00838"></a>00838                       <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* _right,
<a name="l00839"></a>00839                       std::string _op)
<a name="l00840"></a>00840         : <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>(),
<a name="l00841"></a>00841           <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#848829b7036e19b353a4de2eddebe0d8" title="Pointers to the left of the two child parse trees.">left</a>(_left), <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#f4367b4fa2ff6d26366d16b90bc24f87" title="Pointers to the right of the two child parse trees.">right</a>(_right)
<a name="l00842"></a>00842     {
<a name="l00843"></a>00843         <span class="keywordflow">if</span> (_op == <span class="stringliteral">"and"</span> || _op == <span class="stringliteral">"&amp;&amp;"</span>)
<a name="l00844"></a>00844             <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#ce3b2883a75fb243a2a7e7fdda9badfd" title="Comparison operation to perform: left op right.">op</a> = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#0d97e460dac918ff3fba2156a121a5acbcbd80ca43a8c83ee513e3989e379b5c">OP_AND</a>;
<a name="l00845"></a>00845         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_op == <span class="stringliteral">"or"</span> || _op == <span class="stringliteral">"||"</span>)
<a name="l00846"></a>00846             <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#ce3b2883a75fb243a2a7e7fdda9badfd" title="Comparison operation to perform: left op right.">op</a> = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#0d97e460dac918ff3fba2156a121a5ac0facc5c00b8ffa53f83b6755072d4776">OP_OR</a>;
<a name="l00847"></a>00847         <span class="keywordflow">else</span>
<a name="l00848"></a>00848             <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(<span class="stringliteral">"Program Error: invalid binary logic operator."</span>));
<a name="l00849"></a>00849     }
<a name="l00850"></a>00850 
<a name="l00852"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#9bf90380aa35f285c5d0d6a9729159d7">00852</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#9bf90380aa35f285c5d0d6a9729159d7" title="Recursively delete parse tree.">~PNBinaryLogicExpr</a>()
<a name="l00853"></a>00853     {
<a name="l00854"></a>00854         <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#848829b7036e19b353a4de2eddebe0d8" title="Pointers to the left of the two child parse trees.">left</a>) <span class="keyword">delete</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#848829b7036e19b353a4de2eddebe0d8" title="Pointers to the left of the two child parse trees.">left</a>;
<a name="l00855"></a>00855         <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#f4367b4fa2ff6d26366d16b90bc24f87" title="Pointers to the right of the two child parse trees.">right</a>) <span class="keyword">delete</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#f4367b4fa2ff6d26366d16b90bc24f87" title="Pointers to the right of the two child parse trees.">right</a>;
<a name="l00856"></a>00856     }
<a name="l00857"></a>00857 
<a name="l00859"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#2e99ab906ba6dbdb53246dd11963ec9d">00859</a>     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#2e99ab906ba6dbdb53246dd11963ec9d" title="Calculate the operator.">do_operator</a>(<span class="keywordtype">bool</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#848829b7036e19b353a4de2eddebe0d8" title="Pointers to the left of the two child parse trees.">left</a>, <span class="keywordtype">bool</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#f4367b4fa2ff6d26366d16b90bc24f87" title="Pointers to the right of the two child parse trees.">right</a>)<span class="keyword"> const</span>
<a name="l00860"></a>00860 <span class="keyword">    </span>{
<a name="l00861"></a>00861         <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#ce3b2883a75fb243a2a7e7fdda9badfd" title="Comparison operation to perform: left op right.">op</a> == <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#0d97e460dac918ff3fba2156a121a5acbcbd80ca43a8c83ee513e3989e379b5c">OP_AND</a>)
<a name="l00862"></a>00862             <span class="keywordflow">return</span> left &amp;&amp; right;
<a name="l00863"></a>00863         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#ce3b2883a75fb243a2a7e7fdda9badfd" title="Comparison operation to perform: left op right.">op</a> == <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#0d97e460dac918ff3fba2156a121a5ac0facc5c00b8ffa53f83b6755072d4776">OP_OR</a>)
<a name="l00864"></a>00864             <span class="keywordflow">return</span> left || right;
<a name="l00865"></a>00865         <span class="keywordflow">else</span>
<a name="l00866"></a>00866             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00867"></a>00867     }
<a name="l00868"></a>00868 
<a name="l00870"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#7292be683f8838fb83c88b62601c25c2">00870</a>     <span class="keyword">inline</span> std::string <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#7292be683f8838fb83c88b62601c25c2" title="Return the string of this operator.">get_opstr</a>()<span class="keyword"> const</span>
<a name="l00871"></a>00871 <span class="keyword">    </span>{
<a name="l00872"></a>00872         <span class="keywordflow">return</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#ce3b2883a75fb243a2a7e7fdda9badfd" title="Comparison operation to perform: left op right.">op</a> == <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#0d97e460dac918ff3fba2156a121a5acbcbd80ca43a8c83ee513e3989e379b5c">OP_AND</a>) ? <span class="stringliteral">"&amp;&amp;"</span> : <span class="stringliteral">"||"</span>;
<a name="l00873"></a>00873     }
<a name="l00874"></a>00874 
<a name="l00877"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#5e00ba36af427e6cd4634087886c1359">00877</a>     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#5e00ba36af427e6cd4634087886c1359" title="Applies the operator to the two recursive calculated values.">evaluate</a>(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;st)<span class="keyword"> const</span>
<a name="l00878"></a>00878 <span class="keyword">    </span>{
<a name="l00879"></a>00879         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> vl = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#848829b7036e19b353a4de2eddebe0d8" title="Pointers to the left of the two child parse trees.">left</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#90bed95867ee48bbefed46777aa1580b" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>(st);
<a name="l00880"></a>00880         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> vr = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#f4367b4fa2ff6d26366d16b90bc24f87" title="Pointers to the right of the two child parse trees.">right</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#90bed95867ee48bbefed46777aa1580b" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>(st);
<a name="l00881"></a>00881 
<a name="l00882"></a>00882         <span class="comment">// these should never happen.</span>
<a name="l00883"></a>00883         <span class="keywordflow">if</span> (vl.<a class="code" href="classstx_1_1AnyScalar.html#f4e3136656d9100e1f88356c51cb9817" title="Return the type identifier of the object.">getType</a>() != <a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68baf07121e6aecbb26c291f5d92e252ce" title="A boolean type holding only true and false.">AnyScalar::ATTRTYPE_BOOL</a>)
<a name="l00884"></a>00884             <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(std::string(<span class="stringliteral">"Invalid left operand for "</span>) + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#7292be683f8838fb83c88b62601c25c2" title="Return the string of this operator.">get_opstr</a>() + <span class="stringliteral">". Both operands must be of type bool."</span>));
<a name="l00885"></a>00885         <span class="keywordflow">if</span> (vr.<a class="code" href="classstx_1_1AnyScalar.html#f4e3136656d9100e1f88356c51cb9817" title="Return the type identifier of the object.">getType</a>() != <a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68baf07121e6aecbb26c291f5d92e252ce" title="A boolean type holding only true and false.">AnyScalar::ATTRTYPE_BOOL</a>)
<a name="l00886"></a>00886             <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(std::string(<span class="stringliteral">"Invalid right operand for "</span>) + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#7292be683f8838fb83c88b62601c25c2" title="Return the string of this operator.">get_opstr</a>() + <span class="stringliteral">". Both operands must be of type bool."</span>));
<a name="l00887"></a>00887 
<a name="l00888"></a>00888         <span class="keywordtype">int</span> bvl = vl.<a class="code" href="classstx_1_1AnyScalar.html#ce9274342134b7551681a79f6891b1c0" title="Return the value converted to an integer.">getInteger</a>();
<a name="l00889"></a>00889         <span class="keywordtype">int</span> bvr = vr.<a class="code" href="classstx_1_1AnyScalar.html#ce9274342134b7551681a79f6891b1c0" title="Return the value converted to an integer.">getInteger</a>();
<a name="l00890"></a>00890 
<a name="l00891"></a>00891         <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#2e99ab906ba6dbdb53246dd11963ec9d" title="Calculate the operator.">do_operator</a>(bvl, bvr) );
<a name="l00892"></a>00892     }
<a name="l00893"></a>00893 
<a name="l00898"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#46ea90f790fa51cc4f338d2dbbc38250">00898</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#46ea90f790fa51cc4f338d2dbbc38250" title="Applies the operator to the two recursive calculated const values.">evaluate_const</a>(<a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> *dest)<span class="keyword"> const</span>
<a name="l00899"></a>00899 <span class="keyword">    </span>{
<a name="l00900"></a>00900         <span class="keywordflow">if</span> (!dest) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// returns false because this node isn't always constant</span>
<a name="l00901"></a>00901 
<a name="l00902"></a>00902         <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> vl(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b689ee13e69ddc4aac9c4ed7eb6222ad787" title="Flag identifier for an uninitialized object.">AnyScalar::ATTRTYPE_INVALID</a>), vr(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b689ee13e69ddc4aac9c4ed7eb6222ad787" title="Flag identifier for an uninitialized object.">AnyScalar::ATTRTYPE_INVALID</a>);
<a name="l00903"></a>00903         
<a name="l00904"></a>00904         <span class="keywordtype">bool</span> bl = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#848829b7036e19b353a4de2eddebe0d8" title="Pointers to the left of the two child parse trees.">left</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#72b521ba0fee0abbc565e35a443dd910" title="(Internal) Function to check if the subtree evaluates to a constant expression.">evaluate_const</a>(&amp;vl);
<a name="l00905"></a>00905         <span class="keywordtype">bool</span> br = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#f4367b4fa2ff6d26366d16b90bc24f87" title="Pointers to the right of the two child parse trees.">right</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#72b521ba0fee0abbc565e35a443dd910" title="(Internal) Function to check if the subtree evaluates to a constant expression.">evaluate_const</a>(&amp;vr);
<a name="l00906"></a>00906 
<a name="l00907"></a>00907         <span class="keywordflow">if</span> (vl.getType() != <a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68baf07121e6aecbb26c291f5d92e252ce" title="A boolean type holding only true and false.">AnyScalar::ATTRTYPE_BOOL</a>)
<a name="l00908"></a>00908             <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(std::string(<span class="stringliteral">"Invalid left operand for "</span>) + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#7292be683f8838fb83c88b62601c25c2" title="Return the string of this operator.">get_opstr</a>() + <span class="stringliteral">". Both operands must be of type bool."</span>));
<a name="l00909"></a>00909         <span class="keywordflow">if</span> (vr.<a class="code" href="classstx_1_1AnyScalar.html#f4e3136656d9100e1f88356c51cb9817" title="Return the type identifier of the object.">getType</a>() != <a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68baf07121e6aecbb26c291f5d92e252ce" title="A boolean type holding only true and false.">AnyScalar::ATTRTYPE_BOOL</a>)
<a name="l00910"></a>00910             <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(std::string(<span class="stringliteral">"Invalid right operand for "</span>) + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#7292be683f8838fb83c88b62601c25c2" title="Return the string of this operator.">get_opstr</a>() + <span class="stringliteral">". Both operands must be of type bool."</span>));
<a name="l00911"></a>00911 
<a name="l00912"></a>00912         <span class="keywordtype">int</span> bvl = vl.getInteger();
<a name="l00913"></a>00913         <span class="keywordtype">int</span> bvr = vr.<a class="code" href="classstx_1_1AnyScalar.html#ce9274342134b7551681a79f6891b1c0" title="Return the value converted to an integer.">getInteger</a>();
<a name="l00914"></a>00914 
<a name="l00915"></a>00915         *dest = <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#2e99ab906ba6dbdb53246dd11963ec9d" title="Calculate the operator.">do_operator</a>(bvl, bvr) );
<a name="l00916"></a>00916 
<a name="l00917"></a>00917         <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#ce3b2883a75fb243a2a7e7fdda9badfd" title="Comparison operation to perform: left op right.">op</a> == <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#0d97e460dac918ff3fba2156a121a5acbcbd80ca43a8c83ee513e3989e379b5c">OP_AND</a>)
<a name="l00918"></a>00918         {
<a name="l00919"></a>00919             <span class="comment">// true if either both ops are themselves constant, or if either of</span>
<a name="l00920"></a>00920             <span class="comment">// the ops are constant and evaluates to false.</span>
<a name="l00921"></a>00921             <span class="keywordflow">return</span> (bl &amp;&amp; br) || (bl &amp;&amp; !bvl) || (br &amp;&amp; !bvr);
<a name="l00922"></a>00922         }
<a name="l00923"></a>00923         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#ce3b2883a75fb243a2a7e7fdda9badfd" title="Comparison operation to perform: left op right.">op</a> == <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#0d97e460dac918ff3fba2156a121a5ac0facc5c00b8ffa53f83b6755072d4776">OP_OR</a>)
<a name="l00924"></a>00924         {
<a name="l00925"></a>00925             <span class="comment">// true if either both ops are themselves constant, or if either of</span>
<a name="l00926"></a>00926             <span class="comment">// the ops is constant and evaluates to true.</span>
<a name="l00927"></a>00927             <span class="keywordflow">return</span> (bl &amp;&amp; br) || (bl &amp;&amp; bvl) || (br &amp;&amp; bvr);
<a name="l00928"></a>00928         }
<a name="l00929"></a>00929         <span class="keywordflow">else</span> {
<a name="l00930"></a>00930             assert(0);
<a name="l00931"></a>00931             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00932"></a>00932         }
<a name="l00933"></a>00933     }
<a name="l00934"></a>00934 
<a name="l00936"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#b83a3125c2f04088d8d5c74f1a87cc6e">00936</a>     <span class="keyword">virtual</span> std::string <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#b83a3125c2f04088d8d5c74f1a87cc6e" title="String (operandA op operandB).">toString</a>()<span class="keyword"> const</span>
<a name="l00937"></a>00937 <span class="keyword">    </span>{
<a name="l00938"></a>00938         <span class="keywordflow">return</span> std::string(<span class="stringliteral">"("</span>) + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#848829b7036e19b353a4de2eddebe0d8" title="Pointers to the left of the two child parse trees.">left</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#7a57a42525ced8566833ce5c774fedf3" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() + <span class="stringliteral">" "</span> + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#7292be683f8838fb83c88b62601c25c2" title="Return the string of this operator.">get_opstr</a>() + <span class="stringliteral">" "</span> + <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#f4367b4fa2ff6d26366d16b90bc24f87" title="Pointers to the right of the two child parse trees.">right</a>-&gt;<a class="code" href="classstx_1_1ParseNode.html#7a57a42525ced8566833ce5c774fedf3" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() + <span class="stringliteral">")"</span>;
<a name="l00939"></a>00939     }
<a name="l00940"></a>00940 
<a name="l00942"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#261aee10fb1cecad17f4a0c2a0682f44">00942</a>     <span class="keyword">inline</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#261aee10fb1cecad17f4a0c2a0682f44" title="Detach left node.">detach_left</a>()
<a name="l00943"></a>00943     {
<a name="l00944"></a>00944         <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a> *n = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#848829b7036e19b353a4de2eddebe0d8" title="Pointers to the left of the two child parse trees.">left</a>;
<a name="l00945"></a>00945         <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#848829b7036e19b353a4de2eddebe0d8" title="Pointers to the left of the two child parse trees.">left</a> = NULL;
<a name="l00946"></a>00946         <span class="keywordflow">return</span> n;
<a name="l00947"></a>00947     }
<a name="l00948"></a>00948 
<a name="l00950"></a><a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#978b6e1ee3e62eb13f451ee137ee2ecb">00950</a>     <span class="keyword">inline</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#978b6e1ee3e62eb13f451ee137ee2ecb" title="Detach right node.">detach_right</a>()
<a name="l00951"></a>00951     {
<a name="l00952"></a>00952         <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a> *n = <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#f4367b4fa2ff6d26366d16b90bc24f87" title="Pointers to the right of the two child parse trees.">right</a>;
<a name="l00953"></a>00953         <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#f4367b4fa2ff6d26366d16b90bc24f87" title="Pointers to the right of the two child parse trees.">right</a> = NULL;
<a name="l00954"></a>00954         <span class="keywordflow">return</span> n;
<a name="l00955"></a>00955     }
<a name="l00956"></a>00956 };
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 <span class="comment">// *** Functions which translate the resulting parse tree into our expression</span>
<a name="l00959"></a>00959 <span class="comment">// *** tree, simultaneously folding constants.</span>
<a name="l00960"></a>00960 
<a name="l00962"></a><a class="code" href="namespacestx_1_1Grammar.html#16f888b55899690edfebb6e57d814452">00962</a> <span class="keyword">typedef</span> std::string::const_iterator <a class="code" href="namespacestx_1_1Grammar.html#16f888b55899690edfebb6e57d814452" title="Iterator type used by spirit's parsers.">InputIterT</a>;
<a name="l00963"></a>00963 
<a name="l00965"></a><a class="code" href="namespacestx_1_1Grammar.html#62a69eb85701f7de44e71a3231c612d2">00965</a> <span class="keyword">typedef</span> tree_match&lt;InputIterT&gt; <a class="code" href="namespacestx_1_1Grammar.html#62a69eb85701f7de44e71a3231c612d2" title="Resulting match tree after parsing.">ParseTreeMatchT</a>;
<a name="l00966"></a>00966 
<a name="l00968"></a><a class="code" href="namespacestx_1_1Grammar.html#641277b92380afe41fe0e2d52c9a0339">00968</a> <span class="keyword">typedef</span> ParseTreeMatchT::const_tree_iterator <a class="code" href="namespacestx_1_1Grammar.html#641277b92380afe41fe0e2d52c9a0339" title="The iterator of the match tree used in build_expr().">TreeIterT</a>;
<a name="l00969"></a>00969 
<a name="l00972"></a><a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f">00972</a> <span class="keyword">static</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(<a class="code" href="namespacestx_1_1Grammar.html#641277b92380afe41fe0e2d52c9a0339" title="The iterator of the match tree used in build_expr().">TreeIterT</a> <span class="keyword">const</span>&amp; i)
<a name="l00973"></a>00973 {
<a name="l00974"></a>00974 <span class="preprocessor">#ifdef STX_DEBUG_PARSER</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">"In build_expr. i-&gt;value = "</span> &lt;&lt;
<a name="l00976"></a>00976         std::string(i-&gt;value.begin(), i-&gt;value.end()) &lt;&lt;
<a name="l00977"></a>00977         <span class="stringliteral">" i-&gt;children.size() = "</span> &lt;&lt; i-&gt;children.size() &lt;&lt; 
<a name="l00978"></a>00978         <span class="stringliteral">" i-&gt;value.id = "</span> &lt;&lt; i-&gt;value.id().to_long() &lt;&lt; std::endl;
<a name="l00979"></a>00979 <span class="preprocessor">#endif</span>
<a name="l00980"></a>00980 <span class="preprocessor"></span>
<a name="l00981"></a>00981     <span class="keywordflow">switch</span>(i-&gt;value.id().to_long())
<a name="l00982"></a>00982     {
<a name="l00983"></a>00983     <span class="comment">// *** Constant node cases</span>
<a name="l00984"></a>00984 
<a name="l00985"></a>00985     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d96b5de61b6b955e03df9bb7b5cfc1cdbd">boolean_const_id</a>:
<a name="l00986"></a>00986     {
<a name="l00987"></a>00987         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html" title="Constant value nodes of the parse tree.">PNConstant</a>(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68baf07121e6aecbb26c291f5d92e252ce" title="A boolean type holding only true and false.">AnyScalar::ATTRTYPE_BOOL</a>,
<a name="l00988"></a>00988                               std::string(i-&gt;value.begin(), i-&gt;value.end()));
<a name="l00989"></a>00989     }
<a name="l00990"></a>00990 
<a name="l00991"></a>00991     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d90c8d12e62036bd5405d74ae3884e853c">integer_const_id</a>:
<a name="l00992"></a>00992     {
<a name="l00993"></a>00993         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html" title="Constant value nodes of the parse tree.">PNConstant</a>(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b6897be94e66fc295f27091020dab243a53" title="Medium signed integer type, 4 bytes long.">AnyScalar::ATTRTYPE_INTEGER</a>,
<a name="l00994"></a>00994                               std::string(i-&gt;value.begin(), i-&gt;value.end()));
<a name="l00995"></a>00995     }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d99149bee656d51b707a8d9d17d63c5512">long_const_id</a>:
<a name="l00998"></a>00998     {
<a name="l00999"></a>00999         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html" title="Constant value nodes of the parse tree.">PNConstant</a>(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b683015121352593b728d3ac24ed3b0f5be" title="Long (long) signed integer type, 8 bytes long.">AnyScalar::ATTRTYPE_LONG</a>,
<a name="l01000"></a>01000                               std::string(i-&gt;value.begin(), i-&gt;value.end()));
<a name="l01001"></a>01001     }
<a name="l01002"></a>01002 
<a name="l01003"></a>01003     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9c269493fa64c6557037f16f92e7dd236">double_const_id</a>:
<a name="l01004"></a>01004     {
<a name="l01005"></a>01005         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html" title="Constant value nodes of the parse tree.">PNConstant</a>(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68926df969f5ee131fffb0a350e40718d7" title="Double precision floating point type, 8 bytes long.">AnyScalar::ATTRTYPE_DOUBLE</a>,
<a name="l01006"></a>01006                               std::string(i-&gt;value.begin(), i-&gt;value.end()));
<a name="l01007"></a>01007     }
<a name="l01008"></a>01008 
<a name="l01009"></a>01009     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d93234711296d0db18f9e08a73ea0bd7b2">string_const_id</a>:
<a name="l01010"></a>01010     {
<a name="l01011"></a>01011         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html" title="Constant value nodes of the parse tree.">PNConstant</a>(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b683c26cd9826905c708c5093e9c700293c" title="String type, variable length.">AnyScalar::ATTRTYPE_STRING</a>,
<a name="l01012"></a>01012                               std::string(i-&gt;value.begin(), i-&gt;value.end()));
<a name="l01013"></a>01013     }
<a name="l01014"></a>01014 
<a name="l01015"></a>01015     <span class="comment">// *** Arithmetic node cases</span>
<a name="l01016"></a>01016 
<a name="l01017"></a>01017     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d920e16b73c807ad3b36fb65022c054ce9">unary_expr_id</a>:
<a name="l01018"></a>01018     {
<a name="l01019"></a>01019         <span class="keywordtype">char</span> arithop = *i-&gt;value.begin();
<a name="l01020"></a>01020         assert(i-&gt;children.size() == 1);
<a name="l01021"></a>01021 
<a name="l01022"></a>01022         <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a> *val = <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(i-&gt;children.begin());
<a name="l01023"></a>01023 
<a name="l01024"></a>01024         <span class="keywordflow">if</span> (val-&gt;evaluate_const(NULL))
<a name="l01025"></a>01025         {
<a name="l01026"></a>01026             <span class="comment">// construct a constant node</span>
<a name="l01027"></a>01027             <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html" title="Parse tree node representing an unary operator: '+', '-', '!' or "not".">PNUnaryArithmExpr</a> tmpnode(val, arithop);
<a name="l01028"></a>01028             <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> constval(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b689ee13e69ddc4aac9c4ed7eb6222ad787" title="Flag identifier for an uninitialized object.">AnyScalar::ATTRTYPE_INVALID</a>);
<a name="l01029"></a>01029 
<a name="l01030"></a>01030             tmpnode.evaluate_const(&amp;constval);
<a name="l01031"></a>01031 
<a name="l01032"></a>01032             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html" title="Constant value nodes of the parse tree.">PNConstant</a>(constval);
<a name="l01033"></a>01033         }
<a name="l01034"></a>01034         <span class="keywordflow">else</span>
<a name="l01035"></a>01035         {
<a name="l01036"></a>01036             <span class="comment">// calculation node</span>
<a name="l01037"></a>01037             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html" title="Parse tree node representing an unary operator: '+', '-', '!' or "not".">PNUnaryArithmExpr</a>(val, arithop);
<a name="l01038"></a>01038         }
<a name="l01039"></a>01039     }
<a name="l01040"></a>01040 
<a name="l01041"></a>01041     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9358561b4291b403350f0487aedd34632">add_expr_id</a>:
<a name="l01042"></a>01042     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9cf1954fe04fb757c20f333350e3900ee">mul_expr_id</a>:
<a name="l01043"></a>01043     {
<a name="l01044"></a>01044         <span class="keywordtype">char</span> arithop = *i-&gt;value.begin();
<a name="l01045"></a>01045         assert(i-&gt;children.size() == 2);
<a name="l01046"></a>01046 
<a name="l01047"></a>01047         <span class="comment">// auto_ptr needed because of possible parse exceptions in build_expr.</span>
<a name="l01048"></a>01048 
<a name="l01049"></a>01049         std::auto_ptr&lt;const ParseNode&gt; left( <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(i-&gt;children.begin()) );
<a name="l01050"></a>01050         std::auto_ptr&lt;const ParseNode&gt; right( <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(i-&gt;children.begin()+1) );
<a name="l01051"></a>01051 
<a name="l01052"></a>01052         <span class="keywordflow">if</span> (left-&gt;evaluate_const(NULL) &amp;&amp; right-&gt;evaluate_const(NULL))
<a name="l01053"></a>01053         {
<a name="l01054"></a>01054             <span class="comment">// construct a constant node</span>
<a name="l01055"></a>01055             <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html" title="Parse tree node representing a binary operators: +, -, * and / for numeric values...">PNBinaryArithmExpr</a> tmpnode(left.release(), right.release(), arithop);
<a name="l01056"></a>01056             <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> both(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b689ee13e69ddc4aac9c4ed7eb6222ad787" title="Flag identifier for an uninitialized object.">AnyScalar::ATTRTYPE_INVALID</a>);
<a name="l01057"></a>01057 
<a name="l01058"></a>01058             tmpnode.evaluate_const(&amp;both);
<a name="l01059"></a>01059 
<a name="l01060"></a>01060             <span class="comment">// left and right are deleted by tmpnode's deconstructor</span>
<a name="l01061"></a>01061 
<a name="l01062"></a>01062             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html" title="Constant value nodes of the parse tree.">PNConstant</a>(both);
<a name="l01063"></a>01063         }
<a name="l01064"></a>01064         <span class="keywordflow">else</span>
<a name="l01065"></a>01065         {
<a name="l01066"></a>01066             <span class="comment">// calculation node</span>
<a name="l01067"></a>01067             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html" title="Parse tree node representing a binary operators: +, -, * and / for numeric values...">PNBinaryArithmExpr</a>(left.release(), right.release(), arithop);
<a name="l01068"></a>01068         }
<a name="l01069"></a>01069     }
<a name="l01070"></a>01070 
<a name="l01071"></a>01071     <span class="comment">// *** Cast node case</span>
<a name="l01072"></a>01072 
<a name="l01073"></a>01073     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d94a990578c59110c910c1182c4b5dd5f7">cast_spec_id</a>:
<a name="l01074"></a>01074     {
<a name="l01075"></a>01075         assert(i-&gt;children.size() == 1);
<a name="l01076"></a>01076 
<a name="l01077"></a>01077         std::string tname(i-&gt;value.begin(), i-&gt;value.end());
<a name="l01078"></a>01078         <a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b68" title="Enumeration establishing identifiers for all supported types.">AnyScalar::attrtype_t</a> at = <a class="code" href="classstx_1_1AnyScalar.html#97fd734aceffb36a975fe9b0fc59a294" title="Returns the attrtype identifier of a string, throws ConversionException if s does...">AnyScalar::stringToType</a>(tname);
<a name="l01079"></a>01079         
<a name="l01080"></a>01080         <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a> *val = <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(i-&gt;children.begin());
<a name="l01081"></a>01081 
<a name="l01082"></a>01082         <span class="keywordflow">if</span> (val-&gt;<a class="code" href="classstx_1_1ParseNode.html#72b521ba0fee0abbc565e35a443dd910" title="(Internal) Function to check if the subtree evaluates to a constant expression.">evaluate_const</a>(NULL))
<a name="l01083"></a>01083         {
<a name="l01084"></a>01084             <span class="comment">// construct a constant node</span>
<a name="l01085"></a>01085             <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html" title="Parse tree node handling type conversions within the tree.">PNCastExpr</a> tmpnode(val, at);
<a name="l01086"></a>01086 
<a name="l01087"></a>01087             <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> constval(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b689ee13e69ddc4aac9c4ed7eb6222ad787" title="Flag identifier for an uninitialized object.">AnyScalar::ATTRTYPE_INVALID</a>);
<a name="l01088"></a>01088 
<a name="l01089"></a>01089             tmpnode.evaluate_const(&amp;constval);
<a name="l01090"></a>01090 
<a name="l01091"></a>01091             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html" title="Constant value nodes of the parse tree.">PNConstant</a>(constval);
<a name="l01092"></a>01092         }
<a name="l01093"></a>01093         <span class="keywordflow">else</span>
<a name="l01094"></a>01094         {
<a name="l01095"></a>01095             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNCastExpr.html" title="Parse tree node handling type conversions within the tree.">PNCastExpr</a>(val, at);
<a name="l01096"></a>01096         }
<a name="l01097"></a>01097     }
<a name="l01098"></a>01098 
<a name="l01099"></a>01099     <span class="comment">// *** Binary Comparison Operator</span>
<a name="l01100"></a>01100 
<a name="l01101"></a>01101     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d94af2653c49220c268287f93ae89fd87e">comp_expr_id</a>:
<a name="l01102"></a>01102     {
<a name="l01103"></a>01103         assert(i-&gt;children.size() == 2);
<a name="l01104"></a>01104 
<a name="l01105"></a>01105         std::string arithop(i-&gt;value.begin(), i-&gt;value.end());
<a name="l01106"></a>01106 
<a name="l01107"></a>01107         <span class="comment">// we need auto_ptr because of possible parse exceptions in build_expr.</span>
<a name="l01108"></a>01108 
<a name="l01109"></a>01109         std::auto_ptr&lt;const ParseNode&gt; left( <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(i-&gt;children.begin()) );
<a name="l01110"></a>01110         std::auto_ptr&lt;const ParseNode&gt; right( <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(i-&gt;children.begin()+1) );
<a name="l01111"></a>01111 
<a name="l01112"></a>01112         <span class="keywordflow">if</span> (left-&gt;evaluate_const(NULL) &amp;&amp; right-&gt;evaluate_const(NULL))
<a name="l01113"></a>01113         {
<a name="l01114"></a>01114             <span class="comment">// construct a constant node</span>
<a name="l01115"></a>01115             <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html" title="Parse tree node representing a binary comparison operator: ==, =, !=, &lt;, &gt;...">PNBinaryComparisonExpr</a> tmpnode(left.release(), right.release(), arithop);
<a name="l01116"></a>01116             <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> both(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b689ee13e69ddc4aac9c4ed7eb6222ad787" title="Flag identifier for an uninitialized object.">AnyScalar::ATTRTYPE_INVALID</a>);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118             tmpnode.evaluate_const(&amp;both);
<a name="l01119"></a>01119 
<a name="l01120"></a>01120             <span class="comment">// left and right are deleted by tmpnode's deconstructor</span>
<a name="l01121"></a>01121 
<a name="l01122"></a>01122             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html" title="Constant value nodes of the parse tree.">PNConstant</a>(both);
<a name="l01123"></a>01123         }
<a name="l01124"></a>01124         <span class="keywordflow">else</span>
<a name="l01125"></a>01125         {
<a name="l01126"></a>01126             <span class="comment">// calculation node</span>
<a name="l01127"></a>01127             <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html" title="Parse tree node representing a binary comparison operator: ==, =, !=, &lt;, &gt;...">PNBinaryComparisonExpr</a>(left.release(), right.release(), arithop);
<a name="l01128"></a>01128         }
<a name="l01129"></a>01129     }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131     <span class="comment">// *** Binary Logic Operator</span>
<a name="l01132"></a>01132 
<a name="l01133"></a>01133     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9db4864f8124fa8887057d4f196e2a9ac">and_expr_id</a>:
<a name="l01134"></a>01134     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9891a237d94aa87d7db6912d816a17adc">or_expr_id</a>:
<a name="l01135"></a>01135     {
<a name="l01136"></a>01136         assert(i-&gt;children.size() == 2);
<a name="l01137"></a>01137 
<a name="l01138"></a>01138         std::string logicop(i-&gt;value.begin(), i-&gt;value.end());
<a name="l01139"></a>01139         std::transform(logicop.begin(), logicop.end(), logicop.begin(), tolower);
<a name="l01140"></a>01140 
<a name="l01141"></a>01141         <span class="comment">// auto_ptr needed because of possible parse exceptions in build_expr.</span>
<a name="l01142"></a>01142 
<a name="l01143"></a>01143         std::auto_ptr&lt;ParseNode&gt; left( <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(i-&gt;children.begin()) );
<a name="l01144"></a>01144         std::auto_ptr&lt;ParseNode&gt; right( <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(i-&gt;children.begin()+1) );
<a name="l01145"></a>01145 
<a name="l01146"></a>01146         <span class="keywordtype">bool</span> constleft = left-&gt;evaluate_const(NULL);
<a name="l01147"></a>01147         <span class="keywordtype">bool</span> constright = right-&gt;evaluate_const(NULL);
<a name="l01148"></a>01148 
<a name="l01149"></a>01149         <span class="comment">// a logical node is constant if one of the two ops is constant. so we</span>
<a name="l01150"></a>01150         <span class="comment">// construct a calculation node and check later.</span>
<a name="l01151"></a>01151         std::auto_ptr&lt;PNBinaryLogicExpr&gt; node( <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html" title="Parse tree node representing a binary logic operator: and, or, &amp;&amp;, ||.">PNBinaryLogicExpr</a>(left.release(), right.release(), logicop) );
<a name="l01152"></a>01152 
<a name="l01153"></a>01153         <span class="keywordflow">if</span> (constleft || constright)
<a name="l01154"></a>01154         {
<a name="l01155"></a>01155             <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> both(<a class="code" href="classstx_1_1AnyScalar.html#a407cd96834f4548159a3f90d9be6b689ee13e69ddc4aac9c4ed7eb6222ad787" title="Flag identifier for an uninitialized object.">AnyScalar::ATTRTYPE_INVALID</a>);
<a name="l01156"></a>01156 
<a name="l01157"></a>01157             <span class="comment">// test if the node is really const.</span>
<a name="l01158"></a>01158             <span class="keywordflow">if</span> (node-&gt;evaluate_const(&amp;both))
<a name="l01159"></a>01159             {
<a name="l01160"></a>01160                 <span class="comment">// return a constant node instead, node will be deleted by</span>
<a name="l01161"></a>01161                 <span class="comment">// auto_ptr, left,right by node's destructor.</span>
<a name="l01162"></a>01162                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNConstant.html" title="Constant value nodes of the parse tree.">PNConstant</a>(both);
<a name="l01163"></a>01163             }
<a name="l01164"></a>01164         }
<a name="l01165"></a>01165         <span class="keywordflow">if</span> (constleft)
<a name="l01166"></a>01166         {
<a name="l01167"></a>01167             <span class="comment">// left node is constant, but the evaluation is not</span>
<a name="l01168"></a>01168             <span class="comment">// -&gt; only right node is meaningful.</span>
<a name="l01169"></a>01169             <span class="keywordflow">return</span> node-&gt;detach_right();
<a name="l01170"></a>01170         }
<a name="l01171"></a>01171         <span class="keywordflow">if</span> (constright)
<a name="l01172"></a>01172         {
<a name="l01173"></a>01173             <span class="comment">// right node is constant, but the evaluation is not</span>
<a name="l01174"></a>01174             <span class="comment">// -&gt; only left node is meaningful.</span>
<a name="l01175"></a>01175             <span class="keywordflow">return</span> node-&gt;detach_left();
<a name="l01176"></a>01176         }
<a name="l01177"></a>01177 
<a name="l01178"></a>01178         <span class="keywordflow">return</span> node.release();
<a name="l01179"></a>01179     }
<a name="l01180"></a>01180 
<a name="l01181"></a>01181     <span class="comment">// *** Variable and Function name place-holder</span>
<a name="l01182"></a>01182 
<a name="l01183"></a>01183     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d92036f53edd07ee94c05ef7547292f8ff">varname_id</a>:
<a name="l01184"></a>01184     {
<a name="l01185"></a>01185         assert(i-&gt;children.size() == 0);
<a name="l01186"></a>01186 
<a name="l01187"></a>01187         std::string varname(i-&gt;value.begin(), i-&gt;value.end());
<a name="l01188"></a>01188 
<a name="l01189"></a>01189         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNVariable.html" title="Parse tree node representing a variable place-holder.">PNVariable</a>(varname);
<a name="l01190"></a>01190     }
<a name="l01191"></a>01191 
<a name="l01192"></a>01192     <span class="keywordflow">case</span> <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9c6c960472ca5db496d2ab39a26c673cc">function_identifier_id</a>:
<a name="l01193"></a>01193     {
<a name="l01194"></a>01194         std::string funcname(i-&gt;value.begin(), i-&gt;value.end());
<a name="l01195"></a>01195         std::vector&lt;const class ParseNode*&gt; paramlist;
<a name="l01196"></a>01196 
<a name="l01197"></a>01197         <span class="keywordflow">if</span> (i-&gt;children.size() &gt; 0)
<a name="l01198"></a>01198         {
<a name="l01199"></a>01199             <a class="code" href="namespacestx_1_1Grammar.html#641277b92380afe41fe0e2d52c9a0339" title="The iterator of the match tree used in build_expr().">TreeIterT</a> <span class="keyword">const</span>&amp; paramlistchild = i-&gt;children.begin();
<a name="l01200"></a>01200 
<a name="l01201"></a>01201             <span class="keywordflow">if</span> (paramlistchild-&gt;value.id().to_long() == <a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9ba405d3bcd2ccc7a20b192490e0c0c80">exprlist_id</a>)
<a name="l01202"></a>01202             {
<a name="l01203"></a>01203                 <span class="keywordflow">try</span>
<a name="l01204"></a>01204                 {
<a name="l01205"></a>01205                     <span class="keywordflow">for</span>(<a class="code" href="namespacestx_1_1Grammar.html#641277b92380afe41fe0e2d52c9a0339" title="The iterator of the match tree used in build_expr().">TreeIterT</a> ci = paramlistchild-&gt;children.begin(); ci != paramlistchild-&gt;children.end(); ++ci)
<a name="l01206"></a>01206                     {
<a name="l01207"></a>01207                         <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a> *pas = <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(ci);
<a name="l01208"></a>01208                         paramlist.push_back(pas);
<a name="l01209"></a>01209                     }
<a name="l01210"></a>01210                 }
<a name="l01211"></a>01211                 <span class="keywordflow">catch</span> (...) <span class="comment">// need to clean-up</span>
<a name="l01212"></a>01212                 {
<a name="l01213"></a>01213                     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; paramlist.size(); ++i)
<a name="l01214"></a>01214                         <span class="keyword">delete</span> paramlist[i];
<a name="l01215"></a>01215                     <span class="keywordflow">throw</span>;
<a name="l01216"></a>01216                 }
<a name="l01217"></a>01217             }
<a name="l01218"></a>01218             <span class="keywordflow">else</span>
<a name="l01219"></a>01219             {
<a name="l01220"></a>01220                 <span class="comment">// just one subnode and its not a full expression list</span>
<a name="l01221"></a>01221                 paramlist.push_back( <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(paramlistchild) );
<a name="l01222"></a>01222             }
<a name="l01223"></a>01223         }
<a name="l01224"></a>01224 
<a name="l01225"></a>01225         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstx_1_1Grammar_1_1PNFunction.html" title="Parse tree node representing a function place-holder.">PNFunction</a>(funcname, paramlist);
<a name="l01226"></a>01226     }
<a name="l01227"></a>01227 
<a name="l01228"></a>01228     <span class="keywordflow">default</span>:
<a name="l01229"></a>01229         <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a>(<span class="stringliteral">"Unknown AST parse tree node found. This should never happen."</span>));
<a name="l01230"></a>01230     }
<a name="l01231"></a>01231 }
<a name="l01232"></a>01232 
<a name="l01235"></a><a class="code" href="namespacestx_1_1Grammar.html#dfe46d88a5eb9fddcb743a2a048e516e">01235</a> <a class="code" href="classstx_1_1ParseTreeList.html" title="ParseTreeList contains the root parse nodes of a list of expressions.">ParseTreeList</a> <a class="code" href="namespacestx_1_1Grammar.html#dfe46d88a5eb9fddcb743a2a048e516e" title="build_exprlist constructs the vector holding the ParseNode parse tree for each parse...">build_exprlist</a>(<a class="code" href="namespacestx_1_1Grammar.html#641277b92380afe41fe0e2d52c9a0339" title="The iterator of the match tree used in build_expr().">TreeIterT</a> <span class="keyword">const</span> &amp;i)
<a name="l01236"></a>01236 {
<a name="l01237"></a>01237 <span class="preprocessor">#ifdef STX_DEBUG_PARSER</span>
<a name="l01238"></a>01238 <span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">"In build_exprlist. i-&gt;value = "</span> &lt;&lt;
<a name="l01239"></a>01239         std::string(i-&gt;value.begin(), i-&gt;value.end()) &lt;&lt;
<a name="l01240"></a>01240         <span class="stringliteral">" i-&gt;children.size() = "</span> &lt;&lt; i-&gt;children.size() &lt;&lt; 
<a name="l01241"></a>01241         <span class="stringliteral">" i-&gt;value.id = "</span> &lt;&lt; i-&gt;value.id().to_long() &lt;&lt; std::endl;
<a name="l01242"></a>01242 <span class="preprocessor">#endif</span>
<a name="l01243"></a>01243 <span class="preprocessor"></span>
<a name="l01244"></a>01244     <a class="code" href="classstx_1_1ParseTreeList.html" title="ParseTreeList contains the root parse nodes of a list of expressions.">ParseTreeList</a> ptlist;
<a name="l01245"></a>01245 
<a name="l01246"></a>01246     <span class="keywordflow">for</span>(<a class="code" href="namespacestx_1_1Grammar.html#641277b92380afe41fe0e2d52c9a0339" title="The iterator of the match tree used in build_expr().">TreeIterT</a> ci = i-&gt;children.begin(); ci != i-&gt;children.end(); ++ci)
<a name="l01247"></a>01247     {
<a name="l01248"></a>01248         <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a> *vas = <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">build_expr</a>(ci);
<a name="l01249"></a>01249 
<a name="l01250"></a>01250         ptlist.push_back( <a class="code" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">ParseTree</a>(vas) );
<a name="l01251"></a>01251     }
<a name="l01252"></a>01252 
<a name="l01253"></a>01253     <span class="keywordflow">return</span> ptlist;
<a name="l01254"></a>01254 }
<a name="l01255"></a>01255 
<a name="l01257"></a><a class="code" href="namespacestx_1_1Grammar.html#b8fb2c6a89eeea43fc39b545eedc2e5e">01257</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacestx_1_1Grammar.html#b8fb2c6a89eeea43fc39b545eedc2e5e" title="Uses boost::spirit function to convert the parse tree into a XML document.">tree_dump_xml</a>(std::ostream &amp;os, <span class="keyword">const</span> std::string &amp;input, <span class="keyword">const</span> tree_parse_info&lt;InputIterT&gt; &amp;info)
<a name="l01258"></a>01258 {
<a name="l01259"></a>01259     <span class="comment">// map used by the xml dumper to label the nodes</span>
<a name="l01260"></a>01260 
<a name="l01261"></a>01261     std::map&lt;parser_id, std::string&gt; rule_names;
<a name="l01262"></a>01262 
<a name="l01263"></a>01263     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d96b5de61b6b955e03df9bb7b5cfc1cdbd">boolean_const_id</a>] = <span class="stringliteral">"boolean_const"</span>;
<a name="l01264"></a>01264     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d90c8d12e62036bd5405d74ae3884e853c">integer_const_id</a>] = <span class="stringliteral">"integer_const"</span>;
<a name="l01265"></a>01265     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d99149bee656d51b707a8d9d17d63c5512">long_const_id</a>] = <span class="stringliteral">"long_const"</span>;
<a name="l01266"></a>01266     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9c269493fa64c6557037f16f92e7dd236">double_const_id</a>] = <span class="stringliteral">"double_const"</span>;
<a name="l01267"></a>01267     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d93234711296d0db18f9e08a73ea0bd7b2">string_const_id</a>] = <span class="stringliteral">"string_const"</span>;
<a name="l01268"></a>01268     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d967309c293874c11524743d2293a9a4be">constant_id</a>] = <span class="stringliteral">"constant"</span>;
<a name="l01269"></a>01269 
<a name="l01270"></a>01270     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9729ced2f13b7afea76602294f73375a7">function_call_id</a>] = <span class="stringliteral">"function_call"</span>;
<a name="l01271"></a>01271     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9c6c960472ca5db496d2ab39a26c673cc">function_identifier_id</a>] = <span class="stringliteral">"function_identifier"</span>;
<a name="l01272"></a>01272 
<a name="l01273"></a>01273     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d92036f53edd07ee94c05ef7547292f8ff">varname_id</a>] = <span class="stringliteral">"varname"</span>;
<a name="l01274"></a>01274 
<a name="l01275"></a>01275     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d920e16b73c807ad3b36fb65022c054ce9">unary_expr_id</a>] = <span class="stringliteral">"unary_expr"</span>;
<a name="l01276"></a>01276     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9cf1954fe04fb757c20f333350e3900ee">mul_expr_id</a>] = <span class="stringliteral">"mul_expr"</span>;
<a name="l01277"></a>01277     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9358561b4291b403350f0487aedd34632">add_expr_id</a>] = <span class="stringliteral">"add_expr"</span>;
<a name="l01278"></a>01278 
<a name="l01279"></a>01279     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9d0210e4d83663e3b488fe5b12cd9c0d3">cast_expr_id</a>] = <span class="stringliteral">"cast_expr"</span>;
<a name="l01280"></a>01280     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d94a990578c59110c910c1182c4b5dd5f7">cast_spec_id</a>] = <span class="stringliteral">"cast_spec"</span>;
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d94af2653c49220c268287f93ae89fd87e">comp_expr_id</a>] = <span class="stringliteral">"comp_expr"</span>;
<a name="l01283"></a>01283     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9db4864f8124fa8887057d4f196e2a9ac">and_expr_id</a>] = <span class="stringliteral">"and_expr"</span>;
<a name="l01284"></a>01284     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9891a237d94aa87d7db6912d816a17adc">or_expr_id</a>] = <span class="stringliteral">"or_expr"</span>;
<a name="l01285"></a>01285 
<a name="l01286"></a>01286     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d92f300e7fe1da5ac640663145bab77d22">expr_id</a>] = <span class="stringliteral">"expr"</span>;
<a name="l01287"></a>01287     rule_names[<a class="code" href="namespacestx_1_1Grammar.html#817f2e8b0627161b5a720217792b61d9ba405d3bcd2ccc7a20b192490e0c0c80">exprlist_id</a>] = <span class="stringliteral">"exprlist"</span>;
<a name="l01288"></a>01288 
<a name="l01289"></a>01289     tree_to_xml(os, info.trees, input.c_str(), rule_names);
<a name="l01290"></a>01290 }
<a name="l01291"></a>01291 
<a name="l01292"></a>01292 } <span class="comment">// namespace Grammar</span>
<a name="l01293"></a>01293 
<a name="l01294"></a><a class="code" href="namespacestx.html#7a6901ec05156cf3aa6a60bde61f15ca">01294</a> <span class="keyword">const</span> <a class="code" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">ParseTree</a> <a class="code" href="namespacestx.html#7a6901ec05156cf3aa6a60bde61f15ca" title="Parse the given input expression into a parse tree.">parseExpression</a>(<span class="keyword">const</span> std::string &amp;input)
<a name="l01295"></a>01295 {
<a name="l01296"></a>01296     <span class="comment">// instance of the grammar</span>
<a name="l01297"></a>01297     <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar.html" title="The boost::spirit expression parser grammar.">Grammar::ExpressionGrammar</a> g;
<a name="l01298"></a>01298 
<a name="l01299"></a>01299 <span class="preprocessor">#ifdef STX_DEBUG_PARSER</span>
<a name="l01300"></a>01300 <span class="preprocessor"></span>    BOOST_SPIRIT_DEBUG_GRAMMAR(g);
<a name="l01301"></a>01301 <span class="preprocessor">#endif</span>
<a name="l01302"></a>01302 <span class="preprocessor"></span>
<a name="l01303"></a>01303     Grammar::tree_parse_info&lt;Grammar::InputIterT&gt; info =
<a name="l01304"></a>01304         boost::spirit::ast_parse(input.begin(), input.end(),
<a name="l01305"></a>01305                                  g.use_parser&lt;0&gt;(),     <span class="comment">// use first entry point: expr</span>
<a name="l01306"></a>01306                                  boost::spirit::space_p);
<a name="l01307"></a>01307 
<a name="l01308"></a>01308     <span class="keywordflow">if</span> (!info.full)
<a name="l01309"></a>01309     {
<a name="l01310"></a>01310         std::ostringstream oss;
<a name="l01311"></a>01311         oss &lt;&lt; <span class="stringliteral">"Syntax error at position "</span>
<a name="l01312"></a>01312             &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(info.stop - input.begin())
<a name="l01313"></a>01313             &lt;&lt; <span class="stringliteral">" near "</span> 
<a name="l01314"></a>01314             &lt;&lt; std::string(info.stop, input.end());
<a name="l01315"></a>01315 
<a name="l01316"></a>01316         <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(oss.str()));
<a name="l01317"></a>01317     }
<a name="l01318"></a>01318 
<a name="l01319"></a>01319     <span class="keywordflow">return</span> <a class="code" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">ParseTree</a>( <a class="code" href="namespacestx_1_1Grammar.html#21bc174babdead7e363cc35b9783df2f" title="Build_expr is the constructor method to create a parse tree from the AST-tree returned...">Grammar::build_expr</a>(info.trees.begin()) );
<a name="l01320"></a>01320 }
<a name="l01321"></a>01321 
<a name="l01322"></a><a class="code" href="namespacestx.html#3dc0e7ddc7370ce91c85ece0cf118ae4">01322</a> std::string <a class="code" href="namespacestx.html#3dc0e7ddc7370ce91c85ece0cf118ae4" title="Parse the given input expression into a parse tree.">parseExpressionXML</a>(<span class="keyword">const</span> std::string &amp;input)
<a name="l01323"></a>01323 {
<a name="l01324"></a>01324     <span class="comment">// instance of the grammar</span>
<a name="l01325"></a>01325     <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar.html" title="The boost::spirit expression parser grammar.">Grammar::ExpressionGrammar</a> g;
<a name="l01326"></a>01326 
<a name="l01327"></a>01327 <span class="preprocessor">#ifdef STX_DEBUG_PARSER</span>
<a name="l01328"></a>01328 <span class="preprocessor"></span>    BOOST_SPIRIT_DEBUG_GRAMMAR(g);
<a name="l01329"></a>01329 <span class="preprocessor">#endif</span>
<a name="l01330"></a>01330 <span class="preprocessor"></span>
<a name="l01331"></a>01331     Grammar::tree_parse_info&lt;Grammar::InputIterT&gt; info =
<a name="l01332"></a>01332         boost::spirit::ast_parse(input.begin(), input.end(),
<a name="l01333"></a>01333                                  g.use_parser&lt;0&gt;(),     <span class="comment">// use first entry point: expr</span>
<a name="l01334"></a>01334                                  boost::spirit::space_p);
<a name="l01335"></a>01335 
<a name="l01336"></a>01336     <span class="keywordflow">if</span> (!info.full)
<a name="l01337"></a>01337     {
<a name="l01338"></a>01338         std::ostringstream oss;
<a name="l01339"></a>01339         oss &lt;&lt; <span class="stringliteral">"Syntax error at position "</span>
<a name="l01340"></a>01340             &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(info.stop - input.begin())
<a name="l01341"></a>01341             &lt;&lt; <span class="stringliteral">" near "</span> 
<a name="l01342"></a>01342             &lt;&lt; std::string(info.stop, input.end());
<a name="l01343"></a>01343 
<a name="l01344"></a>01344         <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(oss.str()));
<a name="l01345"></a>01345     }
<a name="l01346"></a>01346 
<a name="l01347"></a>01347     std::ostringstream oss;
<a name="l01348"></a>01348     <a class="code" href="namespacestx_1_1Grammar.html#b8fb2c6a89eeea43fc39b545eedc2e5e" title="Uses boost::spirit function to convert the parse tree into a XML document.">Grammar::tree_dump_xml</a>(oss, input, info);
<a name="l01349"></a>01349     <span class="keywordflow">return</span> oss.str();
<a name="l01350"></a>01350 }
<a name="l01351"></a>01351 
<a name="l01352"></a><a class="code" href="namespacestx.html#5dd653f8d4b9a05ef177e5e032b40baa">01352</a> <a class="code" href="classstx_1_1ParseTreeList.html" title="ParseTreeList contains the root parse nodes of a list of expressions.">ParseTreeList</a> <a class="code" href="namespacestx.html#5dd653f8d4b9a05ef177e5e032b40baa" title="Parse the given input as an expression list "expr1, expr2, ..." into a vector of...">parseExpressionList</a>(<span class="keyword">const</span> std::string &amp;input)
<a name="l01353"></a>01353 {
<a name="l01354"></a>01354     <span class="comment">// instance of the grammar</span>
<a name="l01355"></a>01355     <a class="code" href="structstx_1_1Grammar_1_1ExpressionGrammar.html" title="The boost::spirit expression parser grammar.">Grammar::ExpressionGrammar</a> g;
<a name="l01356"></a>01356 
<a name="l01357"></a>01357 <span class="preprocessor">#ifdef STX_DEBUG_PARSER</span>
<a name="l01358"></a>01358 <span class="preprocessor"></span>    BOOST_SPIRIT_DEBUG_GRAMMAR(g);
<a name="l01359"></a>01359 <span class="preprocessor">#endif</span>
<a name="l01360"></a>01360 <span class="preprocessor"></span>
<a name="l01361"></a>01361     Grammar::tree_parse_info&lt;Grammar::InputIterT&gt; info =
<a name="l01362"></a>01362         boost::spirit::ast_parse(input.begin(), input.end(),
<a name="l01363"></a>01363                                  g.use_parser&lt;1&gt;(),     <span class="comment">// use second entry point: exprlist</span>
<a name="l01364"></a>01364                                  boost::spirit::space_p);
<a name="l01365"></a>01365 
<a name="l01366"></a>01366     <span class="keywordflow">if</span> (!info.full)
<a name="l01367"></a>01367     {
<a name="l01368"></a>01368         std::ostringstream oss;
<a name="l01369"></a>01369         oss &lt;&lt; <span class="stringliteral">"Syntax error at position "</span>
<a name="l01370"></a>01370             &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(info.stop - input.begin())
<a name="l01371"></a>01371             &lt;&lt; <span class="stringliteral">" near "</span> 
<a name="l01372"></a>01372             &lt;&lt; std::string(info.stop, input.end());
<a name="l01373"></a>01373 
<a name="l01374"></a>01374         <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(oss.str()));
<a name="l01375"></a>01375     }
<a name="l01376"></a>01376 
<a name="l01377"></a>01377     <span class="keywordflow">return</span> <a class="code" href="namespacestx_1_1Grammar.html#dfe46d88a5eb9fddcb743a2a048e516e" title="build_exprlist constructs the vector holding the ParseNode parse tree for each parse...">Grammar::build_exprlist</a>(info.trees.begin());
<a name="l01378"></a>01378 }
<a name="l01379"></a>01379 
<a name="l01380"></a><a class="code" href="classstx_1_1ParseTreeList.html#ca10206595ca639a7e1d9c52c81e5391">01380</a> std::vector&lt;AnyScalar&gt; <a class="code" href="classstx_1_1ParseTreeList.html#ca10206595ca639a7e1d9c52c81e5391" title="Function to recursively evaluate all the contained parse trees and retrieve each...">ParseTreeList::evaluate</a>(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;st)<span class="keyword"> const</span>
<a name="l01381"></a>01381 <span class="keyword"></span>{
<a name="l01382"></a>01382     std::vector&lt;AnyScalar&gt; vl;
<a name="l01383"></a>01383 
<a name="l01384"></a>01384     <span class="keywordflow">for</span>(parent_type::const_iterator i = parent_type::begin(); i != parent_type::end(); i++)
<a name="l01385"></a>01385     {
<a name="l01386"></a>01386         vl.push_back( i-&gt;evaluate(st) );
<a name="l01387"></a>01387     }
<a name="l01388"></a>01388 
<a name="l01389"></a>01389     <span class="keywordflow">return</span> vl;
<a name="l01390"></a>01390 }
<a name="l01391"></a>01391 
<a name="l01392"></a><a class="code" href="classstx_1_1ParseTreeList.html#e6e7833feaad4876b5589e3eb62a90cd">01392</a> std::string ParseTreeList::toString()<span class="keyword"> const</span>
<a name="l01393"></a>01393 <span class="keyword"></span>{
<a name="l01394"></a>01394     std::string sl;
<a name="l01395"></a>01395 
<a name="l01396"></a>01396     <span class="keywordflow">for</span>(parent_type::const_iterator i = parent_type::begin(); i != parent_type::end(); i++)
<a name="l01397"></a>01397     {
<a name="l01398"></a>01398         <span class="keywordflow">if</span> (i != parent_type::begin()) {
<a name="l01399"></a>01399             sl += <span class="stringliteral">", "</span>;
<a name="l01400"></a>01400         }
<a name="l01401"></a>01401 
<a name="l01402"></a>01402         sl += i-&gt;toString();
<a name="l01403"></a>01403     }
<a name="l01404"></a>01404 
<a name="l01405"></a>01405     <span class="keywordflow">return</span> sl;
<a name="l01406"></a>01406 }
<a name="l01407"></a>01407 
<a name="l01409"></a>01409 
<a name="l01410"></a><a class="code" href="classstx_1_1SymbolTable.html#8d49d60dd4293234ef78bfdf36cd2d4f">01410</a> <a class="code" href="classstx_1_1SymbolTable.html#8d49d60dd4293234ef78bfdf36cd2d4f" title="*** SymbolTable, EmptySymbolTable and BasicSymbolTable implementation">SymbolTable::~SymbolTable</a>()
<a name="l01411"></a>01411 {
<a name="l01412"></a>01412 }
<a name="l01413"></a>01413 
<a name="l01414"></a><a class="code" href="classstx_1_1EmptySymbolTable.html#b04024359b313a812ebaa5f70d1c088f">01414</a> <a class="code" href="classstx_1_1EmptySymbolTable.html#b04024359b313a812ebaa5f70d1c088f" title="Required for virtual functions.">EmptySymbolTable::~EmptySymbolTable</a>()
<a name="l01415"></a>01415 {
<a name="l01416"></a>01416 }
<a name="l01417"></a>01417 
<a name="l01418"></a><a class="code" href="classstx_1_1EmptySymbolTable.html#a8dfcf880de9caa01251e81e6208f9bd">01418</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1EmptySymbolTable.html#a8dfcf880de9caa01251e81e6208f9bd" title="Return the (constant) value of a variable.">EmptySymbolTable::lookupVariable</a>(<span class="keyword">const</span> std::string &amp;varname)<span class="keyword"> const</span>
<a name="l01419"></a>01419 <span class="keyword"></span>{
<a name="l01420"></a>01420     <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1UnknownSymbolException.html" title="Exception class thrown when the symbol table cannot find a variable or function.">UnknownSymbolException</a>(std::string(<span class="stringliteral">"Unknown variable "</span>) + varname));
<a name="l01421"></a>01421 }
<a name="l01422"></a>01422 
<a name="l01423"></a><a class="code" href="classstx_1_1EmptySymbolTable.html#2e30353b08d479102822b886b7ed4102">01423</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1EmptySymbolTable.html#2e30353b08d479102822b886b7ed4102" title="Called when a program-defined function needs to be evaluated within an expression...">EmptySymbolTable::processFunction</a>(<span class="keyword">const</span> std::string &amp;funcname,
<a name="l01424"></a>01424                                             <span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;)<span class="keyword"> const</span>
<a name="l01425"></a>01425 <span class="keyword"></span>{
<a name="l01426"></a>01426     <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1UnknownSymbolException.html" title="Exception class thrown when the symbol table cannot find a variable or function.">UnknownSymbolException</a>(std::string(<span class="stringliteral">"Unknown function "</span>) + funcname + <span class="stringliteral">"()"</span>));
<a name="l01427"></a>01427 }
<a name="l01428"></a>01428 
<a name="l01429"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#1ea145f22d4dff4376d3a5e9b4784091">01429</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#1ea145f22d4dff4376d3a5e9b4784091" title="Fills in the functionmap with the standard functions.">BasicSymbolTable::BasicSymbolTable</a>()
<a name="l01430"></a>01430 {
<a name="l01431"></a>01431     <a class="code" href="classstx_1_1BasicSymbolTable.html#7cecde413c0ba81b4738783a1fc7dd29" title="Add set of standard mathematic functions.">addStandardFunctions</a>();
<a name="l01432"></a>01432 }
<a name="l01433"></a>01433 
<a name="l01434"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#fdd1e15f10a194526ff70f1c410d58aa">01434</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#fdd1e15f10a194526ff70f1c410d58aa" title="Required for virtual functions.">BasicSymbolTable::~BasicSymbolTable</a>()
<a name="l01435"></a>01435 {
<a name="l01436"></a>01436 }
<a name="l01437"></a>01437 
<a name="l01438"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#69cc26322a17a19a3fec86c866afd5fe">01438</a> <span class="keywordtype">void</span> <a class="code" href="classstx_1_1BasicSymbolTable.html#69cc26322a17a19a3fec86c866afd5fe" title="Add or replace a variable to the symbol table.">BasicSymbolTable::setVariable</a>(<span class="keyword">const</span> std::string&amp; varname, <span class="keyword">const</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> &amp;value)
<a name="l01439"></a>01439 {
<a name="l01440"></a>01440     std::string vn = varname;
<a name="l01441"></a>01441     std::transform(vn.begin(), vn.end(), vn.begin(), tolower);
<a name="l01442"></a>01442 
<a name="l01443"></a>01443     <a class="code" href="classstx_1_1BasicSymbolTable.html#f96f8a293b3b1e6a731c66bcfe1a0946" title="Variable map which can be filled by the user-application.">variablemap</a>[vn] = value;
<a name="l01444"></a>01444 }
<a name="l01445"></a>01445 
<a name="l01446"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#d4accd9604a6b69e115d8a73015ad55b">01446</a> <span class="keywordtype">void</span> <a class="code" href="classstx_1_1BasicSymbolTable.html#d4accd9604a6b69e115d8a73015ad55b" title="Add or replace a function to the symbol table.">BasicSymbolTable::setFunction</a>(<span class="keyword">const</span> std::string&amp; funcname, <span class="keywordtype">int</span> arguments, <a class="code" href="classstx_1_1BasicSymbolTable.html#c399528effc6c2e0ddceb592109b1296" title="Signature of a function used in the symbol table.">functionptr_type</a> funcptr)
<a name="l01447"></a>01447 {
<a name="l01448"></a>01448     std::string fn = funcname;
<a name="l01449"></a>01449     std::transform(fn.begin(), fn.end(), fn.begin(), toupper);
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     <a class="code" href="classstx_1_1BasicSymbolTable.html#4a42d56113178636da33f6515f569fd7" title="Function map used to lookup standard or user-added function.">functionmap</a>[fn] = <a class="code" href="structstx_1_1BasicSymbolTable_1_1FunctionInfo.html" title="Extra info about a function: the valid arguments.">FunctionInfo</a>(arguments, funcptr);
<a name="l01452"></a>01452 }
<a name="l01453"></a>01453 
<a name="l01454"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#3f8eb0ceb2ea306d6c586849581a03d1">01454</a> <span class="keywordtype">void</span> <a class="code" href="classstx_1_1BasicSymbolTable.html#3f8eb0ceb2ea306d6c586849581a03d1" title="Clear variables table.">BasicSymbolTable::clearVariables</a>()
<a name="l01455"></a>01455 {
<a name="l01456"></a>01456     <a class="code" href="classstx_1_1BasicSymbolTable.html#f96f8a293b3b1e6a731c66bcfe1a0946" title="Variable map which can be filled by the user-application.">variablemap</a>.clear();
<a name="l01457"></a>01457 }
<a name="l01458"></a>01458 
<a name="l01459"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#287281be4514359725f1093b4bdd2406">01459</a> <span class="keywordtype">void</span> <a class="code" href="classstx_1_1BasicSymbolTable.html#287281be4514359725f1093b4bdd2406" title="Clear function table.">BasicSymbolTable::clearFunctions</a>()
<a name="l01460"></a>01460 {
<a name="l01461"></a>01461     <a class="code" href="classstx_1_1BasicSymbolTable.html#4a42d56113178636da33f6515f569fd7" title="Function map used to lookup standard or user-added function.">functionmap</a>.clear();
<a name="l01462"></a>01462 }
<a name="l01463"></a>01463 
<a name="l01464"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#75eccd3066ac0f7fdae391b65865d10e">01464</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#75eccd3066ac0f7fdae391b65865d10e" title="Return the value of PI as a double AnyScalar.">BasicSymbolTable::funcPI</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;)
<a name="l01465"></a>01465 {
<a name="l01466"></a>01466     <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>(3.14159265358979323846);
<a name="l01467"></a>01467 }
<a name="l01468"></a>01468 
<a name="l01469"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#457693c6dccd8be91779b892759b8594">01469</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#457693c6dccd8be91779b892759b8594" title="Return the value of sin(x) as a double AnyScalar.">BasicSymbolTable::funcSIN</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist)
<a name="l01470"></a>01470 {
<a name="l01471"></a>01471     <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( std::sin(paramlist[0].getDouble()) );
<a name="l01472"></a>01472 }
<a name="l01473"></a>01473 
<a name="l01474"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#ed4a7ff2aaff785946437313bdce6137">01474</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#ed4a7ff2aaff785946437313bdce6137" title="Return the value of cos(x) as a double AnyScalar.">BasicSymbolTable::funcCOS</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist)
<a name="l01475"></a>01475 {
<a name="l01476"></a>01476     <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( std::cos(paramlist[0].getDouble()) );
<a name="l01477"></a>01477 }
<a name="l01478"></a>01478 
<a name="l01479"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#5e3de43f45cd359b3cef1466f0d184fc">01479</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#5e3de43f45cd359b3cef1466f0d184fc" title="Return the value of tan(x) as a double AnyScalar.">BasicSymbolTable::funcTAN</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist)
<a name="l01480"></a>01480 {
<a name="l01481"></a>01481     <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( std::tan(paramlist[0].getDouble()) );
<a name="l01482"></a>01482 }
<a name="l01483"></a>01483 
<a name="l01484"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#27f0c580f3a06cc0211e64d148c6afcc">01484</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#27f0c580f3a06cc0211e64d148c6afcc" title="Return the value of abs(x) or fabs(f).">BasicSymbolTable::funcABS</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist)
<a name="l01485"></a>01485 {
<a name="l01486"></a>01486     <span class="keywordflow">if</span> (paramlist[0].isIntegerType()) {
<a name="l01487"></a>01487         <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( std::abs(paramlist[0].getInteger()) );
<a name="l01488"></a>01488     }
<a name="l01489"></a>01489     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (paramlist[0].isFloatingType()) {
<a name="l01490"></a>01490         <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( std::fabs(paramlist[0].getDouble()) );
<a name="l01491"></a>01491     }
<a name="l01492"></a>01492     <span class="keywordflow">else</span> {
<a name="l01493"></a>01493         <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadFunctionCallException.html" title="Exception class thrown when the symbol table cannot correctly execute a function...">BadFunctionCallException</a>(<span class="stringliteral">"Function ABS() takes exactly one parameter"</span>));
<a name="l01494"></a>01494     }
<a name="l01495"></a>01495 }
<a name="l01496"></a>01496 
<a name="l01497"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#21ae35927156210967c84e29b1bca687">01497</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#21ae35927156210967c84e29b1bca687" title="Return the value of exp(x) as a double AnyScalar.">BasicSymbolTable::funcEXP</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist)
<a name="l01498"></a>01498 {
<a name="l01499"></a>01499     <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( std::exp(paramlist[0].getDouble()) );
<a name="l01500"></a>01500 }
<a name="l01501"></a>01501 
<a name="l01502"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#2f7b5321dca969c8991a7522b3b2620e">01502</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#2f7b5321dca969c8991a7522b3b2620e" title="Return the value of log(x) as a double AnyScalar.">BasicSymbolTable::funcLOGN</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist)
<a name="l01503"></a>01503 {
<a name="l01504"></a>01504     <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( std::log(paramlist[0].getDouble()) );
<a name="l01505"></a>01505 }
<a name="l01506"></a>01506 
<a name="l01507"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#4b092630c736e0f31843b25d2cdd3a3d">01507</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#4b092630c736e0f31843b25d2cdd3a3d" title="Return the value of pow(x,y) as a double AnyScalar.">BasicSymbolTable::funcPOW</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist)
<a name="l01508"></a>01508 {
<a name="l01509"></a>01509     <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( std::pow(paramlist[0].getDouble(), paramlist[1].getDouble()) );
<a name="l01510"></a>01510 }
<a name="l01511"></a>01511 
<a name="l01512"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#db42ea388d0c8f44cc4ea005fe125f0f">01512</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#db42ea388d0c8f44cc4ea005fe125f0f" title="Return the value of sqrt(x) as a double AnyScalar.">BasicSymbolTable::funcSQRT</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist)
<a name="l01513"></a>01513 {
<a name="l01514"></a>01514     <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>( std::sqrt(paramlist[0].getDouble()) );
<a name="l01515"></a>01515 }
<a name="l01516"></a>01516 
<a name="l01517"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#7cecde413c0ba81b4738783a1fc7dd29">01517</a> <span class="keywordtype">void</span> <a class="code" href="classstx_1_1BasicSymbolTable.html#7cecde413c0ba81b4738783a1fc7dd29" title="Add set of standard mathematic functions.">BasicSymbolTable::addStandardFunctions</a>()
<a name="l01518"></a>01518 {
<a name="l01519"></a>01519     <a class="code" href="classstx_1_1BasicSymbolTable.html#d4accd9604a6b69e115d8a73015ad55b" title="Add or replace a function to the symbol table.">setFunction</a>(<span class="stringliteral">"PI"</span>, 0, <a class="code" href="classstx_1_1BasicSymbolTable.html#75eccd3066ac0f7fdae391b65865d10e" title="Return the value of PI as a double AnyScalar.">funcPI</a>);
<a name="l01520"></a>01520 
<a name="l01521"></a>01521     <a class="code" href="classstx_1_1BasicSymbolTable.html#d4accd9604a6b69e115d8a73015ad55b" title="Add or replace a function to the symbol table.">setFunction</a>(<span class="stringliteral">"SIN"</span>, 1, <a class="code" href="classstx_1_1BasicSymbolTable.html#457693c6dccd8be91779b892759b8594" title="Return the value of sin(x) as a double AnyScalar.">funcSIN</a>);
<a name="l01522"></a>01522     <a class="code" href="classstx_1_1BasicSymbolTable.html#d4accd9604a6b69e115d8a73015ad55b" title="Add or replace a function to the symbol table.">setFunction</a>(<span class="stringliteral">"COS"</span>, 1, <a class="code" href="classstx_1_1BasicSymbolTable.html#ed4a7ff2aaff785946437313bdce6137" title="Return the value of cos(x) as a double AnyScalar.">funcCOS</a>);
<a name="l01523"></a>01523     <a class="code" href="classstx_1_1BasicSymbolTable.html#d4accd9604a6b69e115d8a73015ad55b" title="Add or replace a function to the symbol table.">setFunction</a>(<span class="stringliteral">"TAN"</span>, 1, <a class="code" href="classstx_1_1BasicSymbolTable.html#5e3de43f45cd359b3cef1466f0d184fc" title="Return the value of tan(x) as a double AnyScalar.">funcTAN</a>);
<a name="l01524"></a>01524 
<a name="l01525"></a>01525     <a class="code" href="classstx_1_1BasicSymbolTable.html#d4accd9604a6b69e115d8a73015ad55b" title="Add or replace a function to the symbol table.">setFunction</a>(<span class="stringliteral">"ABS"</span>, 1, <a class="code" href="classstx_1_1BasicSymbolTable.html#27f0c580f3a06cc0211e64d148c6afcc" title="Return the value of abs(x) or fabs(f).">funcABS</a>);
<a name="l01526"></a>01526     <a class="code" href="classstx_1_1BasicSymbolTable.html#d4accd9604a6b69e115d8a73015ad55b" title="Add or replace a function to the symbol table.">setFunction</a>(<span class="stringliteral">"EXP"</span>, 1, <a class="code" href="classstx_1_1BasicSymbolTable.html#21ae35927156210967c84e29b1bca687" title="Return the value of exp(x) as a double AnyScalar.">funcEXP</a>);
<a name="l01527"></a>01527     <a class="code" href="classstx_1_1BasicSymbolTable.html#d4accd9604a6b69e115d8a73015ad55b" title="Add or replace a function to the symbol table.">setFunction</a>(<span class="stringliteral">"LOGN"</span>, 1, <a class="code" href="classstx_1_1BasicSymbolTable.html#2f7b5321dca969c8991a7522b3b2620e" title="Return the value of log(x) as a double AnyScalar.">funcLOGN</a>);
<a name="l01528"></a>01528     <a class="code" href="classstx_1_1BasicSymbolTable.html#d4accd9604a6b69e115d8a73015ad55b" title="Add or replace a function to the symbol table.">setFunction</a>(<span class="stringliteral">"POW"</span>, 2, <a class="code" href="classstx_1_1BasicSymbolTable.html#4b092630c736e0f31843b25d2cdd3a3d" title="Return the value of pow(x,y) as a double AnyScalar.">funcPOW</a>);
<a name="l01529"></a>01529     <a class="code" href="classstx_1_1BasicSymbolTable.html#d4accd9604a6b69e115d8a73015ad55b" title="Add or replace a function to the symbol table.">setFunction</a>(<span class="stringliteral">"SQRT"</span>, 1, <a class="code" href="classstx_1_1BasicSymbolTable.html#db42ea388d0c8f44cc4ea005fe125f0f" title="Return the value of sqrt(x) as a double AnyScalar.">funcSQRT</a>);
<a name="l01530"></a>01530 }
<a name="l01531"></a>01531 
<a name="l01532"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#20f5e9a9dd0d6fd647261265b07e8259">01532</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#20f5e9a9dd0d6fd647261265b07e8259" title="Return the (constant) value of a variable.">BasicSymbolTable::lookupVariable</a>(<span class="keyword">const</span> std::string &amp;_varname)<span class="keyword"> const</span>
<a name="l01533"></a>01533 <span class="keyword"></span>{
<a name="l01534"></a>01534     std::string varname = _varname;
<a name="l01535"></a>01535     std::transform(varname.begin(), varname.end(), varname.begin(), tolower);
<a name="l01536"></a>01536 
<a name="l01537"></a>01537     variablemap_type::const_iterator fi = <a class="code" href="classstx_1_1BasicSymbolTable.html#f96f8a293b3b1e6a731c66bcfe1a0946" title="Variable map which can be filled by the user-application.">variablemap</a>.find(varname);
<a name="l01538"></a>01538 
<a name="l01539"></a>01539     <span class="keywordflow">if</span> (fi != <a class="code" href="classstx_1_1BasicSymbolTable.html#f96f8a293b3b1e6a731c66bcfe1a0946" title="Variable map which can be filled by the user-application.">variablemap</a>.end())
<a name="l01540"></a>01540     {
<a name="l01541"></a>01541         <span class="keywordflow">return</span> fi-&gt;second;
<a name="l01542"></a>01542     }
<a name="l01543"></a>01543 
<a name="l01544"></a>01544     <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1UnknownSymbolException.html" title="Exception class thrown when the symbol table cannot find a variable or function.">UnknownSymbolException</a>(std::string(<span class="stringliteral">"Unknown variable "</span>) + varname));
<a name="l01545"></a>01545 }
<a name="l01546"></a>01546 
<a name="l01547"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#71288f825a5a7ccdd519013c1579f3b6">01547</a> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> <a class="code" href="classstx_1_1BasicSymbolTable.html#71288f825a5a7ccdd519013c1579f3b6" title="Called when a program-defined function needs to be evaluated within an expression...">BasicSymbolTable::processFunction</a>(<span class="keyword">const</span> std::string &amp;_funcname,
<a name="l01548"></a>01548                                             <span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist)<span class="keyword"> const</span>
<a name="l01549"></a>01549 <span class="keyword"></span>{
<a name="l01550"></a>01550     std::string funcname = _funcname;
<a name="l01551"></a>01551     std::transform(funcname.begin(), funcname.end(), funcname.begin(), toupper);
<a name="l01552"></a>01552 
<a name="l01553"></a>01553     functionmap_type::const_iterator fi = <a class="code" href="classstx_1_1BasicSymbolTable.html#4a42d56113178636da33f6515f569fd7" title="Function map used to lookup standard or user-added function.">functionmap</a>.find(funcname);
<a name="l01554"></a>01554 
<a name="l01555"></a>01555     <span class="keywordflow">if</span> (fi != <a class="code" href="classstx_1_1BasicSymbolTable.html#4a42d56113178636da33f6515f569fd7" title="Function map used to lookup standard or user-added function.">functionmap</a>.end())
<a name="l01556"></a>01556     {
<a name="l01557"></a>01557         <span class="keywordflow">if</span> (fi-&gt;second.arguments &gt;= 0)
<a name="l01558"></a>01558         {
<a name="l01559"></a>01559             <span class="keywordflow">if</span> (fi-&gt;second.arguments == 0 &amp;&amp; paramlist.size() != 0)
<a name="l01560"></a>01560             {
<a name="l01561"></a>01561                 <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadFunctionCallException.html" title="Exception class thrown when the symbol table cannot correctly execute a function...">BadFunctionCallException</a>(std::string(<span class="stringliteral">"Function "</span>) + funcname + <span class="stringliteral">"() does not take any parameter."</span>));
<a name="l01562"></a>01562             }
<a name="l01563"></a>01563             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fi-&gt;second.arguments == 1 &amp;&amp; paramlist.size() != 1)
<a name="l01564"></a>01564             {
<a name="l01565"></a>01565                 <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadFunctionCallException.html" title="Exception class thrown when the symbol table cannot correctly execute a function...">BadFunctionCallException</a>(std::string(<span class="stringliteral">"Function "</span>) + funcname + <span class="stringliteral">"() takes exactly one parameter."</span>));
<a name="l01566"></a>01566             }
<a name="l01567"></a>01567             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (static_cast&lt;unsigned int&gt;(fi-&gt;second.arguments) != paramlist.size())
<a name="l01568"></a>01568             {
<a name="l01569"></a>01569                 std::ostringstream oss;
<a name="l01570"></a>01570                 oss &lt;&lt; <span class="stringliteral">"Function "</span> &lt;&lt; funcname &lt;&lt; <span class="stringliteral">"() takes exactly "</span> &lt;&lt; fi-&gt;second.arguments &lt;&lt; <span class="stringliteral">" parameters."</span>;
<a name="l01571"></a>01571                 <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1BadFunctionCallException.html" title="Exception class thrown when the symbol table cannot correctly execute a function...">BadFunctionCallException</a>(oss.str()));
<a name="l01572"></a>01572             }
<a name="l01573"></a>01573         }
<a name="l01574"></a>01574         <span class="keywordflow">return</span> fi-&gt;second.func(paramlist);
<a name="l01575"></a>01575     }
<a name="l01576"></a>01576 
<a name="l01577"></a>01577     <span class="keywordflow">throw</span>(<a class="code" href="classstx_1_1UnknownSymbolException.html" title="Exception class thrown when the symbol table cannot find a variable or function.">UnknownSymbolException</a>(std::string(<span class="stringliteral">"Unknown function "</span>) + funcname + <span class="stringliteral">"()"</span>));
<a name="l01578"></a>01578 }
<a name="l01579"></a>01579 
<a name="l01580"></a>01580 } <span class="comment">// namespace stx</span>
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Tue Jul 17 16:51:58 2007 for STX Expression Parser by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
