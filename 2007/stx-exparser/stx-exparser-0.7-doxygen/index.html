<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>STX Expression Parser: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>STX Expression Parser Documentation</h1>
<p>
<h3 align="center">v0.7 </h3>The STX Expression Parser provides a C++ framework, which can process user-specified expression strings containing program-specific variables. It can be integrated into applications to allow user-customized data selection and filtering. The expresssion strings are intuitive SQL-like WHERE-clauses and can contain arbitrarily complex arithmetic. At the same time the expression processing time is guaranteed to be fast enough to safely iterate over larger data sets.<p>
Originally I wrote this parser framework for my study thesis (see <a href="http://idlebox.net/blogtags/study_thesis_large_graphs">http://idlebox.net/blogtags/study_thesis_large_graphs</a>). In the thesis millions of graph edges are processed and organized in an r-tree search index structure. Each vertex and edge had a number of attributes like "color" or "importance". These attributes could then be used in filter expressions to determine which edges are returned by a graph server and displayed on a remote client. The attributes of the filtered edges could be used to calculate the returned data set using expressions similar to SQL column selection clauses.<p>
Four instructive example applications are included in the package. See <a class="el" href="index.html#sec_examples">Extensive Example Programs Including Source Code</a> for more.<h2><a class="anchor" name="sec_web">
Website / API Docs / Bugs / License</a></h2>
The current source distribution package can be downloaded from <a href="http://idlebox.net/2007/stx-exparser/">http://idlebox.net/2007/stx-exparser/</a><p>
The library source and example programs are extensively documented using doxygen. The compiled doxygen HTML documentation can be found at <a href="http://idlebox.net/2007/stx-exparser/stx-exparser-0.7-doxygen/">http://idlebox.net/2007/stx-exparser/stx-exparser-0.7-doxygen/</a> (if you are not reading it right now).<p>
If bugs should become known they will be posted on the above web page together with patches or corrected versions.<p>
The complete source code is released under the GNU Lesser General Public License v2.1 (LGPL) which can be found in the file COPYING.<h3><a class="anchor" name="subsec_webexample">
Online Examples</a></h3>
An online interactive CGI version of the parser can be accessed at <a href="http://idlebox.net/2007/stx-exparser/online.htt">http://idlebox.net/2007/stx-exparser/online.htt</a> . It displays the inner workings of the library for a given expression string.<p>
Furthermore a number of example CSV data files can be browsed, sorted, analyzed and filtered using the csvtool example. See <a href="http://idlebox.net/2007/stx-exparser/csvfilter.htt">http://idlebox.net/2007/stx-exparser/csvfilter.htt</a> for an instructive use of this library.<p>
A wxWidgets demo program is located in the directory wxparserdemo. Compiled binary versions can be found at <a href="http://idlebox.net/2007/stx-exparser/demo.htt">http://idlebox.net/2007/stx-exparser/demo.htt</a><h2><a class="anchor" name="sec_boostspirit">
Compilation and Boost.Spirit</a></h2>
The expression parser's grammar is implemented using the Boost.Spirit parser framework (see <a href="http://spirit.sourceforge.net">http://spirit.sourceforge.net</a>). Therefore Boost must be installed to compile the expression parser library. But as Boost.Spirit is a set template includes, the resulting static library has no external dependencies. The second purpose of this library release is to show a reasonably complex Spirit parser grammar. See <a class="el" href="index.html#subsec_grammar">Spirit Grammar and ParseTree Processing</a> for more details.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Compiling the library with <code>gcc 3.3 -O3</code> can take very long and a huge amount of RAM. This is due to the complex template classes created by Boost.Spirit. Compilation with <code>gcc 4.x</code> is much faster.</dd></dl>
<h2><a class="anchor" name="sec_exprexample">
Expression Examples</a></h2>
The expression parser allows arbitrarily complex arithmetic expressions like: <ul>
<li><code>6 + 3 * 12</code> </li>
<li><code>(5 + 3) * 5.25</code> </li>
<li><code>(int)(30 * 1.4)</code> </li>
<li><code>(5 + 1 + 1 + 1) * (4.25 + 0.4 * 2.5 / (3.1 - 0.525 * 4))</code></li>
</ul>
To process program-defined data functions and variables may be included in the expression: <ul>
<li><code>a * 5 + 3 * b + EXP( LOGN(2) ) + COS( PI() / 2 )</code></li>
</ul>
To enable the expressions to be used as filters many comparison operators and boolean logic operators are defined: <ul>
<li><code>6 * 9 == 42</code> </li>
<li><code>a &gt;= 5 OR (42 &lt;= field2 AND field2 &lt;= 48) || NOT(got == "yes")</code></li>
</ul>
<h2><a class="anchor" name="sec_examples">
Extensive Example Programs Including Source Code</a></h2>
The distribution contains two well documented example programs:<p>
<ul>
<li><a class="el" href="example_exprcalc.html">exprcalc: A Simple Expression Calculator</a> </li>
<li><a class="el" href="example_csvfilter.html">csvfilter: A CSV-File Record Filter</a></li>
</ul>
and a third more complex (less documented) example program:<p>
<ul>
<li><a class="el" href="example_csvtool.html">csvtool: An Enhanced CSV-File Record Filter and Sorter</a></li>
</ul>
Furthermore a user-friendly graphical demonstration application is included:<p>
<ul>
<li><a class="el" href="example_wxparserdemo.html">wxParserDemo: wxWidgets Demo Application</a></li>
</ul>
<h2><a class="anchor" name="sec_design">
Short Overview of the Library's Design</a></h2>
<h3><a class="anchor" name="subsec_anyscalar">
Types and the AnyScalar Class</a></h3>
The parser operates on following scalar types: <ul>
<li>boolean </li>
<li>8-bit '<code>char</code>' integer, 16-bit '<code>short</code>', 32-bit '<code>integer</code>' and 64-bit '<code>long</code>' integer </li>
<li>8-bit '<code>byte</code>', 16-bit '<code>word</code>', 32-bit '<code>dword</code>' and 64-bit '<code>qword</code>' unsigned integers </li>
<li>single and double precision floating point (<code>float</code> and <code>double</code>) </li>
<li><code>string</code></li>
</ul>
These data types are processed by the library using the <a class="el" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> class. It contains a (type, value) pair of one of the scalar type listed above. These scalar values can then be added, subtracted, multiplied, divided or compared using member functions. If the two composed scalar objects are of unequal type, then the operation is calculated in the "higher" data type (very similar to C) and returned as such. So a small unsigned integer can be added to a larger integer or even a string.<p>
The reason to include the smaller integer types is based on the original purpose of this library. In my study thesis the resulting values were transfered over a network socket from a graph server to its drawing client. For this purpose it was important to convert the resulting values into smaller data types and thus reduce network traffic. For online-filtering applications this is probably not as important.<h3><a class="anchor" name="subsec_grammar">
Spirit Grammar and ParseTree Processing</a></h3>
The expression parser grammar is an extension of the more basic "arithmetic calculator". It is extended to recognize floating point numbers, quoted string constants, attribute placeholders, function calls, comparison and boolean operators.<p>
A user given input string is parsed by Spirit into an abstract syntax tree (AST). The AST is then processed into a tree of <a class="el" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">stx::ParseNode</a> objects. During the construction of the <a class="el" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">stx::ParseNode</a> objects all constant subtrees are folded into constant objects. This way repeated evaluation of the ParseTree is accelerated. At the end the top <a class="el" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">stx::ParseNode</a> is returned in a <a class="el" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">stx::ParseTree</a> enclosure.<p>
The <a class="el" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">stx::ParseTree</a>'s main method is <a class="el" href="classstx_1_1ParseTree.html#8fad810eb5af360f69e2624a53f678fb">evaluate()</a>, which takes a <a class="el" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">stx::SymbolTable</a> and recursively evaluates the contained <a class="el" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">stx::ParseNode</a> tree using the variable and functions contained in the symbol table. The result is returned as an <a class="el" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> object.<h3><a class="anchor" name="subsec_further">
Further Details</a></h3>
After this abstract design discussion it is probably best to read the first <a class="el" href="example_exprcalc.html">Example Application: Simple Expression Calculator</a>. It contains a comprehensible walk-through of the libraries interface function and classes.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Timo Bingmann </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>2007-07-17 </dd></dl>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jul 17 16:51:58 2007 for STX Expression Parser by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
