<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>STX Expression Parser: Example Application: CSV-File Record Filter</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="example_csvfilter">Example Application: CSV-File Record Filter</a></h1>The second example is a CSV-file filter.<p>
It will read a tab-delimited csv data file with column headers and apply the given filter expression to each line. Each line is taken as a record of variables named by the column header. For each line the expression is evaluated and if it returns a "true" boolean value, then the line is copied to the output; if it returns a "false" boolean, the line is skipped. In case the expression value is not a boolean, the value is printed on stderr.<p>
This example program is not supposed to be an "industrial-strength" CSV file parser. It cannot handle escaped delimiters or quoted fields. Beware to use it directly on Excel-generated files.<h2><a class="anchor" name="sec_exdata">
CSV sample files</a></h2>
The distribution contains three sample CSV files for the csvfilter. Two are taken from MySQL's world sample database, which can be found at <a href="http://dev.mysql.com/doc/world-setup/en/world-setup.html">http://dev.mysql.com/doc/world-setup/en/world-setup.html</a> . The data contained in the world database is originally Copyright Statistics Finland, <a href="http://www.stat.fi/worldinfigures">http://www.stat.fi/worldinfigures</a> . The third CSV dataset contains some key statistic features extracted from the CIA World Factbook (<a href="https://www.cia.gov/library/publications/the-world-factbook/">https://www.cia.gov/library/publications/the-world-factbook/</a>).<p>
The mysql-world-city.csv file starts like this:<p>
<div class="fragment"><pre class="fragment">
ID	Name	CountryCode	District	Population
1	Kabul	AFG	Kabol	1780000
2	Qandahar	AFG	Qandahar	237500
3	Herat	AFG	Herat	186800
4	Mazar-e-Sharif	AFG	Balkh	127800
5	Amsterdam	NLD	Noord-Holland	731200
6	Rotterdam	NLD	Zuid-Holland	593321
7	Haag	NLD	Zuid-Holland	440900
8	Utrecht	NLD	Utrecht	234323
9	Eindhoven	NLD	Noord-Brabant	201843
10	Tilburg	NLD	Noord-Brabant	193238
...
</pre></div><p>
The csvfilter operates on tab (or otherwise) delimited input streams. The first line of the file is taken to be the column header; the header names can be used within the filter expression as variables. For each of the following data rows the expression is evaluated with variables set to the corresponding data fields.<p>
An example run of the csvfilter could be: <ul>
<li><code>./csvfilter 'Population &gt; 1000000 &amp;&amp; CountryCode = "USA"' &lt; mysql-world-city.csv</code></li>
</ul>
This will output the following debug information on stderr: <div class="fragment"><pre class="fragment">
Expression string: Population &gt; 1000000 &amp;&amp; CountryCode = "USA"
Parsed expression: ((Population &gt; 1000000) &amp;&amp; (CountryCode = "USA"))
Reading CSV column headers from input
Read 5 column headers.
Processed 4079 lines, copied 9 and skipped 4070 lines
</pre></div><p>
and the filtered CSV lines on stdout: <div class="fragment"><pre class="fragment">
ID      Name    CountryCode     District        Population
3793    New York        USA     New York        8008278
3794    Los Angeles     USA     California      3694820
3795    Chicago USA     Illinois        2896016
3796    Houston USA     Texas   1953631
3797    Philadelphia    USA     Pennsylvania    1517550
3798    Phoenix USA     Arizona 1321045
3799    San Diego       USA     California      1223400
3800    Dallas  USA     Texas   1188580
3801    San Antonio     USA     Texas   1144646
</pre></div><h2><a class="anchor" name="sec1">
Detailed Example Code Guide</a></h2>
<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="ExpressionParser_8h.html" title="Definition of a the public interface of the STX Expression Parser.">ExpressionParser.h</a>"</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;map&gt;</span>
</pre></div><p>
First we include the file <a class="el" href="ExpressionParser_8h.html" title="Definition of a the public interface of the STX Expression Parser.">ExpressionParser.h</a>, which contains the required classes, and four Standard Template Library files.<p>
<div class="fragment"><pre class="fragment">
<span class="comment">// use this as the delimiter. this can be changed to ';' or ',' if needed</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> delimiter = <span class="charliteral">'\t'</span>;
</pre></div><p>
The example program uses this constant as the delimiter character. It may be changed if required.<p>
<div class="fragment"><pre class="fragment">
<span class="comment">// read one line from instream and split it into tab (or otherwise) delimited</span>
<span class="comment">// columns. returns the number of columns read, 0 if eof.</span>
<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> read_csvline(std::istream &amp;instream,
                          std::vector&lt;std::string&gt; &amp;columns)
{
    columns.clear();

    <span class="comment">// read one line from the input stream</span>
    std::string line;
    <span class="keywordflow">if</span> (!std::getline(instream, line, <span class="charliteral">'\n'</span>).good()) {
        <span class="keywordflow">return</span> 0;
    }

    <span class="comment">// parse line into tab separated columns, start with inital column</span>
    columns.push_back(<span class="stringliteral">""</span>);

    <span class="keywordflow">for</span> (std::string::const_iterator si = line.begin();
         si != line.end(); ++si)
    {
        <span class="keywordflow">if</span> (*si == delimiter)
            columns.push_back(<span class="stringliteral">""</span>);
        <span class="keywordflow">else</span> <span class="comment">// add non-delimiter to last column</span>
            columns.back() += *si;
    }

    <span class="keywordflow">return</span> columns.size();
}
</pre></div><p>
As state above this example program is not supposed to be an "industrial-strength" CSV file reader. The above function reads one line for the input file stream and splits it into a std::vector of field strings. No escaped delimiters or quoted fields are recognized.<p>
<div class="fragment"><pre class="fragment">
<span class="comment">// subclass stx::BasicSymbolTable and return variable values from the current</span>
<span class="comment">// csv row. the variable names are defined by the map containing the column</span>
<span class="comment">// header.</span>
<span class="keyword">class </span>CSVRowSymbolTable : <span class="keyword">public</span> stx::BasicSymbolTable
{
<span class="keyword">public</span>:
    <span class="comment">// maps the column variable name to the vector index</span>
    <span class="keyword">const</span> std::map&lt;std::string, unsigned int&gt; &amp;headersmap;

    <span class="comment">// refernce to the reused data row vector.</span>
    <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;datacolumns;

    CSVRowSymbolTable(<span class="keyword">const</span> std::map&lt;std::string, unsigned int&gt; &amp;_headersmap,
                      <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;_datacolumns)
        : stx::BasicSymbolTable(),
          headersmap(_headersmap),
          datacolumns(_datacolumns)
    {
    }

    <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> lookupVariable(<span class="keyword">const</span> std::string &amp;varname)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="comment">// look if the variable name is defined by the CSV file</span>
        std::map&lt;std::string, unsigned int&gt;::const_iterator
            varfind = headersmap.find(varname);

        <span class="keywordflow">if</span> (varfind == headersmap.end()) {
            <span class="comment">// if not, let BasicSymbolTable check if it knows it</span>
            <span class="keywordflow">return</span> <a class="code" href="classstx_1_1BasicSymbolTable.html#20f5e9a9dd0d6fd647261265b07e8259" title="Return the (constant) value of a variable.">stx::BasicSymbolTable::lookupVariable</a>(varname);
        }

        <span class="comment">// return the variable value from the current vector. convert it to a</span>
        <span class="comment">// stx::AnyScalar but use the automatic type recognition for input</span>
        <span class="comment">// strings.</span>
        <span class="keywordflow">if</span>(varfind-&gt;second &lt; datacolumns.size())
        {
            <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a>().setAutoString( datacolumns[varfind-&gt;second] );
        }
        <span class="keywordflow">else</span>
        {
            <span class="keywordflow">return</span> <span class="stringliteral">""</span>;  <span class="comment">// happens when a data row has too few delimited</span>
                        <span class="comment">// fields.</span>
        }
    }
};
</pre></div><p>
This is the main meat of the example: the CSVRowSymbolTable is subclassed from <a class="el" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">stx::BasicSymbolTable</a>. This symbol table is used to represent the possible variables in the expression formula. It is constructed from the header row of the CSV file and a vector containing the current data row. However the symbol table object only contains references to the actual vector and map. This way the main program will be able to modify the data row and re-evaluate the parse tree using the new row.<p>
The idea behind this set up is to minimize the number of times the input CSV data fields are copied: the vector containing the string fields is filled once and then only referenced via the symbol table object if the variable is actually used.<p>
Another way to implement the symbol table would be to used an <a class="el" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">stx::BasicSymbolTable</a> and set the variables using <a class="el" href="classstx_1_1BasicSymbolTable.html#69cc26322a17a19a3fec86c866afd5fe">setVariable()</a>. However this would be much slower than the reference symbol table approach shown above.<p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// collect expression by joining all remaining input arguments</span>
    std::string args;
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; argc; i++) {
        <span class="keywordflow">if</span> (!args.empty()) args += <span class="stringliteral">" "</span>;
        args += argv[i];
    }

    std::cerr &lt;&lt; <span class="stringliteral">"Expression string: "</span> &lt;&lt; args &lt;&lt; <span class="stringliteral">"\n"</span>;

    <span class="comment">// parse expression into a parse tree</span>
    <a class="code" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">stx::ParseTree</a> pt;
    <span class="keywordflow">try</span>
    {
        pt = <a class="code" href="namespacestx.html#7a6901ec05156cf3aa6a60bde61f15ca" title="Parse the given input expression into a parse tree.">stx::parseExpression</a>(args);
        std::cerr &lt;&lt; <span class="stringliteral">"Parsed expression: "</span> &lt;&lt; pt.<a class="code" href="classstx_1_1ParseTree.html#d0638a2ab646e0cd68c6d371f6e33fb5" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() &lt;&lt; <span class="stringliteral">"\n"</span>;
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">stx::ExpressionParserException</a> &amp;e)
    {
        std::cerr &lt;&lt; <span class="stringliteral">"ExpressionParserException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        <span class="keywordflow">return</span> 0;
    }
</pre></div><p>
As shown in <a class="el" href="example_exprcalc.html">the first example application</a> all command line arguments are collected into a single string. Then the parser in put into action on the expression string and produces the <a class="el" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">stx::ParseTree</a>. This time the parse tree will be used multiple times.<p>
<div class="fragment"><pre class="fragment">
    <span class="comment">// read first line of CSV input as column headers</span>
    std::cerr &lt;&lt; <span class="stringliteral">"Reading CSV column headers from input\n"</span>;
    std::vector&lt;std::string&gt; headers;

    <span class="keywordflow">if</span> (read_csvline(std::cin, headers) == 0) {
        std::cerr &lt;&lt; <span class="stringliteral">"Error read column headers: no input\n"</span>;
        <span class="keywordflow">return</span> 0;
    }

    std::cerr &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; headers.size() &lt;&lt; <span class="stringliteral">" column headers.\n"</span>;

    <span class="comment">// create a header column lookup map for CSVRowSymbolTable and output the</span>
    <span class="comment">// column header line to std::cout</span>
    std::map&lt;std::string, unsigned int&gt; headersmap;
    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> headnum = 0; headnum &lt; headers.size(); ++headnum)
    {
        headersmap[ headers[headnum] ] = headnum;

        <span class="keywordflow">if</span> (headnum != 0) std::cout &lt;&lt; delimiter;
        std::cout &lt;&lt; headers[headnum];
    }
    std::cout &lt;&lt; <span class="stringliteral">"\n"</span>;
</pre></div><p>
The csvfilter reads the CSV file from the stdin stream. The first line is read and saved. It is considered to contain the column headers. This header row is inserted into the header map for faster lookup by the symbol table. The header row is also outputted to std::cout.<p>
The following loop then iterates over the data rows read from the CSV input. The symbol table is constructed only once and for each row the referenced vector "datacolumns" is refilled. Using this symbol table the parse tree is re-evaluated for each data row.<p>
The evaluation result is checked for a boolean type. In this case a filter expression was given and the row is either copied to std::cout or skipped depending on the filter's result.<p>
If the expression returned a non-boolean type, it is taken to be some calculation and the result is printed on std::cerr.<p>
<div class="fragment"><pre class="fragment">
    <span class="comment">// iterate over the data lines of the CSV input</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> linesprocessed = 0, linesskipped = 0;
    std::vector&lt;std::string&gt; datacolumns;
    CSVRowSymbolTable csvsymboltable(headersmap, datacolumns);

    <span class="keywordflow">while</span>( read_csvline(std::cin, datacolumns) &gt; 0 )
    {
        <span class="comment">// evaluate the expression for each row using the headers/datacolumns</span>
        <span class="comment">// as variables</span>
        <span class="keywordflow">try</span>
        {
            linesprocessed++;
            <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> val = pt.<a class="code" href="classstx_1_1ParseTree.html#8fad810eb5af360f69e2624a53f678fb" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>( csvsymboltable );

            <span class="keywordflow">if</span> (val.<a class="code" href="classstx_1_1AnyScalar.html#d29f046827f770eeb9639aedc3606188" title="Returns true if this object contains a boolean value.">isBooleanType</a>())
            {
                <span class="keywordflow">if</span> (!val.<a class="code" href="classstx_1_1AnyScalar.html#0d412834608517c35a72ae5660e6c00f" title="Return the value converted to a boolean.">getBoolean</a>()) {
                    linesskipped++;
                    <span class="keywordflow">continue</span>;
                }
            }
            <span class="keywordflow">else</span> {
                std::cerr &lt;&lt; <span class="stringliteral">"evaluated: "</span> &lt;&lt; val &lt;&lt; <span class="stringliteral">"\n"</span>;
            }

            <span class="comment">// output this data row to std::cout</span>
            <span class="keywordflow">for</span>(std::vector&lt;std::string&gt;::const_iterator
                    coliter = datacolumns.begin();
                coliter != datacolumns.end(); ++coliter)
            {
                <span class="keywordflow">if</span> (coliter != datacolumns.begin()) std::cout &lt;&lt; delimiter;
                std::cout &lt;&lt; *coliter;
            }
            std::cout &lt;&lt; <span class="stringliteral">"\n"</span>;
        }
        <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1UnknownSymbolException.html" title="Exception class thrown when the symbol table cannot find a variable or function.">stx::UnknownSymbolException</a> &amp;e)
        {
            std::cerr &lt;&lt; <span class="stringliteral">"evaluated: UnknownSymbolException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        }
        <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">stx::ExpressionParserException</a> &amp;e)
        {
            std::cerr &lt;&lt; <span class="stringliteral">"evaluated: ExpressionParserException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        }
    }
    std::cerr &lt;&lt; <span class="stringliteral">"Processed "</span> &lt;&lt; linesprocessed &lt;&lt; <span class="stringliteral">" lines, "</span>
              &lt;&lt; <span class="stringliteral">"copied "</span> &lt;&lt; (linesprocessed - linesskipped) &lt;&lt; <span class="stringliteral">" and "</span>
              &lt;&lt; <span class="stringliteral">"skipped "</span> &lt;&lt; linesskipped &lt;&lt; <span class="stringliteral">" lines"</span> &lt;&lt; <span class="stringliteral">"\n"</span>;
}
</pre></div><h2><a class="anchor" name="sec1_complete">
Complete Example Source Code</a></h2>
The example can be found in the distribution in examples/csvfilter/. That directory also contains three CSV files to test the csvfilter: mysql-world-city.csv, mysql-world-country.csv and cia-world-factbook.csv<p>
<div class="fragment"><pre class="fragment"><span class="comment">// $Id: csvfilter.cc 59 2007-07-17 14:43:23Z tb $</span>

<span class="comment">/*</span>
<span class="comment"> * STX Expression Parser C++ Framework v0.7</span>
<span class="comment"> * Copyright (C) 2007 Timo Bingmann</span>
<span class="comment"> *</span>
<span class="comment"> * This library is free software; you can redistribute it and/or modify it</span>
<span class="comment"> * under the terms of the GNU Lesser General Public License as published by the</span>
<span class="comment"> * Free Software Foundation; either version 2.1 of the License, or (at your</span>
<span class="comment"> * option) any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This library is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License</span>
<span class="comment"> * for more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU Lesser General Public License</span>
<span class="comment"> * along with this library; if not, write to the Free Software Foundation,</span>
<span class="comment"> * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="comment"> */</span>

<span class="comment">// CSV Parser and Filter using the Expression Parser</span>
 
<span class="preprocessor">#include "<a class="code" href="ExpressionParser_8h.html" title="Definition of a the public interface of the STX Expression Parser.">ExpressionParser.h</a>"</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;map&gt;</span>

<span class="comment">// use this as the delimiter. this can be changed to ';' or ',' if needed</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> delimiter = <span class="charliteral">'\t'</span>;

<span class="comment">// read one line from instream and split it into tab (or otherwise) delimited</span>
<span class="comment">// columns. returns the number of columns read, 0 if eof.</span>
<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> read_csvline(std::istream &amp;instream,
                          std::vector&lt;std::string&gt; &amp;columns)
{
    columns.clear();

    <span class="comment">// read one line from the input stream</span>
    std::string line;
    <span class="keywordflow">if</span> (!std::getline(instream, line, <span class="charliteral">'\n'</span>).good()) {
        <span class="keywordflow">return</span> 0;
    }

    <span class="comment">// parse line into tab separated columns, start with inital column</span>
    columns.push_back(<span class="stringliteral">""</span>);

    <span class="keywordflow">for</span> (std::string::const_iterator si = line.begin();
         si != line.end(); ++si)
    {
        <span class="keywordflow">if</span> (*si == delimiter)
            columns.push_back(<span class="stringliteral">""</span>);
        <span class="keywordflow">else</span> <span class="comment">// add non-delimiter to last column</span>
            columns.back() += *si;
    }

    <span class="keywordflow">return</span> columns.size();
}

<span class="comment">// subclass stx::BasicSymbolTable and return variable values from the current</span>
<span class="comment">// csv row. the variable names are defined by the map containing the column</span>
<span class="comment">// header.</span>
<span class="keyword">class </span>CSVRowSymbolTable : <span class="keyword">public</span> stx::BasicSymbolTable
{
<span class="keyword">public</span>:
    <span class="comment">// maps the column variable name to the vector index</span>
    <span class="keyword">const</span> std::map&lt;std::string, unsigned int&gt; &amp;headersmap;

    <span class="comment">// refernce to the reused data row vector.</span>
    <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;datacolumns;

    CSVRowSymbolTable(<span class="keyword">const</span> std::map&lt;std::string, unsigned int&gt; &amp;_headersmap,
                      <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;_datacolumns)
        : stx::BasicSymbolTable(),
          headersmap(_headersmap),
          datacolumns(_datacolumns)
    {
    }

    <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> lookupVariable(<span class="keyword">const</span> std::string &amp;varname)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="comment">// look if the variable name is defined by the CSV file</span>
        std::map&lt;std::string, unsigned int&gt;::const_iterator
            varfind = headersmap.find(varname);

        <span class="keywordflow">if</span> (varfind == headersmap.end()) {
            <span class="comment">// if not, let BasicSymbolTable check if it knows it</span>
            <span class="keywordflow">return</span> <a class="code" href="classstx_1_1BasicSymbolTable.html#20f5e9a9dd0d6fd647261265b07e8259" title="Return the (constant) value of a variable.">stx::BasicSymbolTable::lookupVariable</a>(varname);
        }

        <span class="comment">// return the variable value from the current vector. convert it to a</span>
        <span class="comment">// stx::AnyScalar but use the automatic type recognition for input</span>
        <span class="comment">// strings.</span>
        <span class="keywordflow">if</span>(varfind-&gt;second &lt; datacolumns.size())
        {
            <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a>().setAutoString( datacolumns[varfind-&gt;second] );
        }
        <span class="keywordflow">else</span>
        {
            <span class="keywordflow">return</span> <span class="stringliteral">""</span>;  <span class="comment">// happens when a data row has too few delimited</span>
                        <span class="comment">// fields.</span>
        }
    }
};

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// collect expression by joining all remaining input arguments</span>
    std::string args;
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; argc; i++) {
        <span class="keywordflow">if</span> (!args.empty()) args += <span class="stringliteral">" "</span>;
        args += argv[i];
    }

    std::cerr &lt;&lt; <span class="stringliteral">"Expression string: "</span> &lt;&lt; args &lt;&lt; <span class="stringliteral">"\n"</span>;

    <span class="comment">// parse expression into a parse tree</span>
    <a class="code" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">stx::ParseTree</a> pt;
    <span class="keywordflow">try</span>
    {
        pt = <a class="code" href="namespacestx.html#7a6901ec05156cf3aa6a60bde61f15ca" title="Parse the given input expression into a parse tree.">stx::parseExpression</a>(args);
        std::cerr &lt;&lt; <span class="stringliteral">"Parsed expression: "</span> &lt;&lt; pt.<a class="code" href="classstx_1_1ParseTree.html#d0638a2ab646e0cd68c6d371f6e33fb5" title="Return the parsed expression as a string, which can be parsed again.">toString</a>() &lt;&lt; <span class="stringliteral">"\n"</span>;
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">stx::ExpressionParserException</a> &amp;e)
    {
        std::cerr &lt;&lt; <span class="stringliteral">"ExpressionParserException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        <span class="keywordflow">return</span> 0;
    }

    <span class="comment">// read first line of CSV input as column headers</span>
    std::cerr &lt;&lt; <span class="stringliteral">"Reading CSV column headers from input\n"</span>;
    std::vector&lt;std::string&gt; headers;

    <span class="keywordflow">if</span> (read_csvline(std::cin, headers) == 0) {
        std::cerr &lt;&lt; <span class="stringliteral">"Error read column headers: no input\n"</span>;
        <span class="keywordflow">return</span> 0;
    }

    std::cerr &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; headers.size() &lt;&lt; <span class="stringliteral">" column headers.\n"</span>;

    <span class="comment">// create a header column lookup map for CSVRowSymbolTable and output the</span>
    <span class="comment">// column header line to std::cout</span>
    std::map&lt;std::string, unsigned int&gt; headersmap;
    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> headnum = 0; headnum &lt; headers.size(); ++headnum)
    {
        headersmap[ headers[headnum] ] = headnum;

        <span class="keywordflow">if</span> (headnum != 0) std::cout &lt;&lt; delimiter;
        std::cout &lt;&lt; headers[headnum];
    }
    std::cout &lt;&lt; <span class="stringliteral">"\n"</span>;

    <span class="comment">// iterate over the data lines of the CSV input</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> linesprocessed = 0, linesskipped = 0;
    std::vector&lt;std::string&gt; datacolumns;
    CSVRowSymbolTable csvsymboltable(headersmap, datacolumns);

    <span class="keywordflow">while</span>( read_csvline(std::cin, datacolumns) &gt; 0 )
    {
        <span class="comment">// evaluate the expression for each row using the headers/datacolumns</span>
        <span class="comment">// as variables</span>
        <span class="keywordflow">try</span>
        {
            linesprocessed++;
            <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> val = pt.<a class="code" href="classstx_1_1ParseTree.html#8fad810eb5af360f69e2624a53f678fb" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>( csvsymboltable );

            <span class="keywordflow">if</span> (val.<a class="code" href="classstx_1_1AnyScalar.html#d29f046827f770eeb9639aedc3606188" title="Returns true if this object contains a boolean value.">isBooleanType</a>())
            {
                <span class="keywordflow">if</span> (!val.<a class="code" href="classstx_1_1AnyScalar.html#0d412834608517c35a72ae5660e6c00f" title="Return the value converted to a boolean.">getBoolean</a>()) {
                    linesskipped++;
                    <span class="keywordflow">continue</span>;
                }
            }
            <span class="keywordflow">else</span> {
                std::cerr &lt;&lt; <span class="stringliteral">"evaluated: "</span> &lt;&lt; val &lt;&lt; <span class="stringliteral">"\n"</span>;
            }

            <span class="comment">// output this data row to std::cout</span>
            <span class="keywordflow">for</span>(std::vector&lt;std::string&gt;::const_iterator
                    coliter = datacolumns.begin();
                coliter != datacolumns.end(); ++coliter)
            {
                <span class="keywordflow">if</span> (coliter != datacolumns.begin()) std::cout &lt;&lt; delimiter;
                std::cout &lt;&lt; *coliter;
            }
            std::cout &lt;&lt; <span class="stringliteral">"\n"</span>;
        }
        <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1UnknownSymbolException.html" title="Exception class thrown when the symbol table cannot find a variable or function.">stx::UnknownSymbolException</a> &amp;e)
        {
            std::cerr &lt;&lt; <span class="stringliteral">"evaluated: UnknownSymbolException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        }
        <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">stx::ExpressionParserException</a> &amp;e)
        {
            std::cerr &lt;&lt; <span class="stringliteral">"evaluated: ExpressionParserException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        }
    }
    std::cerr &lt;&lt; <span class="stringliteral">"Processed "</span> &lt;&lt; linesprocessed &lt;&lt; <span class="stringliteral">" lines, "</span>
              &lt;&lt; <span class="stringliteral">"copied "</span> &lt;&lt; (linesprocessed - linesskipped) &lt;&lt; <span class="stringliteral">" and "</span>
              &lt;&lt; <span class="stringliteral">"skipped "</span> &lt;&lt; linesskipped &lt;&lt; <span class="stringliteral">" lines"</span> &lt;&lt; <span class="stringliteral">"\n"</span>;
}
</pre></div> <hr size="1"><address style="text-align: right;"><small>Generated on Tue Jul 17 16:51:58 2007 for STX Expression Parser by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
