<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>STX Expression Parser: libstx-exparser/ExpressionParser.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>libstx-exparser/ExpressionParser.h</h1><a href="ExpressionParser_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// $Id: ExpressionParser.h 59 2007-07-17 14:43:23Z tb $</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="comment">/*</span>
<a name="l00004"></a>00004 <span class="comment"> * STX Expression Parser C++ Framework v0.7</span>
<a name="l00005"></a>00005 <span class="comment"> * Copyright (C) 2007 Timo Bingmann</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * This library is free software; you can redistribute it and/or modify it</span>
<a name="l00008"></a>00008 <span class="comment"> * under the terms of the GNU Lesser General Public License as published by the</span>
<a name="l00009"></a>00009 <span class="comment"> * Free Software Foundation; either version 2.1 of the License, or (at your</span>
<a name="l00010"></a>00010 <span class="comment"> * option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> * This library is distributed in the hope that it will be useful, but WITHOUT</span>
<a name="l00013"></a>00013 <span class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<a name="l00014"></a>00014 <span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License</span>
<a name="l00015"></a>00015 <span class="comment"> * for more details.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> * You should have received a copy of the GNU Lesser General Public License</span>
<a name="l00018"></a>00018 <span class="comment"> * along with this library; if not, write to the Free Software Foundation,</span>
<a name="l00019"></a>00019 <span class="comment"> * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</span>
<a name="l00020"></a>00020 <span class="comment"> */</span>
<a name="l00021"></a>00021 
<a name="l00028"></a>00028 <span class="preprocessor">#ifndef _STX_ExpressionParser_H_</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#define _STX_ExpressionParser_H_</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;boost/smart_ptr.hpp&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include "<a class="code" href="AnyScalar_8h.html" title="Definition of a typed scalar value class AnyScalar used by the parser to represent...">AnyScalar.h</a>"</span>
<a name="l00037"></a>00037 
<a name="l00039"></a>00039 <span class="keyword">namespace </span>stx {
<a name="l00040"></a>00040 
<a name="l00043"></a><a class="code" href="classstx_1_1ExpressionParserException.html">00043</a> <span class="keyword">class </span><a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a> : <span class="keyword">public</span> std::runtime_error
<a name="l00044"></a>00044 {
<a name="l00045"></a>00045 <span class="keyword">public</span>:
<a name="l00047"></a><a class="code" href="classstx_1_1ExpressionParserException.html#f5cda56ede07c8c5b5272ac74a0fed18">00047</a>     <span class="keyword">inline</span> <a class="code" href="classstx_1_1ExpressionParserException.html#f5cda56ede07c8c5b5272ac74a0fed18" title="Construct with a description string.">ExpressionParserException</a>(<span class="keyword">const</span> std::string &amp;s) <span class="keywordflow">throw</span>()
<a name="l00048"></a>00048         : std::runtime_error(s)
<a name="l00049"></a>00049     { }
<a name="l00050"></a>00050 };
<a name="l00051"></a>00051 
<a name="l00055"></a><a class="code" href="classstx_1_1ConversionException.html">00055</a> <span class="keyword">class </span><a class="code" href="classstx_1_1ConversionException.html" title="ConversionException is an exception class thrown by some combinations of get and...">ConversionException</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a>
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057 <span class="keyword">public</span>:
<a name="l00059"></a><a class="code" href="classstx_1_1ConversionException.html#41b8a59a5a48274f8f4143646ce665ef">00059</a>     <span class="keyword">inline</span> <a class="code" href="classstx_1_1ConversionException.html" title="ConversionException is an exception class thrown by some combinations of get and...">ConversionException</a>(<span class="keyword">const</span> std::string &amp;s) <span class="keywordflow">throw</span>()
<a name="l00060"></a>00060         : <a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a>(s)
<a name="l00061"></a>00061     { }
<a name="l00062"></a>00062 };
<a name="l00063"></a>00063 
<a name="l00067"></a><a class="code" href="classstx_1_1ArithmeticException.html">00067</a> <span class="keyword">class </span><a class="code" href="classstx_1_1ArithmeticException.html" title="ArithmeticException is an exception class thrown upon some arithmetic errors like...">ArithmeticException</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a>
<a name="l00068"></a>00068 {
<a name="l00069"></a>00069 <span class="keyword">public</span>:
<a name="l00071"></a><a class="code" href="classstx_1_1ArithmeticException.html#0fd720773043e577eb378c5309ec931a">00071</a>     <span class="keyword">inline</span> <a class="code" href="classstx_1_1ArithmeticException.html" title="ArithmeticException is an exception class thrown upon some arithmetic errors like...">ArithmeticException</a>(<span class="keyword">const</span> std::string &amp;s) <span class="keywordflow">throw</span>()
<a name="l00072"></a>00072         : <a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a>(s)
<a name="l00073"></a>00073     { }
<a name="l00074"></a>00074 };
<a name="l00075"></a>00075 
<a name="l00079"></a><a class="code" href="classstx_1_1BadSyntaxException.html">00079</a> <span class="keyword">class </span><a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a>
<a name="l00080"></a>00080 {
<a name="l00081"></a>00081 <span class="keyword">public</span>:
<a name="l00083"></a><a class="code" href="classstx_1_1BadSyntaxException.html#0f7ef23563a91ee7ab1fa762e22839fe">00083</a>     <span class="keyword">inline</span> <a class="code" href="classstx_1_1BadSyntaxException.html" title="Exception class thrown when the parser recognizes a syntax error.">BadSyntaxException</a>(<span class="keyword">const</span> std::string &amp;s) <span class="keywordflow">throw</span>()
<a name="l00084"></a>00084         : <a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a>(s)
<a name="l00085"></a>00085     { }
<a name="l00086"></a>00086 };
<a name="l00087"></a>00087 
<a name="l00091"></a><a class="code" href="classstx_1_1UnknownSymbolException.html">00091</a> <span class="keyword">class </span><a class="code" href="classstx_1_1UnknownSymbolException.html" title="Exception class thrown when the symbol table cannot find a variable or function.">UnknownSymbolException</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a>
<a name="l00092"></a>00092 {
<a name="l00093"></a>00093 <span class="keyword">public</span>:
<a name="l00095"></a><a class="code" href="classstx_1_1UnknownSymbolException.html#2bc1bec95e89997fdf59bbae1105e659">00095</a>     <span class="keyword">inline</span> <a class="code" href="classstx_1_1UnknownSymbolException.html" title="Exception class thrown when the symbol table cannot find a variable or function.">UnknownSymbolException</a>(<span class="keyword">const</span> std::string &amp;s) <span class="keywordflow">throw</span>()
<a name="l00096"></a>00096         : <a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a>(s)
<a name="l00097"></a>00097     { }
<a name="l00098"></a>00098 };
<a name="l00099"></a>00099 
<a name="l00103"></a><a class="code" href="classstx_1_1BadFunctionCallException.html">00103</a> <span class="keyword">class </span><a class="code" href="classstx_1_1BadFunctionCallException.html" title="Exception class thrown when the symbol table cannot correctly execute a function...">BadFunctionCallException</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a>
<a name="l00104"></a>00104 {
<a name="l00105"></a>00105 <span class="keyword">public</span>:
<a name="l00107"></a><a class="code" href="classstx_1_1BadFunctionCallException.html#0b30f0c6deab4810782165d695820359">00107</a>     <span class="keyword">inline</span> <a class="code" href="classstx_1_1BadFunctionCallException.html" title="Exception class thrown when the symbol table cannot correctly execute a function...">BadFunctionCallException</a>(<span class="keyword">const</span> std::string &amp;s) <span class="keywordflow">throw</span>()
<a name="l00108"></a>00108         : <a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">ExpressionParserException</a>(s)
<a name="l00109"></a>00109     { }
<a name="l00110"></a>00110 };
<a name="l00111"></a>00111 
<a name="l00116"></a><a class="code" href="classstx_1_1SymbolTable.html">00116</a> <span class="keyword">class </span><a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a>
<a name="l00117"></a>00117 {
<a name="l00118"></a>00118 <span class="keyword">public</span>:
<a name="l00120"></a><a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2">00120</a>     <span class="keyword">typedef</span> std::vector&lt;AnyScalar&gt;      <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>;
<a name="l00121"></a>00121 
<a name="l00123"></a>00123     <span class="keyword">virtual</span> ~<a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a>();
<a name="l00124"></a>00124 
<a name="l00126"></a>00126     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>   lookupVariable(<span class="keyword">const</span> std::string &amp;varname) <span class="keyword">const</span> = 0;
<a name="l00127"></a>00127 
<a name="l00130"></a>00130     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>   processFunction(<span class="keyword">const</span> std::string &amp;funcname,
<a name="l00131"></a>00131                                         <span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist) <span class="keyword">const</span> = 0;
<a name="l00132"></a>00132 };
<a name="l00133"></a>00133 
<a name="l00138"></a><a class="code" href="classstx_1_1EmptySymbolTable.html">00138</a> <span class="keyword">class </span><a class="code" href="classstx_1_1EmptySymbolTable.html" title="Concrete class used for evaluation of variables and function placeholders within...">EmptySymbolTable</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a>
<a name="l00139"></a>00139 {
<a name="l00140"></a>00140 <span class="keyword">public</span>:
<a name="l00142"></a><a class="code" href="classstx_1_1EmptySymbolTable.html#afb5f0fb8a066f625b4406907233a801">00142</a>     <span class="keyword">typedef</span> std::vector&lt;AnyScalar&gt;      <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>;
<a name="l00143"></a>00143 
<a name="l00145"></a>00145     <span class="keyword">virtual</span> ~<a class="code" href="classstx_1_1EmptySymbolTable.html" title="Concrete class used for evaluation of variables and function placeholders within...">EmptySymbolTable</a>();
<a name="l00146"></a>00146 
<a name="l00149"></a>00149     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>   lookupVariable(<span class="keyword">const</span> std::string &amp;varname) <span class="keyword">const</span>;
<a name="l00150"></a>00150 
<a name="l00154"></a>00154     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>   processFunction(<span class="keyword">const</span> std::string &amp;funcname,
<a name="l00155"></a>00155                                         <span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist) <span class="keyword">const</span>;
<a name="l00156"></a>00156 };
<a name="l00157"></a>00157 
<a name="l00163"></a><a class="code" href="classstx_1_1BasicSymbolTable.html">00163</a> <span class="keyword">class </span><a class="code" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">BasicSymbolTable</a> : <span class="keyword">public</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a>
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165 <span class="keyword">public</span>:
<a name="l00167"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#c399528effc6c2e0ddceb592109b1296">00167</a>     <span class="keyword">typedef</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>   (*functionptr_type)(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>&amp; paramlist);
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="keyword">protected</span>:
<a name="l00170"></a>00170 
<a name="l00172"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#426c205aa32ed01a92803d05f9785c16">00172</a>     <span class="keyword">typedef</span> std::map&lt;std::string, AnyScalar&gt;    <a class="code" href="classstx_1_1BasicSymbolTable.html#426c205aa32ed01a92803d05f9785c16" title="Container used to save a map of variable names.">variablemap_type</a>;
<a name="l00173"></a>00173 
<a name="l00175"></a><a class="code" href="structstx_1_1BasicSymbolTable_1_1FunctionInfo.html">00175</a>     <span class="keyword">struct </span><a class="code" href="structstx_1_1BasicSymbolTable_1_1FunctionInfo.html" title="Extra info about a function: the valid arguments.">FunctionInfo</a>
<a name="l00176"></a>00176     {
<a name="l00179"></a><a class="code" href="structstx_1_1BasicSymbolTable_1_1FunctionInfo.html#5daf8131d253e6496436fe6f865ecf0c">00179</a>         <span class="keywordtype">int</span>             arguments;
<a name="l00180"></a>00180 
<a name="l00182"></a><a class="code" href="structstx_1_1BasicSymbolTable_1_1FunctionInfo.html#20e0f98d7124bda2897511da07cb8950">00182</a>         functionptr_type func;
<a name="l00183"></a>00183 
<a name="l00185"></a><a class="code" href="structstx_1_1BasicSymbolTable_1_1FunctionInfo.html#8b23b3ab08f0333c3f0f125a192896f2">00185</a>         <a class="code" href="structstx_1_1BasicSymbolTable_1_1FunctionInfo.html" title="Extra info about a function: the valid arguments.">FunctionInfo</a>(<span class="keywordtype">int</span> _arguments = 0, functionptr_type _func = NULL)
<a name="l00186"></a>00186             : arguments(_arguments), func(_func)
<a name="l00187"></a>00187         {
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189     };
<a name="l00190"></a>00190 
<a name="l00192"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#663d6ce9d28ad278c9c979b2332d4ed8">00192</a>     <span class="keyword">typedef</span> std::map&lt;std::string, struct FunctionInfo&gt;  <a class="code" href="classstx_1_1BasicSymbolTable.html#663d6ce9d28ad278c9c979b2332d4ed8" title="Container used to save a map of function names.">functionmap_type</a>;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="keyword">private</span>:
<a name="l00196"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#f96f8a293b3b1e6a731c66bcfe1a0946">00196</a>     <a class="code" href="classstx_1_1BasicSymbolTable.html#426c205aa32ed01a92803d05f9785c16" title="Container used to save a map of variable names.">variablemap_type</a>    variablemap;
<a name="l00197"></a>00197 
<a name="l00199"></a><a class="code" href="classstx_1_1BasicSymbolTable.html#4a42d56113178636da33f6515f569fd7">00199</a>     <a class="code" href="classstx_1_1BasicSymbolTable.html#663d6ce9d28ad278c9c979b2332d4ed8" title="Container used to save a map of function names.">functionmap_type</a>    functionmap;
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="keyword">protected</span>:
<a name="l00202"></a>00202     <span class="comment">// *** Lots of Standard Functions</span>
<a name="l00203"></a>00203 
<a name="l00205"></a>00205     <span class="keyword">static</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>    funcPI(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>&amp; paramlist);
<a name="l00206"></a>00206 
<a name="l00208"></a>00208     <span class="keyword">static</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>    funcSIN(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>&amp; paramlist);
<a name="l00209"></a>00209 
<a name="l00211"></a>00211     <span class="keyword">static</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>    funcCOS(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>&amp; paramlist);
<a name="l00212"></a>00212 
<a name="l00214"></a>00214     <span class="keyword">static</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>    funcTAN(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>&amp; paramlist);
<a name="l00215"></a>00215 
<a name="l00217"></a>00217     <span class="keyword">static</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>    funcABS(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>&amp; paramlist);
<a name="l00218"></a>00218 
<a name="l00220"></a>00220     <span class="keyword">static</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>    funcEXP(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>&amp; paramlist);
<a name="l00221"></a>00221 
<a name="l00223"></a>00223     <span class="keyword">static</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>    funcLOGN(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>&amp; paramlist);
<a name="l00224"></a>00224 
<a name="l00226"></a>00226     <span class="keyword">static</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>    funcPOW(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>&amp; paramlist);
<a name="l00227"></a>00227 
<a name="l00229"></a>00229     <span class="keyword">static</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>    funcSQRT(<span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a>&amp; paramlist);
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 <span class="keyword">public</span>:
<a name="l00233"></a>00233     <a class="code" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">BasicSymbolTable</a>();
<a name="l00234"></a>00234 
<a name="l00236"></a>00236     <span class="keyword">virtual</span> ~<a class="code" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">BasicSymbolTable</a>();
<a name="l00237"></a>00237 
<a name="l00240"></a>00240     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>   lookupVariable(<span class="keyword">const</span> std::string &amp;varname) <span class="keyword">const</span>;
<a name="l00241"></a>00241 
<a name="l00244"></a>00244     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>   processFunction(<span class="keyword">const</span> std::string &amp;funcname,
<a name="l00245"></a>00245                                         <span class="keyword">const</span> <a class="code" href="classstx_1_1SymbolTable.html#1d27ae61e8783e24c24a492b98b3c5a2" title="STL container type used for parameter lists: a vector.">paramlist_type</a> &amp;paramlist) <span class="keyword">const</span>;
<a name="l00246"></a>00246 
<a name="l00248"></a>00248     <span class="keywordtype">void</span>        setVariable(<span class="keyword">const</span> std::string&amp; varname, <span class="keyword">const</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> &amp;value);
<a name="l00249"></a>00249 
<a name="l00251"></a>00251     <span class="keywordtype">void</span>        setFunction(<span class="keyword">const</span> std::string&amp; funcname, <span class="keywordtype">int</span> arguments, functionptr_type funcptr);
<a name="l00252"></a>00252 
<a name="l00254"></a>00254     <span class="keywordtype">void</span>        clearVariables();
<a name="l00255"></a>00255 
<a name="l00257"></a>00257     <span class="keywordtype">void</span>        clearFunctions();
<a name="l00258"></a>00258 
<a name="l00260"></a>00260     <span class="keywordtype">void</span>        addStandardFunctions();
<a name="l00261"></a>00261 };
<a name="l00262"></a>00262 
<a name="l00267"></a><a class="code" href="classstx_1_1ParseNode.html">00267</a> <span class="keyword">class </span><a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>
<a name="l00268"></a>00268 {
<a name="l00269"></a>00269 <span class="keyword">protected</span>:
<a name="l00271"></a><a class="code" href="classstx_1_1ParseNode.html#47592a5442dcaae24661187a56d51ab8">00271</a>     <span class="keyword">inline</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>()
<a name="l00272"></a>00272     { }
<a name="l00273"></a>00273 
<a name="l00275"></a>00275     <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>(<span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a> &amp;pn);
<a name="l00276"></a>00276 
<a name="l00278"></a>00278     <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a> &amp;pn);
<a name="l00279"></a>00279     
<a name="l00280"></a>00280 <span class="keyword">public</span>:
<a name="l00283"></a><a class="code" href="classstx_1_1ParseNode.html#bec6cdedf6a879c84cb59d9a86d02715">00283</a>     <span class="keyword">virtual</span> ~<a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>()
<a name="l00284"></a>00284     {
<a name="l00285"></a>00285     }
<a name="l00286"></a>00286 
<a name="l00289"></a>00289     <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> evaluate(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;st = <a class="code" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">BasicSymbolTable</a>()) <span class="keyword">const</span> = 0;
<a name="l00290"></a>00290 
<a name="l00296"></a>00296     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> evaluate_const(<a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a> *dest) <span class="keyword">const</span> = 0;
<a name="l00297"></a>00297 
<a name="l00299"></a>00299     <span class="keyword">virtual</span> std::string toString() <span class="keyword">const</span> = 0;
<a name="l00300"></a>00300 };
<a name="l00301"></a>00301 
<a name="l00305"></a><a class="code" href="classstx_1_1ParseTree.html">00305</a> <span class="keyword">class </span><a class="code" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">ParseTree</a>
<a name="l00306"></a>00306 {
<a name="l00307"></a>00307 <span class="keyword">protected</span>:
<a name="l00310"></a><a class="code" href="classstx_1_1ParseTree.html#382d6f22685ab6a22884bf07f30f9c73">00310</a>     boost::shared_ptr&lt;ParseNode&gt;        rootnode;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 <span class="keyword">public</span>:
<a name="l00315"></a><a class="code" href="classstx_1_1ParseTree.html#8615810509eba70d85133f36fb0a13c1">00315</a>     <a class="code" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">ParseTree</a>()
<a name="l00316"></a>00316         : rootnode(static_cast&lt;<a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>*&gt;(NULL))
<a name="l00317"></a>00317     {
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319 
<a name="l00321"></a><a class="code" href="classstx_1_1ParseTree.html#2ed34085c660003456b3b82d29075196">00321</a>     <a class="code" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">ParseTree</a>(<a class="code" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a>* pt)
<a name="l00322"></a>00322         : rootnode(pt)
<a name="l00323"></a>00323     {
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325 
<a name="l00327"></a><a class="code" href="classstx_1_1ParseTree.html#ccb25574b0752c5f768e5eea0130353e">00327</a>     <span class="keyword">inline</span> <span class="keywordtype">bool</span> isEmpty()<span class="keyword"> const</span>
<a name="l00328"></a>00328 <span class="keyword">    </span>{
<a name="l00329"></a>00329         <span class="keywordflow">return</span> (rootnode.get() == NULL);
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331 
<a name="l00334"></a><a class="code" href="classstx_1_1ParseTree.html#8fad810eb5af360f69e2624a53f678fb">00334</a>     <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">AnyScalar</a>   evaluate(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;st = <a class="code" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">BasicSymbolTable</a>())<span class="keyword"> const</span>
<a name="l00335"></a>00335 <span class="keyword">    </span>{
<a name="l00336"></a>00336         assert(rootnode.get() != NULL);
<a name="l00337"></a>00337         <span class="keywordflow">return</span> rootnode-&gt;evaluate(st);
<a name="l00338"></a>00338     }
<a name="l00339"></a>00339 
<a name="l00341"></a><a class="code" href="classstx_1_1ParseTree.html#d0638a2ab646e0cd68c6d371f6e33fb5">00341</a>     std::string toString()<span class="keyword"> const</span>
<a name="l00342"></a>00342 <span class="keyword">    </span>{
<a name="l00343"></a>00343         assert(rootnode.get() != NULL);
<a name="l00344"></a>00344         <span class="keywordflow">return</span> rootnode-&gt;toString();
<a name="l00345"></a>00345     }
<a name="l00346"></a>00346 };
<a name="l00347"></a>00347 
<a name="l00350"></a>00350 <span class="keyword">const</span> ParseTree <a class="code" href="namespacestx.html#7a6901ec05156cf3aa6a60bde61f15ca" title="Parse the given input expression into a parse tree.">parseExpression</a>(<span class="keyword">const</span> std::string &amp;input);
<a name="l00351"></a>00351 
<a name="l00354"></a>00354 std::string <a class="code" href="namespacestx.html#3dc0e7ddc7370ce91c85ece0cf118ae4" title="Parse the given input expression into a parse tree.">parseExpressionXML</a>(<span class="keyword">const</span> std::string &amp;input);
<a name="l00355"></a>00355 
<a name="l00359"></a><a class="code" href="classstx_1_1ParseTreeList.html">00359</a> <span class="keyword">class </span><a class="code" href="classstx_1_1ParseTreeList.html" title="ParseTreeList contains the root parse nodes of a list of expressions.">ParseTreeList</a> : <span class="keyword">public</span> std::vector&lt;ParseTree&gt;
<a name="l00360"></a>00360 {
<a name="l00361"></a>00361 <span class="keyword">protected</span>:
<a name="l00363"></a><a class="code" href="classstx_1_1ParseTreeList.html#f23a4e372f95f38c4fb495b53ee3d3ab">00363</a>     <span class="keyword">typedef</span> std::vector&lt;ParseTree&gt;      <a class="code" href="classstx_1_1ParseTreeList.html#f23a4e372f95f38c4fb495b53ee3d3ab" title="typedef of our parent class">parent_type</a>;
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="keyword">public</span>:
<a name="l00368"></a>00368     std::vector&lt;AnyScalar&gt;      evaluate(<span class="keyword">const</span> <span class="keyword">class</span> <a class="code" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> &amp;st = <a class="code" href="classstx_1_1BasicSymbolTable.html" title="Class representing variables and functions placeholders within an expression.">BasicSymbolTable</a>()) <span class="keyword">const</span>;
<a name="l00369"></a>00369 
<a name="l00372"></a>00372     std::string toString() <span class="keyword">const</span>;
<a name="l00373"></a>00373 };
<a name="l00374"></a>00374 
<a name="l00378"></a>00378 <a class="code" href="classstx_1_1ParseTreeList.html" title="ParseTreeList contains the root parse nodes of a list of expressions.">ParseTreeList</a> <a class="code" href="namespacestx.html#5dd653f8d4b9a05ef177e5e032b40baa" title="Parse the given input as an expression list "expr1, expr2, ..." into a vector of...">parseExpressionList</a>(<span class="keyword">const</span> std::string &amp;input);
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 } <span class="comment">// namespace stx</span>
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 <span class="preprocessor">#endif // _STX_ExpressionParser_H_</span>
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Tue Jul 17 16:51:58 2007 for STX Expression Parser by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
