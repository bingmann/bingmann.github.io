<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>STX Expression Parser: stx::ParseNode Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacestx.html">stx</a>::<a class="el" href="classstx_1_1ParseNode.html">ParseNode</a></div>
<h1>stx::ParseNode Class Reference</h1><!-- doxytag: class="stx::ParseNode" --><a class="el" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a> is the abstract node interface of different parse nodes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="ExpressionParser_8h-source.html">ExpressionParser.h</a>&gt;</code>
<p>
<p>Inheritance diagram for stx::ParseNode:
<p><center><img src="classstx_1_1ParseNode.png" usemap="#stx::ParseNode_map" border="0" alt=""></center>
<map name="stx::ParseNode_map">
<area href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html" alt="stx::Grammar::PNBinaryArithmExpr" shape="rect" coords="247,56,484,80">
<area href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html" alt="stx::Grammar::PNBinaryComparisonExpr" shape="rect" coords="247,112,484,136">
<area href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html" alt="stx::Grammar::PNBinaryLogicExpr" shape="rect" coords="247,168,484,192">
<area href="classstx_1_1Grammar_1_1PNCastExpr.html" alt="stx::Grammar::PNCastExpr" shape="rect" coords="247,224,484,248">
<area href="classstx_1_1Grammar_1_1PNConstant.html" alt="stx::Grammar::PNConstant" shape="rect" coords="247,280,484,304">
<area href="classstx_1_1Grammar_1_1PNFunction.html" alt="stx::Grammar::PNFunction" shape="rect" coords="247,336,484,360">
<area href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html" alt="stx::Grammar::PNUnaryArithmExpr" shape="rect" coords="247,392,484,416">
<area href="classstx_1_1Grammar_1_1PNVariable.html" alt="stx::Grammar::PNVariable" shape="rect" coords="247,448,484,472">
</map>
<a href="classstx_1_1ParseNode-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1ParseNode.html#bec6cdedf6a879c84cb59d9a86d02715">~ParseNode</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Virtual destructor so derived classes can deallocate their children nodes.  <a href="#bec6cdedf6a879c84cb59d9a86d02715"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classstx_1_1AnyScalar.html">AnyScalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1ParseNode.html#90bed95867ee48bbefed46777aa1580b">evaluate</a> (const class <a class="el" href="classstx_1_1SymbolTable.html">SymbolTable</a> &amp;st=<a class="el" href="classstx_1_1BasicSymbolTable.html">BasicSymbolTable</a>()) const=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to recursively evaluate the contained parse tree and retrieve the calculated scalar value based on the given symbol table.  <a href="#90bed95867ee48bbefed46777aa1580b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1ParseNode.html#72b521ba0fee0abbc565e35a443dd910">evaluate_const</a> (<a class="el" href="classstx_1_1AnyScalar.html">AnyScalar</a> *dest) const=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(Internal) Function to check if the subtree evaluates to a constant expression.  <a href="#72b521ba0fee0abbc565e35a443dd910"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7a57a42525ced8566833ce5c774fedf3"></a><!-- doxytag: member="stx::ParseNode::toString" ref="7a57a42525ced8566833ce5c774fedf3" args="() const=0" -->
virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1ParseNode.html#7a57a42525ced8566833ce5c774fedf3">toString</a> () const=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the parsed expression as a string, which can be parsed again. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="47592a5442dcaae24661187a56d51ab8"></a><!-- doxytag: member="stx::ParseNode::ParseNode" ref="47592a5442dcaae24661187a56d51ab8" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1ParseNode.html#47592a5442dcaae24661187a56d51ab8">ParseNode</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Usual construction. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="07b9afc5701bc6b08d1fefe9ff7f8142"></a><!-- doxytag: member="stx::ParseNode::ParseNode" ref="07b9afc5701bc6b08d1fefe9ff7f8142" args="(const ParseNode &amp;pn)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1ParseNode.html#07b9afc5701bc6b08d1fefe9ff7f8142">ParseNode</a> (const <a class="el" href="classstx_1_1ParseNode.html">ParseNode</a> &amp;pn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable copy construction. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b9475745c6d8b861e04f4ae3a9ed243e"></a><!-- doxytag: member="stx::ParseNode::operator=" ref="b9475745c6d8b861e04f4ae3a9ed243e" args="(const ParseNode &amp;pn)" -->
<a class="el" href="classstx_1_1ParseNode.html">ParseNode</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstx_1_1ParseNode.html#b9475745c6d8b861e04f4ae3a9ed243e">operator=</a> (const <a class="el" href="classstx_1_1ParseNode.html">ParseNode</a> &amp;pn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">And disable assignment. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classstx_1_1ParseNode.html" title="ParseNode is the abstract node interface of different parse nodes.">ParseNode</a> is the abstract node interface of different parse nodes. 
<p>
From these parse nodes the the ExpressionParser constructs a tree which can be evaluated using different <a class="el" href="classstx_1_1SymbolTable.html" title="Abstract class used for evaluation of variables and function placeholders within...">SymbolTable</a> settings. 
<p>

<p>
Definition at line <a class="el" href="ExpressionParser_8h-source.html#l00267">267</a> of file <a class="el" href="ExpressionParser_8h-source.html">ExpressionParser.h</a>.<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="bec6cdedf6a879c84cb59d9a86d02715"></a><!-- doxytag: member="stx::ParseNode::~ParseNode" ref="bec6cdedf6a879c84cb59d9a86d02715" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual stx::ParseNode::~ParseNode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor so derived classes can deallocate their children nodes. 
<p>

<p>
Definition at line <a class="el" href="ExpressionParser_8h-source.html#l00283">283</a> of file <a class="el" href="ExpressionParser_8h-source.html">ExpressionParser.h</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="90bed95867ee48bbefed46777aa1580b"></a><!-- doxytag: member="stx::ParseNode::evaluate" ref="90bed95867ee48bbefed46777aa1580b" args="(const class SymbolTable &amp;st=BasicSymbolTable()) const=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classstx_1_1AnyScalar.html">AnyScalar</a> stx::ParseNode::evaluate           </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="classstx_1_1SymbolTable.html">SymbolTable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>st</em> = <code><a class="el" href="classstx_1_1BasicSymbolTable.html">BasicSymbolTable</a>()</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to recursively evaluate the contained parse tree and retrieve the calculated scalar value based on the given symbol table. 
<p>

<p>
Implemented in <a class="el" href="classstx_1_1Grammar_1_1PNConstant.html#8d09415826aa3414668ec599c6cae5b0">stx::Grammar::PNConstant</a>, <a class="el" href="classstx_1_1Grammar_1_1PNVariable.html#c14d6054cf293d902bcae8ca150a8f30">stx::Grammar::PNVariable</a>, <a class="el" href="classstx_1_1Grammar_1_1PNFunction.html#1a3c0a9b4dd3a1ec979671b21e0487f0">stx::Grammar::PNFunction</a>, <a class="el" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#409b3d3eb3ce61395b25639c5e807891">stx::Grammar::PNUnaryArithmExpr</a>, <a class="el" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#bad9b3c32c8e9563050c67bcd4ba9729">stx::Grammar::PNBinaryArithmExpr</a>, <a class="el" href="classstx_1_1Grammar_1_1PNCastExpr.html#7777631ccb4ff4d7faadb40d670c0b9d">stx::Grammar::PNCastExpr</a>, <a class="el" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#1bd4a28349c469ad1587c5d1e67f204a">stx::Grammar::PNBinaryComparisonExpr</a>, and <a class="el" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#5e00ba36af427e6cd4634087886c1359">stx::Grammar::PNBinaryLogicExpr</a>.
<p>
Referenced by <a class="el" href="ExpressionParser_8cc-source.html#l00877">stx::Grammar::PNBinaryLogicExpr::evaluate()</a>, <a class="el" href="ExpressionParser_8cc-source.html#l00731">stx::Grammar::PNBinaryComparisonExpr::evaluate()</a>, <a class="el" href="ExpressionParser_8cc-source.html#l00656">stx::Grammar::PNCastExpr::evaluate()</a>, <a class="el" href="ExpressionParser_8cc-source.html#l00574">stx::Grammar::PNBinaryArithmExpr::evaluate()</a>, and <a class="el" href="ExpressionParser_8cc-source.html#l00488">stx::Grammar::PNUnaryArithmExpr::evaluate()</a>.
</div>
</div><p>
<a class="anchor" name="72b521ba0fee0abbc565e35a443dd910"></a><!-- doxytag: member="stx::ParseNode::evaluate_const" ref="72b521ba0fee0abbc565e35a443dd910" args="(AnyScalar *dest) const=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool stx::ParseNode::evaluate_const           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstx_1_1AnyScalar.html">AnyScalar</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
(Internal) Function to check if the subtree evaluates to a constant expression. 
<p>
If dest == NULL then do a static check whether the node is always a constant (ignoring subnodes), if dest != NULL try to calculate the constant value and type recursively, thus the return value can be true for a non-constant tree node. 
<p>
Implemented in <a class="el" href="classstx_1_1Grammar_1_1PNConstant.html#a01ee7fc2b4408c526ff606822c36e77">stx::Grammar::PNConstant</a>, <a class="el" href="classstx_1_1Grammar_1_1PNVariable.html#764680d56c2e4fa358a405df0e6f9f50">stx::Grammar::PNVariable</a>, <a class="el" href="classstx_1_1Grammar_1_1PNFunction.html#3d674ea2d8e283be1ec9360bffb2a5c1">stx::Grammar::PNFunction</a>, <a class="el" href="classstx_1_1Grammar_1_1PNUnaryArithmExpr.html#3405ea16e99634277cba276f5bc5f3d3">stx::Grammar::PNUnaryArithmExpr</a>, <a class="el" href="classstx_1_1Grammar_1_1PNBinaryArithmExpr.html#12a0b0f98a8245be1436cc0d0dfc9c8a">stx::Grammar::PNBinaryArithmExpr</a>, <a class="el" href="classstx_1_1Grammar_1_1PNCastExpr.html#6a9973ff2e3511d5836f8033e2c35896">stx::Grammar::PNCastExpr</a>, <a class="el" href="classstx_1_1Grammar_1_1PNBinaryComparisonExpr.html#de3500549d846289b5496250fac20259">stx::Grammar::PNBinaryComparisonExpr</a>, and <a class="el" href="classstx_1_1Grammar_1_1PNBinaryLogicExpr.html#46ea90f790fa51cc4f338d2dbbc38250">stx::Grammar::PNBinaryLogicExpr</a>.
<p>
Referenced by <a class="el" href="ExpressionParser_8cc-source.html#l00972">stx::Grammar::build_expr()</a>, <a class="el" href="ExpressionParser_8cc-source.html#l00898">stx::Grammar::PNBinaryLogicExpr::evaluate_const()</a>, <a class="el" href="ExpressionParser_8cc-source.html#l00772">stx::Grammar::PNBinaryComparisonExpr::evaluate_const()</a>, <a class="el" href="ExpressionParser_8cc-source.html#l00664">stx::Grammar::PNCastExpr::evaluate_const()</a>, <a class="el" href="ExpressionParser_8cc-source.html#l00598">stx::Grammar::PNBinaryArithmExpr::evaluate_const()</a>, and <a class="el" href="ExpressionParser_8cc-source.html#l00511">stx::Grammar::PNUnaryArithmExpr::evaluate_const()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>libstx-exparser/<a class="el" href="ExpressionParser_8h-source.html">ExpressionParser.h</a></ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jul 17 16:51:58 2007 for STX Expression Parser by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
