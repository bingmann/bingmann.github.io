<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>STX Expression Parser: Example Application: Enhanced CSV-File Record Filter and Sorter</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="example_csvtool">Example Application: Enhanced CSV-File Record Filter and Sorter</a></h1>The csvtool example program is an extended version of the <a class="el" href="example_csvfilter.html">csvfilter</a> program.<p>
It buffers all matching lines from the csv after evaluation of the filter. This buffered table is then sorted using a "natural sort" relation and outputted to stdout. Offset and limit of the outputted region can be given.<p>
This tool is used on the expression parser's web site for an Online CSV Filter Demo: <a href="http://idlebox.net/2007/stx-exparser/csvfilter.htt">http://idlebox.net/2007/stx-exparser/csvfilter.htt</a><h2><a class="anchor" name="sec1_complete">
Complete Example Source Code</a></h2>
<div class="fragment"><pre class="fragment"><span class="comment">// $Id: csvtool.cc 59 2007-07-17 14:43:23Z tb $</span>

<span class="comment">/*</span>
<span class="comment"> * STX Expression Parser C++ Framework v0.7</span>
<span class="comment"> * Copyright (C) 2007 Timo Bingmann</span>
<span class="comment"> *</span>
<span class="comment"> * This library is free software; you can redistribute it and/or modify it</span>
<span class="comment"> * under the terms of the GNU Lesser General Public License as published by the</span>
<span class="comment"> * Free Software Foundation; either version 2.1 of the License, or (at your</span>
<span class="comment"> * option) any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This library is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License</span>
<span class="comment"> * for more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU Lesser General Public License</span>
<span class="comment"> * along with this library; if not, write to the Free Software Foundation,</span>
<span class="comment"> * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="comment"> */</span>

<span class="comment">// Enhanced CSV Parser and Filter using the Expression Parser</span>
 
<span class="preprocessor">#include "<a class="code" href="ExpressionParser_8h.html" title="Definition of a the public interface of the STX Expression Parser.">ExpressionParser.h</a>"</span>
<span class="preprocessor">#include "strnatcmp.h"</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;map&gt;</span>

<span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span>

<span class="comment">// use this as the delimiter. this can be changed to ';' or ',' if needed</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> delimiter = <span class="charliteral">'\t'</span>;

<span class="comment">// read one line from instream and split it into tab (or otherwise) delimited</span>
<span class="comment">// columns. returns the number of columns read, 0 if eof.</span>
<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> read_csvline(std::istream &amp;instream,
                          std::vector&lt;std::string&gt; &amp;columns)
{
    columns.clear();

    <span class="comment">// read one line from the input stream</span>
    std::string line;
    <span class="keywordflow">if</span> (!std::getline(instream, line, <span class="charliteral">'\n'</span>).good()) {
        <span class="keywordflow">return</span> 0;
    }

    <span class="comment">// parse line into tab separated columns, start with inital column</span>
    columns.push_back(<span class="stringliteral">""</span>);

    <span class="keywordflow">for</span> (std::string::const_iterator si = line.begin();
         si != line.end(); ++si)
    {
        <span class="keywordflow">if</span> (*si == delimiter)
            columns.push_back(<span class="stringliteral">""</span>);
        <span class="keywordflow">else</span> <span class="comment">// add non-delimiter to last column</span>
            columns.back() += *si;
    }

    <span class="keywordflow">return</span> columns.size();
}

<span class="comment">// subclass stx::BasicSymbolTable and return variable values from the current</span>
<span class="comment">// csv row. the variable names are defined by the map containing the column</span>
<span class="comment">// header.</span>
<span class="keyword">class </span>CSVRowSymbolTable : <span class="keyword">public</span> stx::BasicSymbolTable
{
<span class="keyword">public</span>:
    <span class="comment">// maps the column variable name to the vector index</span>
    <span class="keyword">const</span> std::map&lt;std::string, unsigned int&gt; &amp;headersmap;

    <span class="comment">// refernce to the reused data row vector.</span>
    <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;datacolumns;

    CSVRowSymbolTable(<span class="keyword">const</span> std::map&lt;std::string, unsigned int&gt; &amp;_headersmap,
                      <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;_datacolumns)
        : stx::BasicSymbolTable(),
          headersmap(_headersmap),
          datacolumns(_datacolumns)
    {
    }

    <span class="keyword">virtual</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> lookupVariable(<span class="keyword">const</span> std::string &amp;varname)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="comment">// look if the variable name is defined by the CSV file</span>
        std::map&lt;std::string, unsigned int&gt;::const_iterator
            varfind = headersmap.find(varname);

        <span class="keywordflow">if</span> (varfind == headersmap.end()) {
            <span class="comment">// if not, let BasicSymbolTable check if it knows it</span>
            <span class="keywordflow">return</span> <a class="code" href="classstx_1_1BasicSymbolTable.html#20f5e9a9dd0d6fd647261265b07e8259" title="Return the (constant) value of a variable.">stx::BasicSymbolTable::lookupVariable</a>(varname);
        }

        <span class="comment">// return the variable value from the current vector. convert it to a</span>
        <span class="comment">// stx::AnyScalar but use the automatic type recognition for input</span>
        <span class="comment">// strings.</span>
        <span class="keywordflow">if</span>(varfind-&gt;second &lt; datacolumns.size())
        {
            <span class="keywordflow">return</span> <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a>().setAutoString( datacolumns[varfind-&gt;second] );
        }
        <span class="keywordflow">else</span>
        {
            <span class="keywordflow">return</span> <span class="stringliteral">""</span>;  <span class="comment">// happens when a data row has too few delimited</span>
                        <span class="comment">// fields.</span>
        }
    }
};

<span class="comment">// std::sort order relation functional object</span>
<span class="keyword">struct </span>DataRecordSortRelation
{
    <span class="comment">// the column index to sort by</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sortcol;

    <span class="comment">// sort ascending or descending</span>
    <span class="keywordtype">bool</span>        descending;

    <span class="keyword">inline</span> DataRecordSortRelation(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _sortcol, <span class="keywordtype">bool</span> _descending = 0)
        : sortcol(_sortcol), descending(_descending)
    {
    }

    <span class="comment">// calls the strnatcasecmp on the given column's text or "" if the column</span>
    <span class="comment">// does not exist. sorts in "natural" sort order means numbers and text are</span>
    <span class="comment">// ordered correctly.</span>
    <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;recordA,
                           <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;recordB)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">if</span> (!descending) {
            <span class="keywordflow">return</span> strnatcasecmp(sortcol &lt; recordA.size() ? recordA[sortcol].c_str() : <span class="stringliteral">""</span>,
                                 sortcol &lt; recordB.size() ? recordB[sortcol].c_str() : <span class="stringliteral">""</span>) &lt; 0;
        }
        <span class="keywordflow">else</span> {
            <span class="keywordflow">return</span> strnatcasecmp(sortcol &lt; recordA.size() ? recordA[sortcol].c_str() : <span class="stringliteral">""</span>,
                                 sortcol &lt; recordB.size() ? recordB[sortcol].c_str() : <span class="stringliteral">""</span>) &gt; 0;
        }
    }
};

<span class="comment">// trim function from my weblog.</span>
<span class="keyword">static</span> <span class="keyword">inline</span> std::string string_trim(<span class="keyword">const</span> std::string&amp; str)
{
    std::string::size_type pos1 = str.find_first_not_of(<span class="charliteral">' '</span>);
    <span class="keywordflow">if</span> (pos1 == std::string::npos) <span class="keywordflow">return</span> std::string();

    std::string::size_type pos2 = str.find_last_not_of(<span class="charliteral">' '</span>);
    <span class="keywordflow">if</span> (pos2 == std::string::npos) <span class="keywordflow">return</span> std::string();

    <span class="keywordflow">return</span> str.substr(pos1 == std::string::npos ? 0 : pos1,
                      pos2 == std::string::npos ? (str.length() - 1) : (pos2 - pos1 + 1));
}

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// get progarm argment or reasonable defaults</span>
    <span class="keywordflow">if</span> (argc &lt; 2) {
        std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" &lt;csv-filename&gt; [filter expression] [sort-column] [offset] [limit]"</span> &lt;&lt; <span class="stringliteral">"\n"</span>;
        <span class="keywordflow">return</span> 0;
    }

    std::string csvfilename = argv[1];
    std::string exprstring = (argc &gt;= 3) ? string_trim(argv[2]) : <span class="stringliteral">""</span>;
    std::string sortcolumn = (argc &gt;= 4) ? string_trim(argv[3]) : <span class="stringliteral">""</span>;
    std::string offsetstring = (argc &gt;= 5) ? string_trim(argv[4]) : <span class="stringliteral">""</span>;
    std::string limitstring = (argc &gt;= 6) ? string_trim(argv[5]) : <span class="stringliteral">""</span>;

    <span class="comment">// parse expression into a parse tree</span>
    <a class="code" href="classstx_1_1ParseTree.html" title="ParseTree contains the root node of a parse tree.">stx::ParseTree</a> pt;
    <span class="keywordflow">try</span>
    {
        <span class="keywordflow">if</span> (exprstring.size()) {
            pt = <a class="code" href="namespacestx.html#7a6901ec05156cf3aa6a60bde61f15ca" title="Parse the given input expression into a parse tree.">stx::parseExpression</a>(exprstring);
        }
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">stx::ExpressionParserException</a> &amp;e)
    {
        std::cerr &lt;&lt; <span class="stringliteral">"ExpressionParserException: "</span> &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">"\n"</span>;
        <span class="keywordflow">return</span> 0;
    }

    <span class="comment">// open the CSV file stream, either stdin or the given filename</span>
    std::ifstream csvfilestream;
    <span class="keywordflow">if</span> (csvfilename != <span class="stringliteral">"-"</span>)
    {
        csvfilestream.open(csvfilename.c_str());
        <span class="keywordflow">if</span> (!csvfilestream) {
            std::cerr &lt;&lt; <span class="stringliteral">"Error opening CSV file "</span> &lt;&lt; csvfilename &lt;&lt; <span class="stringliteral">"\n"</span>;
            <span class="keywordflow">return</span> 0;
        }
    }

    std::istream&amp; csvfile = (csvfilename == <span class="stringliteral">"-"</span>) ? std::cin : csvfilestream;

    <span class="comment">// read first line of CSV input as column headers</span>
    std::vector&lt;std::string&gt; headers;

    <span class="keywordflow">if</span> (read_csvline(csvfile, headers) == 0) {
        std::cerr &lt;&lt; <span class="stringliteral">"Error read column headers: no input\n"</span>;
        <span class="keywordflow">return</span> 0;
    }

    <span class="comment">// create a header column lookup map for CSVRowSymbolTable </span>
    std::map&lt;std::string, unsigned int&gt; headersmap;
    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> headnum = 0; headnum &lt; headers.size(); ++headnum)
    {
        headersmap[ headers[headnum] ] = headnum;
    }

    <span class="comment">// iterate over the data lines of the CSV input and save matching data rows</span>
    <span class="comment">// into "datarecords"</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> linesprocessed = 0;
    <span class="keywordtype">bool</span> addedEvalResult = <span class="keyword">false</span>;

    std::vector&lt;std::string&gt; datacolumns;       <span class="comment">// current row</span>
    CSVRowSymbolTable csvsymboltable(headersmap, datacolumns);

    <span class="comment">// huge table containing copied rows.</span>
    std::vector&lt; std::vector&lt;std::string&gt; &gt; datarecords;

    <span class="keywordflow">while</span>( read_csvline(csvfile, datacolumns) &gt; 0 )
    {
        <span class="comment">// evaluate the expression for each row using the headers/datacolumns</span>
        <span class="comment">// as variables</span>
        <span class="keywordflow">try</span>
        {
            linesprocessed++;
            <span class="keywordflow">if</span> (!pt.<a class="code" href="classstx_1_1ParseTree.html#ccb25574b0752c5f768e5eea0130353e" title="Returns true if this object does not contain a parse tree.">isEmpty</a>())
            {
                <a class="code" href="classstx_1_1AnyScalar.html" title="AnyScalar constructs objects holding a typed scalar value.">stx::AnyScalar</a> val = pt.<a class="code" href="classstx_1_1ParseTree.html#8fad810eb5af360f69e2624a53f678fb" title="Function to recursively evaluate the contained parse tree and retrieve the calculated...">evaluate</a>( csvsymboltable );

                <span class="keywordflow">if</span> (val.<a class="code" href="classstx_1_1AnyScalar.html#d29f046827f770eeb9639aedc3606188" title="Returns true if this object contains a boolean value.">isBooleanType</a>())
                {
                    <span class="keywordflow">if</span> (!val.<a class="code" href="classstx_1_1AnyScalar.html#0d412834608517c35a72ae5660e6c00f" title="Return the value converted to a boolean.">getBoolean</a>()) <span class="keywordflow">continue</span>;
                }
                <span class="keywordflow">else</span>
                {
                    <span class="comment">// if calculation results in non-boolean value, then save</span>
                    <span class="comment">// that value into a column "EvalResult"</span>
                    <span class="keywordflow">if</span> (!addedEvalResult) {
                        headers.push_back(<span class="stringliteral">"EvalResult"</span>);
                        addedEvalResult = <span class="keyword">true</span>;
                    }

                    <span class="keywordflow">while</span>( datacolumns.size() + 1 &lt; headers.size() )
                        datacolumns.push_back(<span class="stringliteral">""</span>);
                    datacolumns.push_back(val.<a class="code" href="classstx_1_1AnyScalar.html#4cd8cd1546ba59723c31bcc592943420" title="Return the value converted to a string.">getString</a>());
                }
            }
        }
        <span class="keywordflow">catch</span> (<a class="code" href="classstx_1_1ExpressionParserException.html" title="Base class for other exceptions of the expression parser and evaluators.">stx::ExpressionParserException</a> &amp;e)
        {
            <span class="comment">// save exception text into column "EvalResult"</span>
            <span class="keywordflow">if</span> (!addedEvalResult) {
                headers.push_back(<span class="stringliteral">"EvalResult"</span>);
                addedEvalResult = <span class="keyword">true</span>;
            }
            <span class="comment">// add calculation result as last column</span>
            <span class="keywordflow">while</span>( datacolumns.size() + 1 &lt; headers.size() )
                datacolumns.push_back(<span class="stringliteral">""</span>);

            datacolumns.push_back(std::string(<span class="stringliteral">"Exception: "</span>) + e.what());
        }

        datarecords.push_back( datacolumns );
    }

    <span class="comment">// add "EvalResult" to headers map to allow sorting by it.</span>
    <span class="keywordflow">if</span> (addedEvalResult) {
        headersmap[ headers[headers.size() - 1] ] = headers.size() - 1;
    }

    <span class="comment">// sort the result table if required.</span>
    <span class="keywordflow">if</span> (sortcolumn.size())
    {
        std::map&lt;std::string, unsigned int&gt;::const_iterator
            colfind = headersmap.find(sortcolumn);

        <span class="keywordflow">if</span> (colfind != headersmap.end())
        {
            <span class="comment">// sort ascending</span>
            std::sort(datarecords.begin(), datarecords.end(),
                      DataRecordSortRelation(colfind-&gt;second));
        }
        <span class="keywordflow">else</span> 
        {
            <span class="comment">// the the sort column is !header it is sorted descending.</span>
            <span class="keywordflow">if</span> (sortcolumn[0] == <span class="charliteral">'!'</span>)
            {
                sortcolumn.erase(0, 1);
                
                colfind = headersmap.find(sortcolumn);
                <span class="keywordflow">if</span> (colfind != headersmap.end())
                {
                    std::sort(datarecords.begin(), datarecords.end(),
                              DataRecordSortRelation(colfind-&gt;second, 1));
                }
                <span class="keywordflow">else</span>
                {
                    std::cerr &lt;&lt; <span class="stringliteral">"Bad sort column: "</span> &lt;&lt; sortcolumn &lt;&lt; <span class="stringliteral">" could not be found.\n"</span>;
                    <span class="keywordflow">return</span> 0;
                }
            }
            <span class="keywordflow">else</span>
            {
                std::cerr &lt;&lt; <span class="stringliteral">"Bad sort column: "</span> &lt;&lt; sortcolumn &lt;&lt; <span class="stringliteral">" could not be found.\n"</span>;
                <span class="keywordflow">return</span> 0;
            }
        }
    }

    <span class="comment">// determine offset and limit of the outputted data rows.</span>

    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset = 0;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> limit = datarecords.size();

    <span class="keywordflow">if</span> (offsetstring.size())
    {
        <span class="keywordflow">try</span> {
            offset = boost::lexical_cast&lt;unsigned int&gt;(offsetstring);
        }
        <span class="keywordflow">catch</span> (boost::bad_lexical_cast &amp;e) {
            std::cerr &lt;&lt; <span class="stringliteral">"Bad number in offset: not an integer.\n"</span>;
            <span class="keywordflow">return</span> 0;
        }
    }

    <span class="keywordflow">if</span> (limitstring.size())
    {
        <span class="keywordflow">try</span> {
            limit = boost::lexical_cast&lt;unsigned int&gt;(limitstring);
        }
        <span class="keywordflow">catch</span> (boost::bad_lexical_cast &amp;e) {
            std::cerr &lt;&lt; <span class="stringliteral">"Bad number in limit: not an integer.\n"</span>;
            <span class="keywordflow">return</span> 0;
        }
    }

    <span class="comment">// write a processing summary to stderr</span>
    std::cerr &lt;&lt; <span class="stringliteral">"Processed "</span> &lt;&lt; linesprocessed &lt;&lt; <span class="stringliteral">" lines, "</span>
              &lt;&lt; <span class="stringliteral">"copied "</span> &lt;&lt; datarecords.size() &lt;&lt; <span class="stringliteral">" and "</span>
              &lt;&lt; <span class="stringliteral">"skipped "</span> &lt;&lt; (linesprocessed - datarecords.size()) &lt;&lt; <span class="stringliteral">" lines"</span> &lt;&lt; <span class="stringliteral">"\n"</span>;


    <span class="comment">// write column headers to stdout</span>
    <span class="keywordflow">for</span>(std::vector&lt;std::string&gt;::const_iterator coliter = headers.begin();
        coliter != headers.end(); ++coliter)
    {
        <span class="keywordflow">if</span> (coliter != headers.begin()) std::cout &lt;&lt; delimiter;
        std::cout &lt;&lt; *coliter;
    }
    std::cout &lt;&lt; <span class="stringliteral">"\n"</span>;

    <span class="comment">// output data rows from "offset" to "offset+limit"</span>

    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current = offset;
        current &lt; offset + limit &amp;&amp; current &lt; datarecords.size();
        ++current)
    {
        std::vector&lt;std::string&gt; &amp;currrecord = datarecords[current];

        <span class="comment">// output this data row to std::cout</span>
        <span class="keywordflow">for</span>(std::vector&lt;std::string&gt;::const_iterator coliter = currrecord.begin();
            coliter != currrecord.end(); ++coliter)
        {
            <span class="keywordflow">if</span> (coliter != currrecord.begin()) std::cout &lt;&lt; delimiter;
            std::cout &lt;&lt; *coliter;
        }
        std::cout &lt;&lt; <span class="stringliteral">"\n"</span>;
    }
}
</pre></div> <hr size="1"><address style="text-align: right;"><small>Generated on Tue Jul 17 16:51:58 2007 for STX Expression Parser by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
