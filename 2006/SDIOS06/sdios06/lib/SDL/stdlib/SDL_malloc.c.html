<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><meta name="viewport" content="initial-scale=1"><title>/2006/SDIOS06/sdios06/lib/SDL/stdlib/SDL_malloc.c - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="stylesheet" type="text/css" href="/css/fonts.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="http://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="http://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/js/base.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body style="background-image: url(/img/bgfractal4.jpg)"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/"><i class="icon-book"></i> Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2015/">2015</a></li><li><a href="/2014/">2014</a></li><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li class="nt"><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li><li class="ns"><a href="/search.html">Search</a></li></ul></li><li class="top"><a class="ni" href="/tags/"><i class="icon-tags"></i> Tags</a><div style="width: 14em; margin-left: -9em; margin-top: 4px"><a style="font-size: 10pt" href="/tags/algebra.html">algebra</a> <a style="font-size: 16pt" href="/tags/c++.html">c++</a> <a style="font-size: 12pt" href="/tags/code-example.html">code-example</a> <a style="font-size: 14pt" href="/tags/code-snippet.html">code-snippet</a> <a style="font-size: 11pt" href="/tags/coding_tricks.html">coding tricks</a> <a style="font-size: 10pt" href="/tags/compsci.html">compsci</a> <a style="font-size: 10pt" href="/tags/compsci_study_thesis.html">compsci study thesis</a> <a style="font-size: 9pt" href="/tags/crypto-speedtest.html">crypto-speedtest</a> <a style="font-size: 10pt" href="/tags/cryptography.html">cryptography</a> <a style="font-size: 9pt" href="/tags/cryptote.html">cryptote</a> <a style="font-size: 12pt" href="/tags/flex-bison-cpp-example.html">flex-bison-cpp-example</a> <a style="font-size: 16pt" href="/tags/frontpage.html">frontpage</a> <a style="font-size: 14pt" href="/tags/fun.html">fun</a> <a style="font-size: 10pt" href="/tags/graphviz.html">graphviz</a> <a style="font-size: 9pt" href="http://www.hmtg.de">hartmetall</a> <a style="font-size: 9pt" href="/tags/helppc.html">helppc</a> <a style="font-size: 9pt" href="/tags/hifi_selbstbau.html">hifi selbstbau</a> <a style="font-size: 10pt" href="/tags/latex.html">latex</a> <a style="font-size: 10pt" href="/tags/librivox.html">librivox</a> <a style="font-size: 10pt" href="/tags/linux.html">linux</a> <a style="font-size: 9pt" href="/tags/massive-sorting.html">massive-sorting</a> <a style="font-size: 10pt" href="/tags/maths.html">maths</a> <a style="font-size: 9pt" href="/tags/music.html">music</a> <a style="font-size: 10pt" href="/tags/netfundamentals.html">netfundamentals</a> <a style="font-size: 11pt" href="/tags/ns-3.html">ns-3</a> <a style="font-size: 10pt" href="/tags/parallel-string-sorting.html">parallel-string-sorting</a> <a style="font-size: 9pt" href="/tags/qtsqlview.html">qtsqlview</a> <a style="font-size: 13pt" href="/tags/research.html">research</a> <a style="font-size: 11pt" href="/tags/sdios06.html">sdios06</a> <a style="font-size: 9pt" href="/tags/sdlfractal.html">sdlfractal</a> <a style="font-size: 14pt" href="/tags/sorting.html">sorting</a> <a style="font-size: 10pt" href="/tags/stringology.html">stringology</a> <a style="font-size: 16pt" href="/tags/stx-btree.html">stx-btree</a> <a style="font-size: 9pt" href="/tags/stx-exparser.html">stx-exparser</a> <a style="font-size: 14pt" href="/tags/stxxl.html">stxxl</a> <a style="font-size: 16pt" href="/tags/talk.html">talk</a> <a style="font-size: 10pt" href="/tags/thrill.html">thrill</a> <a style="font-size: 10pt" href="/tags/tutorium.html">tutorium</a> <a style="font-size: 16pt" href="/tags/university.html">university</a> <a style="font-size: 13pt" href="/tags/utilities.html">utilities</a> <a style="font-size: 10pt" href="/tags/vncrec.html">vncrec</a> <a style="font-size: 9pt" href="/tags/webdesign.html">webdesign</a> </div></li><li class="top"> <a class="ni" href="#"><i class="icon-cubes"></i> Projects</a> <ul style="margin-left: -8em; margin-top: 4px;" class="nx"> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2013/parallel-string-sorting/">parallel-string-sorting</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2014/sqlplot-tools/">SqlPlotTools</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li><a href="/tags/stxxl.html">STXXL 1.4</a></li> <li class="nt"><a href="/2014/vncrec-rgb/">VNCrec RGB 0.4</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="#"><i class="icon-graduation-cap"></i> Research</a> <ul style="margin-left: -16em; margin-top: 4px" class="nx"> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP - External Memory Suffix Sorting</a></li> <li><a href="/2013/parallel-string-sorting/">Parallel String Sorting</a></li> <li><a href="/tags/massive-sorting.html">Practical Massively Parallel Sorting</a></li> <li><a href="/tags/stxxl.html">STXXL - External Memory Algorithms</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="/about/"><i class="icon-info-circled"></i> About</a> <ul style="margin-left: -6em; margin-top: 4px" class="nx"> <li><a href="/about/">Timo Bingmann</a></li> <li><a href="/about/impressum.html">Impressum</a></li> </ul></li><li class="top"> <a class="ni" href="/subscribe.html"><i class="icon-rss-squared"></i> Subscribe</a></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2006/">2006</a> / <a href="/2006/SDIOS06/">SDIOS06</a> / <a href="/2006/SDIOS06/sdios06/">sdios06</a> / <a href="/2006/SDIOS06/sdios06/lib/">lib</a> / <a href="/2006/SDIOS06/sdios06/lib/SDL/">SDL</a> / <a href="/2006/SDIOS06/sdios06/lib/SDL/stdlib/">stdlib</a> / <a href="/2006/SDIOS06/sdios06/lib/SDL/stdlib/SDL_malloc.c.html">SDL_malloc.c</a> (<a href="/2006/SDIOS06/sdios06/lib/SDL/stdlib/SDL_malloc.c">Download File</a>)</div></div><div class="ptfullwidth"><pre class="codesnippet" style="font-family: monospace"><tt><span class="comment">/*</span>
<span class="comment">    SDL - Simple DirectMedia Layer</span>
<span class="comment">    Copyright (C) 1997-2006 Sam Lantinga</span>

<span class="comment">    This library is free software; you can redistribute it and/or</span>
<span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
<span class="comment">    License as published by the Free Software Foundation; either</span>
<span class="comment">    version 2.1 of the License, or (at your option) any later version.</span>

<span class="comment">    This library is distributed in the hope that it will be useful,</span>
<span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="comment">    Lesser General Public License for more details.</span>

<span class="comment">    You should have received a copy of the GNU Lesser General Public</span>
<span class="comment">    License along with this library; if not, write to the Free Software</span>
<span class="comment">    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>

<span class="comment">    Sam Lantinga</span>
<span class="comment">    </span><span class="url">slouken@libsdl.org</span>
<span class="comment">*/</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">"SDL_config.h"</span>

<span class="comment">/* This file contains portable memory management functions for SDL */</span>

<span class="preproc">#include</span><span class="normal"> </span><span class="string">"SDL_stdinc.h"</span>

<span class="preproc">#ifndef</span><span class="normal"> HAVE_MALLOC</span>

<span class="preproc">#define</span><span class="normal"> LACKS_SYS_TYPES_H</span>
<span class="preproc">#define</span><span class="normal"> LACKS_STDIO_H</span>
<span class="preproc">#define</span><span class="normal"> LACKS_STRINGS_H</span>
<span class="preproc">#define</span><span class="normal"> LACKS_STRING_H</span>
<span class="preproc">#define</span><span class="normal"> LACKS_STDLIB_H</span>
<span class="preproc">#define</span><span class="normal"> ABORT</span>

<span class="comment">/*</span>
<span class="comment">  This is a version (aka dlmalloc) of malloc/free/realloc written by</span>
<span class="comment">  Doug Lea and released to the public domain, as explained at</span>
<span class="comment">  </span><span class="url">http://creativecommons.org/licenses/publicdomain.</span><span class="comment">  Send questions,</span>
<span class="comment">  comments, complaints, performance data, etc to </span><span class="url">dl@cs.oswego.edu</span>

<span class="comment">* Version 2.8.3 Thu Sep 22 11:16:15 2005  Doug Lea  (dl at gee)</span>

<span class="comment">   Note: There may be an updated version of this malloc obtainable at</span>
<span class="comment">           </span><span class="url">ftp://gee.cs.oswego.edu/pub/misc/malloc.c</span>
<span class="comment">         Check before installing!</span>

<span class="comment">* Quickstart</span>

<span class="comment">  This library is all in one file to simplify the most common usage:</span>
<span class="comment">  ftp it, compile it (-O3), and link it into another program. All of</span>
<span class="comment">  the compile-time options default to reasonable values for use on</span>
<span class="comment">  most platforms.  You might later want to step through various</span>
<span class="comment">  compile-time and dynamic tuning options.</span>

<span class="comment">  For convenience, an include file for code using this malloc is at:</span>
<span class="comment">     </span><span class="url">ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.3.h</span>
<span class="comment">  You don't really need this .h file unless you call functions not</span>
<span class="comment">  defined in your system include files.  The .h file contains only the</span>
<span class="comment">  excerpts from this file needed for using this malloc on ANSI C/C++</span>
<span class="comment">  systems, so long as you haven't changed compile-time options about</span>
<span class="comment">  naming and tuning parameters.  If you do, then you can create your</span>
<span class="comment">  own malloc.h that does include all settings by cutting at the point</span>
<span class="comment">  indicated below. Note that you may already by default be using a C</span>
<span class="comment">  library containing a malloc that is based on some version of this</span>
<span class="comment">  malloc (for example in linux). You might still want to use the one</span>
<span class="comment">  in this file to customize settings or to avoid overheads associated</span>
<span class="comment">  with library versions.</span>

<span class="comment">* Vital statistics:</span>

<span class="comment">  Supported pointer/size_t representation:       4 or 8 bytes</span>
<span class="comment">       size_t MUST be an unsigned type of the same width as</span>
<span class="comment">       pointers. (If you are using an ancient system that declares</span>
<span class="comment">       size_t as a signed type, or need it to be a different width</span>
<span class="comment">       than pointers, you can use a previous release of this malloc</span>
<span class="comment">       (e.g. 2.7.2) supporting these.)</span>

<span class="comment">  Alignment:                                     8 bytes (default)</span>
<span class="comment">       This suffices for nearly all current machines and C compilers.</span>
<span class="comment">       However, you can define MALLOC_ALIGNMENT to be wider than this</span>
<span class="comment">       if necessary (up to 128bytes), at the expense of using more space.</span>

<span class="comment">  Minimum overhead per allocated chunk:   4 or  8 bytes (if 4byte sizes)</span>
<span class="comment">                                          8 or 16 bytes (if 8byte sizes)</span>
<span class="comment">       Each malloced chunk has a hidden word of overhead holding size</span>
<span class="comment">       and status information, and additional cross-check word</span>
<span class="comment">       if FOOTERS is defined.</span>

<span class="comment">  Minimum allocated size: 4-byte ptrs:  16 bytes    (including overhead)</span>
<span class="comment">                          8-byte ptrs:  32 bytes    (including overhead)</span>

<span class="comment">       Even a request for zero bytes (i.e., malloc(0)) returns a</span>
<span class="comment">       pointer to something of the minimum allocatable size.</span>
<span class="comment">       The maximum overhead wastage (i.e., number of extra bytes</span>
<span class="comment">       allocated than were requested in malloc) is less than or equal</span>
<span class="comment">       to the minimum size, except for requests &gt;= mmap_threshold that</span>
<span class="comment">       are serviced via mmap(), where the worst case wastage is about</span>
<span class="comment">       32 bytes plus the remainder from a system page (the minimal</span>
<span class="comment">       mmap unit); typically 4096 or 8192 bytes.</span>

<span class="comment">  Security: static-safe; optionally more or less</span>
<span class="comment">       The "security" of malloc refers to the ability of malicious</span>
<span class="comment">       code to accentuate the effects of errors (for example, freeing</span>
<span class="comment">       space that is not currently malloc'ed or overwriting past the</span>
<span class="comment">       ends of chunks) in code that calls malloc.  This malloc</span>
<span class="comment">       guarantees not to modify any memory locations below the base of</span>
<span class="comment">       heap, i.e., static variables, even in the presence of usage</span>
<span class="comment">       errors.  The routines additionally detect most improper frees</span>
<span class="comment">       and reallocs.  All this holds as long as the static bookkeeping</span>
<span class="comment">       for malloc itself is not corrupted by some other means.  This</span>
<span class="comment">       is only one aspect of security -- these checks do not, and</span>
<span class="comment">       cannot, detect all possible programming errors.</span>

<span class="comment">       If FOOTERS is defined nonzero, then each allocated chunk</span>
<span class="comment">       carries an additional check word to verify that it was malloced</span>
<span class="comment">       from its space.  These check words are the same within each</span>
<span class="comment">       execution of a program using malloc, but differ across</span>
<span class="comment">       executions, so externally crafted fake chunks cannot be</span>
<span class="comment">       freed. This improves security by rejecting frees/reallocs that</span>
<span class="comment">       could corrupt heap memory, in addition to the checks preventing</span>
<span class="comment">       writes to statics that are always on.  This may further improve</span>
<span class="comment">       security at the expense of time and space overhead.  (Note that</span>
<span class="comment">       FOOTERS may also be worth using with MSPACES.)</span>

<span class="comment">       By default detected errors cause the program to abort (calling</span>
<span class="comment">       "abort()"). You can override this to instead proceed past</span>
<span class="comment">       errors by defining PROCEED_ON_ERROR.  In this case, a bad free</span>
<span class="comment">       has no effect, and a malloc that encounters a bad address</span>
<span class="comment">       caused by user overwrites will ignore the bad address by</span>
<span class="comment">       dropping pointers and indices to all known memory. This may</span>
<span class="comment">       be appropriate for programs that should continue if at all</span>
<span class="comment">       possible in the face of programming errors, although they may</span>
<span class="comment">       run out of memory because dropped memory is never reclaimed.</span>

<span class="comment">       If you don't like either of these options, you can define</span>
<span class="comment">       CORRUPTION_ERROR_ACTION and USAGE_ERROR_ACTION to do anything</span>
<span class="comment">       else. And if if you are sure that your program using malloc has</span>
<span class="comment">       no errors or vulnerabilities, you can define INSECURE to 1,</span>
<span class="comment">       which might (or might not) provide a small performance improvement.</span>

<span class="comment">  Thread-safety: NOT thread-safe unless USE_LOCKS defined</span>
<span class="comment">       When USE_LOCKS is defined, each public call to malloc, free,</span>
<span class="comment">       etc is surrounded with either a pthread mutex or a win32</span>
<span class="comment">       spinlock (depending on WIN32). This is not especially fast, and</span>
<span class="comment">       can be a major bottleneck.  It is designed only to provide</span>
<span class="comment">       minimal protection in concurrent environments, and to provide a</span>
<span class="comment">       basis for extensions.  If you are using malloc in a concurrent</span>
<span class="comment">       program, consider instead using ptmalloc, which is derived from</span>
<span class="comment">       a version of this malloc. (See </span><span class="url">http://www.malloc.de</span><span class="comment">).</span>

<span class="comment">  System requirements: Any combination of MORECORE and/or MMAP/MUNMAP</span>
<span class="comment">       This malloc can use unix sbrk or any emulation (invoked using</span>
<span class="comment">       the CALL_MORECORE macro) and/or mmap/munmap or any emulation</span>
<span class="comment">       (invoked using CALL_MMAP/CALL_MUNMAP) to get and release system</span>
<span class="comment">       memory.  On most unix systems, it tends to work best if both</span>
<span class="comment">       MORECORE and MMAP are enabled.  On Win32, it uses emulations</span>
<span class="comment">       based on VirtualAlloc. It also uses common C library functions</span>
<span class="comment">       like memset.</span>

<span class="comment">  Compliance: I believe it is compliant with the Single Unix Specification</span>
<span class="comment">       (See </span><span class="url">http://www.unix.org</span><span class="comment">). Also SVID/XPG, ANSI C, and probably</span>
<span class="comment">       others as well.</span>

<span class="comment">* Overview of algorithms</span>

<span class="comment">  This is not the fastest, most space-conserving, most portable, or</span>
<span class="comment">  most tunable malloc ever written. However it is among the fastest</span>
<span class="comment">  while also being among the most space-conserving, portable and</span>
<span class="comment">  tunable.  Consistent balance across these factors results in a good</span>
<span class="comment">  general-purpose allocator for malloc-intensive programs.</span>

<span class="comment">  In most ways, this malloc is a best-fit allocator. Generally, it</span>
<span class="comment">  chooses the best-fitting existing chunk for a request, with ties</span>
<span class="comment">  broken in approximately least-recently-used order. (This strategy</span>
<span class="comment">  normally maintains low fragmentation.) However, for requests less</span>
<span class="comment">  than 256bytes, it deviates from best-fit when there is not an</span>
<span class="comment">  exactly fitting available chunk by preferring to use space adjacent</span>
<span class="comment">  to that used for the previous small request, as well as by breaking</span>
<span class="comment">  ties in approximately most-recently-used order. (These enhance</span>
<span class="comment">  locality of series of small allocations.)  And for very large requests</span>
<span class="comment">  (&gt;= 256Kb by default), it relies on system memory mapping</span>
<span class="comment">  facilities, if supported.  (This helps avoid carrying around and</span>
<span class="comment">  possibly fragmenting memory used only for large chunks.)</span>

<span class="comment">  All operations (except malloc_stats and mallinfo) have execution</span>
<span class="comment">  times that are bounded by a constant factor of the number of bits in</span>
<span class="comment">  a size_t, not counting any clearing in calloc or copying in realloc,</span>
<span class="comment">  or actions surrounding MORECORE and MMAP that have times</span>
<span class="comment">  proportional to the number of non-contiguous regions returned by</span>
<span class="comment">  system allocation routines, which is often just 1.</span>

<span class="comment">  The implementation is not very modular and seriously overuses</span>
<span class="comment">  macros. Perhaps someday all C compilers will do as good a job</span>
<span class="comment">  inlining modular code as can now be done by brute-force expansion,</span>
<span class="comment">  but now, enough of them seem not to.</span>

<span class="comment">  Some compilers issue a lot of warnings about code that is</span>
<span class="comment">  dead/unreachable only on some platforms, and also about intentional</span>
<span class="comment">  uses of negation on unsigned types. All known cases of each can be</span>
<span class="comment">  ignored.</span>

<span class="comment">  For a longer but out of date high-level description, see</span>
<span class="comment">     </span><span class="url">http://gee.cs.oswego.edu/dl/html/malloc.html</span>

<span class="comment">* MSPACES</span>
<span class="comment">  If MSPACES is defined, then in addition to malloc, free, etc.,</span>
<span class="comment">  this file also defines mspace_malloc, mspace_free, etc. These</span>
<span class="comment">  are versions of malloc routines that take an "mspace" argument</span>
<span class="comment">  obtained using create_mspace, to control all internal bookkeeping.</span>
<span class="comment">  If ONLY_MSPACES is defined, only these versions are compiled.</span>
<span class="comment">  So if you would like to use this allocator for only some allocations,</span>
<span class="comment">  and your system malloc for others, you can compile with</span>
<span class="comment">  ONLY_MSPACES and then do something like...</span>
<span class="comment">    static mspace mymspace = create_mspace(0,0); // for example</span>
<span class="comment">    #define mymalloc(bytes)  mspace_malloc(mymspace, bytes)</span>

<span class="comment">  (Note: If you only need one instance of an mspace, you can instead</span>
<span class="comment">  use "USE_DL_PREFIX" to relabel the global malloc.)</span>

<span class="comment">  You can similarly create thread-local allocators by storing</span>
<span class="comment">  mspaces as thread-locals. For example:</span>
<span class="comment">    static __thread mspace tlms = 0;</span>
<span class="comment">    void*  tlmalloc(size_t bytes) {</span>
<span class="comment">      if (tlms == 0) tlms = create_mspace(0, 0);</span>
<span class="comment">      return mspace_malloc(tlms, bytes);</span>
<span class="comment">    }</span>
<span class="comment">    void  tlfree(void* mem) { mspace_free(tlms, mem); }</span>

<span class="comment">  Unless FOOTERS is defined, each mspace is completely independent.</span>
<span class="comment">  You cannot allocate from one and free to another (although</span>
<span class="comment">  conformance is only weakly checked, so usage errors are not always</span>
<span class="comment">  caught). If FOOTERS is defined, then each chunk carries around a tag</span>
<span class="comment">  indicating its originating mspace, and frees are directed to their</span>
<span class="comment">  originating spaces.</span>

<span class="comment"> -------------------------  Compile-time options ---------------------------</span>

<span class="comment">Be careful in setting #define values for numerical constants of type</span>
<span class="comment">size_t. On some systems, literal values are not automatically extended</span>
<span class="comment">to size_t precision unless they are explicitly casted.</span>

<span class="comment">WIN32                    default: defined if _WIN32 defined</span>
<span class="comment">  Defining WIN32 sets up defaults for MS environment and compilers.</span>
<span class="comment">  Otherwise defaults are for unix.</span>

<span class="comment">MALLOC_ALIGNMENT         default: (size_t)8</span>
<span class="comment">  Controls the minimum alignment for malloc'ed chunks.  It must be a</span>
<span class="comment">  power of two and at least 8, even on machines for which smaller</span>
<span class="comment">  alignments would suffice. It may be defined as larger than this</span>
<span class="comment">  though. Note however that code and data structures are optimized for</span>
<span class="comment">  the case of 8-byte alignment.</span>

<span class="comment">MSPACES                  default: 0 (false)</span>
<span class="comment">  If true, compile in support for independent allocation spaces.</span>
<span class="comment">  This is only supported if HAVE_MMAP is true.</span>

<span class="comment">ONLY_MSPACES             default: 0 (false)</span>
<span class="comment">  If true, only compile in mspace versions, not regular versions.</span>

<span class="comment">USE_LOCKS                default: 0 (false)</span>
<span class="comment">  Causes each call to each public routine to be surrounded with</span>
<span class="comment">  pthread or WIN32 mutex lock/unlock. (If set true, this can be</span>
<span class="comment">  overridden on a per-mspace basis for mspace versions.)</span>

<span class="comment">FOOTERS                  default: 0</span>
<span class="comment">  If true, provide extra checking and dispatching by placing</span>
<span class="comment">  information in the footers of allocated chunks. This adds</span>
<span class="comment">  space and time overhead.</span>

<span class="comment">INSECURE                 default: 0</span>
<span class="comment">  If true, omit checks for usage errors and heap space overwrites.</span>

<span class="comment">USE_DL_PREFIX            default: NOT defined</span>
<span class="comment">  Causes compiler to prefix all public routines with the string 'dl'.</span>
<span class="comment">  This can be useful when you only want to use this malloc in one part</span>
<span class="comment">  of a program, using your regular system malloc elsewhere.</span>

<span class="comment">ABORT                    default: defined as abort()</span>
<span class="comment">  Defines how to abort on failed checks.  On most systems, a failed</span>
<span class="comment">  check cannot die with an "assert" or even print an informative</span>
<span class="comment">  message, because the underlying print routines in turn call malloc,</span>
<span class="comment">  which will fail again.  Generally, the best policy is to simply call</span>
<span class="comment">  abort(). It's not very useful to do more than this because many</span>
<span class="comment">  errors due to overwriting will show up as address faults (null, odd</span>
<span class="comment">  addresses etc) rather than malloc-triggered checks, so will also</span>
<span class="comment">  abort.  Also, most compilers know that abort() does not return, so</span>
<span class="comment">  can better optimize code conditionally calling it.</span>

<span class="comment">PROCEED_ON_ERROR           default: defined as 0 (false)</span>
<span class="comment">  Controls whether detected bad addresses cause them to bypassed</span>
<span class="comment">  rather than aborting. If set, detected bad arguments to free and</span>
<span class="comment">  realloc are ignored. And all bookkeeping information is zeroed out</span>
<span class="comment">  upon a detected overwrite of freed heap space, thus losing the</span>
<span class="comment">  ability to ever return it from malloc again, but enabling the</span>
<span class="comment">  application to proceed. If PROCEED_ON_ERROR is defined, the</span>
<span class="comment">  static variable malloc_corruption_error_count is compiled in</span>
<span class="comment">  and can be examined to see if errors have occurred. This option</span>
<span class="comment">  generates slower code than the default abort policy.</span>

<span class="comment">DEBUG                    default: NOT defined</span>
<span class="comment">  The DEBUG setting is mainly intended for people trying to modify</span>
<span class="comment">  this code or diagnose problems when porting to new platforms.</span>
<span class="comment">  However, it may also be able to better isolate user errors than just</span>
<span class="comment">  using runtime checks.  The assertions in the check routines spell</span>
<span class="comment">  out in more detail the assumptions and invariants underlying the</span>
<span class="comment">  algorithms.  The checking is fairly extensive, and will slow down</span>
<span class="comment">  execution noticeably. Calling malloc_stats or mallinfo with DEBUG</span>
<span class="comment">  set will attempt to check every non-mmapped allocated and free chunk</span>
<span class="comment">  in the course of computing the summaries.</span>

<span class="comment">ABORT_ON_ASSERT_FAILURE   default: defined as 1 (true)</span>
<span class="comment">  Debugging assertion failures can be nearly impossible if your</span>
<span class="comment">  version of the assert macro causes malloc to be called, which will</span>
<span class="comment">  lead to a cascade of further failures, blowing the runtime stack.</span>
<span class="comment">  ABORT_ON_ASSERT_FAILURE cause assertions failures to call abort(),</span>
<span class="comment">  which will usually make debugging easier.</span>

<span class="comment">MALLOC_FAILURE_ACTION     default: sets errno to ENOMEM, or no-op on win32</span>
<span class="comment">  The action to take before "return 0" when malloc fails to be able to</span>
<span class="comment">  return memory because there is none available.</span>

<span class="comment">HAVE_MORECORE             default: 1 (true) unless win32 or ONLY_MSPACES</span>
<span class="comment">  True if this system supports sbrk or an emulation of it.</span>

<span class="comment">MORECORE                  default: sbrk</span>
<span class="comment">  The name of the sbrk-style system routine to call to obtain more</span>
<span class="comment">  memory.  See below for guidance on writing custom MORECORE</span>
<span class="comment">  functions. The type of the argument to sbrk/MORECORE varies across</span>
<span class="comment">  systems.  It cannot be size_t, because it supports negative</span>
<span class="comment">  arguments, so it is normally the signed type of the same width as</span>
<span class="comment">  size_t (sometimes declared as "intptr_t").  It doesn't much matter</span>
<span class="comment">  though. Internally, we only call it with arguments less than half</span>
<span class="comment">  the max value of a size_t, which should work across all reasonable</span>
<span class="comment">  possibilities, although sometimes generating compiler warnings.  See</span>
<span class="comment">  near the end of this file for guidelines for creating a custom</span>
<span class="comment">  version of MORECORE.</span>

<span class="comment">MORECORE_CONTIGUOUS       default: 1 (true)</span>
<span class="comment">  If true, take advantage of fact that consecutive calls to MORECORE</span>
<span class="comment">  with positive arguments always return contiguous increasing</span>
<span class="comment">  addresses.  This is true of unix sbrk. It does not hurt too much to</span>
<span class="comment">  set it true anyway, since malloc copes with non-contiguities.</span>
<span class="comment">  Setting it false when definitely non-contiguous saves time</span>
<span class="comment">  and possibly wasted space it would take to discover this though.</span>

<span class="comment">MORECORE_CANNOT_TRIM      default: NOT defined</span>
<span class="comment">  True if MORECORE cannot release space back to the system when given</span>
<span class="comment">  negative arguments. This is generally necessary only if you are</span>
<span class="comment">  using a hand-crafted MORECORE function that cannot handle negative</span>
<span class="comment">  arguments.</span>

<span class="comment">HAVE_MMAP                 default: 1 (true)</span>
<span class="comment">  True if this system supports mmap or an emulation of it.  If so, and</span>
<span class="comment">  HAVE_MORECORE is not true, MMAP is used for all system</span>
<span class="comment">  allocation. If set and HAVE_MORECORE is true as well, MMAP is</span>
<span class="comment">  primarily used to directly allocate very large blocks. It is also</span>
<span class="comment">  used as a backup strategy in cases where MORECORE fails to provide</span>
<span class="comment">  space from system. Note: A single call to MUNMAP is assumed to be</span>
<span class="comment">  able to unmap memory that may have be allocated using multiple calls</span>
<span class="comment">  to MMAP, so long as they are adjacent.</span>

<span class="comment">HAVE_MREMAP               default: 1 on linux, else 0</span>
<span class="comment">  If true realloc() uses mremap() to re-allocate large blocks and</span>
<span class="comment">  extend or shrink allocation spaces.</span>

<span class="comment">MMAP_CLEARS               default: 1 on unix</span>
<span class="comment">  True if mmap clears memory so calloc doesn't need to. This is true</span>
<span class="comment">  for standard unix mmap using /dev/zero.</span>

<span class="comment">USE_BUILTIN_FFS            default: 0 (i.e., not used)</span>
<span class="comment">  Causes malloc to use the builtin ffs() function to compute indices.</span>
<span class="comment">  Some compilers may recognize and intrinsify ffs to be faster than the</span>
<span class="comment">  supplied C version. Also, the case of x86 using gcc is special-cased</span>
<span class="comment">  to an asm instruction, so is already as fast as it can be, and so</span>
<span class="comment">  this setting has no effect. (On most x86s, the asm version is only</span>
<span class="comment">  slightly faster than the C version.)</span>

<span class="comment">malloc_getpagesize         default: derive from system includes, or 4096.</span>
<span class="comment">  The system page size. To the extent possible, this malloc manages</span>
<span class="comment">  memory from the system in page-size units.  This may be (and</span>
<span class="comment">  usually is) a function rather than a constant. This is ignored</span>
<span class="comment">  if WIN32, where page size is determined using getSystemInfo during</span>
<span class="comment">  initialization.</span>

<span class="comment">USE_DEV_RANDOM             default: 0 (i.e., not used)</span>
<span class="comment">  Causes malloc to use /dev/random to initialize secure magic seed for</span>
<span class="comment">  stamping footers. Otherwise, the current time is used.</span>

<span class="comment">NO_MALLINFO                default: 0</span>
<span class="comment">  If defined, don't compile "mallinfo". This can be a simple way</span>
<span class="comment">  of dealing with mismatches between system declarations and</span>
<span class="comment">  those in this file.</span>

<span class="comment">MALLINFO_FIELD_TYPE        default: size_t</span>
<span class="comment">  The type of the fields in the mallinfo struct. This was originally</span>
<span class="comment">  defined as "int" in SVID etc, but is more usefully defined as</span>
<span class="comment">  size_t. The value is used only if  HAVE_USR_INCLUDE_MALLOC_H is not set</span>

<span class="comment">REALLOC_ZERO_BYTES_FREES    default: not defined</span>
<span class="comment">  This should be set if a call to realloc with zero bytes should </span>
<span class="comment">  be the same as a call to free. Some people think it should. Otherwise, </span>
<span class="comment">  since this malloc returns a unique pointer for malloc(0), so does </span>
<span class="comment">  realloc(p, 0).</span>

<span class="comment">LACKS_UNISTD_H, LACKS_FCNTL_H, LACKS_SYS_PARAM_H, LACKS_SYS_MMAN_H</span>
<span class="comment">LACKS_STRINGS_H, LACKS_STRING_H, LACKS_SYS_TYPES_H,  LACKS_ERRNO_H</span>
<span class="comment">LACKS_STDLIB_H                default: NOT defined unless on WIN32</span>
<span class="comment">  Define these if your system does not have these header files.</span>
<span class="comment">  You might need to manually insert some of the declarations they provide.</span>

<span class="comment">DEFAULT_GRANULARITY        default: page size if MORECORE_CONTIGUOUS,</span>
<span class="comment">                                system_info.dwAllocationGranularity in WIN32,</span>
<span class="comment">                                otherwise 64K.</span>
<span class="comment">      Also settable using mallopt(M_GRANULARITY, x)</span>
<span class="comment">  The unit for allocating and deallocating memory from the system.  On</span>
<span class="comment">  most systems with contiguous MORECORE, there is no reason to</span>
<span class="comment">  make this more than a page. However, systems with MMAP tend to</span>
<span class="comment">  either require or encourage larger granularities.  You can increase</span>
<span class="comment">  this value to prevent system allocation functions to be called so</span>
<span class="comment">  often, especially if they are slow.  The value must be at least one</span>
<span class="comment">  page and must be a power of two.  Setting to 0 causes initialization</span>
<span class="comment">  to either page size or win32 region size.  (Note: In previous</span>
<span class="comment">  versions of malloc, the equivalent of this option was called</span>
<span class="comment">  "TOP_PAD")</span>

<span class="comment">DEFAULT_TRIM_THRESHOLD    default: 2MB</span>
<span class="comment">      Also settable using mallopt(M_TRIM_THRESHOLD, x)</span>
<span class="comment">  The maximum amount of unused top-most memory to keep before</span>
<span class="comment">  releasing via malloc_trim in free().  Automatic trimming is mainly</span>
<span class="comment">  useful in long-lived programs using contiguous MORECORE.  Because</span>
<span class="comment">  trimming via sbrk can be slow on some systems, and can sometimes be</span>
<span class="comment">  wasteful (in cases where programs immediately afterward allocate</span>
<span class="comment">  more large chunks) the value should be high enough so that your</span>
<span class="comment">  overall system performance would improve by releasing this much</span>
<span class="comment">  memory.  As a rough guide, you might set to a value close to the</span>
<span class="comment">  average size of a process (program) running on your system.</span>
<span class="comment">  Releasing this much memory would allow such a process to run in</span>
<span class="comment">  memory.  Generally, it is worth tuning trim thresholds when a</span>
<span class="comment">  program undergoes phases where several large chunks are allocated</span>
<span class="comment">  and released in ways that can reuse each other's storage, perhaps</span>
<span class="comment">  mixed with phases where there are no such chunks at all. The trim</span>
<span class="comment">  value must be greater than page size to have any useful effect.  To</span>
<span class="comment">  disable trimming completely, you can set to MAX_SIZE_T. Note that the trick</span>
<span class="comment">  some people use of mallocing a huge space and then freeing it at</span>
<span class="comment">  program startup, in an attempt to reserve system memory, doesn't</span>
<span class="comment">  have the intended effect under automatic trimming, since that memory</span>
<span class="comment">  will immediately be returned to the system.</span>

<span class="comment">DEFAULT_MMAP_THRESHOLD       default: 256K</span>
<span class="comment">      Also settable using mallopt(M_MMAP_THRESHOLD, x)</span>
<span class="comment">  The request size threshold for using MMAP to directly service a</span>
<span class="comment">  request. Requests of at least this size that cannot be allocated</span>
<span class="comment">  using already-existing space will be serviced via mmap.  (If enough</span>
<span class="comment">  normal freed space already exists it is used instead.)  Using mmap</span>
<span class="comment">  segregates relatively large chunks of memory so that they can be</span>
<span class="comment">  individually obtained and released from the host system. A request</span>
<span class="comment">  serviced through mmap is never reused by any other request (at least</span>
<span class="comment">  not directly; the system may just so happen to remap successive</span>
<span class="comment">  requests to the same locations).  Segregating space in this way has</span>
<span class="comment">  the benefits that: Mmapped space can always be individually released</span>
<span class="comment">  back to the system, which helps keep the system level memory demands</span>
<span class="comment">  of a long-lived program low.  Also, mapped memory doesn't become</span>
<span class="comment">  `locked' between other chunks, as can happen with normally allocated</span>
<span class="comment">  chunks, which means that even trimming via malloc_trim would not</span>
<span class="comment">  release them.  However, it has the disadvantage that the space</span>
<span class="comment">  cannot be reclaimed, consolidated, and then used to service later</span>
<span class="comment">  requests, as happens with normal chunks.  The advantages of mmap</span>
<span class="comment">  nearly always outweigh disadvantages for "large" chunks, but the</span>
<span class="comment">  value of "large" may vary across systems.  The default is an</span>
<span class="comment">  empirically derived value that works well in most systems. You can</span>
<span class="comment">  disable mmap by setting to MAX_SIZE_T.</span>

<span class="comment">*/</span>

<span class="preproc">#ifndef</span><span class="normal"> WIN32</span>
<span class="preproc">#ifdef</span><span class="normal"> _WIN32</span>
<span class="preproc">#define</span><span class="normal"> WIN32 </span><span class="number">1</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* _WIN32 */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* WIN32 */</span>
<span class="preproc">#ifdef</span><span class="normal"> WIN32</span>
<span class="preproc">#define</span><span class="normal"> WIN32_LEAN_AND_MEAN</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;windows.h&gt;</span>
<span class="preproc">#define</span><span class="normal"> HAVE_MMAP </span><span class="number">1</span>
<span class="preproc">#define</span><span class="normal"> HAVE_MORECORE </span><span class="number">0</span>
<span class="preproc">#define</span><span class="normal"> LACKS_UNISTD_H</span>
<span class="preproc">#define</span><span class="normal"> LACKS_SYS_PARAM_H</span>
<span class="preproc">#define</span><span class="normal"> LACKS_SYS_MMAN_H</span>
<span class="preproc">#define</span><span class="normal"> LACKS_STRING_H</span>
<span class="preproc">#define</span><span class="normal"> LACKS_STRINGS_H</span>
<span class="preproc">#define</span><span class="normal"> LACKS_SYS_TYPES_H</span>
<span class="preproc">#define</span><span class="normal"> LACKS_ERRNO_H</span>
<span class="preproc">#define</span><span class="normal"> LACKS_FCNTL_H </span>
<span class="preproc">#define</span><span class="normal"> MALLOC_FAILURE_ACTION</span>
<span class="preproc">#define</span><span class="normal"> MMAP_CLEARS </span><span class="number">0</span><span class="normal"> </span><span class="comment">/* WINCE and some others apparently don't clear */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* WIN32 */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">DARWIN</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">_DARWIN</span><span class="symbol">)</span>
<span class="comment">/* Mac OSX docs advise not to use sbrk; it seems better to use mmap */</span>
<span class="preproc">#ifndef</span><span class="normal"> HAVE_MORECORE</span>
<span class="preproc">#define</span><span class="normal"> HAVE_MORECORE </span><span class="number">0</span>
<span class="preproc">#define</span><span class="normal"> HAVE_MMAP </span><span class="number">1</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* HAVE_MORECORE */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* DARWIN */</span>

<span class="preproc">#ifndef</span><span class="normal"> LACKS_SYS_TYPES_H</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;sys/types.h&gt;</span><span class="normal">  </span><span class="comment">/* For size_t */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* LACKS_SYS_TYPES_H */</span>

<span class="comment">/* The maximum possible size_t value has all bits set */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MAX_SIZE_T</span><span class="normal">           </span><span class="symbol">(~(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="number">0</span><span class="symbol">)</span>

<span class="preproc">#ifndef</span><span class="normal"> ONLY_MSPACES</span>
<span class="preproc">#define</span><span class="normal"> ONLY_MSPACES </span><span class="number">0</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* ONLY_MSPACES */</span>
<span class="preproc">#ifndef</span><span class="normal"> MSPACES</span>
<span class="preproc">#if</span><span class="normal"> ONLY_MSPACES</span>
<span class="preproc">#define</span><span class="normal"> MSPACES </span><span class="number">1</span>
<span class="preproc">#else</span><span class="normal">   </span><span class="comment">/* ONLY_MSPACES */</span>
<span class="preproc">#define</span><span class="normal"> MSPACES </span><span class="number">0</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* ONLY_MSPACES */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* MSPACES */</span>
<span class="preproc">#ifndef</span><span class="normal"> MALLOC_ALIGNMENT</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MALLOC_ALIGNMENT</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">8U</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* MALLOC_ALIGNMENT */</span>
<span class="preproc">#ifndef</span><span class="normal"> FOOTERS</span>
<span class="preproc">#define</span><span class="normal"> FOOTERS </span><span class="number">0</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* FOOTERS */</span>
<span class="preproc">#ifndef</span><span class="normal"> ABORT</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">ABORT</span><span class="normal">  </span><span class="function">abort</span><span class="symbol">()</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* ABORT */</span>
<span class="preproc">#ifndef</span><span class="normal"> ABORT_ON_ASSERT_FAILURE</span>
<span class="preproc">#define</span><span class="normal"> ABORT_ON_ASSERT_FAILURE </span><span class="number">1</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* ABORT_ON_ASSERT_FAILURE */</span>
<span class="preproc">#ifndef</span><span class="normal"> PROCEED_ON_ERROR</span>
<span class="preproc">#define</span><span class="normal"> PROCEED_ON_ERROR </span><span class="number">0</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* PROCEED_ON_ERROR */</span>
<span class="preproc">#ifndef</span><span class="normal"> USE_LOCKS</span>
<span class="preproc">#define</span><span class="normal"> USE_LOCKS </span><span class="number">0</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* USE_LOCKS */</span>
<span class="preproc">#ifndef</span><span class="normal"> INSECURE</span>
<span class="preproc">#define</span><span class="normal"> INSECURE </span><span class="number">0</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* INSECURE */</span>
<span class="preproc">#ifndef</span><span class="normal"> HAVE_MMAP</span>
<span class="preproc">#define</span><span class="normal"> HAVE_MMAP </span><span class="number">1</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* HAVE_MMAP */</span>
<span class="preproc">#ifndef</span><span class="normal"> MMAP_CLEARS</span>
<span class="preproc">#define</span><span class="normal"> MMAP_CLEARS </span><span class="number">1</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* MMAP_CLEARS */</span>
<span class="preproc">#ifndef</span><span class="normal"> HAVE_MREMAP</span>
<span class="preproc">#ifdef</span><span class="normal"> linux</span>
<span class="preproc">#define</span><span class="normal"> HAVE_MREMAP </span><span class="number">1</span>
<span class="preproc">#else</span><span class="normal">   </span><span class="comment">/* linux */</span>
<span class="preproc">#define</span><span class="normal"> HAVE_MREMAP </span><span class="number">0</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* linux */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* HAVE_MREMAP */</span>
<span class="preproc">#ifndef</span><span class="normal"> MALLOC_FAILURE_ACTION</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">MALLOC_FAILURE_ACTION</span><span class="normal">  errno </span><span class="symbol">=</span><span class="normal"> ENOMEM</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* MALLOC_FAILURE_ACTION */</span>
<span class="preproc">#ifndef</span><span class="normal"> HAVE_MORECORE</span>
<span class="preproc">#if</span><span class="normal"> ONLY_MSPACES</span>
<span class="preproc">#define</span><span class="normal"> HAVE_MORECORE </span><span class="number">0</span>
<span class="preproc">#else</span><span class="normal">   </span><span class="comment">/* ONLY_MSPACES */</span>
<span class="preproc">#define</span><span class="normal"> HAVE_MORECORE </span><span class="number">1</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* ONLY_MSPACES */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* HAVE_MORECORE */</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">HAVE_MORECORE</span>
<span class="preproc">#define</span><span class="normal"> MORECORE_CONTIGUOUS </span><span class="number">0</span>
<span class="preproc">#else</span><span class="normal">   </span><span class="comment">/* !HAVE_MORECORE */</span>
<span class="preproc">#ifndef</span><span class="normal"> MORECORE</span>
<span class="preproc">#define</span><span class="normal"> MORECORE sbrk</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* MORECORE */</span>
<span class="preproc">#ifndef</span><span class="normal"> MORECORE_CONTIGUOUS</span>
<span class="preproc">#define</span><span class="normal"> MORECORE_CONTIGUOUS </span><span class="number">1</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* MORECORE_CONTIGUOUS */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* HAVE_MORECORE */</span>
<span class="preproc">#ifndef</span><span class="normal"> DEFAULT_GRANULARITY</span>
<span class="preproc">#if</span><span class="normal"> MORECORE_CONTIGUOUS</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">DEFAULT_GRANULARITY</span><span class="normal"> </span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal">  </span><span class="comment">/* 0 means to compute in init_mparams */</span>
<span class="preproc">#else</span><span class="normal">   </span><span class="comment">/* MORECORE_CONTIGUOUS */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">DEFAULT_GRANULARITY</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">64U </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">1024U</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* MORECORE_CONTIGUOUS */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* DEFAULT_GRANULARITY */</span>
<span class="preproc">#ifndef</span><span class="normal"> DEFAULT_TRIM_THRESHOLD</span>
<span class="preproc">#ifndef</span><span class="normal"> MORECORE_CANNOT_TRIM</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">DEFAULT_TRIM_THRESHOLD</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">2U </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">1024U </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">1024U</span><span class="symbol">)</span>
<span class="preproc">#else</span><span class="normal">   </span><span class="comment">/* MORECORE_CANNOT_TRIM */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">DEFAULT_TRIM_THRESHOLD</span><span class="normal"> MAX_SIZE_T</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* MORECORE_CANNOT_TRIM */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* DEFAULT_TRIM_THRESHOLD */</span>
<span class="preproc">#ifndef</span><span class="normal"> DEFAULT_MMAP_THRESHOLD</span>
<span class="preproc">#if</span><span class="normal"> HAVE_MMAP</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">DEFAULT_MMAP_THRESHOLD</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">256U </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">1024U</span><span class="symbol">)</span>
<span class="preproc">#else</span><span class="normal">   </span><span class="comment">/* HAVE_MMAP */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">DEFAULT_MMAP_THRESHOLD</span><span class="normal"> MAX_SIZE_T</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* HAVE_MMAP */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* DEFAULT_MMAP_THRESHOLD */</span>
<span class="preproc">#ifndef</span><span class="normal"> USE_BUILTIN_FFS</span>
<span class="preproc">#define</span><span class="normal"> USE_BUILTIN_FFS </span><span class="number">0</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* USE_BUILTIN_FFS */</span>
<span class="preproc">#ifndef</span><span class="normal"> USE_DEV_RANDOM</span>
<span class="preproc">#define</span><span class="normal"> USE_DEV_RANDOM </span><span class="number">0</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* USE_DEV_RANDOM */</span>
<span class="preproc">#ifndef</span><span class="normal"> NO_MALLINFO</span>
<span class="preproc">#define</span><span class="normal"> NO_MALLINFO </span><span class="number">0</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* NO_MALLINFO */</span>
<span class="preproc">#ifndef</span><span class="normal"> MALLINFO_FIELD_TYPE</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">MALLINFO_FIELD_TYPE</span><span class="normal"> size_t</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* MALLINFO_FIELD_TYPE */</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">memset</span><span class="normal">	SDL_memset</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">memcpy</span><span class="normal">	SDL_memcpy</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">malloc</span><span class="normal">	SDL_malloc</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">calloc</span><span class="normal">	SDL_calloc</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">realloc</span><span class="normal">	SDL_realloc</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">free</span><span class="normal">	SDL_free</span>

<span class="comment">/*</span>
<span class="comment">  mallopt tuning options.  SVID/XPG defines four standard parameter</span>
<span class="comment">  numbers for mallopt, normally defined in malloc.h.  None of these</span>
<span class="comment">  are used in this malloc, so setting them has no effect. But this</span>
<span class="comment">  malloc does support the following options.</span>
<span class="comment">*/</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">M_TRIM_THRESHOLD</span><span class="normal">     </span><span class="symbol">(-</span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">M_GRANULARITY</span><span class="normal">        </span><span class="symbol">(-</span><span class="number">2</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">M_MMAP_THRESHOLD</span><span class="normal">     </span><span class="symbol">(-</span><span class="number">3</span><span class="symbol">)</span>

<span class="comment">/* ------------------------ Mallinfo declarations ------------------------ */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">NO_MALLINFO</span>
<span class="comment">/*</span>
<span class="comment">  This version of malloc supports the standard SVID/XPG mallinfo</span>
<span class="comment">  routine that returns a struct containing usage properties and</span>
<span class="comment">  statistics. It should work on any system that has a</span>
<span class="comment">  /usr/include/malloc.h defining struct mallinfo.  The main</span>
<span class="comment">  declaration needed is the mallinfo struct that is returned (by-copy)</span>
<span class="comment">  by mallinfo().  The malloinfo struct contains a bunch of fields that</span>
<span class="comment">  are not even meaningful in this version of malloc.  These fields are</span>
<span class="comment">  are instead filled by mallinfo() with other numbers that might be of</span>
<span class="comment">  interest.</span>

<span class="comment">  HAVE_USR_INCLUDE_MALLOC_H should be set if you have a</span>
<span class="comment">  /usr/include/malloc.h file that includes a declaration of struct</span>
<span class="comment">  mallinfo.  If so, it is included; else a compliant version is</span>
<span class="comment">  declared below.  These must be precisely the same for mallinfo() to</span>
<span class="comment">  work.  The original SVID version of this struct, defined on most</span>
<span class="comment">  systems with mallinfo, declares all fields as ints. But some others</span>
<span class="comment">  define as unsigned long. If your system defines the fields using a</span>
<span class="comment">  type of different width than listed here, you MUST #include your</span>
<span class="comment">  system version and #define HAVE_USR_INCLUDE_MALLOC_H.</span>
<span class="comment">*/</span>

<span class="comment">/* #define HAVE_USR_INCLUDE_MALLOC_H */</span>

<span class="preproc">#ifdef</span><span class="normal"> HAVE_USR_INCLUDE_MALLOC_H</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">"/usr/include/malloc.h"</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* HAVE_USR_INCLUDE_MALLOC_H */</span>

<span class="keyword">struct</span><span class="normal"> </span><span class="classname">mallinfo</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">MALLINFO_FIELD_TYPE</span><span class="normal"> arena</span><span class="symbol">;</span><span class="normal">    </span><span class="comment">/* non-mmapped space allocated from system */</span>
<span class="normal">  </span><span class="usertype">MALLINFO_FIELD_TYPE</span><span class="normal"> ordblks</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">/* number of free chunks */</span>
<span class="normal">  </span><span class="usertype">MALLINFO_FIELD_TYPE</span><span class="normal"> smblks</span><span class="symbol">;</span><span class="normal">   </span><span class="comment">/* always 0 */</span>
<span class="normal">  </span><span class="usertype">MALLINFO_FIELD_TYPE</span><span class="normal"> hblks</span><span class="symbol">;</span><span class="normal">    </span><span class="comment">/* always 0 */</span>
<span class="normal">  </span><span class="usertype">MALLINFO_FIELD_TYPE</span><span class="normal"> hblkhd</span><span class="symbol">;</span><span class="normal">   </span><span class="comment">/* space in mmapped regions */</span>
<span class="normal">  </span><span class="usertype">MALLINFO_FIELD_TYPE</span><span class="normal"> usmblks</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">/* maximum total allocated space */</span>
<span class="normal">  </span><span class="usertype">MALLINFO_FIELD_TYPE</span><span class="normal"> fsmblks</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">/* always 0 */</span>
<span class="normal">  </span><span class="usertype">MALLINFO_FIELD_TYPE</span><span class="normal"> uordblks</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* total allocated space */</span>
<span class="normal">  </span><span class="usertype">MALLINFO_FIELD_TYPE</span><span class="normal"> fordblks</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* total free space */</span>
<span class="normal">  </span><span class="usertype">MALLINFO_FIELD_TYPE</span><span class="normal"> keepcost</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* releasable (via malloc_trim) space */</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* HAVE_USR_INCLUDE_MALLOC_H */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* NO_MALLINFO */</span>

<span class="preproc">#ifdef</span><span class="normal"> __cplusplus</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="string">"C"</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* __cplusplus */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">ONLY_MSPACES</span>

<span class="comment">/* ------------------- Declarations of public routines ------------------- */</span>

<span class="preproc">#ifndef</span><span class="normal"> USE_DL_PREFIX</span>
<span class="preproc">#define</span><span class="normal"> dlcalloc               calloc</span>
<span class="preproc">#define</span><span class="normal"> dlfree                 free</span>
<span class="preproc">#define</span><span class="normal"> dlmalloc               malloc</span>
<span class="preproc">#define</span><span class="normal"> dlmemalign             memalign</span>
<span class="preproc">#define</span><span class="normal"> dlrealloc              realloc</span>
<span class="preproc">#define</span><span class="normal"> dlvalloc               valloc</span>
<span class="preproc">#define</span><span class="normal"> dlpvalloc              pvalloc</span>
<span class="preproc">#define</span><span class="normal"> dlmallinfo             mallinfo</span>
<span class="preproc">#define</span><span class="normal"> dlmallopt              mallopt</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">dlmalloc_trim</span><span class="normal">          malloc_trim</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">dlmalloc_stats</span><span class="normal">         malloc_stats</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">dlmalloc_usable_size</span><span class="normal">   malloc_usable_size</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">dlmalloc_footprint</span><span class="normal">     malloc_footprint</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">dlmalloc_max_footprint</span><span class="normal"> malloc_max_footprint</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">dlindependent_calloc</span><span class="normal">   independent_calloc</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">dlindependent_comalloc</span><span class="normal"> independent_comalloc</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* USE_DL_PREFIX */</span>


<span class="comment">/*</span>
<span class="comment">  malloc(size_t n)</span>
<span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or</span>
<span class="comment">  null if no space is available, in which case errno is set to ENOMEM</span>
<span class="comment">  on ANSI C systems.</span>

<span class="comment">  If n is zero, malloc returns a minimum-sized chunk. (The minimum</span>
<span class="comment">  size is 16 bytes on most 32bit systems, and 32 bytes on 64bit</span>
<span class="comment">  systems.)  Note that size_t is an unsigned type, so calls with</span>
<span class="comment">  arguments that would be negative if signed are interpreted as</span>
<span class="comment">  requests for huge amounts of space, which will often fail. The</span>
<span class="comment">  maximum supported value of n differs across systems, but is in all</span>
<span class="comment">  cases less than the maximum representable value of a size_t.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">dlmalloc</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  free(void* p)</span>
<span class="comment">  Releases the chunk of memory pointed to by p, that had been previously</span>
<span class="comment">  allocated using malloc or a related routine such as realloc.</span>
<span class="comment">  It has no effect if p is null. If p was not malloced or already</span>
<span class="comment">  freed, free(p) will by default cause the current program to abort.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="normal">  </span><span class="function">dlfree</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*);</span>

<span class="comment">/*</span>
<span class="comment">  calloc(size_t n_elements, size_t element_size);</span>
<span class="comment">  Returns a pointer to n_elements * element_size bytes, with all locations</span>
<span class="comment">  set to zero.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">dlcalloc</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">,</span><span class="normal"> size_t</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  realloc(void* p, size_t n)</span>
<span class="comment">  Returns a pointer to a chunk of size n that contains the same data</span>
<span class="comment">  as does chunk p up to the minimum of (n, p's size) bytes, or null</span>
<span class="comment">  if no space is available.</span>

<span class="comment">  The returned pointer may or may not be the same as p. The algorithm</span>
<span class="comment">  prefers extending p in most cases when possible, otherwise it</span>
<span class="comment">  employs the equivalent of a malloc-copy-free sequence.</span>

<span class="comment">  If p is null, realloc is equivalent to malloc.</span>

<span class="comment">  If space is not available, realloc returns null, errno is set (if on</span>
<span class="comment">  ANSI) and p is NOT freed.</span>

<span class="comment">  if n is for fewer bytes than already held by p, the newly unused</span>
<span class="comment">  space is lopped off and freed if possible.  realloc with a size</span>
<span class="comment">  argument of zero (re)allocates a minimum-sized chunk.</span>

<span class="comment">  The old unix realloc convention of allowing the last-free'd chunk</span>
<span class="comment">  to be used as an argument to realloc is not supported.</span>
<span class="comment">*/</span>

<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">dlrealloc</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*,</span><span class="normal"> size_t</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  memalign(size_t alignment, size_t n);</span>
<span class="comment">  Returns a pointer to a newly allocated chunk of n bytes, aligned</span>
<span class="comment">  in accord with the alignment argument.</span>

<span class="comment">  The alignment argument should be a power of two. If the argument is</span>
<span class="comment">  not a power of two, the nearest greater power is used.</span>
<span class="comment">  8-byte alignment is guaranteed by normal malloc calls, so don't</span>
<span class="comment">  bother calling memalign with an argument of 8 or less.</span>

<span class="comment">  Overreliance on memalign is a sure way to fragment space.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">dlmemalign</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">,</span><span class="normal"> size_t</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  valloc(size_t n);</span>
<span class="comment">  Equivalent to memalign(pagesize, n), where pagesize is the page</span>
<span class="comment">  size of the system. If the pagesize is unknown, 4096 is used.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">dlvalloc</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  mallopt(int parameter_number, int parameter_value)</span>
<span class="comment">  Sets tunable parameters The format is to provide a</span>
<span class="comment">  (parameter-number, parameter-value) pair.  mallopt then sets the</span>
<span class="comment">  corresponding parameter to the argument value if it can (i.e., so</span>
<span class="comment">  long as the value is meaningful), and returns 1 if successful else</span>
<span class="comment">  0.  SVID/XPG/ANSI defines four standard param numbers for mallopt,</span>
<span class="comment">  normally defined in malloc.h.  None of these are use in this malloc,</span>
<span class="comment">  so setting them has no effect. But this malloc also supports other</span>
<span class="comment">  options in mallopt. See below for details.  Briefly, supported</span>
<span class="comment">  parameters are as follows (listed defaults are for "typical"</span>
<span class="comment">  configurations).</span>

<span class="comment">  Symbol            param #  default    allowed param values</span>
<span class="comment">  M_TRIM_THRESHOLD     -1   2*1024*1024   any   (MAX_SIZE_T disables)</span>
<span class="comment">  M_GRANULARITY        -2     page size   any power of 2 &gt;= page size</span>
<span class="comment">  M_MMAP_THRESHOLD     -3      256*1024   any   (or 0 if no MMAP support)</span>
<span class="comment">*/</span>
<span class="type">int</span><span class="normal"> </span><span class="function">dlmallopt</span><span class="symbol">(</span><span class="type">int</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  malloc_footprint();</span>
<span class="comment">  Returns the number of bytes obtained from the system.  The total</span>
<span class="comment">  number of bytes allocated by malloc, realloc etc., is less than this</span>
<span class="comment">  value. Unlike mallinfo, this function returns only a precomputed</span>
<span class="comment">  result, so can be called frequently to monitor memory consumption.</span>
<span class="comment">  Even if locks are otherwise defined, this function does not use them,</span>
<span class="comment">  so results might not be up to date.</span>
<span class="comment">*/</span>
<span class="usertype">size_t</span><span class="normal"> </span><span class="function">dlmalloc_footprint</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  malloc_max_footprint();</span>
<span class="comment">  Returns the maximum number of bytes obtained from the system. This</span>
<span class="comment">  value will be greater than current footprint if deallocated space</span>
<span class="comment">  has been reclaimed by the system. The peak number of bytes allocated</span>
<span class="comment">  by malloc, realloc etc., is less than this value. Unlike mallinfo,</span>
<span class="comment">  this function returns only a precomputed result, so can be called</span>
<span class="comment">  frequently to monitor memory consumption.  Even if locks are</span>
<span class="comment">  otherwise defined, this function does not use them, so results might</span>
<span class="comment">  not be up to date.</span>
<span class="comment">*/</span>
<span class="usertype">size_t</span><span class="normal"> </span><span class="function">dlmalloc_max_footprint</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">NO_MALLINFO</span>
<span class="comment">/*</span>
<span class="comment">  mallinfo()</span>
<span class="comment">  Returns (by copy) a struct containing various summary statistics:</span>

<span class="comment">  arena:     current total non-mmapped bytes allocated from system</span>
<span class="comment">  ordblks:   the number of free chunks</span>
<span class="comment">  smblks:    always zero.</span>
<span class="comment">  hblks:     current number of mmapped regions</span>
<span class="comment">  hblkhd:    total bytes held in mmapped regions</span>
<span class="comment">  usmblks:   the maximum total allocated space. This will be greater</span>
<span class="comment">                than current total if trimming has occurred.</span>
<span class="comment">  fsmblks:   always zero</span>
<span class="comment">  uordblks:  current total allocated space (normal or mmapped)</span>
<span class="comment">  fordblks:  total free space</span>
<span class="comment">  keepcost:  the maximum number of bytes that could ideally be released</span>
<span class="comment">               back to system via malloc_trim. ("ideally" means that</span>
<span class="comment">               it ignores page restrictions etc.)</span>

<span class="comment">  Because these fields are ints, but internal bookkeeping may</span>
<span class="comment">  be kept as longs, the reported values may wrap around zero and</span>
<span class="comment">  thus be inaccurate.</span>
<span class="comment">*/</span>
<span class="keyword">struct</span><span class="normal"> </span><span class="classname">mallinfo</span><span class="normal"> </span><span class="function">dlmallinfo</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">);</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* NO_MALLINFO */</span>

<span class="comment">/*</span>
<span class="comment">  independent_calloc(size_t n_elements, size_t element_size, void* chunks[]);</span>

<span class="comment">  independent_calloc is similar to calloc, but instead of returning a</span>
<span class="comment">  single cleared space, it returns an array of pointers to n_elements</span>
<span class="comment">  independent elements that can hold contents of size elem_size, each</span>
<span class="comment">  of which starts out cleared, and can be independently freed,</span>
<span class="comment">  realloc'ed etc. The elements are guaranteed to be adjacently</span>
<span class="comment">  allocated (this is not guaranteed to occur with multiple callocs or</span>
<span class="comment">  mallocs), which may also improve cache locality in some</span>
<span class="comment">  applications.</span>

<span class="comment">  The "chunks" argument is optional (i.e., may be null, which is</span>
<span class="comment">  probably the most typical usage). If it is null, the returned array</span>
<span class="comment">  is itself dynamically allocated and should also be freed when it is</span>
<span class="comment">  no longer needed. Otherwise, the chunks array must be of at least</span>
<span class="comment">  n_elements in length. It is filled in with the pointers to the</span>
<span class="comment">  chunks.</span>

<span class="comment">  In either case, independent_calloc returns this pointer array, or</span>
<span class="comment">  null if the allocation failed.  If n_elements is zero and "chunks"</span>
<span class="comment">  is null, it returns a chunk representing an array with zero elements</span>
<span class="comment">  (which should be freed if not wanted).</span>

<span class="comment">  Each element must be individually freed when it is no longer</span>
<span class="comment">  needed. If you'd like to instead be able to free all at once, you</span>
<span class="comment">  should instead use regular calloc and assign pointers into this</span>
<span class="comment">  space to represent elements.  (In this case though, you cannot</span>
<span class="comment">  independently free elements.)</span>

<span class="comment">  independent_calloc simplifies and speeds up implementations of many</span>
<span class="comment">  kinds of pools.  It may also be useful when constructing large data</span>
<span class="comment">  structures that initially have a fixed number of fixed-sized nodes,</span>
<span class="comment">  but the number is not known at compile time, and some of the nodes</span>
<span class="comment">  may later need to be freed. For example:</span>

<span class="comment">  struct Node { int item; struct Node* next; };</span>

<span class="comment">  struct Node* build_list() {</span>
<span class="comment">    struct Node** pool;</span>
<span class="comment">    int n = read_number_of_nodes_needed();</span>
<span class="comment">    if (n &lt;= 0) return 0;</span>
<span class="comment">    pool = (struct Node**)(independent_calloc(n, sizeof(struct Node), 0);</span>
<span class="comment">    if (pool == 0) die();</span>
<span class="comment">    // organize into a linked list...</span>
<span class="comment">    struct Node* first = pool[0];</span>
<span class="comment">    for (i = 0; i &lt; n-1; ++i)</span>
<span class="comment">      pool[i]-&gt;next = pool[i+1];</span>
<span class="comment">    free(pool);     // Can now free the array (or not, if it is needed later)</span>
<span class="comment">    return first;</span>
<span class="comment">  }</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">**</span><span class="normal"> </span><span class="function">dlindependent_calloc</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">,</span><span class="normal"> size_t</span><span class="symbol">,</span><span class="normal"> </span><span class="type">void</span><span class="symbol">**);</span>

<span class="comment">/*</span>
<span class="comment">  independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);</span>

<span class="comment">  independent_comalloc allocates, all at once, a set of n_elements</span>
<span class="comment">  chunks with sizes indicated in the "sizes" array.    It returns</span>
<span class="comment">  an array of pointers to these elements, each of which can be</span>
<span class="comment">  independently freed, realloc'ed etc. The elements are guaranteed to</span>
<span class="comment">  be adjacently allocated (this is not guaranteed to occur with</span>
<span class="comment">  multiple callocs or mallocs), which may also improve cache locality</span>
<span class="comment">  in some applications.</span>

<span class="comment">  The "chunks" argument is optional (i.e., may be null). If it is null</span>
<span class="comment">  the returned array is itself dynamically allocated and should also</span>
<span class="comment">  be freed when it is no longer needed. Otherwise, the chunks array</span>
<span class="comment">  must be of at least n_elements in length. It is filled in with the</span>
<span class="comment">  pointers to the chunks.</span>

<span class="comment">  In either case, independent_comalloc returns this pointer array, or</span>
<span class="comment">  null if the allocation failed.  If n_elements is zero and chunks is</span>
<span class="comment">  null, it returns a chunk representing an array with zero elements</span>
<span class="comment">  (which should be freed if not wanted).</span>

<span class="comment">  Each element must be individually freed when it is no longer</span>
<span class="comment">  needed. If you'd like to instead be able to free all at once, you</span>
<span class="comment">  should instead use a single regular malloc, and assign pointers at</span>
<span class="comment">  particular offsets in the aggregate space. (In this case though, you</span>
<span class="comment">  cannot independently free elements.)</span>

<span class="comment">  independent_comallac differs from independent_calloc in that each</span>
<span class="comment">  element may have a different size, and also that it does not</span>
<span class="comment">  automatically clear elements.</span>

<span class="comment">  independent_comalloc can be used to speed up allocation in cases</span>
<span class="comment">  where several structs or objects must always be allocated at the</span>
<span class="comment">  same time.  For example:</span>

<span class="comment">  struct Head { ... }</span>
<span class="comment">  struct Foot { ... }</span>

<span class="comment">  void send_message(char* msg) {</span>
<span class="comment">    int msglen = strlen(msg);</span>
<span class="comment">    size_t sizes[3] = { sizeof(struct Head), msglen, sizeof(struct Foot) };</span>
<span class="comment">    void* chunks[3];</span>
<span class="comment">    if (independent_comalloc(3, sizes, chunks) == 0)</span>
<span class="comment">      die();</span>
<span class="comment">    struct Head* head = (struct Head*)(chunks[0]);</span>
<span class="comment">    char*        body = (char*)(chunks[1]);</span>
<span class="comment">    struct Foot* foot = (struct Foot*)(chunks[2]);</span>
<span class="comment">    // ...</span>
<span class="comment">  }</span>

<span class="comment">  In general though, independent_comalloc is worth using only for</span>
<span class="comment">  larger values of n_elements. For small values, you probably won't</span>
<span class="comment">  detect enough difference from series of malloc calls to bother.</span>

<span class="comment">  Overuse of independent_comalloc can increase overall memory usage,</span>
<span class="comment">  since it cannot reuse existing noncontiguous small chunks that</span>
<span class="comment">  might be available for some of the elements.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">**</span><span class="normal"> </span><span class="function">dlindependent_comalloc</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">,</span><span class="normal"> size_t</span><span class="symbol">*,</span><span class="normal"> </span><span class="type">void</span><span class="symbol">**);</span>


<span class="comment">/*</span>
<span class="comment">  pvalloc(size_t n);</span>
<span class="comment">  Equivalent to valloc(minimum-page-that-holds(n)), that is,</span>
<span class="comment">  round up n to nearest pagesize.</span>
<span class="comment"> */</span>
<span class="type">void</span><span class="symbol">*</span><span class="normal">  </span><span class="function">dlpvalloc</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  malloc_trim(size_t pad);</span>

<span class="comment">  If possible, gives memory back to the system (via negative arguments</span>
<span class="comment">  to sbrk) if there is unused memory at the `high' end of the malloc</span>
<span class="comment">  pool or in unused MMAP segments. You can call this after freeing</span>
<span class="comment">  large blocks of memory to potentially reduce the system-level memory</span>
<span class="comment">  requirements of a program. However, it cannot guarantee to reduce</span>
<span class="comment">  memory. Under some allocation patterns, some large free blocks of</span>
<span class="comment">  memory will be locked between two used chunks, so they cannot be</span>
<span class="comment">  given back to the system.</span>

<span class="comment">  The `pad' argument to malloc_trim represents the amount of free</span>
<span class="comment">  trailing space to leave untrimmed. If this argument is zero, only</span>
<span class="comment">  the minimum amount of memory to maintain internal data structures</span>
<span class="comment">  will be left. Non-zero arguments can be supplied to maintain enough</span>
<span class="comment">  trailing space to service future expected allocations without having</span>
<span class="comment">  to re-obtain memory from the system.</span>

<span class="comment">  Malloc_trim returns 1 if it actually released any memory, else 0.</span>
<span class="comment">*/</span>
<span class="type">int</span><span class="normal">  </span><span class="function">dlmalloc_trim</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  malloc_usable_size(void* p);</span>

<span class="comment">  Returns the number of bytes you can actually use in</span>
<span class="comment">  an allocated chunk, which may be more than you requested (although</span>
<span class="comment">  often not) due to alignment and minimum size constraints.</span>
<span class="comment">  You can use this many bytes without worrying about</span>
<span class="comment">  overwriting other allocated objects. This is not a particularly great</span>
<span class="comment">  programming practice. malloc_usable_size can be more useful in</span>
<span class="comment">  debugging and assertions, for example:</span>

<span class="comment">  p = malloc(n);</span>
<span class="comment">  assert(malloc_usable_size(p) &gt;= 256);</span>
<span class="comment">*/</span>
<span class="usertype">size_t</span><span class="normal"> </span><span class="function">dlmalloc_usable_size</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*);</span>

<span class="comment">/*</span>
<span class="comment">  malloc_stats();</span>
<span class="comment">  Prints on stderr the amount of space obtained from the system (both</span>
<span class="comment">  via sbrk and mmap), the maximum amount (which may be more than</span>
<span class="comment">  current if malloc_trim and/or munmap got called), and the current</span>
<span class="comment">  number of bytes allocated via malloc (or realloc, etc) but not yet</span>
<span class="comment">  freed. Note that this is the number of bytes allocated, not the</span>
<span class="comment">  number requested. It will be larger than the number requested</span>
<span class="comment">  because of alignment and bookkeeping overhead. Because it includes</span>
<span class="comment">  alignment wastage as being in use, this figure may be greater than</span>
<span class="comment">  zero even when no user-level chunks are allocated.</span>

<span class="comment">  The reported current and maximum system memory can be inaccurate if</span>
<span class="comment">  a program makes other calls to system memory allocation functions</span>
<span class="comment">  (normally sbrk) outside of malloc.</span>

<span class="comment">  malloc_stats prints only the most commonly interesting statistics.</span>
<span class="comment">  More information can be obtained by calling mallinfo.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="normal">  </span><span class="function">dlmalloc_stats</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">);</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* ONLY_MSPACES */</span>

<span class="preproc">#if</span><span class="normal"> MSPACES</span>

<span class="comment">/*</span>
<span class="comment">  mspace is an opaque type representing an independent</span>
<span class="comment">  region of space that supports mspace_malloc, etc.</span>
<span class="comment">*/</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mspace</span><span class="symbol">;</span>

<span class="comment">/*</span>
<span class="comment">  create_mspace creates and returns a new independent space with the</span>
<span class="comment">  given initial capacity, or, if 0, the default granularity size.  It</span>
<span class="comment">  returns null if there is no system memory available to create the</span>
<span class="comment">  space.  If argument locked is non-zero, the space uses a separate</span>
<span class="comment">  lock to control access. The capacity of the space will grow</span>
<span class="comment">  dynamically as needed to service mspace_malloc requests.  You can</span>
<span class="comment">  control the sizes of incremental increases of this space by</span>
<span class="comment">  compiling with a different DEFAULT_GRANULARITY or dynamically</span>
<span class="comment">  setting with mallopt(M_GRANULARITY, value).</span>
<span class="comment">*/</span>
<span class="usertype">mspace</span><span class="normal"> </span><span class="function">create_mspace</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> capacity</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> locked</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  destroy_mspace destroys the given space, and attempts to return all</span>
<span class="comment">  of its memory back to the system, returning the total number of</span>
<span class="comment">  bytes freed. After destruction, the results of access to all memory</span>
<span class="comment">  used by the space become undefined.</span>
<span class="comment">*/</span>
<span class="usertype">size_t</span><span class="normal"> </span><span class="function">destroy_mspace</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  create_mspace_with_base uses the memory supplied as the initial base</span>
<span class="comment">  of a new mspace. Part (less than 128*sizeof(size_t) bytes) of this</span>
<span class="comment">  space is used for bookkeeping, so the capacity must be at least this</span>
<span class="comment">  large. (Otherwise 0 is returned.) When this initial space is</span>
<span class="comment">  exhausted, additional memory will be obtained from the system.</span>
<span class="comment">  Destroying this space will deallocate all additionally allocated</span>
<span class="comment">  space (if possible) but not the initial base.</span>
<span class="comment">*/</span>
<span class="usertype">mspace</span><span class="normal"> </span><span class="function">create_mspace_with_base</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*</span><span class="normal"> base</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> capacity</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> locked</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  mspace_malloc behaves as malloc, but operates within</span>
<span class="comment">  the given space.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">mspace_malloc</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  mspace_free behaves as free, but operates within</span>
<span class="comment">  the given space.</span>

<span class="comment">  If compiled with FOOTERS==1, mspace_free is not actually needed.</span>
<span class="comment">  free may be called instead of mspace_free because freed chunks from</span>
<span class="comment">  any space are handled by their originating spaces.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="normal"> </span><span class="function">mspace_free</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  mspace_realloc behaves as realloc, but operates within</span>
<span class="comment">  the given space.</span>

<span class="comment">  If compiled with FOOTERS==1, mspace_realloc is not actually</span>
<span class="comment">  needed.  realloc may be called instead of mspace_realloc because</span>
<span class="comment">  realloced chunks from any space are handled by their originating</span>
<span class="comment">  spaces.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">mspace_realloc</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> newsize</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  mspace_calloc behaves as calloc, but operates within</span>
<span class="comment">  the given space.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">mspace_calloc</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> n_elements</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> elem_size</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  mspace_memalign behaves as memalign, but operates within</span>
<span class="comment">  the given space.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">mspace_memalign</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> alignment</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  mspace_independent_calloc behaves as independent_calloc, but</span>
<span class="comment">  operates within the given space.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">**</span><span class="normal"> </span><span class="function">mspace_independent_calloc</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> n_elements</span><span class="symbol">,</span>
<span class="normal">                                 </span><span class="usertype">size_t</span><span class="normal"> elem_size</span><span class="symbol">,</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> chunks</span><span class="symbol">[]);</span>

<span class="comment">/*</span>
<span class="comment">  mspace_independent_comalloc behaves as independent_comalloc, but</span>
<span class="comment">  operates within the given space.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="symbol">**</span><span class="normal"> </span><span class="function">mspace_independent_comalloc</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> n_elements</span><span class="symbol">,</span>
<span class="normal">                                   </span><span class="usertype">size_t</span><span class="normal"> sizes</span><span class="symbol">[],</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> chunks</span><span class="symbol">[]);</span>

<span class="comment">/*</span>
<span class="comment">  mspace_footprint() returns the number of bytes obtained from the</span>
<span class="comment">  system for this space.</span>
<span class="comment">*/</span>
<span class="usertype">size_t</span><span class="normal"> </span><span class="function">mspace_footprint</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  mspace_max_footprint() returns the peak number of bytes obtained from the</span>
<span class="comment">  system for this space.</span>
<span class="comment">*/</span>
<span class="usertype">size_t</span><span class="normal"> </span><span class="function">mspace_max_footprint</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">);</span>


<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">NO_MALLINFO</span>
<span class="comment">/*</span>
<span class="comment">  mspace_mallinfo behaves as mallinfo, but reports properties of</span>
<span class="comment">  the given space.</span>
<span class="comment">*/</span>
<span class="keyword">struct</span><span class="normal"> </span><span class="classname">mallinfo</span><span class="normal"> </span><span class="function">mspace_mallinfo</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">);</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* NO_MALLINFO */</span>

<span class="comment">/*</span>
<span class="comment">  mspace_malloc_stats behaves as malloc_stats, but reports</span>
<span class="comment">  properties of the given space.</span>
<span class="comment">*/</span>
<span class="type">void</span><span class="normal"> </span><span class="function">mspace_malloc_stats</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  mspace_trim behaves as malloc_trim, but</span>
<span class="comment">  operates within the given space.</span>
<span class="comment">*/</span>
<span class="type">int</span><span class="normal"> </span><span class="function">mspace_trim</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> pad</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment">  An alias for mallopt.</span>
<span class="comment">*/</span>
<span class="type">int</span><span class="normal"> </span><span class="function">mspace_mallopt</span><span class="symbol">(</span><span class="type">int</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="symbol">);</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* MSPACES */</span>

<span class="preproc">#ifdef</span><span class="normal"> __cplusplus</span>
<span class="cbracket">}</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">/* end of extern "C" */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* __cplusplus */</span>

<span class="comment">/*</span>
<span class="comment">  ========================================================================</span>
<span class="comment">  To make a fully customizable malloc.h header file, cut everything</span>
<span class="comment">  above this line, put into file malloc.h, edit to suit, and #include it</span>
<span class="comment">  on the next line, as well as in programs that use this malloc.</span>
<span class="comment">  ========================================================================</span>
<span class="comment">*/</span>

<span class="comment">/* #include "malloc.h" */</span>

<span class="comment">/*------------------------------ internal #includes ---------------------- */</span>

<span class="preproc">#ifdef</span><span class="normal"> _MSC_VER</span>
<span class="preproc">#pragma</span><span class="normal"> </span><span class="function">warning</span><span class="symbol">(</span><span class="normal"> disable </span><span class="symbol">:</span><span class="normal"> </span><span class="number">4146</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="comment">/* no "unsigned" warnings */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* _MSC_VER */</span>

<span class="preproc">#ifndef</span><span class="normal"> LACKS_STDIO_H</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;stdio.h&gt;</span><span class="normal">       </span><span class="comment">/* for printing in malloc_stats */</span>
<span class="preproc">#endif</span>

<span class="preproc">#ifndef</span><span class="normal"> LACKS_ERRNO_H</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;errno.h&gt;</span><span class="normal">       </span><span class="comment">/* for MALLOC_FAILURE_ACTION */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* LACKS_ERRNO_H */</span>
<span class="preproc">#if</span><span class="normal"> FOOTERS</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;time.h&gt;</span><span class="normal">        </span><span class="comment">/* for magic initialization */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>
<span class="preproc">#ifndef</span><span class="normal"> LACKS_STDLIB_H</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;stdlib.h&gt;</span><span class="normal">      </span><span class="comment">/* for abort() */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* LACKS_STDLIB_H */</span>
<span class="preproc">#ifdef</span><span class="normal"> DEBUG</span>
<span class="preproc">#if</span><span class="normal"> ABORT_ON_ASSERT_FAILURE</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">if</span><span class="symbol">(!(</span><span class="normal">x</span><span class="symbol">))</span><span class="normal"> ABORT</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* ABORT_ON_ASSERT_FAILURE */</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;assert.h&gt;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* ABORT_ON_ASSERT_FAILURE */</span>
<span class="preproc">#else</span><span class="normal">  </span><span class="comment">/* DEBUG */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* DEBUG */</span>
<span class="preproc">#ifndef</span><span class="normal"> LACKS_STRING_H</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;string.h&gt;</span><span class="normal">      </span><span class="comment">/* for memset etc */</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* LACKS_STRING_H */</span>
<span class="preproc">#if</span><span class="normal"> USE_BUILTIN_FFS</span>
<span class="preproc">#ifndef</span><span class="normal"> LACKS_STRINGS_H</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;strings.h&gt;</span><span class="normal">     </span><span class="comment">/* for ffs */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* LACKS_STRINGS_H */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* USE_BUILTIN_FFS */</span>
<span class="preproc">#if</span><span class="normal"> HAVE_MMAP</span>
<span class="preproc">#ifndef</span><span class="normal"> LACKS_SYS_MMAN_H</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;sys/mman.h&gt;</span><span class="normal">    </span><span class="comment">/* for mmap */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* LACKS_SYS_MMAN_H */</span>
<span class="preproc">#ifndef</span><span class="normal"> LACKS_FCNTL_H</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;fcntl.h&gt;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* LACKS_FCNTL_H */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* HAVE_MMAP */</span>
<span class="preproc">#if</span><span class="normal"> HAVE_MORECORE</span>
<span class="preproc">#ifndef</span><span class="normal"> LACKS_UNISTD_H</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;unistd.h&gt;</span><span class="normal">     </span><span class="comment">/* for sbrk */</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* LACKS_UNISTD_H */</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="function">defined</span><span class="symbol">(</span><span class="normal">__FreeBSD__</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">defined</span><span class="symbol">(</span><span class="normal">__OpenBSD__</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">defined</span><span class="symbol">(</span><span class="normal">__NetBSD__</span><span class="symbol">)</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal">     </span><span class="function">sbrk</span><span class="symbol">(</span><span class="normal">ptrdiff_t</span><span class="symbol">);</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* FreeBSD etc */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* LACKS_UNISTD_H */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* HAVE_MMAP */</span>

<span class="preproc">#ifndef</span><span class="normal"> WIN32</span>
<span class="preproc">#ifndef</span><span class="normal"> malloc_getpagesize</span>
<span class="preproc">#  ifdef</span><span class="normal"> _SC_PAGESIZE         </span><span class="comment">/* some SVR4 systems omit an underscore */</span>
<span class="preproc">#    ifndef</span><span class="normal"> _SC_PAGE_SIZE</span>
<span class="preproc">#      define</span><span class="normal"> </span><span class="usertype">_SC_PAGE_SIZE</span><span class="normal"> _SC_PAGESIZE</span>
<span class="preproc">#    endif</span>
<span class="preproc">#  endif</span>
<span class="preproc">#  ifdef</span><span class="normal"> _SC_PAGE_SIZE</span>
<span class="preproc">#    define</span><span class="normal"> </span><span class="usertype">malloc_getpagesize</span><span class="normal"> </span><span class="function">sysconf</span><span class="symbol">(</span><span class="normal">_SC_PAGE_SIZE</span><span class="symbol">)</span>
<span class="preproc">#  else</span>
<span class="preproc">#    if</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">BSD</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">DGUX</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">HAVE_GETPAGESIZE</span><span class="symbol">)</span>
<span class="normal">       </span><span class="keyword">extern</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> </span><span class="function">getpagesize</span><span class="symbol">();</span>
<span class="preproc">#      define</span><span class="normal"> </span><span class="usertype">malloc_getpagesize</span><span class="normal"> </span><span class="function">getpagesize</span><span class="symbol">()</span>
<span class="preproc">#    else</span>
<span class="preproc">#      ifdef</span><span class="normal"> WIN32 </span><span class="comment">/* use supplied emulation of getpagesize */</span>
<span class="preproc">#        define</span><span class="normal"> </span><span class="usertype">malloc_getpagesize</span><span class="normal"> </span><span class="function">getpagesize</span><span class="symbol">()</span>
<span class="preproc">#      else</span>
<span class="preproc">#        ifndef</span><span class="normal"> LACKS_SYS_PARAM_H</span>
<span class="preproc">#          include</span><span class="normal"> </span><span class="string">&lt;sys/param.h&gt;</span>
<span class="preproc">#        endif</span>
<span class="preproc">#        ifdef</span><span class="normal"> EXEC_PAGESIZE</span>
<span class="preproc">#          define</span><span class="normal"> </span><span class="usertype">malloc_getpagesize</span><span class="normal"> EXEC_PAGESIZE</span>
<span class="preproc">#        else</span>
<span class="preproc">#          ifdef</span><span class="normal"> NBPG</span>
<span class="preproc">#            ifndef</span><span class="normal"> CLSIZE</span>
<span class="preproc">#              define</span><span class="normal"> malloc_getpagesize NBPG</span>
<span class="preproc">#            else</span>
<span class="preproc">#              define</span><span class="normal"> </span><span class="function">malloc_getpagesize</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">NBPG </span><span class="symbol">*</span><span class="normal"> CLSIZE</span><span class="symbol">)</span>
<span class="preproc">#            endif</span>
<span class="preproc">#          else</span>
<span class="preproc">#            ifdef</span><span class="normal"> NBPC</span>
<span class="preproc">#              define</span><span class="normal"> malloc_getpagesize NBPC</span>
<span class="preproc">#            else</span>
<span class="preproc">#              ifdef</span><span class="normal"> PAGESIZE</span>
<span class="preproc">#                define</span><span class="normal"> malloc_getpagesize PAGESIZE</span>
<span class="preproc">#              else</span><span class="normal"> </span><span class="comment">/* just guess */</span>
<span class="preproc">#                define</span><span class="normal"> </span><span class="function">malloc_getpagesize</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">4096U</span><span class="symbol">)</span>
<span class="preproc">#              endif</span>
<span class="preproc">#            endif</span>
<span class="preproc">#          endif</span>
<span class="preproc">#        endif</span>
<span class="preproc">#      endif</span>
<span class="preproc">#    endif</span>
<span class="preproc">#  endif</span>
<span class="preproc">#endif</span>
<span class="preproc">#endif</span>

<span class="comment">/* ------------------- size_t and alignment properties -------------------- */</span>

<span class="comment">/* The byte and bit size of a size_t */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">SIZE_T_SIZE</span><span class="normal">         </span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">SIZE_T_BITSIZE</span><span class="normal">      </span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">3</span><span class="symbol">)</span>

<span class="comment">/* Some constants coerced to size_t */</span>
<span class="comment">/* Annoying but necessary to avoid errors on some plaftorms */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">SIZE_T_ZERO</span><span class="normal">         </span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)</span><span class="number">0</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">SIZE_T_ONE</span><span class="normal">          </span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)</span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">SIZE_T_TWO</span><span class="normal">          </span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)</span><span class="number">2</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">TWO_SIZE_T_SIZES</span><span class="normal">    </span><span class="symbol">(</span><span class="normal">SIZE_T_SIZE</span><span class="symbol">&lt;&lt;</span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">FOUR_SIZE_T_SIZES</span><span class="normal">   </span><span class="symbol">(</span><span class="normal">SIZE_T_SIZE</span><span class="symbol">&lt;&lt;</span><span class="number">2</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">SIX_SIZE_T_SIZES</span><span class="normal">    </span><span class="symbol">(</span><span class="normal">FOUR_SIZE_T_SIZES</span><span class="symbol">+</span><span class="normal">TWO_SIZE_T_SIZES</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">HALF_MAX_SIZE_T</span><span class="normal">     </span><span class="symbol">(</span><span class="normal">MAX_SIZE_T </span><span class="symbol">/</span><span class="normal"> 2U</span><span class="symbol">)</span>

<span class="comment">/* The bit mask value corresponding to MALLOC_ALIGNMENT */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CHUNK_ALIGN_MASK</span><span class="normal">    </span><span class="symbol">(</span><span class="normal">MALLOC_ALIGNMENT </span><span class="symbol">-</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">)</span>

<span class="comment">/* True if address a has acceptable alignment */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">is_aligned</span><span class="symbol">(</span><span class="normal">A</span><span class="symbol">)</span><span class="normal">       </span><span class="symbol">(((</span><span class="normal">size_t</span><span class="symbol">)((</span><span class="normal">A</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">CHUNK_ALIGN_MASK</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>

<span class="comment">/* the number of bytes to offset an address to align it */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">align_offset</span><span class="symbol">(</span><span class="normal">A</span><span class="symbol">)\</span>
<span class="normal"> </span><span class="symbol">((((</span><span class="normal">size_t</span><span class="symbol">)(</span><span class="normal">A</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> CHUNK_ALIGN_MASK</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)?</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">:\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">MALLOC_ALIGNMENT </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)(</span><span class="normal">A</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> CHUNK_ALIGN_MASK</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> CHUNK_ALIGN_MASK</span><span class="symbol">))</span>

<span class="comment">/* -------------------------- MMAP preliminaries ------------------------- */</span>

<span class="comment">/*</span>
<span class="comment">   If HAVE_MORECORE or HAVE_MMAP are false, we just define calls and</span>
<span class="comment">   checks to fail so compiler optimizer can delete code rather than</span>
<span class="comment">   using so many "#if"s.</span>
<span class="comment">*/</span>


<span class="comment">/* MORECORE and MMAP must return MFAIL on failure */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MFAIL</span><span class="normal">                </span><span class="symbol">((</span><span class="type">void</span><span class="symbol">*)(</span><span class="normal">MAX_SIZE_T</span><span class="symbol">))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CMFAIL</span><span class="normal">               </span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">MFAIL</span><span class="symbol">))</span><span class="normal"> </span><span class="comment">/* defined for convenience */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">HAVE_MMAP</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">IS_MMAPPED_BIT</span><span class="normal">       </span><span class="symbol">(</span><span class="normal">SIZE_T_ZERO</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">USE_MMAP_BIT</span><span class="normal">         </span><span class="symbol">(</span><span class="normal">SIZE_T_ZERO</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALL_MMAP</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span><span class="normal">         MFAIL</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALL_MUNMAP</span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">)</span><span class="normal">    </span><span class="symbol">(-</span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">DIRECT_MMAP</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span><span class="normal">       MFAIL</span>

<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* HAVE_MMAP */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">IS_MMAPPED_BIT</span><span class="normal">       </span><span class="symbol">(</span><span class="normal">SIZE_T_ONE</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">USE_MMAP_BIT</span><span class="normal">         </span><span class="symbol">(</span><span class="normal">SIZE_T_ONE</span><span class="symbol">)</span>

<span class="preproc">#ifndef</span><span class="normal"> WIN32</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALL_MUNMAP</span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">)</span><span class="normal">    </span><span class="function">munmap</span><span class="symbol">((</span><span class="normal">a</span><span class="symbol">),</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MMAP_PROT</span><span class="normal">            </span><span class="symbol">(</span><span class="normal">PROT_READ</span><span class="symbol">|</span><span class="normal">PROT_WRITE</span><span class="symbol">)</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="function">defined</span><span class="symbol">(</span><span class="normal">MAP_ANONYMOUS</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">MAP_ANON</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">MAP_ANONYMOUS</span><span class="normal">        MAP_ANON</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* MAP_ANON */</span>
<span class="preproc">#ifdef</span><span class="normal"> MAP_ANONYMOUS</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MMAP_FLAGS</span><span class="normal">           </span><span class="symbol">(</span><span class="normal">MAP_PRIVATE</span><span class="symbol">|</span><span class="normal">MAP_ANONYMOUS</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALL_MMAP</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span><span class="normal">         </span><span class="function">mmap</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">),</span><span class="normal"> MMAP_PROT</span><span class="symbol">,</span><span class="normal"> MMAP_FLAGS</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* MAP_ANONYMOUS */</span>
<span class="comment">/*</span>
<span class="comment">   Nearly all versions of mmap support MAP_ANONYMOUS, so the following</span>
<span class="comment">   is unlikely to be needed, but is supplied just in case.</span>
<span class="comment">*/</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MMAP_FLAGS</span><span class="normal">           </span><span class="symbol">(</span><span class="normal">MAP_PRIVATE</span><span class="symbol">)</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">int</span><span class="normal"> dev_zero_fd </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* Cached file descriptor for /dev/zero. */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALL_MMAP</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">dev_zero_fd </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">           </span><span class="symbol">(</span><span class="normal">dev_zero_fd </span><span class="symbol">=</span><span class="normal"> </span><span class="function">open</span><span class="symbol">(</span><span class="string">"/dev/zero"</span><span class="symbol">,</span><span class="normal"> O_RDWR</span><span class="symbol">),</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">            </span><span class="function">mmap</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">),</span><span class="normal"> MMAP_PROT</span><span class="symbol">,</span><span class="normal"> MMAP_FLAGS</span><span class="symbol">,</span><span class="normal"> dev_zero_fd</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">            </span><span class="function">mmap</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">),</span><span class="normal"> MMAP_PROT</span><span class="symbol">,</span><span class="normal"> MMAP_FLAGS</span><span class="symbol">,</span><span class="normal"> dev_zero_fd</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">))</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* MAP_ANONYMOUS */</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">DIRECT_MMAP</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span><span class="normal">       </span><span class="function">CALL_MMAP</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* WIN32 */</span>

<span class="comment">/* Win32 MMAP via VirtualAlloc */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">win32mmap</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> size</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> ptr </span><span class="symbol">=</span><span class="normal"> </span><span class="function">VirtualAlloc</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">,</span><span class="normal"> size</span><span class="symbol">,</span><span class="normal"> MEM_RESERVE</span><span class="symbol">|</span><span class="normal">MEM_COMMIT</span><span class="symbol">,</span><span class="normal"> PAGE_READWRITE</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ptr </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)?</span><span class="normal"> ptr</span><span class="symbol">:</span><span class="normal"> MFAIL</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">win32direct_mmap</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> size</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> ptr </span><span class="symbol">=</span><span class="normal"> </span><span class="function">VirtualAlloc</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">,</span><span class="normal"> size</span><span class="symbol">,</span><span class="normal"> MEM_RESERVE</span><span class="symbol">|</span><span class="normal">MEM_COMMIT</span><span class="symbol">|</span><span class="normal">MEM_TOP_DOWN</span><span class="symbol">,</span>
<span class="normal">                           PAGE_READWRITE</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ptr </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)?</span><span class="normal"> ptr</span><span class="symbol">:</span><span class="normal"> MFAIL</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* This function supports releasing coalesed segments */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">win32munmap</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*</span><span class="normal"> ptr</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> size</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">MEMORY_BASIC_INFORMATION</span><span class="normal"> minfo</span><span class="symbol">;</span>
<span class="normal">  </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> cptr </span><span class="symbol">=</span><span class="normal"> ptr</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">VirtualQuery</span><span class="symbol">(</span><span class="normal">cptr</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">minfo</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">minfo</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">minfo</span><span class="symbol">.</span><span class="normal">BaseAddress </span><span class="symbol">!=</span><span class="normal"> cptr </span><span class="symbol">||</span><span class="normal"> minfo</span><span class="symbol">.</span><span class="normal">AllocationBase </span><span class="symbol">!=</span><span class="normal"> cptr </span><span class="symbol">||</span>
<span class="normal">        minfo</span><span class="symbol">.</span><span class="normal">State </span><span class="symbol">!=</span><span class="normal"> MEM_COMMIT </span><span class="symbol">||</span><span class="normal"> minfo</span><span class="symbol">.</span><span class="normal">RegionSize </span><span class="symbol">&gt;</span><span class="normal"> size</span><span class="symbol">)</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">VirtualFree</span><span class="symbol">(</span><span class="normal">cptr</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> MEM_RELEASE</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">    cptr </span><span class="symbol">+=</span><span class="normal"> minfo</span><span class="symbol">.</span><span class="normal">RegionSize</span><span class="symbol">;</span>
<span class="normal">    size </span><span class="symbol">-=</span><span class="normal"> minfo</span><span class="symbol">.</span><span class="normal">RegionSize</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALL_MMAP</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span><span class="normal">         </span><span class="function">win32mmap</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALL_MUNMAP</span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">)</span><span class="normal">    </span><span class="function">win32munmap</span><span class="symbol">((</span><span class="normal">a</span><span class="symbol">),</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">DIRECT_MMAP</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span><span class="normal">       </span><span class="function">win32direct_mmap</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* WIN32 */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* HAVE_MMAP */</span>

<span class="preproc">#if</span><span class="normal"> HAVE_MMAP </span><span class="symbol">&amp;&amp;</span><span class="normal"> HAVE_MREMAP</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALL_MREMAP</span><span class="symbol">(</span><span class="normal">addr</span><span class="symbol">,</span><span class="normal"> osz</span><span class="symbol">,</span><span class="normal"> nsz</span><span class="symbol">,</span><span class="normal"> mv</span><span class="symbol">)</span><span class="normal"> </span><span class="function">mremap</span><span class="symbol">((</span><span class="normal">addr</span><span class="symbol">),</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">osz</span><span class="symbol">),</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">nsz</span><span class="symbol">),</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mv</span><span class="symbol">))</span>
<span class="preproc">#else</span><span class="normal">  </span><span class="comment">/* HAVE_MMAP &amp;&amp; HAVE_MREMAP */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALL_MREMAP</span><span class="symbol">(</span><span class="normal">addr</span><span class="symbol">,</span><span class="normal"> osz</span><span class="symbol">,</span><span class="normal"> nsz</span><span class="symbol">,</span><span class="normal"> mv</span><span class="symbol">)</span><span class="normal"> MFAIL</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* HAVE_MMAP &amp;&amp; HAVE_MREMAP */</span>

<span class="preproc">#if</span><span class="normal"> HAVE_MORECORE</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALL_MORECORE</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">)</span><span class="normal">     </span><span class="function">MORECORE</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">)</span>
<span class="preproc">#else</span><span class="normal">  </span><span class="comment">/* HAVE_MORECORE */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALL_MORECORE</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">)</span><span class="normal">     MFAIL</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* HAVE_MORECORE */</span>

<span class="comment">/* mstate bit set if continguous morecore disabled or failed */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">USE_NONCONTIGUOUS_BIT</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">4U</span><span class="symbol">)</span>

<span class="comment">/* segment bit set in create_mspace_with_base */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">EXTERN_BIT</span><span class="normal">            </span><span class="symbol">(</span><span class="normal">8U</span><span class="symbol">)</span>


<span class="comment">/* --------------------------- Lock preliminaries ------------------------ */</span>

<span class="preproc">#if</span><span class="normal"> USE_LOCKS</span>

<span class="comment">/*</span>
<span class="comment">  When locks are defined, there are up to two global locks:</span>

<span class="comment">  * If HAVE_MORECORE, morecore_mutex protects sequences of calls to</span>
<span class="comment">    MORECORE.  In many cases sys_alloc requires two calls, that should</span>
<span class="comment">    not be interleaved with calls by other threads.  This does not</span>
<span class="comment">    protect against direct calls to MORECORE by other threads not</span>
<span class="comment">    using this lock, so there is still code to cope the best we can on</span>
<span class="comment">    interference.</span>

<span class="comment">  * magic_init_mutex ensures that mparams.magic and other</span>
<span class="comment">    unique mparams values are initialized only once.</span>
<span class="comment">*/</span>

<span class="preproc">#ifndef</span><span class="normal"> WIN32</span>
<span class="comment">/* By default use posix locks */</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;pthread.h&gt;</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">MLOCK_T</span><span class="normal"> pthread_mutex_t</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">INITIAL_LOCK</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">)</span><span class="normal">      </span><span class="function">pthread_mutex_init</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">,</span><span class="normal"> NULL</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ACQUIRE_LOCK</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">)</span><span class="normal">      </span><span class="function">pthread_mutex_lock</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">RELEASE_LOCK</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">)</span><span class="normal">      </span><span class="function">pthread_mutex_unlock</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">)</span>

<span class="preproc">#if</span><span class="normal"> HAVE_MORECORE</span>
<span class="keyword">static</span><span class="normal"> </span><span class="usertype">MLOCK_T</span><span class="normal"> morecore_mutex </span><span class="symbol">=</span><span class="normal"> PTHREAD_MUTEX_INITIALIZER</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* HAVE_MORECORE */</span>

<span class="keyword">static</span><span class="normal"> </span><span class="usertype">MLOCK_T</span><span class="normal"> magic_init_mutex </span><span class="symbol">=</span><span class="normal"> PTHREAD_MUTEX_INITIALIZER</span><span class="symbol">;</span>

<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* WIN32 */</span>
<span class="comment">/*</span>
<span class="comment">   Because lock-protected regions have bounded times, and there</span>
<span class="comment">   are no recursive lock calls, we can use simple spinlocks.</span>
<span class="comment">*/</span>

<span class="preproc">#define</span><span class="normal"> MLOCK_T </span><span class="type">long</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">win32_acquire_lock</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">MLOCK_T</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sl</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(;;)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="preproc">#ifdef</span><span class="normal"> InterlockedCompareExchangePointer</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">InterlockedCompareExchange</span><span class="symbol">(</span><span class="normal">sl</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">))</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="preproc">#else</span><span class="normal">  </span><span class="comment">/* Use older void* version */</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">InterlockedCompareExchange</span><span class="symbol">((</span><span class="type">void</span><span class="symbol">**)</span><span class="normal">sl</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*)</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*)</span><span class="number">0</span><span class="symbol">))</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* InterlockedCompareExchangePointer */</span>
<span class="normal">    </span><span class="function">Sleep</span><span class="normal"> </span><span class="symbol">(</span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">win32_release_lock</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">MLOCK_T</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sl</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="function">InterlockedExchange</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sl</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">INITIAL_LOCK</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">)</span><span class="normal">      </span><span class="symbol">*(</span><span class="normal">l</span><span class="symbol">)=</span><span class="number">0</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ACQUIRE_LOCK</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">)</span><span class="normal">      </span><span class="function">win32_acquire_lock</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">RELEASE_LOCK</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">)</span><span class="normal">      </span><span class="function">win32_release_lock</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">)</span>
<span class="preproc">#if</span><span class="normal"> HAVE_MORECORE</span>
<span class="keyword">static</span><span class="normal"> </span><span class="usertype">MLOCK_T</span><span class="normal"> morecore_mutex</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* HAVE_MORECORE */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="usertype">MLOCK_T</span><span class="normal"> magic_init_mutex</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* WIN32 */</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">USE_LOCK_BIT</span><span class="normal">               </span><span class="symbol">(</span><span class="normal">2U</span><span class="symbol">)</span>
<span class="preproc">#else</span><span class="normal">  </span><span class="comment">/* USE_LOCKS */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">USE_LOCK_BIT</span><span class="normal">               </span><span class="symbol">(</span><span class="normal">0U</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">INITIAL_LOCK</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* USE_LOCKS */</span>

<span class="preproc">#if</span><span class="normal"> USE_LOCKS </span><span class="symbol">&amp;&amp;</span><span class="normal"> HAVE_MORECORE</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ACQUIRE_MORECORE_LOCK</span><span class="symbol">()</span><span class="normal">    </span><span class="function">ACQUIRE_LOCK</span><span class="symbol">(&amp;</span><span class="normal">morecore_mutex</span><span class="symbol">);</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">RELEASE_MORECORE_LOCK</span><span class="symbol">()</span><span class="normal">    </span><span class="function">RELEASE_LOCK</span><span class="symbol">(&amp;</span><span class="normal">morecore_mutex</span><span class="symbol">);</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* USE_LOCKS &amp;&amp; HAVE_MORECORE */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ACQUIRE_MORECORE_LOCK</span><span class="symbol">()</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">RELEASE_MORECORE_LOCK</span><span class="symbol">()</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* USE_LOCKS &amp;&amp; HAVE_MORECORE */</span>

<span class="preproc">#if</span><span class="normal"> USE_LOCKS</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ACQUIRE_MAGIC_INIT_LOCK</span><span class="symbol">()</span><span class="normal">  </span><span class="function">ACQUIRE_LOCK</span><span class="symbol">(&amp;</span><span class="normal">magic_init_mutex</span><span class="symbol">);</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">RELEASE_MAGIC_INIT_LOCK</span><span class="symbol">()</span><span class="normal">  </span><span class="function">RELEASE_LOCK</span><span class="symbol">(&amp;</span><span class="normal">magic_init_mutex</span><span class="symbol">);</span>
<span class="preproc">#else</span><span class="normal">  </span><span class="comment">/* USE_LOCKS */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ACQUIRE_MAGIC_INIT_LOCK</span><span class="symbol">()</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">RELEASE_MAGIC_INIT_LOCK</span><span class="symbol">()</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* USE_LOCKS */</span>


<span class="comment">/* -----------------------  Chunk representations ------------------------ */</span>

<span class="comment">/*</span>
<span class="comment">  (The following includes lightly edited explanations by Colin Plumb.)</span>

<span class="comment">  The malloc_chunk declaration below is misleading (but accurate and</span>
<span class="comment">  necessary).  It declares a "view" into memory allowing access to</span>
<span class="comment">  necessary fields at known offsets from a given base.</span>

<span class="comment">  Chunks of memory are maintained using a `boundary tag' method as</span>
<span class="comment">  originally described by Knuth.  (See the paper by Paul Wilson</span>
<span class="comment">  </span><span class="url">ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps</span><span class="comment"> for a survey of such</span>
<span class="comment">  techniques.)  Sizes of free chunks are stored both in the front of</span>
<span class="comment">  each chunk and at the end.  This makes consolidating fragmented</span>
<span class="comment">  chunks into bigger chunks fast.  The head fields also hold bits</span>
<span class="comment">  representing whether chunks are free or in use.</span>

<span class="comment">  Here are some pictures to make it clearer.  They are "exploded" to</span>
<span class="comment">  show that the state of a chunk can be thought of as extending from</span>
<span class="comment">  the high 31 bits of the head field of its header through the</span>
<span class="comment">  prev_foot and PINUSE_BIT bit of the following chunk header.</span>

<span class="comment">  A chunk that's in use looks like:</span>

<span class="comment">   chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">           | Size of previous chunk (if P = 1)                             |</span>
<span class="comment">           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|</span>
<span class="comment">         | Size of this chunk                                         1| +-+</span>
<span class="comment">   mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">         |                                                               |</span>
<span class="comment">         +-                                                             -+</span>
<span class="comment">         |                                                               |</span>
<span class="comment">         +-                                                             -+</span>
<span class="comment">         |                                                               :</span>
<span class="comment">         +-      size - sizeof(size_t) available payload bytes          -+</span>
<span class="comment">         :                                                               |</span>
<span class="comment"> chunk-&gt; +-                                                             -+</span>
<span class="comment">         |                                                               |</span>
<span class="comment">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|</span>
<span class="comment">       | Size of next chunk (may or may not be in use)               | +-+</span>
<span class="comment"> mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>

<span class="comment">    And if it's free, it looks like this:</span>

<span class="comment">   chunk-&gt; +-                                                             -+</span>
<span class="comment">           | User payload (must be in use, or we would have merged!)       |</span>
<span class="comment">           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|</span>
<span class="comment">         | Size of this chunk                                         0| +-+</span>
<span class="comment">   mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">         | Next pointer                                                  |</span>
<span class="comment">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">         | Prev pointer                                                  |</span>
<span class="comment">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">         |                                                               :</span>
<span class="comment">         +-      size - sizeof(struct chunk) unused bytes               -+</span>
<span class="comment">         :                                                               |</span>
<span class="comment"> chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">         | Size of this chunk                                            |</span>
<span class="comment">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|</span>
<span class="comment">       | Size of next chunk (must be in use, or we would have merged)| +-+</span>
<span class="comment"> mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">       |                                                               :</span>
<span class="comment">       +- User payload                                                -+</span>
<span class="comment">       :                                                               |</span>
<span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">                                                                     |0|</span>
<span class="comment">                                                                     +-+</span>
<span class="comment">  Note that since we always merge adjacent free chunks, the chunks</span>
<span class="comment">  adjacent to a free chunk must be in use.</span>

<span class="comment">  Given a pointer to a chunk (which can be derived trivially from the</span>
<span class="comment">  payload pointer) we can, in O(1) time, find out whether the adjacent</span>
<span class="comment">  chunks are free, and if so, unlink them from the lists that they</span>
<span class="comment">  are on and merge them with the current chunk.</span>

<span class="comment">  Chunks always begin on even word boundaries, so the mem portion</span>
<span class="comment">  (which is returned to the user) is also on an even word boundary, and</span>
<span class="comment">  thus at least double-word aligned.</span>

<span class="comment">  The P (PINUSE_BIT) bit, stored in the unused low-order bit of the</span>
<span class="comment">  chunk size (which is always a multiple of two words), is an in-use</span>
<span class="comment">  bit for the *previous* chunk.  If that bit is *clear*, then the</span>
<span class="comment">  word before the current chunk size contains the previous chunk</span>
<span class="comment">  size, and can be used to find the front of the previous chunk.</span>
<span class="comment">  The very first chunk allocated always has this bit set, preventing</span>
<span class="comment">  access to non-existent (or non-owned) memory. If pinuse is set for</span>
<span class="comment">  any given chunk, then you CANNOT determine the size of the</span>
<span class="comment">  previous chunk, and might even get a memory addressing fault when</span>
<span class="comment">  trying to do so.</span>

<span class="comment">  The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of</span>
<span class="comment">  the chunk size redundantly records whether the current chunk is</span>
<span class="comment">  inuse. This redundancy enables usage checks within free and realloc,</span>
<span class="comment">  and reduces indirection when freeing and consolidating chunks.</span>

<span class="comment">  Each freshly allocated chunk must have both cinuse and pinuse set.</span>
<span class="comment">  That is, each allocated chunk borders either a previously allocated</span>
<span class="comment">  and still in-use chunk, or the base of its memory arena. This is</span>
<span class="comment">  ensured by making all allocations from the the `lowest' part of any</span>
<span class="comment">  found chunk.  Further, no free chunk physically borders another one,</span>
<span class="comment">  so each free chunk is known to be preceded and followed by either</span>
<span class="comment">  inuse chunks or the ends of memory.</span>

<span class="comment">  Note that the `foot' of the current chunk is actually represented</span>
<span class="comment">  as the prev_foot of the NEXT chunk. This makes it easier to</span>
<span class="comment">  deal with alignments etc but can be very confusing when trying</span>
<span class="comment">  to extend or adapt this code.</span>

<span class="comment">  The exceptions to all this are</span>

<span class="comment">     1. The special chunk `top' is the top-most available chunk (i.e.,</span>
<span class="comment">        the one bordering the end of available memory). It is treated</span>
<span class="comment">        specially.  Top is never included in any bin, is used only if</span>
<span class="comment">        no other chunk is available, and is released back to the</span>
<span class="comment">        system if it is very large (see M_TRIM_THRESHOLD).  In effect,</span>
<span class="comment">        the top chunk is treated as larger (and thus less well</span>
<span class="comment">        fitting) than any other available chunk.  The top chunk</span>
<span class="comment">        doesn't update its trailing size field since there is no next</span>
<span class="comment">        contiguous chunk that would have to index off it. However,</span>
<span class="comment">        space is still allocated for it (TOP_FOOT_SIZE) to enable</span>
<span class="comment">        separation or merging when space is extended.</span>

<span class="comment">     3. Chunks allocated via mmap, which have the lowest-order bit</span>
<span class="comment">        (IS_MMAPPED_BIT) set in their prev_foot fields, and do not set</span>
<span class="comment">        PINUSE_BIT in their head fields.  Because they are allocated</span>
<span class="comment">        one-by-one, each must carry its own prev_foot field, which is</span>
<span class="comment">        also used to hold the offset this chunk has within its mmapped</span>
<span class="comment">        region, which is needed to preserve alignment. Each mmapped</span>
<span class="comment">        chunk is trailed by the first two fields of a fake next-chunk</span>
<span class="comment">        for sake of usage checks.</span>

<span class="comment">*/</span>

<span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_chunk</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">               prev_foot</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">/* Size of previous chunk (if free).  */</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">               head</span><span class="symbol">;</span><span class="normal">       </span><span class="comment">/* Size and inuse bits. */</span>
<span class="normal">  </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_chunk</span><span class="symbol">*</span><span class="normal"> fd</span><span class="symbol">;</span><span class="normal">         </span><span class="comment">/* double links -- used only if free. */</span>
<span class="normal">  </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_chunk</span><span class="symbol">*</span><span class="normal"> bk</span><span class="symbol">;</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_chunk</span><span class="normal">  mchunk</span><span class="symbol">;</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_chunk</span><span class="symbol">*</span><span class="normal"> mchunkptr</span><span class="symbol">;</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_chunk</span><span class="symbol">*</span><span class="normal"> sbinptr</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">/* The type of bins of chunks */</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> bindex_t</span><span class="symbol">;</span><span class="normal">               </span><span class="comment">/* Described below */</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> binmap_t</span><span class="symbol">;</span><span class="normal">         </span><span class="comment">/* Described below */</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> flag_t</span><span class="symbol">;</span><span class="normal">           </span><span class="comment">/* The type of various bit flag sets */</span>

<span class="comment">/* ------------------- Chunks sizes and alignments ----------------------- */</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">MCHUNK_SIZE</span><span class="normal">         </span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">mchunk</span><span class="symbol">))</span>

<span class="preproc">#if</span><span class="normal"> FOOTERS</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CHUNK_OVERHEAD</span><span class="normal">      </span><span class="symbol">(</span><span class="normal">TWO_SIZE_T_SIZES</span><span class="symbol">)</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CHUNK_OVERHEAD</span><span class="normal">      </span><span class="symbol">(</span><span class="normal">SIZE_T_SIZE</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>

<span class="comment">/* MMapped chunks need a second word of overhead ... */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MMAP_CHUNK_OVERHEAD</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">TWO_SIZE_T_SIZES</span><span class="symbol">)</span>
<span class="comment">/* ... and additional padding for fake next-chunk at foot */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MMAP_FOOT_PAD</span><span class="normal">       </span><span class="symbol">(</span><span class="normal">FOUR_SIZE_T_SIZES</span><span class="symbol">)</span>

<span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span>
<span class="preproc">#define</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">MCHUNK_SIZE </span><span class="symbol">+</span><span class="normal"> CHUNK_ALIGN_MASK</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">CHUNK_ALIGN_MASK</span><span class="symbol">)</span>

<span class="comment">/* conversion from malloc headers to user pointers, and back */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">        </span><span class="symbol">((</span><span class="type">void</span><span class="symbol">*)((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">       </span><span class="symbol">+</span><span class="normal"> TWO_SIZE_T_SIZES</span><span class="symbol">))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">)</span><span class="normal">      </span><span class="symbol">((</span><span class="normal">mchunkptr</span><span class="symbol">)((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">mem</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> TWO_SIZE_T_SIZES</span><span class="symbol">))</span>
<span class="comment">/* chunk associated with aligned address A */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">align_as_chunk</span><span class="symbol">(</span><span class="normal">A</span><span class="symbol">)</span><span class="normal">   </span><span class="symbol">(</span><span class="normal">mchunkptr</span><span class="symbol">)((</span><span class="normal">A</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="function">align_offset</span><span class="symbol">(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">A</span><span class="symbol">)))</span>

<span class="comment">/* Bounds on request (not chunk) sizes. */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MAX_REQUEST</span><span class="normal">         </span><span class="symbol">((-</span><span class="normal">MIN_CHUNK_SIZE</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">2</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MIN_REQUEST</span><span class="normal">         </span><span class="symbol">(</span><span class="normal">MIN_CHUNK_SIZE </span><span class="symbol">-</span><span class="normal"> CHUNK_OVERHEAD </span><span class="symbol">-</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">)</span>

<span class="comment">/* pad request bytes into a usable size */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">pad_request</span><span class="symbol">(</span><span class="normal">req</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">   </span><span class="symbol">(((</span><span class="normal">req</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> CHUNK_OVERHEAD </span><span class="symbol">+</span><span class="normal"> CHUNK_ALIGN_MASK</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">CHUNK_ALIGN_MASK</span><span class="symbol">)</span>

<span class="comment">/* pad request, checking for minimum (but not maximum) */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">request2size</span><span class="symbol">(</span><span class="normal">req</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">  </span><span class="symbol">(((</span><span class="normal">req</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> MIN_REQUEST</span><span class="symbol">)?</span><span class="normal"> MIN_CHUNK_SIZE </span><span class="symbol">:</span><span class="normal"> </span><span class="function">pad_request</span><span class="symbol">(</span><span class="normal">req</span><span class="symbol">))</span>


<span class="comment">/* ------------------ Operations on head and foot fields ----------------- */</span>

<span class="comment">/*</span>
<span class="comment">  The head field of a chunk is or'ed with PINUSE_BIT when previous</span>
<span class="comment">  adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in</span>
<span class="comment">  use. If the chunk was obtained with mmap, the prev_foot field has</span>
<span class="comment">  IS_MMAPPED_BIT set, otherwise holding the offset of the base of the</span>
<span class="comment">  mmapped region to the base of the chunk.</span>
<span class="comment">*/</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">PINUSE_BIT</span><span class="normal">          </span><span class="symbol">(</span><span class="normal">SIZE_T_ONE</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CINUSE_BIT</span><span class="normal">          </span><span class="symbol">(</span><span class="normal">SIZE_T_TWO</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">INUSE_BITS</span><span class="normal">          </span><span class="symbol">(</span><span class="normal">PINUSE_BIT</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">)</span>

<span class="comment">/* Head value for fenceposts */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">FENCEPOST_HEAD</span><span class="normal">      </span><span class="symbol">(</span><span class="normal">INUSE_BITS</span><span class="symbol">|</span><span class="normal">SIZE_T_SIZE</span><span class="symbol">)</span>

<span class="comment">/* extraction of fields from head words */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">           </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">&amp;</span><span class="normal"> CINUSE_BIT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">           </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">&amp;</span><span class="normal"> PINUSE_BIT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">        </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~(</span><span class="normal">INUSE_BITS</span><span class="symbol">))</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">clear_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">     </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">&amp;=</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">PINUSE_BIT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">clear_cinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">     </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">&amp;=</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">CINUSE_BIT</span><span class="symbol">)</span>

<span class="comment">/* Treat space at ptr +/- offset as a chunk */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">((</span><span class="normal">mchunkptr</span><span class="symbol">)(((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">chunk_minus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">mchunkptr</span><span class="symbol">)(((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)))</span>

<span class="comment">/* Ptr to next or previous physical malloc_chunk. */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">next_chunk</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">mchunkptr</span><span class="symbol">)(</span><span class="normal"> </span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">INUSE_BITS</span><span class="symbol">)))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">prev_chunk</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">mchunkptr</span><span class="symbol">)(</span><span class="normal"> </span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">prev_foot</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">))</span>

<span class="comment">/* extract next chunk's pinuse bit */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">next_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">((</span><span class="function">next_chunk</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> PINUSE_BIT</span><span class="symbol">)</span>

<span class="comment">/* Get/set size at footer */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">get_foot</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">(((</span><span class="normal">mchunkptr</span><span class="symbol">)((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)))-&gt;</span><span class="normal">prev_foot</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">set_foot</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">(((</span><span class="normal">mchunkptr</span><span class="symbol">)((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)))-&gt;</span><span class="normal">prev_foot </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">))</span>

<span class="comment">/* Set size, pinuse bit, and foot */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">|</span><span class="normal">PINUSE_BIT</span><span class="symbol">),</span><span class="normal"> </span><span class="function">set_foot</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">))</span>

<span class="comment">/* Set size, pinuse bit, foot, and clear next pinuse */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">set_free_with_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">,</span><span class="normal"> n</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">(</span><span class="function">clear_pinuse</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">),</span><span class="normal"> </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">))</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">(!((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">&amp;</span><span class="normal"> PINUSE_BIT</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">prev_foot </span><span class="symbol">&amp;</span><span class="normal"> IS_MMAPPED_BIT</span><span class="symbol">))</span>

<span class="comment">/* Get the internal overhead associated with chunk p */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">overhead_for</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)\</span>
<span class="normal"> </span><span class="symbol">(</span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)?</span><span class="normal"> MMAP_CHUNK_OVERHEAD </span><span class="symbol">:</span><span class="normal"> CHUNK_OVERHEAD</span><span class="symbol">)</span>

<span class="comment">/* Return true if malloced space is not necessarily cleared */</span>
<span class="preproc">#if</span><span class="normal"> MMAP_CLEARS</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">calloc_must_clear</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">))</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* MMAP_CLEARS */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">calloc_must_clear</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">(</span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* MMAP_CLEARS */</span>

<span class="comment">/* ---------------------- Overlaid data structures ----------------------- */</span>

<span class="comment">/*</span>
<span class="comment">  When chunks are not in use, they are treated as nodes of either</span>
<span class="comment">  lists or trees.</span>

<span class="comment">  "Small"  chunks are stored in circular doubly-linked lists, and look</span>
<span class="comment">  like this:</span>

<span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             Size of previous chunk                            |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">    `head:' |             Size of chunk, in bytes                         |P|</span>
<span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             Forward pointer to next chunk in list             |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             Back pointer to previous chunk in list            |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             Unused space (may be 0 bytes long)                .</span>
<span class="comment">            .                                                               .</span>
<span class="comment">            .                                                               |</span>
<span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">    `foot:' |             Size of chunk, in bytes                           |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>

<span class="comment">  Larger chunks are kept in a form of bitwise digital trees (aka</span>
<span class="comment">  tries) keyed on chunksizes.  Because malloc_tree_chunks are only for</span>
<span class="comment">  free chunks greater than 256 bytes, their size doesn't impose any</span>
<span class="comment">  constraints on user chunk sizes.  Each node looks like:</span>

<span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             Size of previous chunk                            |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">    `head:' |             Size of chunk, in bytes                         |P|</span>
<span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             Forward pointer to next chunk of same size        |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             Back pointer to previous chunk of same size       |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             Pointer to left child (child[0])                  |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             Pointer to right child (child[1])                 |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             Pointer to parent                                 |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             bin index of this chunk                           |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">            |             Unused space                                      .</span>
<span class="comment">            .                                                               |</span>
<span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="comment">    `foot:' |             Size of chunk, in bytes                           |</span>
<span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>

<span class="comment">  Each tree holding treenodes is a tree of unique chunk sizes.  Chunks</span>
<span class="comment">  of the same size are arranged in a circularly-linked list, with only</span>
<span class="comment">  the oldest chunk (the next to be used, in our FIFO ordering)</span>
<span class="comment">  actually in the tree.  (Tree members are distinguished by a non-null</span>
<span class="comment">  parent pointer.)  If a chunk with the same size an an existing node</span>
<span class="comment">  is inserted, it is linked off the existing node using pointers that</span>
<span class="comment">  work in the same way as fd/bk pointers of small chunks.</span>

<span class="comment">  Each tree contains a power of 2 sized range of chunk sizes (the</span>
<span class="comment">  smallest is 0x100 &lt;= x &lt; 0x180), which is is divided in half at each</span>
<span class="comment">  tree level, with the chunks in the smaller half of the range (0x100</span>
<span class="comment">  &lt;= x &lt; 0x140 for the top nose) in the left subtree and the larger</span>
<span class="comment">  half (0x140 &lt;= x &lt; 0x180) in the right subtree.  This is, of course,</span>
<span class="comment">  done by inspecting individual bits.</span>

<span class="comment">  Using these rules, each node's left subtree contains all smaller</span>
<span class="comment">  sizes than its right subtree.  However, the node at the root of each</span>
<span class="comment">  subtree has no particular ordering relationship to either.  (The</span>
<span class="comment">  dividing line between the subtree sizes is based on trie relation.)</span>
<span class="comment">  If we remove the last chunk of a given size from the interior of the</span>
<span class="comment">  tree, we need to replace it with a leaf node.  The tree ordering</span>
<span class="comment">  rules permit a node to be replaced by any leaf below it.</span>

<span class="comment">  The smallest chunk in a tree (a common operation in a best-fit</span>
<span class="comment">  allocator) can be found by walking a path to the leftmost leaf in</span>
<span class="comment">  the tree.  Unlike a usual binary tree, where we follow left child</span>
<span class="comment">  pointers until we reach a null, here we follow the right child</span>
<span class="comment">  pointer any time the left one is null, until we reach a leaf with</span>
<span class="comment">  both child pointers null. The smallest chunk in the tree will be</span>
<span class="comment">  somewhere along that path.</span>

<span class="comment">  The worst case number of steps to add, find, or remove a node is</span>
<span class="comment">  bounded by the number of bits differentiating chunks within</span>
<span class="comment">  bins. Under current bin calculations, this ranges from 6 up to 21</span>
<span class="comment">  (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case</span>
<span class="comment">  is of course much better.</span>
<span class="comment">*/</span>

<span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_tree_chunk</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="comment">/* The first four fields must be compatible with malloc_chunk */</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">                    prev_foot</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">                    head</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_tree_chunk</span><span class="symbol">*</span><span class="normal"> fd</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_tree_chunk</span><span class="symbol">*</span><span class="normal"> bk</span><span class="symbol">;</span>

<span class="normal">  </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_tree_chunk</span><span class="symbol">*</span><span class="normal"> child</span><span class="symbol">[</span><span class="number">2</span><span class="symbol">];</span>
<span class="normal">  </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_tree_chunk</span><span class="symbol">*</span><span class="normal"> parent</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">bindex_t</span><span class="normal">                  index</span><span class="symbol">;</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_tree_chunk</span><span class="normal">  tchunk</span><span class="symbol">;</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_tree_chunk</span><span class="symbol">*</span><span class="normal"> tchunkptr</span><span class="symbol">;</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_tree_chunk</span><span class="symbol">*</span><span class="normal"> tbinptr</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* The type of bins of trees */</span>

<span class="comment">/* A little helper macro for trees */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">leftmost_child</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">t</span><span class="symbol">)-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">?</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])</span>

<span class="comment">/* ----------------------------- Segments -------------------------------- */</span>

<span class="comment">/*</span>
<span class="comment">  Each malloc space may include non-contiguous segments, held in a</span>
<span class="comment">  list headed by an embedded malloc_segment record representing the</span>
<span class="comment">  top-most space. Segments also include flags holding properties of</span>
<span class="comment">  the space. Large chunks that are directly allocated by mmap are not</span>
<span class="comment">  included in this list. They are instead independently created and</span>
<span class="comment">  destroyed without otherwise keeping track of them.</span>

<span class="comment">  Segment management mainly comes into play for spaces allocated by</span>
<span class="comment">  MMAP.  Any call to MMAP might or might not return memory that is</span>
<span class="comment">  adjacent to an existing segment.  MORECORE normally contiguously</span>
<span class="comment">  extends the current space, so this space is almost always adjacent,</span>
<span class="comment">  which is simpler and faster to deal with. (This is why MORECORE is</span>
<span class="comment">  used preferentially to MMAP when both are available -- see</span>
<span class="comment">  sys_alloc.)  When allocating using MMAP, we don't use any of the</span>
<span class="comment">  hinting mechanisms (inconsistently) supported in various</span>
<span class="comment">  implementations of unix mmap, or distinguish reserving from</span>
<span class="comment">  committing memory. Instead, we just ask for space, and exploit</span>
<span class="comment">  contiguity when we get it.  It is probably possible to do</span>
<span class="comment">  better than this on some systems, but no general scheme seems</span>
<span class="comment">  to be significantly better.</span>

<span class="comment">  Management entails a simpler variant of the consolidation scheme</span>
<span class="comment">  used for chunks to reduce fragmentation -- new adjacent memory is</span>
<span class="comment">  normally prepended or appended to an existing segment. However,</span>
<span class="comment">  there are limitations compared to chunk consolidation that mostly</span>
<span class="comment">  reflect the fact that segment processing is relatively infrequent</span>
<span class="comment">  (occurring only when getting memory from system) and that we</span>
<span class="comment">  don't expect to have huge numbers of segments:</span>

<span class="comment">  * Segments are not indexed, so traversal requires linear scans.  (It</span>
<span class="comment">    would be possible to index these, but is not worth the extra</span>
<span class="comment">    overhead and complexity for most programs on most platforms.)</span>
<span class="comment">  * New segments are only appended to old ones when holding top-most</span>
<span class="comment">    memory; if they cannot be prepended to others, they are held in</span>
<span class="comment">    different segments.</span>

<span class="comment">  Except for the top-most segment of an mstate, each segment record</span>
<span class="comment">  is kept at the tail of its segment. Segments are added by pushing</span>
<span class="comment">  segment records onto the list headed by &amp;mstate.seg for the</span>
<span class="comment">  containing mstate.</span>

<span class="comment">  Segment flags control allocation/merge/deallocation policies:</span>
<span class="comment">  * If EXTERN_BIT set, then we did not allocate this segment,</span>
<span class="comment">    and so should not try to deallocate or merge with others.</span>
<span class="comment">    (This currently holds only for the initial segment passed</span>
<span class="comment">    into create_mspace_with_base.)</span>
<span class="comment">  * If IS_MMAPPED_BIT set, the segment may be merged with</span>
<span class="comment">    other surrounding mmapped segments and trimmed/de-allocated</span>
<span class="comment">    using munmap.</span>
<span class="comment">  * If neither bit is set, then the segment was obtained using</span>
<span class="comment">    MORECORE so can be merged with surrounding MORECORE'd segments</span>
<span class="comment">    and deallocated/trimmed using MORECORE with negative arguments.</span>
<span class="comment">*/</span>

<span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_segment</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="type">char</span><span class="symbol">*</span><span class="normal">        base</span><span class="symbol">;</span><span class="normal">             </span><span class="comment">/* base address */</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">       size</span><span class="symbol">;</span><span class="normal">             </span><span class="comment">/* allocated size */</span>
<span class="normal">  </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_segment</span><span class="symbol">*</span><span class="normal"> next</span><span class="symbol">;</span><span class="normal">   </span><span class="comment">/* ptr to next segment */</span>
<span class="normal">  </span><span class="usertype">flag_t</span><span class="normal">       sflags</span><span class="symbol">;</span><span class="normal">           </span><span class="comment">/* mmap and extern flag */</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">is_mmapped_segment</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">((</span><span class="normal">S</span><span class="symbol">)-&gt;</span><span class="normal">sflags </span><span class="symbol">&amp;</span><span class="normal"> IS_MMAPPED_BIT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">is_extern_segment</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">)</span><span class="normal">   </span><span class="symbol">((</span><span class="normal">S</span><span class="symbol">)-&gt;</span><span class="normal">sflags </span><span class="symbol">&amp;</span><span class="normal"> EXTERN_BIT</span><span class="symbol">)</span>

<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_segment</span><span class="normal">  msegment</span><span class="symbol">;</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_segment</span><span class="symbol">*</span><span class="normal"> msegmentptr</span><span class="symbol">;</span>

<span class="comment">/* ---------------------------- malloc_state ----------------------------- */</span>

<span class="comment">/*</span>
<span class="comment">   A malloc_state holds all of the bookkeeping for a space.</span>
<span class="comment">   The main fields are:</span>

<span class="comment">  Top</span>
<span class="comment">    The topmost chunk of the currently active segment. Its size is</span>
<span class="comment">    cached in topsize.  The actual size of topmost space is</span>
<span class="comment">    topsize+TOP_FOOT_SIZE, which includes space reserved for adding</span>
<span class="comment">    fenceposts and segment records if necessary when getting more</span>
<span class="comment">    space from the system.  The size at which to autotrim top is</span>
<span class="comment">    cached from mparams in trim_check, except that it is disabled if</span>
<span class="comment">    an autotrim fails.</span>

<span class="comment">  Designated victim (dv)</span>
<span class="comment">    This is the preferred chunk for servicing small requests that</span>
<span class="comment">    don't have exact fits.  It is normally the chunk split off most</span>
<span class="comment">    recently to service another small request.  Its size is cached in</span>
<span class="comment">    dvsize. The link fields of this chunk are not maintained since it</span>
<span class="comment">    is not kept in a bin.</span>

<span class="comment">  SmallBins</span>
<span class="comment">    An array of bin headers for free chunks.  These bins hold chunks</span>
<span class="comment">    with sizes less than MIN_LARGE_SIZE bytes. Each bin contains</span>
<span class="comment">    chunks of all the same size, spaced 8 bytes apart.  To simplify</span>
<span class="comment">    use in double-linked lists, each bin header acts as a malloc_chunk</span>
<span class="comment">    pointing to the real first node, if it exists (else pointing to</span>
<span class="comment">    itself).  This avoids special-casing for headers.  But to avoid</span>
<span class="comment">    waste, we allocate only the fd/bk pointers of bins, and then use</span>
<span class="comment">    repositioning tricks to treat these as the fields of a chunk.</span>

<span class="comment">  TreeBins</span>
<span class="comment">    Treebins are pointers to the roots of trees holding a range of</span>
<span class="comment">    sizes. There are 2 equally spaced treebins for each power of two</span>
<span class="comment">    from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything</span>
<span class="comment">    larger.</span>

<span class="comment">  Bin maps</span>
<span class="comment">    There is one bit map for small bins ("smallmap") and one for</span>
<span class="comment">    treebins ("treemap).  Each bin sets its bit when non-empty, and</span>
<span class="comment">    clears the bit when empty.  Bit operations are then used to avoid</span>
<span class="comment">    bin-by-bin searching -- nearly all "search" is done without ever</span>
<span class="comment">    looking at bins that won't be selected.  The bit maps</span>
<span class="comment">    conservatively use 32 bits per map word, even if on 64bit system.</span>
<span class="comment">    For a good description of some of the bit-based techniques used</span>
<span class="comment">    here, see Henry S. Warren Jr's book "Hacker's Delight" (and</span>
<span class="comment">    supplement at </span><span class="url">http://hackersdelight.org/</span><span class="comment">). Many of these are</span>
<span class="comment">    intended to reduce the branchiness of paths through malloc etc, as</span>
<span class="comment">    well as to reduce the number of memory locations read or written.</span>

<span class="comment">  Segments</span>
<span class="comment">    A list of segments headed by an embedded malloc_segment record</span>
<span class="comment">    representing the initial space.</span>

<span class="comment">  Address check support</span>
<span class="comment">    The least_addr field is the least address ever obtained from</span>
<span class="comment">    MORECORE or MMAP. Attempted frees and reallocs of any address less</span>
<span class="comment">    than this are trapped (unless INSECURE is defined).</span>

<span class="comment">  Magic tag</span>
<span class="comment">    A cross-check field that should always hold same value as mparams.magic.</span>

<span class="comment">  Flags</span>
<span class="comment">    Bits recording whether to use MMAP, locks, or contiguous MORECORE</span>

<span class="comment">  Statistics</span>
<span class="comment">    Each space keeps track of current and maximum system memory</span>
<span class="comment">    obtained via MORECORE or MMAP.</span>

<span class="comment">  Locking</span>
<span class="comment">    If USE_LOCKS is defined, the "mutex" lock is acquired and released</span>
<span class="comment">    around every public call using this mspace.</span>
<span class="comment">*/</span>

<span class="comment">/* Bin types, widths and sizes */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">NSMALLBINS</span><span class="normal">        </span><span class="symbol">(</span><span class="normal">32U</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">NTREEBINS</span><span class="normal">         </span><span class="symbol">(</span><span class="normal">32U</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">SMALLBIN_SHIFT</span><span class="normal">    </span><span class="symbol">(</span><span class="normal">3U</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">SMALLBIN_WIDTH</span><span class="normal">    </span><span class="symbol">(</span><span class="normal">SIZE_T_ONE </span><span class="symbol">&lt;&lt;</span><span class="normal"> SMALLBIN_SHIFT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">TREEBIN_SHIFT</span><span class="normal">     </span><span class="symbol">(</span><span class="normal">8U</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MIN_LARGE_SIZE</span><span class="normal">    </span><span class="symbol">(</span><span class="normal">SIZE_T_ONE </span><span class="symbol">&lt;&lt;</span><span class="normal"> TREEBIN_SHIFT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MAX_SMALL_SIZE</span><span class="normal">    </span><span class="symbol">(</span><span class="normal">MIN_LARGE_SIZE </span><span class="symbol">-</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MAX_SMALL_REQUEST</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">MAX_SMALL_SIZE </span><span class="symbol">-</span><span class="normal"> CHUNK_ALIGN_MASK </span><span class="symbol">-</span><span class="normal"> CHUNK_OVERHEAD</span><span class="symbol">)</span>

<span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_state</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">binmap_t</span><span class="normal">   smallmap</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">binmap_t</span><span class="normal">   treemap</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">     dvsize</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">     topsize</span><span class="symbol">;</span>
<span class="normal">  </span><span class="type">char</span><span class="symbol">*</span><span class="normal">      least_addr</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal">  dv</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal">  top</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">     trim_check</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">     magic</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal">  smallbins</span><span class="symbol">[(</span><span class="normal">NSMALLBINS</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">)*</span><span class="number">2</span><span class="symbol">];</span>
<span class="normal">  </span><span class="usertype">tbinptr</span><span class="normal">    treebins</span><span class="symbol">[</span><span class="normal">NTREEBINS</span><span class="symbol">];</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">     footprint</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">     max_footprint</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">flag_t</span><span class="normal">     mflags</span><span class="symbol">;</span>
<span class="preproc">#if</span><span class="normal"> USE_LOCKS</span>
<span class="normal">  </span><span class="usertype">MLOCK_T</span><span class="normal">    mutex</span><span class="symbol">;</span><span class="normal">     </span><span class="comment">/* locate lock among fields that rarely change */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* USE_LOCKS */</span>
<span class="normal">  </span><span class="usertype">msegment</span><span class="normal">   seg</span><span class="symbol">;</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_state</span><span class="symbol">*</span><span class="normal">    mstate</span><span class="symbol">;</span>

<span class="comment">/* ------------- Global malloc_state and malloc_params ------------------- */</span>

<span class="comment">/*</span>
<span class="comment">  malloc_params holds global properties, including those that can be</span>
<span class="comment">  dynamically set using mallopt. There is a single instance, mparams,</span>
<span class="comment">  initialized in init_mparams.</span>
<span class="comment">*/</span>

<span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_params</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> magic</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> page_size</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> granularity</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> mmap_threshold</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> trim_threshold</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">flag_t</span><span class="normal"> default_mflags</span><span class="symbol">;</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">static</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_params</span><span class="normal"> mparams</span><span class="symbol">;</span>

<span class="comment">/* The global malloc_state used for all non-"mspace" calls */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_state</span><span class="normal"> _gm_</span><span class="symbol">;</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">gm</span><span class="normal">                 </span><span class="symbol">(&amp;</span><span class="normal">_gm_</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">is_global</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">       </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">_gm_</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">is_initialized</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">top </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>

<span class="comment">/* -------------------------- system alloc setup ------------------------- */</span>

<span class="comment">/* Operations on mflags */</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">use_lock</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">           </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mflags </span><span class="symbol">&amp;</span><span class="normal">   USE_LOCK_BIT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">enable_lock</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">        </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mflags </span><span class="symbol">|=</span><span class="normal">  USE_LOCK_BIT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">disable_lock</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">       </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mflags </span><span class="symbol">&amp;=</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">USE_LOCK_BIT</span><span class="symbol">)</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">use_mmap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">           </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mflags </span><span class="symbol">&amp;</span><span class="normal">   USE_MMAP_BIT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">enable_mmap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">        </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mflags </span><span class="symbol">|=</span><span class="normal">  USE_MMAP_BIT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">disable_mmap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">       </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mflags </span><span class="symbol">&amp;=</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">USE_MMAP_BIT</span><span class="symbol">)</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">use_noncontiguous</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mflags </span><span class="symbol">&amp;</span><span class="normal">   USE_NONCONTIGUOUS_BIT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">disable_contiguous</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mflags </span><span class="symbol">|=</span><span class="normal">  USE_NONCONTIGUOUS_BIT</span><span class="symbol">)</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">set_lock</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">L</span><span class="symbol">)\</span>
<span class="normal"> </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mflags </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">L</span><span class="symbol">)?\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mflags </span><span class="symbol">|</span><span class="normal"> USE_LOCK_BIT</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mflags </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">USE_LOCK_BIT</span><span class="symbol">))</span>

<span class="comment">/* page-align a size */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">page_align</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">)\</span>
<span class="normal"> </span><span class="symbol">(((</span><span class="normal">S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">page_size</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">page_size </span><span class="symbol">-</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">))</span>

<span class="comment">/* granularity-align a size */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">granularity_align</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">(((</span><span class="normal">S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">granularity</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">granularity </span><span class="symbol">-</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">))</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">is_page_aligned</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">)\</span>
<span class="normal">   </span><span class="symbol">(((</span><span class="normal">size_t</span><span class="symbol">)(</span><span class="normal">S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">page_size </span><span class="symbol">-</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">is_granularity_aligned</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">)\</span>
<span class="normal">   </span><span class="symbol">(((</span><span class="normal">size_t</span><span class="symbol">)(</span><span class="normal">S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">granularity </span><span class="symbol">-</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>

<span class="comment">/*  True if segment S holds address A */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">segment_holds</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">,</span><span class="normal"> A</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">A</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;=</span><span class="normal"> S</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">A</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> S</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">+</span><span class="normal"> S</span><span class="symbol">-&gt;</span><span class="normal">size</span><span class="symbol">)</span>

<span class="comment">/* Return segment holding given address */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="usertype">msegmentptr</span><span class="normal"> </span><span class="function">segment_holding</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> addr</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">msegmentptr</span><span class="normal"> sp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(;;)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">addr </span><span class="symbol">&gt;=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">&amp;&amp;</span><span class="normal"> addr </span><span class="symbol">&lt;</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">+</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">size</span><span class="symbol">)</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> sp</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">sp </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">next</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="comment">/* Return true if segment contains a segment link */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">has_segment_link</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">msegmentptr</span><span class="normal"> ss</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">msegmentptr</span><span class="normal"> sp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(;;)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">sp </span><span class="symbol">&gt;=</span><span class="normal"> ss</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">sp </span><span class="symbol">&lt;</span><span class="normal"> ss</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">+</span><span class="normal"> ss</span><span class="symbol">-&gt;</span><span class="normal">size</span><span class="symbol">)</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">sp </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">next</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="preproc">#ifndef</span><span class="normal"> MORECORE_CANNOT_TRIM</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">should_trim</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">s</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">((</span><span class="normal">s</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">trim_check</span><span class="symbol">)</span>
<span class="preproc">#else</span><span class="normal">  </span><span class="comment">/* MORECORE_CANNOT_TRIM */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">should_trim</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">s</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* MORECORE_CANNOT_TRIM */</span>

<span class="comment">/*</span>
<span class="comment">  TOP_FOOT_SIZE is padding at the end of a segment, including space</span>
<span class="comment">  that may be needed to place segment records and fenceposts when new</span>
<span class="comment">  noncontiguous segments are added.</span>
<span class="comment">*/</span>
<span class="preproc">#define</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">\</span>
<span class="normal">  </span><span class="symbol">(</span><span class="function">align_offset</span><span class="symbol">(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">))+</span><span class="function">pad_request</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_segment</span><span class="symbol">))+</span><span class="normal">MIN_CHUNK_SIZE</span><span class="symbol">)</span>


<span class="comment">/* -------------------------------  Hooks -------------------------------- */</span>

<span class="comment">/*</span>
<span class="comment">  PREACTION should be defined to return 0 on success, and nonzero on</span>
<span class="comment">  failure. If you are not using locking, you can redefine these to do</span>
<span class="comment">  anything you like.</span>
<span class="comment">*/</span>

<span class="preproc">#if</span><span class="normal"> USE_LOCKS</span>

<span class="comment">/* Ensure locks are initialized */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">GLOBALLY_INITIALIZE</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">page_size </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">init_mparams</span><span class="symbol">())</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">((</span><span class="function">GLOBALLY_INITIALIZE</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">use_lock</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">))?</span><span class="normal"> </span><span class="function">ACQUIRE_LOCK</span><span class="symbol">(&amp;(</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mutex</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">use_lock</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">))</span><span class="normal"> </span><span class="function">RELEASE_LOCK</span><span class="symbol">(&amp;(</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">mutex</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* USE_LOCKS */</span>

<span class="preproc">#ifndef</span><span class="normal"> PREACTION</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* PREACTION */</span>

<span class="preproc">#ifndef</span><span class="normal"> POSTACTION</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal">  </span><span class="comment">/* POSTACTION */</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* USE_LOCKS */</span>

<span class="comment">/*</span>
<span class="comment">  CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.</span>
<span class="comment">  USAGE_ERROR_ACTION is triggered on detected bad frees and</span>
<span class="comment">  reallocs. The argument p is an address that might have triggered the</span>
<span class="comment">  fault. It is ignored by the two predefined actions, but might be</span>
<span class="comment">  useful in custom actions that try to help diagnose errors.</span>
<span class="comment">*/</span>

<span class="preproc">#if</span><span class="normal"> PROCEED_ON_ERROR</span>

<span class="comment">/* A count of the number of corruption errors causing resets */</span>
<span class="type">int</span><span class="normal"> malloc_corruption_error_count</span><span class="symbol">;</span>

<span class="comment">/* default corruption action */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">reset_on_error</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">);</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">)</span><span class="normal">  </span><span class="function">reset_on_error</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">)</span>

<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* PROCEED_ON_ERROR */</span>

<span class="preproc">#ifndef</span><span class="normal"> CORRUPTION_ERROR_ACTION</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">)</span><span class="normal"> ABORT</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* CORRUPTION_ERROR_ACTION */</span>

<span class="preproc">#ifndef</span><span class="normal"> USAGE_ERROR_ACTION</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> ABORT</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* USAGE_ERROR_ACTION */</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* PROCEED_ON_ERROR */</span>

<span class="comment">/* -------------------------- Debugging setup ---------------------------- */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal"> DEBUG</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_free_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_inuse_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">,</span><span class="normal">N</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_mmapped_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_malloc_state</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_top_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span>

<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* DEBUG */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_free_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span><span class="normal">       </span><span class="function">do_check_free_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_inuse_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span><span class="normal">      </span><span class="function">do_check_inuse_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_top_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span><span class="normal">        </span><span class="function">do_check_top_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">,</span><span class="normal">N</span><span class="symbol">)</span><span class="normal"> </span><span class="function">do_check_malloced_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">,</span><span class="normal">N</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_mmapped_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span><span class="normal">    </span><span class="function">do_check_mmapped_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">P</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">check_malloc_state</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">       </span><span class="function">do_check_malloc_state</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span>

<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal">   </span><span class="function">do_check_any_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal">   </span><span class="function">do_check_top_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal">   </span><span class="function">do_check_mmapped_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal">   </span><span class="function">do_check_inuse_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal">   </span><span class="function">do_check_free_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal">   </span><span class="function">do_check_malloced_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> s</span><span class="symbol">);</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal">   </span><span class="function">do_check_tree</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">tchunkptr</span><span class="normal"> t</span><span class="symbol">);</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal">   </span><span class="function">do_check_treebin</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">bindex_t</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal">   </span><span class="function">do_check_smallbin</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">bindex_t</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal">   </span><span class="function">do_check_malloc_state</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">);</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">int</span><span class="normal">    </span><span class="function">bin_find</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> x</span><span class="symbol">);</span>
<span class="keyword">static</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> </span><span class="function">traverse_and_check</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">);</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* DEBUG */</span>

<span class="comment">/* ---------------------------- Indexing Bins ---------------------------- */</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">is_small</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span><span class="normal">         </span><span class="symbol">(((</span><span class="normal">s</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> SMALLBIN_SHIFT</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> NSMALLBINS</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">small_index</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)</span><span class="normal">      </span><span class="symbol">((</span><span class="normal">s</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">&gt;&gt;</span><span class="normal"> SMALLBIN_SHIFT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">i</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">&lt;&lt;</span><span class="normal"> SMALLBIN_SHIFT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">MIN_SMALL_INDEX</span><span class="normal">     </span><span class="symbol">(</span><span class="function">small_index</span><span class="symbol">(</span><span class="normal">MIN_CHUNK_SIZE</span><span class="symbol">))</span>

<span class="comment">/* addressing by index. See above about smallbin repositioning */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">smallbin_at</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">)</span><span class="normal">   </span><span class="symbol">((</span><span class="normal">sbinptr</span><span class="symbol">)((</span><span class="type">char</span><span class="symbol">*)&amp;((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">smallbins</span><span class="symbol">[(</span><span class="normal">i</span><span class="symbol">)&lt;&lt;</span><span class="number">1</span><span class="symbol">])))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">treebin_at</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">i</span><span class="symbol">)</span><span class="normal">     </span><span class="symbol">(&amp;((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">treebins</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]))</span>

<span class="comment">/* assign tree index for size S to variable I */</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">__GNUC__</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">i386</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">compute_tree_index</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">)\</span>
<span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> X </span><span class="symbol">=</span><span class="normal"> S </span><span class="symbol">&gt;&gt;</span><span class="normal"> TREEBIN_SHIFT</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">X </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)\</span>
<span class="normal">    I </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">X </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0xFFFF</span><span class="symbol">)\</span>
<span class="normal">    I </span><span class="symbol">=</span><span class="normal"> NTREEBINS</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> K</span><span class="symbol">;\</span>
<span class="normal">    </span><span class="function">__asm__</span><span class="symbol">(</span><span class="string">"bsrl %1,%0</span><span class="specialchar">\n\t</span><span class="string">"</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="string">"=r"</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">K</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="string">"rm"</span><span class="normal">  </span><span class="symbol">(</span><span class="normal">X</span><span class="symbol">));\</span>
<span class="normal">    I </span><span class="symbol">=</span><span class="normal">  </span><span class="symbol">(</span><span class="normal">bindex_t</span><span class="symbol">)((</span><span class="normal">K </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">S </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">K </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">TREEBIN_SHIFT</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)));\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="cbracket">}</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* GNUC */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">compute_tree_index</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">)\</span>
<span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> X </span><span class="symbol">=</span><span class="normal"> S </span><span class="symbol">&gt;&gt;</span><span class="normal"> TREEBIN_SHIFT</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">X </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)\</span>
<span class="normal">    I </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">X </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0xFFFF</span><span class="symbol">)\</span>
<span class="normal">    I </span><span class="symbol">=</span><span class="normal"> NTREEBINS</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> Y </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">)</span><span class="normal">X</span><span class="symbol">;\</span>
<span class="normal">    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> N </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">Y </span><span class="symbol">-</span><span class="normal"> </span><span class="number">0x100</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">16</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">8</span><span class="symbol">;\</span>
<span class="normal">    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> K </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">Y </span><span class="symbol">&lt;&lt;=</span><span class="normal"> N</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="number">0x1000</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">16</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">4</span><span class="symbol">;\</span>
<span class="normal">    N </span><span class="symbol">+=</span><span class="normal"> K</span><span class="symbol">;\</span>
<span class="normal">    N </span><span class="symbol">+=</span><span class="normal"> K </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">Y </span><span class="symbol">&lt;&lt;=</span><span class="normal"> K</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="number">0x4000</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">16</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;\</span>
<span class="normal">    K </span><span class="symbol">=</span><span class="normal"> </span><span class="number">14</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> N </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">Y </span><span class="symbol">&lt;&lt;=</span><span class="normal"> K</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">15</span><span class="symbol">);\</span>
<span class="normal">    I </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">K </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">S </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">K </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">TREEBIN_SHIFT</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">));\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* GNUC */</span>

<span class="comment">/* Bit representing maximum resolved size in a treebin at i */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">bit_for_tree_index</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">   </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">==</span><span class="normal"> NTREEBINS</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">)?</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">SIZE_T_BITSIZE</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> TREEBIN_SHIFT </span><span class="symbol">-</span><span class="normal"> </span><span class="number">2</span><span class="symbol">)</span>

<span class="comment">/* Shift placing maximum resolved bit in a treebin at i as sign bit */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">leftshift_for_tree_index</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">   </span><span class="symbol">((</span><span class="normal">i </span><span class="symbol">==</span><span class="normal"> NTREEBINS</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">)?</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">    </span><span class="symbol">((</span><span class="normal">SIZE_T_BITSIZE</span><span class="symbol">-</span><span class="normal">SIZE_T_ONE</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> TREEBIN_SHIFT </span><span class="symbol">-</span><span class="normal"> </span><span class="number">2</span><span class="symbol">)))</span>

<span class="comment">/* The size of the smallest chunk held in bin with index i */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">minsize_for_tree_index</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">   </span><span class="symbol">((</span><span class="normal">SIZE_T_ONE </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> TREEBIN_SHIFT</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">|</span><span class="normal">  </span><span class="symbol">\</span>
<span class="normal">   </span><span class="symbol">(((</span><span class="normal">size_t</span><span class="symbol">)((</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> TREEBIN_SHIFT </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)))</span>


<span class="comment">/* ------------------------ Operations on bin maps ----------------------- */</span>

<span class="comment">/* bit corresponding to given index */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">idx2bit</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">)</span><span class="normal">              </span><span class="symbol">((</span><span class="normal">binmap_t</span><span class="symbol">)(</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">))</span>

<span class="comment">/* Mark/Clear bits with given index */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">mark_smallmap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">i</span><span class="symbol">)</span><span class="normal">      </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">smallmap </span><span class="symbol">|=</span><span class="normal">  </span><span class="function">idx2bit</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">clear_smallmap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">i</span><span class="symbol">)</span><span class="normal">     </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">smallmap </span><span class="symbol">&amp;=</span><span class="normal"> </span><span class="symbol">~</span><span class="function">idx2bit</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">smallmap_is_marked</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">smallmap </span><span class="symbol">&amp;</span><span class="normal">   </span><span class="function">idx2bit</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">))</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">mark_treemap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">i</span><span class="symbol">)</span><span class="normal">       </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">treemap  </span><span class="symbol">|=</span><span class="normal">  </span><span class="function">idx2bit</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">clear_treemap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">i</span><span class="symbol">)</span><span class="normal">      </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">treemap  </span><span class="symbol">&amp;=</span><span class="normal"> </span><span class="symbol">~</span><span class="function">idx2bit</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">))</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">treemap_is_marked</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">i</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">treemap  </span><span class="symbol">&amp;</span><span class="normal">   </span><span class="function">idx2bit</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">))</span>

<span class="comment">/* index corresponding to given bit */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">__GNUC__</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">i386</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">compute_bit2idx</span><span class="symbol">(</span><span class="normal">X</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">)\</span>
<span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">  </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> J</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="function">__asm__</span><span class="symbol">(</span><span class="string">"bsfl %1,%0</span><span class="specialchar">\n\t</span><span class="string">"</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="string">"=r"</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">J</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="string">"rm"</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">X</span><span class="symbol">));\</span>
<span class="normal">  I </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bindex_t</span><span class="symbol">)</span><span class="normal">J</span><span class="symbol">;\</span>
<span class="cbracket">}</span>

<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* GNUC */</span>
<span class="preproc">#if</span><span class="normal">  USE_BUILTIN_FFS</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">compute_bit2idx</span><span class="symbol">(</span><span class="normal">X</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">)</span><span class="normal"> I </span><span class="symbol">=</span><span class="normal"> </span><span class="function">ffs</span><span class="symbol">(</span><span class="normal">X</span><span class="symbol">)-</span><span class="number">1</span>

<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* USE_BUILTIN_FFS */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">compute_bit2idx</span><span class="symbol">(</span><span class="normal">X</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">)\</span>
<span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">  </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> Y </span><span class="symbol">=</span><span class="normal"> X </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> K </span><span class="symbol">=</span><span class="normal"> Y </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="number">16</span><span class="symbol">-</span><span class="number">4</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">16</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> N </span><span class="symbol">=</span><span class="normal"> K</span><span class="symbol">;</span><span class="normal">        Y </span><span class="symbol">&gt;&gt;=</span><span class="normal"> K</span><span class="symbol">;\</span>
<span class="normal">  N </span><span class="symbol">+=</span><span class="normal"> K </span><span class="symbol">=</span><span class="normal"> Y </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="number">8</span><span class="symbol">-</span><span class="number">3</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">  </span><span class="number">8</span><span class="symbol">;</span><span class="normal">  Y </span><span class="symbol">&gt;&gt;=</span><span class="normal"> K</span><span class="symbol">;\</span>
<span class="normal">  N </span><span class="symbol">+=</span><span class="normal"> K </span><span class="symbol">=</span><span class="normal"> Y </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="number">4</span><span class="symbol">-</span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">  </span><span class="number">4</span><span class="symbol">;</span><span class="normal">  Y </span><span class="symbol">&gt;&gt;=</span><span class="normal"> K</span><span class="symbol">;\</span>
<span class="normal">  N </span><span class="symbol">+=</span><span class="normal"> K </span><span class="symbol">=</span><span class="normal"> Y </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="number">2</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">  </span><span class="number">2</span><span class="symbol">;</span><span class="normal">  Y </span><span class="symbol">&gt;&gt;=</span><span class="normal"> K</span><span class="symbol">;\</span>
<span class="normal">  N </span><span class="symbol">+=</span><span class="normal"> K </span><span class="symbol">=</span><span class="normal"> Y </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="number">1</span><span class="symbol">-</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">  </span><span class="number">1</span><span class="symbol">;</span><span class="normal">  Y </span><span class="symbol">&gt;&gt;=</span><span class="normal"> K</span><span class="symbol">;\</span>
<span class="normal">  I </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bindex_t</span><span class="symbol">)(</span><span class="normal">N </span><span class="symbol">+</span><span class="normal"> Y</span><span class="symbol">);\</span>
<span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* USE_BUILTIN_FFS */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* GNUC */</span>

<span class="comment">/* isolate the least set bit of a bitmap */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">least_bit</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">         </span><span class="symbol">((</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">-(</span><span class="normal">x</span><span class="symbol">))</span>

<span class="comment">/* mask with all bits to left of least bit of x on */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">left_bits</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">         </span><span class="symbol">((</span><span class="normal">x</span><span class="symbol">&lt;&lt;</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span><span class="normal"> </span><span class="symbol">-(</span><span class="normal">x</span><span class="symbol">&lt;&lt;</span><span class="number">1</span><span class="symbol">))</span>

<span class="comment">/* mask with all bits to left of or equal to least bit of x on */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">same_or_left_bits</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span><span class="normal"> </span><span class="symbol">-(</span><span class="normal">x</span><span class="symbol">))</span>


<span class="comment">/* ----------------------- Runtime Check Support ------------------------- */</span>

<span class="comment">/*</span>
<span class="comment">  For security, the main invariant is that malloc/free/etc never</span>
<span class="comment">  writes to a static address other than malloc_state, unless static</span>
<span class="comment">  malloc_state itself has been corrupted, which cannot occur via</span>
<span class="comment">  malloc (because of these checks). In essence this means that we</span>
<span class="comment">  believe all pointers, sizes, maps etc held in malloc_state, but</span>
<span class="comment">  check all of those linked or offsetted from other embedded data</span>
<span class="comment">  structures.  These checks are interspersed with main code in a way</span>
<span class="comment">  that tends to minimize their run-time cost.</span>

<span class="comment">  When FOOTERS is defined, in addition to range checking, we also</span>
<span class="comment">  verify footer fields of inuse chunks, which can be used guarantee</span>
<span class="comment">  that the mstate controlling malloc/free is intact.  This is a</span>
<span class="comment">  streamlined version of the approach described by William Robertson</span>
<span class="comment">  et al in "Run-time Detection of Heap-based Overflows" LISA'03</span>
<span class="comment">  </span><span class="url">http://www.usenix.org/events/lisa03/tech/robertson.html</span><span class="comment"> The footer</span>
<span class="comment">  of an inuse chunk holds the xor of its mstate and a random seed,</span>
<span class="comment">  that is checked upon calls to free() and realloc().  This is</span>
<span class="comment">  (probablistically) unguessable from outside the program, but can be</span>
<span class="comment">  computed by any code successfully malloc'ing any chunk, so does not</span>
<span class="comment">  itself provide protection against code that has already broken</span>
<span class="comment">  security through some other means.  Unlike Robertson et al, we</span>
<span class="comment">  always dynamically check addresses of all offset chunks (previous,</span>
<span class="comment">  next, etc). This turns out to be cheaper than relying on hashes.</span>
<span class="comment">*/</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">INSECURE</span>
<span class="comment">/* Check if address a is at least as high as any from MORECORE or MMAP */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> a</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">a</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">least_addr</span><span class="symbol">)</span>
<span class="comment">/* Check if address of next chunk n is higher than base chunk p */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ok_next</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> n</span><span class="symbol">)</span><span class="normal">    </span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">n</span><span class="symbol">))</span>
<span class="comment">/* Check if p has its cinuse bit on */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ok_cinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">     </span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span>
<span class="comment">/* Check if p has its pinuse bit on */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ok_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">     </span><span class="function">pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span>

<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* !INSECURE */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> a</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">(</span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ok_next</span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">,</span><span class="normal"> n</span><span class="symbol">)</span><span class="normal">    </span><span class="symbol">(</span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ok_cinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">     </span><span class="symbol">(</span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ok_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal">     </span><span class="symbol">(</span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* !INSECURE */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">FOOTERS </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">INSECURE</span><span class="symbol">)</span>
<span class="comment">/* Check if (alleged) mstate m has expected magic field */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">      </span><span class="symbol">((</span><span class="normal">M</span><span class="symbol">)-&gt;</span><span class="normal">magic </span><span class="symbol">==</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">magic</span><span class="symbol">)</span>
<span class="preproc">#else</span><span class="normal">  </span><span class="comment">/* (FOOTERS &amp;&amp; !INSECURE) */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal">      </span><span class="symbol">(</span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* (FOOTERS &amp;&amp; !INSECURE) */</span>


<span class="comment">/* In gcc, use __builtin_expect to minimize impact of checks */</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">INSECURE</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">__GNUC__</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> __GNUC__ </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">3</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span><span class="normal">  </span><span class="function">__builtin_expect</span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* GNUC */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* GNUC */</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* !INSECURE */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="normal">e</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">(</span><span class="number">1</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* !INSECURE */</span>

<span class="comment">/* macros to set up inuse chunks with or without footers */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">FOOTERS</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">mark_inuse_foot</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">p</span><span class="symbol">,</span><span class="normal">s</span><span class="symbol">)</span>

<span class="comment">/* Set cinuse bit and pinuse bit of next chunk */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">set_inuse</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">p</span><span class="symbol">,</span><span class="normal">s</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">&amp;</span><span class="normal"> PINUSE_BIT</span><span class="symbol">)|</span><span class="normal">s</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">),\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">mchunkptr</span><span class="symbol">)(((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)))-&gt;</span><span class="normal">head </span><span class="symbol">|=</span><span class="normal"> PINUSE_BIT</span><span class="symbol">)</span>

<span class="comment">/* Set cinuse and pinuse of this chunk and pinuse of next chunk */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">set_inuse_and_pinuse</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">p</span><span class="symbol">,</span><span class="normal">s</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">|</span><span class="normal">PINUSE_BIT</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">),\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">mchunkptr</span><span class="symbol">)(((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)))-&gt;</span><span class="normal">head </span><span class="symbol">|=</span><span class="normal"> PINUSE_BIT</span><span class="symbol">)</span>

<span class="comment">/* Set size, cinuse and pinuse bit of this chunk */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">|</span><span class="normal">PINUSE_BIT</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">))</span>

<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>

<span class="comment">/* Set foot of inuse chunk to be xor of mstate and seed */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">mark_inuse_foot</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">p</span><span class="symbol">,</span><span class="normal">s</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">(((</span><span class="normal">mchunkptr</span><span class="symbol">)((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)))-&gt;</span><span class="normal">prev_foot </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)(</span><span class="normal">M</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">^</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">magic</span><span class="symbol">))</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">get_mstate_for</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">mstate</span><span class="symbol">)(((</span><span class="normal">mchunkptr</span><span class="symbol">)((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+\</span>
<span class="normal">    </span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">))))-&gt;</span><span class="normal">prev_foot </span><span class="symbol">^</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">magic</span><span class="symbol">))</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">set_inuse</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">p</span><span class="symbol">,</span><span class="normal">s</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">&amp;</span><span class="normal"> PINUSE_BIT</span><span class="symbol">)|</span><span class="normal">s</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">),\</span>
<span class="normal">  </span><span class="symbol">(((</span><span class="normal">mchunkptr</span><span class="symbol">)(((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)))-&gt;</span><span class="normal">head </span><span class="symbol">|=</span><span class="normal"> PINUSE_BIT</span><span class="symbol">),</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">  </span><span class="function">mark_inuse_foot</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">p</span><span class="symbol">,</span><span class="normal">s</span><span class="symbol">))</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">set_inuse_and_pinuse</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">p</span><span class="symbol">,</span><span class="normal">s</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">|</span><span class="normal">PINUSE_BIT</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">),\</span>
<span class="normal">  </span><span class="symbol">(((</span><span class="normal">mchunkptr</span><span class="symbol">)(((</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">)))-&gt;</span><span class="normal">head </span><span class="symbol">|=</span><span class="normal"> PINUSE_BIT</span><span class="symbol">),\</span>
<span class="normal"> </span><span class="function">mark_inuse_foot</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">p</span><span class="symbol">,</span><span class="normal">s</span><span class="symbol">))</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">|</span><span class="normal">PINUSE_BIT</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">),\</span>
<span class="normal">  </span><span class="function">mark_inuse_foot</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> s</span><span class="symbol">))</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* !FOOTERS */</span>

<span class="comment">/* ---------------------------- setting mparams -------------------------- */</span>

<span class="comment">/* Initialize mparams */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">init_mparams</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">page_size </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> s</span><span class="symbol">;</span>

<span class="normal">    mparams</span><span class="symbol">.</span><span class="normal">mmap_threshold </span><span class="symbol">=</span><span class="normal"> DEFAULT_MMAP_THRESHOLD</span><span class="symbol">;</span>
<span class="normal">    mparams</span><span class="symbol">.</span><span class="normal">trim_threshold </span><span class="symbol">=</span><span class="normal"> DEFAULT_TRIM_THRESHOLD</span><span class="symbol">;</span>
<span class="preproc">#if</span><span class="normal"> MORECORE_CONTIGUOUS</span>
<span class="normal">    mparams</span><span class="symbol">.</span><span class="normal">default_mflags </span><span class="symbol">=</span><span class="normal"> USE_LOCK_BIT</span><span class="symbol">|</span><span class="normal">USE_MMAP_BIT</span><span class="symbol">;</span>
<span class="preproc">#else</span><span class="normal">  </span><span class="comment">/* MORECORE_CONTIGUOUS */</span>
<span class="normal">    mparams</span><span class="symbol">.</span><span class="normal">default_mflags </span><span class="symbol">=</span><span class="normal"> USE_LOCK_BIT</span><span class="symbol">|</span><span class="normal">USE_MMAP_BIT</span><span class="symbol">|</span><span class="normal">USE_NONCONTIGUOUS_BIT</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* MORECORE_CONTIGUOUS */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">FOOTERS </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">INSECURE</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="preproc">#if</span><span class="normal"> USE_DEV_RANDOM</span>
<span class="normal">      </span><span class="type">int</span><span class="normal"> fd</span><span class="symbol">;</span>
<span class="normal">      </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="normal"> buf</span><span class="symbol">[</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)];</span>
<span class="normal">      </span><span class="comment">/* Try to use /dev/urandom, else fall back on using time */</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> </span><span class="function">open</span><span class="symbol">(</span><span class="string">"/dev/urandom"</span><span class="symbol">,</span><span class="normal"> O_RDONLY</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">          </span><span class="function">read</span><span class="symbol">(</span><span class="normal">fd</span><span class="symbol">,</span><span class="normal"> buf</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">buf</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">buf</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        s </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*((</span><span class="normal">size_t </span><span class="symbol">*)</span><span class="normal"> buf</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">close</span><span class="symbol">(</span><span class="normal">fd</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">else</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* USE_DEV_RANDOM */</span>
<span class="normal">        s </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)(</span><span class="function">time</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">^</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">0x55555555U</span><span class="symbol">);</span>

<span class="normal">      s </span><span class="symbol">|=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">8U</span><span class="symbol">;</span><span class="normal">    </span><span class="comment">/* ensure nonzero */</span>
<span class="normal">      s </span><span class="symbol">&amp;=</span><span class="normal"> </span><span class="symbol">~(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">7U</span><span class="symbol">;</span><span class="normal">   </span><span class="comment">/* improve chances of fault for bad values */</span>

<span class="normal">    </span><span class="cbracket">}</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* (FOOTERS &amp;&amp; !INSECURE) */</span>
<span class="normal">    s </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">0x58585858U</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* (FOOTERS &amp;&amp; !INSECURE) */</span>
<span class="normal">    </span><span class="function">ACQUIRE_MAGIC_INIT_LOCK</span><span class="symbol">();</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">magic </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      mparams</span><span class="symbol">.</span><span class="normal">magic </span><span class="symbol">=</span><span class="normal"> s</span><span class="symbol">;</span>
<span class="normal">      </span><span class="comment">/* Set up lock for main malloc area */</span>
<span class="normal">      </span><span class="function">INITIAL_LOCK</span><span class="symbol">(&amp;</span><span class="normal">gm</span><span class="symbol">-&gt;</span><span class="normal">mutex</span><span class="symbol">);</span>
<span class="normal">      gm</span><span class="symbol">-&gt;</span><span class="normal">mflags </span><span class="symbol">=</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">default_mflags</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="function">RELEASE_MAGIC_INIT_LOCK</span><span class="symbol">();</span>

<span class="preproc">#ifndef</span><span class="normal"> WIN32</span>
<span class="normal">    mparams</span><span class="symbol">.</span><span class="normal">page_size </span><span class="symbol">=</span><span class="normal"> malloc_getpagesize</span><span class="symbol">;</span>
<span class="normal">    mparams</span><span class="symbol">.</span><span class="normal">granularity </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">DEFAULT_GRANULARITY </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)?</span>
<span class="normal">                           DEFAULT_GRANULARITY </span><span class="symbol">:</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">page_size</span><span class="symbol">);</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* WIN32 */</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">SYSTEM_INFO</span><span class="normal"> system_info</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">GetSystemInfo</span><span class="symbol">(&amp;</span><span class="normal">system_info</span><span class="symbol">);</span>
<span class="normal">      mparams</span><span class="symbol">.</span><span class="normal">page_size </span><span class="symbol">=</span><span class="normal"> system_info</span><span class="symbol">.</span><span class="normal">dwPageSize</span><span class="symbol">;</span>
<span class="normal">      mparams</span><span class="symbol">.</span><span class="normal">granularity </span><span class="symbol">=</span><span class="normal"> system_info</span><span class="symbol">.</span><span class="normal">dwAllocationGranularity</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* WIN32 */</span>

<span class="normal">    </span><span class="comment">/* Sanity-check configuration:</span>
<span class="comment">       size_t must be unsigned and as wide as pointer type.</span>
<span class="comment">       ints must be at least 4 bytes.</span>
<span class="comment">       alignment must be at least 8.</span>
<span class="comment">       Alignment, min chunk size, and page size must all be powers of 2.</span>
<span class="comment">    */</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*))</span><span class="normal"> </span><span class="symbol">||</span>
<span class="normal">        </span><span class="symbol">(</span><span class="normal">MAX_SIZE_T </span><span class="symbol">&lt;</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">||</span>
<span class="normal">        </span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="type">int</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">4</span><span class="symbol">)</span><span class="normal">  </span><span class="symbol">||</span>
<span class="normal">        </span><span class="symbol">(</span><span class="normal">MALLOC_ALIGNMENT </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">8U</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span>
<span class="normal">        </span><span class="symbol">((</span><span class="normal">MALLOC_ALIGNMENT    </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">MALLOC_ALIGNMENT</span><span class="symbol">-</span><span class="normal">SIZE_T_ONE</span><span class="symbol">))</span><span class="normal">    </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span>
<span class="normal">        </span><span class="symbol">((</span><span class="normal">MCHUNK_SIZE         </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">MCHUNK_SIZE</span><span class="symbol">-</span><span class="normal">SIZE_T_ONE</span><span class="symbol">))</span><span class="normal">         </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span>
<span class="normal">        </span><span class="symbol">((</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">granularity </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">granularity</span><span class="symbol">-</span><span class="normal">SIZE_T_ONE</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span>
<span class="normal">        </span><span class="symbol">((</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">page_size   </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">page_size</span><span class="symbol">-</span><span class="normal">SIZE_T_ONE</span><span class="symbol">))</span><span class="normal">   </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">))</span>
<span class="normal">      ABORT</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* support for mallopt */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">change_mparam</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> param_number</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> value</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> val </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">value</span><span class="symbol">;</span>
<span class="normal">  </span><span class="function">init_mparams</span><span class="symbol">();</span>
<span class="normal">  </span><span class="keyword">switch</span><span class="symbol">(</span><span class="normal">param_number</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">case</span><span class="normal"> M_TRIM_THRESHOLD</span><span class="symbol">:</span>
<span class="normal">    mparams</span><span class="symbol">.</span><span class="normal">trim_threshold </span><span class="symbol">=</span><span class="normal"> val</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">case</span><span class="normal"> M_GRANULARITY</span><span class="symbol">:</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">val </span><span class="symbol">&gt;=</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">page_size </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">val </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">val</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      mparams</span><span class="symbol">.</span><span class="normal">granularity </span><span class="symbol">=</span><span class="normal"> val</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">case</span><span class="normal"> M_MMAP_THRESHOLD</span><span class="symbol">:</span>
<span class="normal">    mparams</span><span class="symbol">.</span><span class="normal">mmap_threshold </span><span class="symbol">=</span><span class="normal"> val</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="label">  default:</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> DEBUG</span>
<span class="comment">/* ------------------------- Debugging Support --------------------------- */</span>

<span class="comment">/* Check properties of any chunk, whether free, inuse, mmapped etc  */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">do_check_any_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">((</span><span class="function">is_aligned</span><span class="symbol">(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)))</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">==</span><span class="normal"> FENCEPOST_HEAD</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">));</span>
<span class="cbracket">}</span>

<span class="comment">/* Check properties of top chunk */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">do_check_top_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">msegmentptr</span><span class="normal"> sp </span><span class="symbol">=</span><span class="normal"> </span><span class="function">segment_holding</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">  sz </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">sp </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">((</span><span class="function">is_aligned</span><span class="symbol">(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)))</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">==</span><span class="normal"> FENCEPOST_HEAD</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">sz </span><span class="symbol">==</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">sz </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">sz </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">sp</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">+</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">size</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(!</span><span class="function">next_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>
<span class="cbracket">}</span>

<span class="comment">/* Check properties of (inuse) mmapped chunks */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">do_check_mmapped_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">  sz </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> len </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sz </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">-&gt;</span><span class="normal">prev_foot </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">IS_MMAPPED_BIT</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> MMAP_FOOT_PAD</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">use_mmap</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">((</span><span class="function">is_aligned</span><span class="symbol">(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)))</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">==</span><span class="normal"> FENCEPOST_HEAD</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(!</span><span class="function">is_small</span><span class="symbol">(</span><span class="normal">sz</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">((</span><span class="normal">len </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">page_size</span><span class="symbol">-</span><span class="normal">SIZE_T_ONE</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> sz</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">==</span><span class="normal"> FENCEPOST_HEAD</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> sz</span><span class="symbol">+</span><span class="normal">SIZE_T_SIZE</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="comment">/* Check properties of inuse chunks */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">do_check_inuse_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="function">do_check_any_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">next_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>
<span class="normal">  </span><span class="comment">/* If not pinuse and not mmapped, previous chunk has OK offset */</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">next_chunk</span><span class="symbol">(</span><span class="function">prev_chunk</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">))</span>
<span class="normal">    </span><span class="function">do_check_mmapped_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="comment">/* Check properties of free chunks */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">do_check_free_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> sz </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~(</span><span class="normal">PINUSE_BIT</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> next </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> sz</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">do_check_any_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(!</span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(!</span><span class="function">next_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p </span><span class="symbol">!=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">&amp;&amp;</span><span class="normal"> p </span><span class="symbol">!=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sz </span><span class="symbol">&gt;=</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">((</span><span class="normal">sz </span><span class="symbol">&amp;</span><span class="normal"> CHUNK_ALIGN_MASK</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_aligned</span><span class="symbol">(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)));</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">next</span><span class="symbol">-&gt;</span><span class="normal">prev_foot </span><span class="symbol">==</span><span class="normal"> sz</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="function">pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>
<span class="normal">      </span><span class="function">assert</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next </span><span class="symbol">==</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">||</span><span class="normal"> </span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">next</span><span class="symbol">));</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">==</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">-&gt;</span><span class="normal">bk</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">==</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal">  </span><span class="comment">/* markers are always of size SIZE_T_SIZE */</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">sz </span><span class="symbol">==</span><span class="normal"> SIZE_T_SIZE</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="comment">/* Check properties of malloced chunks at the point they are malloced */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">do_check_malloced_chunk</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> s</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> </span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">);</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> sz </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~(</span><span class="normal">PINUSE_BIT</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">do_check_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">((</span><span class="normal">sz </span><span class="symbol">&amp;</span><span class="normal"> CHUNK_ALIGN_MASK</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">sz </span><span class="symbol">&gt;=</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">sz </span><span class="symbol">&gt;=</span><span class="normal"> s</span><span class="symbol">);</span>
<span class="normal">    </span><span class="comment">/* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> sz </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s </span><span class="symbol">+</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">));</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="comment">/* Check a tree and its subtrees.  */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">do_check_tree</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">tchunkptr</span><span class="normal"> t</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">tchunkptr</span><span class="normal"> head </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">tchunkptr</span><span class="normal"> u </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">bindex_t</span><span class="normal"> tindex </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">-&gt;</span><span class="normal">index</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> tsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">bindex_t</span><span class="normal"> idx</span><span class="symbol">;</span>
<span class="normal">  </span><span class="function">compute_tree_index</span><span class="symbol">(</span><span class="normal">tsize</span><span class="symbol">,</span><span class="normal"> idx</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">tindex </span><span class="symbol">==</span><span class="normal"> idx</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">tsize </span><span class="symbol">&gt;=</span><span class="normal"> MIN_LARGE_SIZE</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">tsize </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="function">minsize_for_tree_index</span><span class="symbol">(</span><span class="normal">idx</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">((</span><span class="normal">idx </span><span class="symbol">==</span><span class="normal"> NTREEBINS</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">tsize </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="function">minsize_for_tree_index</span><span class="symbol">((</span><span class="normal">idx</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">))));</span>

<span class="normal">  </span><span class="keyword">do</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* traverse through chain of same-sized nodes */</span>
<span class="normal">    </span><span class="function">do_check_any_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">mchunkptr</span><span class="symbol">)</span><span class="normal">u</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">index </span><span class="symbol">==</span><span class="normal"> tindex</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> tsize</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(!</span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(!</span><span class="function">next_pinuse</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">==</span><span class="normal"> u</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">bk</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">==</span><span class="normal"> u</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">parent </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">head </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span><span class="normal"> </span><span class="comment">/* only one node on chain has parent */</span>
<span class="normal">      head </span><span class="symbol">=</span><span class="normal"> u</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">parent </span><span class="symbol">!=</span><span class="normal"> u</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">assert</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> u </span><span class="symbol">||</span>
<span class="normal">              u</span><span class="symbol">-&gt;</span><span class="normal">parent</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> u </span><span class="symbol">||</span>
<span class="normal">              </span><span class="symbol">*((</span><span class="normal">tbinptr</span><span class="symbol">*)(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">parent</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> u</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]-&gt;</span><span class="normal">parent </span><span class="symbol">==</span><span class="normal"> u</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> u</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">do_check_tree</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]-&gt;</span><span class="normal">parent </span><span class="symbol">==</span><span class="normal"> u</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> u</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">do_check_tree</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">u</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]));</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    u </span><span class="symbol">=</span><span class="normal"> u</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">u </span><span class="symbol">!=</span><span class="normal"> t</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">head </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="comment">/*  Check all the chunks in a treebin.  */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">do_check_treebin</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">bindex_t</span><span class="normal"> i</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  tbinptr</span><span class="symbol">*</span><span class="normal"> tb </span><span class="symbol">=</span><span class="normal"> </span><span class="function">treebin_at</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">tchunkptr</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">tb</span><span class="symbol">;</span>
<span class="normal">  </span><span class="type">int</span><span class="normal"> empty </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">treemap </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">1U </span><span class="symbol">&lt;&lt;</span><span class="normal"> i</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">empty</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">empty</span><span class="symbol">)</span>
<span class="normal">    </span><span class="function">do_check_tree</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="comment">/*  Check all the chunks in a smallbin.  */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">do_check_smallbin</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">bindex_t</span><span class="normal"> i</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">sbinptr</span><span class="normal"> b </span><span class="symbol">=</span><span class="normal"> </span><span class="function">smallbin_at</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> b</span><span class="symbol">-&gt;</span><span class="normal">bk</span><span class="symbol">;</span>
<span class="normal">  </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> empty </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">smallmap </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">1U </span><span class="symbol">&lt;&lt;</span><span class="normal"> i</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">)</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">empty</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">empty</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(;</span><span class="normal"> p </span><span class="symbol">!=</span><span class="normal"> b</span><span class="symbol">;</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">-&gt;</span><span class="normal">bk</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> size </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> q</span><span class="symbol">;</span>
<span class="normal">      </span><span class="comment">/* each chunk claims to be free */</span>
<span class="normal">      </span><span class="function">do_check_free_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="comment">/* chunk belongs in bin */</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="function">small_index</span><span class="symbol">(</span><span class="normal">size</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">==</span><span class="normal"> b </span><span class="symbol">||</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">-&gt;</span><span class="normal">bk</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>
<span class="normal">      </span><span class="comment">/* chunk is followed by an inuse chunk */</span>
<span class="normal">      q </span><span class="symbol">=</span><span class="normal"> </span><span class="function">next_chunk</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">!=</span><span class="normal"> FENCEPOST_HEAD</span><span class="symbol">)</span>
<span class="normal">        </span><span class="function">do_check_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="comment">/* Find x in a bin. Used in other check functions. */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">bin_find</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> x</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> size </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_small</span><span class="symbol">(</span><span class="normal">size</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">bindex_t</span><span class="normal"> sidx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">small_index</span><span class="symbol">(</span><span class="normal">size</span><span class="symbol">);</span>
<span class="normal">    </span><span class="usertype">sbinptr</span><span class="normal"> b </span><span class="symbol">=</span><span class="normal"> </span><span class="function">smallbin_at</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> sidx</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">smallmap_is_marked</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> sidx</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> b</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">do</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p </span><span class="symbol">==</span><span class="normal"> x</span><span class="symbol">)</span>
<span class="normal">          </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">p </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> b</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">bindex_t</span><span class="normal"> tidx</span><span class="symbol">;</span>
<span class="normal">    </span><span class="function">compute_tree_index</span><span class="symbol">(</span><span class="normal">size</span><span class="symbol">,</span><span class="normal"> tidx</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">treemap_is_marked</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> tidx</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">tchunkptr</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="function">treebin_at</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> tidx</span><span class="symbol">);</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> sizebits </span><span class="symbol">=</span><span class="normal"> size </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">leftshift_for_tree_index</span><span class="symbol">(</span><span class="normal">tidx</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> size</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        t </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[(</span><span class="normal">sizebits </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">SIZE_T_BITSIZE</span><span class="symbol">-</span><span class="normal">SIZE_T_ONE</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">        sizebits </span><span class="symbol">&lt;&lt;=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">tchunkptr</span><span class="normal"> u </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">do</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">u </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">tchunkptr</span><span class="symbol">)</span><span class="normal">x</span><span class="symbol">)</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">u </span><span class="symbol">=</span><span class="normal"> u</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> t</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* Traverse each chunk and check it; return total */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> </span><span class="function">traverse_and_check</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> sum </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_initialized</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">msegmentptr</span><span class="normal"> s </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">;</span>
<span class="normal">    sum </span><span class="symbol">+=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> q </span><span class="symbol">=</span><span class="normal"> </span><span class="function">align_as_chunk</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">-&gt;</span><span class="normal">base</span><span class="symbol">);</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> lastq </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="function">pinuse</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">));</span>
<span class="normal">      </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="function">segment_holds</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">             q </span><span class="symbol">!=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">&amp;&amp;</span><span class="normal"> q</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">!=</span><span class="normal"> FENCEPOST_HEAD</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        sum </span><span class="symbol">+=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="function">assert</span><span class="symbol">(!</span><span class="function">bin_find</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">));</span>
<span class="normal">          </span><span class="function">do_check_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">q </span><span class="symbol">==</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">||</span><span class="normal"> </span><span class="function">bin_find</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">));</span>
<span class="normal">          </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">lastq </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">lastq</span><span class="symbol">));</span><span class="normal"> </span><span class="comment">/* Not 2 consecutive free */</span>
<span class="normal">          </span><span class="function">do_check_free_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        lastq </span><span class="symbol">=</span><span class="normal"> q</span><span class="symbol">;</span>
<span class="normal">        q </span><span class="symbol">=</span><span class="normal"> </span><span class="function">next_chunk</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      s </span><span class="symbol">=</span><span class="normal"> s</span><span class="symbol">-&gt;</span><span class="normal">next</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> sum</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* Check all properties of malloc_state. */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">do_check_malloc_state</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">bindex_t</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> total</span><span class="symbol">;</span>
<span class="normal">  </span><span class="comment">/* check bins */</span>
<span class="normal">  </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> NSMALLBINS</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">    </span><span class="function">do_check_smallbin</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> NTREEBINS</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">    </span><span class="function">do_check_treebin</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* check dv chunk */</span>
<span class="normal">    </span><span class="function">do_check_any_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">==</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">&gt;=</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="function">bin_find</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">   </span><span class="comment">/* check top chunk */</span>
<span class="normal">    </span><span class="function">do_check_top_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">==</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="function">bin_find</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  total </span><span class="symbol">=</span><span class="normal"> </span><span class="function">traverse_and_check</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">total </span><span class="symbol">&lt;=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">footprint</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">footprint </span><span class="symbol">&lt;=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">max_footprint</span><span class="symbol">);</span>
<span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* DEBUG */</span>

<span class="comment">/* ----------------------------- statistics ------------------------------ */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">NO_MALLINFO</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">mallinfo</span><span class="normal"> </span><span class="function">internal_mallinfo</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">mallinfo</span><span class="normal"> nm </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">check_malloc_state</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_initialized</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> nfree </span><span class="symbol">=</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* top always free */</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> mfree </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> sum </span><span class="symbol">=</span><span class="normal"> mfree</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">msegmentptr</span><span class="normal"> s </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">mchunkptr</span><span class="normal"> q </span><span class="symbol">=</span><span class="normal"> </span><span class="function">align_as_chunk</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">-&gt;</span><span class="normal">base</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="function">segment_holds</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">               q </span><span class="symbol">!=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">&amp;&amp;</span><span class="normal"> q</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">!=</span><span class="normal"> FENCEPOST_HEAD</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="usertype">size_t</span><span class="normal"> sz </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">);</span>
<span class="normal">          sum </span><span class="symbol">+=</span><span class="normal"> sz</span><span class="symbol">;</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            mfree </span><span class="symbol">+=</span><span class="normal"> sz</span><span class="symbol">;</span>
<span class="normal">            </span><span class="symbol">++</span><span class="normal">nfree</span><span class="symbol">;</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">          q </span><span class="symbol">=</span><span class="normal"> </span><span class="function">next_chunk</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        s </span><span class="symbol">=</span><span class="normal"> s</span><span class="symbol">-&gt;</span><span class="normal">next</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>

<span class="normal">      nm</span><span class="symbol">.</span><span class="normal">arena    </span><span class="symbol">=</span><span class="normal"> sum</span><span class="symbol">;</span>
<span class="normal">      nm</span><span class="symbol">.</span><span class="normal">ordblks  </span><span class="symbol">=</span><span class="normal"> nfree</span><span class="symbol">;</span>
<span class="normal">      nm</span><span class="symbol">.</span><span class="normal">hblkhd   </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">footprint </span><span class="symbol">-</span><span class="normal"> sum</span><span class="symbol">;</span>
<span class="normal">      nm</span><span class="symbol">.</span><span class="normal">usmblks  </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">max_footprint</span><span class="symbol">;</span>
<span class="normal">      nm</span><span class="symbol">.</span><span class="normal">uordblks </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">footprint </span><span class="symbol">-</span><span class="normal"> mfree</span><span class="symbol">;</span>
<span class="normal">      nm</span><span class="symbol">.</span><span class="normal">fordblks </span><span class="symbol">=</span><span class="normal"> mfree</span><span class="symbol">;</span>
<span class="normal">      nm</span><span class="symbol">.</span><span class="normal">keepcost </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> nm</span><span class="symbol">;</span>
<span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* !NO_MALLINFO */</span>

<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">internal_malloc_stats</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> maxfp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> fp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> used </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="function">check_malloc_state</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_initialized</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">msegmentptr</span><span class="normal"> s </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">;</span>
<span class="normal">      maxfp </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">max_footprint</span><span class="symbol">;</span>
<span class="normal">      fp </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">footprint</span><span class="symbol">;</span>
<span class="normal">      used </span><span class="symbol">=</span><span class="normal"> fp </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">);</span>

<span class="normal">      </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">mchunkptr</span><span class="normal"> q </span><span class="symbol">=</span><span class="normal"> </span><span class="function">align_as_chunk</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">-&gt;</span><span class="normal">base</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="function">segment_holds</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">               q </span><span class="symbol">!=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">&amp;&amp;</span><span class="normal"> q</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">!=</span><span class="normal"> FENCEPOST_HEAD</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">))</span>
<span class="normal">            used </span><span class="symbol">-=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">);</span>
<span class="normal">          q </span><span class="symbol">=</span><span class="normal"> </span><span class="function">next_chunk</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        s </span><span class="symbol">=</span><span class="normal"> s</span><span class="symbol">-&gt;</span><span class="normal">next</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="preproc">#ifndef</span><span class="normal"> LACKS_STDIO_H</span>
<span class="normal">    </span><span class="function">fprintf</span><span class="symbol">(</span><span class="normal">stderr</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"max system bytes = %10lu</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">long</span><span class="symbol">)(</span><span class="normal">maxfp</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">fprintf</span><span class="symbol">(</span><span class="normal">stderr</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"system bytes     = %10lu</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">long</span><span class="symbol">)(</span><span class="normal">fp</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">fprintf</span><span class="symbol">(</span><span class="normal">stderr</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"in use bytes     = %10lu</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">long</span><span class="symbol">)(</span><span class="normal">used</span><span class="symbol">));</span>
<span class="preproc">#endif</span>

<span class="normal">    </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="comment">/* ----------------------- Operations on smallbins ----------------------- */</span>

<span class="comment">/*</span>
<span class="comment">  Various forms of linking and unlinking are defined as macros.  Even</span>
<span class="comment">  the ones for trees, which are very long but have very short typical</span>
<span class="comment">  paths.  This is ugly but reduces reliance on inlining support of</span>
<span class="comment">  compilers.</span>
<span class="comment">*/</span>

<span class="comment">/* Link a free chunk into a smallbin  */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">insert_small_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> P</span><span class="symbol">,</span><span class="normal"> S</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">  </span><span class="usertype">bindex_t</span><span class="normal"> I  </span><span class="symbol">=</span><span class="normal"> </span><span class="function">small_index</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> B </span><span class="symbol">=</span><span class="normal"> </span><span class="function">smallbin_at</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> F </span><span class="symbol">=</span><span class="normal"> B</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">S </span><span class="symbol">&gt;=</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">smallmap_is_marked</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">))\</span>
<span class="normal">    </span><span class="function">mark_smallmap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> B</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">)))\</span>
<span class="normal">    F </span><span class="symbol">=</span><span class="normal"> B</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">  B</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> P</span><span class="symbol">;\</span>
<span class="normal">  F</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">=</span><span class="normal"> P</span><span class="symbol">;\</span>
<span class="normal">  P</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> F</span><span class="symbol">;\</span>
<span class="normal">  P</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">=</span><span class="normal"> B</span><span class="symbol">;\</span>
<span class="cbracket">}</span>

<span class="comment">/* Unlink a chunk from a smallbin  */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">unlink_small_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> P</span><span class="symbol">,</span><span class="normal"> S</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> F </span><span class="symbol">=</span><span class="normal"> P</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> B </span><span class="symbol">=</span><span class="normal"> P</span><span class="symbol">-&gt;</span><span class="normal">bk</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="usertype">bindex_t</span><span class="normal"> I </span><span class="symbol">=</span><span class="normal"> </span><span class="function">small_index</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">P </span><span class="symbol">!=</span><span class="normal"> B</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">P </span><span class="symbol">!=</span><span class="normal"> F</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">P</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">I</span><span class="symbol">));\</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">F </span><span class="symbol">==</span><span class="normal"> B</span><span class="symbol">)\</span>
<span class="normal">    </span><span class="function">clear_smallmap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">((</span><span class="normal">F </span><span class="symbol">==</span><span class="normal"> </span><span class="function">smallbin_at</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">I</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> F</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;&amp;\</span>
<span class="normal">                   </span><span class="symbol">(</span><span class="normal">B </span><span class="symbol">==</span><span class="normal"> </span><span class="function">smallbin_at</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal">I</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> B</span><span class="symbol">))))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    F</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">=</span><span class="normal"> B</span><span class="symbol">;\</span>
<span class="normal">    B</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> F</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="cbracket">}</span>

<span class="comment">/* Unlink the first chunk from a smallbin */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">unlink_first_small_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> B</span><span class="symbol">,</span><span class="normal"> P</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> F </span><span class="symbol">=</span><span class="normal"> P</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">P </span><span class="symbol">!=</span><span class="normal"> B</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">P </span><span class="symbol">!=</span><span class="normal"> F</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">P</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">I</span><span class="symbol">));\</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">B </span><span class="symbol">==</span><span class="normal"> F</span><span class="symbol">)\</span>
<span class="normal">    </span><span class="function">clear_smallmap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> F</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    B</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> F</span><span class="symbol">;\</span>
<span class="normal">    F</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">=</span><span class="normal"> B</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="cbracket">}</span>

<span class="comment">/* Replace dv node, binning the old one */</span>
<span class="comment">/* Used only when dvsize known to be small */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">replace_dv</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> P</span><span class="symbol">,</span><span class="normal"> S</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> DVS </span><span class="symbol">=</span><span class="normal"> M</span><span class="symbol">-&gt;</span><span class="normal">dvsize</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">DVS </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> DV </span><span class="symbol">=</span><span class="normal"> M</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">;\</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_small</span><span class="symbol">(</span><span class="normal">DVS</span><span class="symbol">));\</span>
<span class="normal">    </span><span class="function">insert_small_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> DV</span><span class="symbol">,</span><span class="normal"> DVS</span><span class="symbol">);\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">  M</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> S</span><span class="symbol">;\</span>
<span class="normal">  M</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> P</span><span class="symbol">;\</span>
<span class="cbracket">}</span>

<span class="comment">/* ------------------------- Operations on trees ------------------------- */</span>

<span class="comment">/* Insert chunk into tree */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">insert_large_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> X</span><span class="symbol">,</span><span class="normal"> S</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">  tbinptr</span><span class="symbol">*</span><span class="normal"> H</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="usertype">bindex_t</span><span class="normal"> I</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="function">compute_tree_index</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">);\</span>
<span class="normal">  H </span><span class="symbol">=</span><span class="normal"> </span><span class="function">treebin_at</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">);\</span>
<span class="normal">  X</span><span class="symbol">-&gt;</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> I</span><span class="symbol">;\</span>
<span class="normal">  X</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">treemap_is_marked</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    </span><span class="function">mark_treemap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> I</span><span class="symbol">);\</span>
<span class="normal">    </span><span class="symbol">*</span><span class="normal">H </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">;\</span>
<span class="normal">    X</span><span class="symbol">-&gt;</span><span class="normal">parent </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">tchunkptr</span><span class="symbol">)</span><span class="normal">H</span><span class="symbol">;\</span>
<span class="normal">    X</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    </span><span class="usertype">tchunkptr</span><span class="normal"> T </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">H</span><span class="symbol">;\</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> K </span><span class="symbol">=</span><span class="normal"> S </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">leftshift_for_tree_index</span><span class="symbol">(</span><span class="normal">I</span><span class="symbol">);\</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(;;)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">T</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> S</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">        tchunkptr</span><span class="symbol">*</span><span class="normal"> C </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;(</span><span class="normal">T</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[(</span><span class="normal">K </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">SIZE_T_BITSIZE</span><span class="symbol">-</span><span class="normal">SIZE_T_ONE</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">]);\</span>
<span class="normal">        K </span><span class="symbol">&lt;&lt;=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;\</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">C </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)\</span>
<span class="normal">          T </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">C</span><span class="symbol">;\</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> C</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">          </span><span class="symbol">*</span><span class="normal">C </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">;\</span>
<span class="normal">          X</span><span class="symbol">-&gt;</span><span class="normal">parent </span><span class="symbol">=</span><span class="normal"> T</span><span class="symbol">;\</span>
<span class="normal">          X</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">;\</span>
<span class="normal">          </span><span class="keyword">break</span><span class="symbol">;\</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">          </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">);\</span>
<span class="normal">          </span><span class="keyword">break</span><span class="symbol">;\</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">      </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">        </span><span class="usertype">tchunkptr</span><span class="normal"> F </span><span class="symbol">=</span><span class="normal"> T</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">;\</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> T</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> F</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">          T</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> F</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">;\</span>
<span class="normal">          X</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> F</span><span class="symbol">;\</span>
<span class="normal">          X</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">=</span><span class="normal"> T</span><span class="symbol">;\</span>
<span class="normal">          X</span><span class="symbol">-&gt;</span><span class="normal">parent </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;\</span>
<span class="normal">          </span><span class="keyword">break</span><span class="symbol">;\</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">          </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">);\</span>
<span class="normal">          </span><span class="keyword">break</span><span class="symbol">;\</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">      </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="cbracket">}</span>

<span class="comment">/*</span>
<span class="comment">  Unlink steps:</span>

<span class="comment">  1. If x is a chained node, unlink it from its same-sized fd/bk links</span>
<span class="comment">     and choose its bk node as its replacement.</span>
<span class="comment">  2. If x was the last node of its size, but not a leaf node, it must</span>
<span class="comment">     be replaced with a leaf node (not merely one with an open left or</span>
<span class="comment">     right), to make sure that lefts and rights of descendents</span>
<span class="comment">     correspond properly to bit masks.  We use the rightmost descendent</span>
<span class="comment">     of x.  We could use any other leaf, but this is easy to locate and</span>
<span class="comment">     tends to counteract removal of leftmosts elsewhere, and so keeps</span>
<span class="comment">     paths shorter than minimally guaranteed.  This doesn't loop much</span>
<span class="comment">     because on average a node in a tree is near the bottom.</span>
<span class="comment">  3. If x is the base of a chain (i.e., has parent links) relink</span>
<span class="comment">     x's parent and children to x's replacement (or null if none).</span>
<span class="comment">*/</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">unlink_large_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> X</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">  </span><span class="usertype">tchunkptr</span><span class="normal"> XP </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">-&gt;</span><span class="normal">parent</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="usertype">tchunkptr</span><span class="normal"> R</span><span class="symbol">;\</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">X</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">!=</span><span class="normal"> X</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    </span><span class="usertype">tchunkptr</span><span class="normal"> F </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">;\</span>
<span class="normal">    R </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">-&gt;</span><span class="normal">bk</span><span class="symbol">;\</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> F</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">      F</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">=</span><span class="normal"> R</span><span class="symbol">;\</span>
<span class="normal">      R</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> F</span><span class="symbol">;\</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">      </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">);\</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    tchunkptr</span><span class="symbol">*</span><span class="normal"> RP</span><span class="symbol">;\</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">R </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">RP </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;(</span><span class="normal">X</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||\</span>
<span class="normal">        </span><span class="symbol">((</span><span class="normal">R </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">RP </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;(</span><span class="normal">X</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">      tchunkptr</span><span class="symbol">*</span><span class="normal"> CP</span><span class="symbol">;\</span>
<span class="normal">      </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">((*(</span><span class="normal">CP </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;(</span><span class="normal">R</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||\</span>
<span class="normal">             </span><span class="symbol">(*(</span><span class="normal">CP </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;(</span><span class="normal">R</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">        R </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">RP </span><span class="symbol">=</span><span class="normal"> CP</span><span class="symbol">);\</span>
<span class="normal">      </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> RP</span><span class="symbol">)))\</span>
<span class="normal">        </span><span class="symbol">*</span><span class="normal">RP </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;\</span>
<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">        </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">);\</span>
<span class="normal">      </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">XP </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">    tbinptr</span><span class="symbol">*</span><span class="normal"> H </span><span class="symbol">=</span><span class="normal"> </span><span class="function">treebin_at</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> X</span><span class="symbol">-&gt;</span><span class="normal">index</span><span class="symbol">);\</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">X </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">H</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((*</span><span class="normal">H </span><span class="symbol">=</span><span class="normal"> R</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">        </span><span class="function">clear_treemap</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> X</span><span class="symbol">-&gt;</span><span class="normal">index</span><span class="symbol">);\</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> XP</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">XP</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> X</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">        XP</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> R</span><span class="symbol">;\</span>
<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">        XP</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> R</span><span class="symbol">;\</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">    </span><span class="keyword">else</span><span class="symbol">\</span>
<span class="normal">      </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">);\</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">R </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> R</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">        </span><span class="usertype">tchunkptr</span><span class="normal"> C0</span><span class="symbol">,</span><span class="normal"> C1</span><span class="symbol">;\</span>
<span class="normal">        R</span><span class="symbol">-&gt;</span><span class="normal">parent </span><span class="symbol">=</span><span class="normal"> XP</span><span class="symbol">;\</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">C0 </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> C0</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">            R</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> C0</span><span class="symbol">;\</span>
<span class="normal">            C0</span><span class="symbol">-&gt;</span><span class="normal">parent </span><span class="symbol">=</span><span class="normal"> R</span><span class="symbol">;\</span>
<span class="normal">          </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">          </span><span class="keyword">else</span><span class="symbol">\</span>
<span class="normal">            </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">);\</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">C1 </span><span class="symbol">=</span><span class="normal"> X</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> C1</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span><span class="symbol">\</span>
<span class="normal">            R</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> C1</span><span class="symbol">;\</span>
<span class="normal">            C1</span><span class="symbol">-&gt;</span><span class="normal">parent </span><span class="symbol">=</span><span class="normal"> R</span><span class="symbol">;\</span>
<span class="normal">          </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">          </span><span class="keyword">else</span><span class="symbol">\</span>
<span class="normal">            </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">);\</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">      </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">      </span><span class="keyword">else</span><span class="symbol">\</span>
<span class="normal">        </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">);\</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="normal">  </span><span class="cbracket">}</span><span class="symbol">\</span>
<span class="cbracket">}</span>

<span class="comment">/* Relays to large vs small bin operations */</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">insert_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> P</span><span class="symbol">,</span><span class="normal"> S</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_small</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">))</span><span class="normal"> </span><span class="function">insert_small_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> P</span><span class="symbol">,</span><span class="normal"> S</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="usertype">tchunkptr</span><span class="normal"> TP </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">tchunkptr</span><span class="symbol">)(</span><span class="normal">P</span><span class="symbol">);</span><span class="normal"> </span><span class="function">insert_large_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> TP</span><span class="symbol">,</span><span class="normal"> S</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">unlink_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> P</span><span class="symbol">,</span><span class="normal"> S</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_small</span><span class="symbol">(</span><span class="normal">S</span><span class="symbol">))</span><span class="normal"> </span><span class="function">unlink_small_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> P</span><span class="symbol">,</span><span class="normal"> S</span><span class="symbol">)\</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="usertype">tchunkptr</span><span class="normal"> TP </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">tchunkptr</span><span class="symbol">)(</span><span class="normal">P</span><span class="symbol">);</span><span class="normal"> </span><span class="function">unlink_large_chunk</span><span class="symbol">(</span><span class="normal">M</span><span class="symbol">,</span><span class="normal"> TP</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>


<span class="comment">/* Relays to internal calls to malloc/free from realloc, memalign etc */</span>

<span class="preproc">#if</span><span class="normal"> ONLY_MSPACES</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">internal_malloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="function">mspace_malloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">internal_free</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">)</span><span class="normal"> </span><span class="function">mspace_free</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal">mem</span><span class="symbol">);</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* ONLY_MSPACES */</span>
<span class="preproc">#if</span><span class="normal"> MSPACES</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">internal_malloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">)\</span>
<span class="normal">   </span><span class="symbol">(</span><span class="normal">m </span><span class="symbol">==</span><span class="normal"> gm</span><span class="symbol">)?</span><span class="normal"> </span><span class="function">dlmalloc</span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="function">mspace_malloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">internal_free</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">)\</span>
<span class="normal">   </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m </span><span class="symbol">==</span><span class="normal"> gm</span><span class="symbol">)</span><span class="normal"> </span><span class="function">dlfree</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">);</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> </span><span class="function">mspace_free</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal">mem</span><span class="symbol">);</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* MSPACES */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">internal_malloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="function">dlmalloc</span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">internal_free</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">)</span><span class="normal"> </span><span class="function">dlfree</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* MSPACES */</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* ONLY_MSPACES */</span>

<span class="comment">/* -----------------------  Direct-mmapping chunks ----------------------- */</span>

<span class="comment">/*</span>
<span class="comment">  Directly mmapped chunks are set up with an offset to the start of</span>
<span class="comment">  the mmapped region stored in the prev_foot field of the chunk. This</span>
<span class="comment">  allows reconstruction of the required argument to MUNMAP when freed,</span>
<span class="comment">  and also allows adjustment of the returned chunk to meet alignment</span>
<span class="comment">  requirements (especially in memalign).  There is also enough space</span>
<span class="comment">  allocated to hold a fake next chunk of size SIZE_T_SIZE to maintain</span>
<span class="comment">  the PINUSE bit so frees can be checked.</span>
<span class="comment">*/</span>

<span class="comment">/* Malloc using mmap */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">mmap_alloc</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> nb</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> mmsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">granularity_align</span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">+</span><span class="normal"> SIX_SIZE_T_SIZES </span><span class="symbol">+</span><span class="normal"> CHUNK_ALIGN_MASK</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mmsize </span><span class="symbol">&gt;</span><span class="normal"> nb</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">     </span><span class="comment">/* Check for wrap around 0 */</span>
<span class="normal">    </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> mm </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="function">DIRECT_MMAP</span><span class="symbol">(</span><span class="normal">mmsize</span><span class="symbol">));</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mm </span><span class="symbol">!=</span><span class="normal"> CMFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> offset </span><span class="symbol">=</span><span class="normal"> </span><span class="function">align_offset</span><span class="symbol">(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">mm</span><span class="symbol">));</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> psize </span><span class="symbol">=</span><span class="normal"> mmsize </span><span class="symbol">-</span><span class="normal"> offset </span><span class="symbol">-</span><span class="normal"> MMAP_FOOT_PAD</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mchunkptr</span><span class="symbol">)(</span><span class="normal">mm </span><span class="symbol">+</span><span class="normal"> offset</span><span class="symbol">);</span>
<span class="normal">      p</span><span class="symbol">-&gt;</span><span class="normal">prev_foot </span><span class="symbol">=</span><span class="normal"> offset </span><span class="symbol">|</span><span class="normal"> IS_MMAPPED_BIT</span><span class="symbol">;</span>
<span class="normal">      </span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">psize</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">mark_inuse_foot</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> FENCEPOST_HEAD</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">+</span><span class="normal">SIZE_T_SIZE</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mm </span><span class="symbol">&lt;</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">least_addr</span><span class="symbol">)</span>
<span class="normal">        m</span><span class="symbol">-&gt;</span><span class="normal">least_addr </span><span class="symbol">=</span><span class="normal"> mm</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">footprint </span><span class="symbol">+=</span><span class="normal"> mmsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">max_footprint</span><span class="symbol">)</span>
<span class="normal">        m</span><span class="symbol">-&gt;</span><span class="normal">max_footprint </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">footprint</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_aligned</span><span class="symbol">(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)));</span>
<span class="normal">      </span><span class="function">check_mmapped_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* Realloc using mmap */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> </span><span class="function">mmap_resize</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> oldp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> nb</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> oldsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">oldp</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_small</span><span class="symbol">(</span><span class="normal">nb</span><span class="symbol">))</span><span class="normal"> </span><span class="comment">/* Can't shrink mmap regions below small size */</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="comment">/* Keep old chunk if big enough but not too big */</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">oldsize </span><span class="symbol">&gt;=</span><span class="normal"> nb </span><span class="symbol">+</span><span class="normal"> SIZE_T_SIZE </span><span class="symbol">&amp;&amp;</span>
<span class="normal">      </span><span class="symbol">(</span><span class="normal">oldsize </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mparams</span><span class="symbol">.</span><span class="normal">granularity </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">))</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> oldp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> offset </span><span class="symbol">=</span><span class="normal"> oldp</span><span class="symbol">-&gt;</span><span class="normal">prev_foot </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">IS_MMAPPED_BIT</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> oldmmsize </span><span class="symbol">=</span><span class="normal"> oldsize </span><span class="symbol">+</span><span class="normal"> offset </span><span class="symbol">+</span><span class="normal"> MMAP_FOOT_PAD</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> newmmsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">granularity_align</span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">+</span><span class="normal"> SIX_SIZE_T_SIZES </span><span class="symbol">+</span>
<span class="normal">                                         CHUNK_ALIGN_MASK</span><span class="symbol">);</span>
<span class="normal">    </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> cp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="function">CALL_MREMAP</span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">oldp </span><span class="symbol">-</span><span class="normal"> offset</span><span class="symbol">,</span>
<span class="normal">                                  oldmmsize</span><span class="symbol">,</span><span class="normal"> newmmsize</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">cp </span><span class="symbol">!=</span><span class="normal"> CMFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> newp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mchunkptr</span><span class="symbol">)(</span><span class="normal">cp </span><span class="symbol">+</span><span class="normal"> offset</span><span class="symbol">);</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> psize </span><span class="symbol">=</span><span class="normal"> newmmsize </span><span class="symbol">-</span><span class="normal"> offset </span><span class="symbol">-</span><span class="normal"> MMAP_FOOT_PAD</span><span class="symbol">;</span>
<span class="normal">      newp</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">psize</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">mark_inuse_foot</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> newp</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">newp</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> FENCEPOST_HEAD</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">newp</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">+</span><span class="normal">SIZE_T_SIZE</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">cp </span><span class="symbol">&lt;</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">least_addr</span><span class="symbol">)</span>
<span class="normal">        m</span><span class="symbol">-&gt;</span><span class="normal">least_addr </span><span class="symbol">=</span><span class="normal"> cp</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">footprint </span><span class="symbol">+=</span><span class="normal"> newmmsize </span><span class="symbol">-</span><span class="normal"> oldmmsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">max_footprint</span><span class="symbol">)</span>
<span class="normal">        m</span><span class="symbol">-&gt;</span><span class="normal">max_footprint </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">footprint</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">check_mmapped_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> newp</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> newp</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* -------------------------- mspace management -------------------------- */</span>

<span class="comment">/* Initialize top chunk and its size */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">init_top</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> psize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="comment">/* Ensure alignment */</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> offset </span><span class="symbol">=</span><span class="normal"> </span><span class="function">align_offset</span><span class="symbol">(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>
<span class="normal">  p </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mchunkptr</span><span class="symbol">)((</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">p </span><span class="symbol">+</span><span class="normal"> offset</span><span class="symbol">);</span>
<span class="normal">  psize </span><span class="symbol">-=</span><span class="normal"> offset</span><span class="symbol">;</span>

<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">=</span><span class="normal"> psize</span><span class="symbol">;</span>
<span class="normal">  p</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> psize </span><span class="symbol">|</span><span class="normal"> PINUSE_BIT</span><span class="symbol">;</span>
<span class="normal">  </span><span class="comment">/* set size of fake trailing chunk holding overhead space only once */</span>
<span class="normal">  </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">)-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">trim_check </span><span class="symbol">=</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">trim_threshold</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* reset on each update */</span>
<span class="cbracket">}</span>

<span class="comment">/* Initialize bins for a new mstate that is otherwise zeroed out */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">init_bins</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="comment">/* Establish circular links for smallbins */</span>
<span class="normal">  </span><span class="usertype">bindex_t</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> NSMALLBINS</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">sbinptr</span><span class="normal"> bin </span><span class="symbol">=</span><span class="normal"> </span><span class="function">smallbin_at</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal">i</span><span class="symbol">);</span>
<span class="normal">    bin</span><span class="symbol">-&gt;</span><span class="normal">fd </span><span class="symbol">=</span><span class="normal"> bin</span><span class="symbol">-&gt;</span><span class="normal">bk </span><span class="symbol">=</span><span class="normal"> bin</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> PROCEED_ON_ERROR</span>

<span class="comment">/* default corruption action */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">reset_on_error</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="type">int</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="normal">  </span><span class="symbol">++</span><span class="normal">malloc_corruption_error_count</span><span class="symbol">;</span>
<span class="normal">  </span><span class="comment">/* Reinitialize fields to forget about all memory */</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">smallbins </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">treebins </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">base </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">size </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">next </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> NTREEBINS</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">    </span><span class="symbol">*</span><span class="function">treebin_at</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="function">init_bins</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* PROCEED_ON_ERROR */</span>

<span class="comment">/* Allocate chunk and prepend remainder with chunk in successor base. */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">prepend_alloc</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> newbase</span><span class="symbol">,</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> oldbase</span><span class="symbol">,</span>
<span class="normal">                           </span><span class="usertype">size_t</span><span class="normal"> nb</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> </span><span class="function">align_as_chunk</span><span class="symbol">(</span><span class="normal">newbase</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> oldfirst </span><span class="symbol">=</span><span class="normal"> </span><span class="function">align_as_chunk</span><span class="symbol">(</span><span class="normal">oldbase</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> psize </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">oldfirst </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">p</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> q </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> qsize </span><span class="symbol">=</span><span class="normal"> psize </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">  </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>

<span class="normal">  </span><span class="function">assert</span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">oldfirst </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">q</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">pinuse</span><span class="symbol">(</span><span class="normal">oldfirst</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">qsize </span><span class="symbol">&gt;=</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">);</span>

<span class="normal">  </span><span class="comment">/* consolidate remainder with first chunk of old base */</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">oldfirst </span><span class="symbol">==</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> tsize </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">+=</span><span class="normal"> qsize</span><span class="symbol">;</span>
<span class="normal">    m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">=</span><span class="normal"> q</span><span class="symbol">;</span>
<span class="normal">    q</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> tsize </span><span class="symbol">|</span><span class="normal"> PINUSE_BIT</span><span class="symbol">;</span>
<span class="normal">    </span><span class="function">check_top_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">oldfirst </span><span class="symbol">==</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> dsize </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">+=</span><span class="normal"> qsize</span><span class="symbol">;</span>
<span class="normal">    m</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> q</span><span class="symbol">;</span>
<span class="normal">    </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">,</span><span class="normal"> dsize</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">oldfirst</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> nsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">oldfirst</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">unlink_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> oldfirst</span><span class="symbol">,</span><span class="normal"> nsize</span><span class="symbol">);</span>
<span class="normal">      oldfirst </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">oldfirst</span><span class="symbol">,</span><span class="normal"> nsize</span><span class="symbol">);</span>
<span class="normal">      qsize </span><span class="symbol">+=</span><span class="normal"> nsize</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="function">set_free_with_pinuse</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">,</span><span class="normal"> qsize</span><span class="symbol">,</span><span class="normal"> oldfirst</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">insert_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">,</span><span class="normal"> qsize</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">check_free_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">),</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="cbracket">}</span>


<span class="comment">/* Add a segment to hold a new noncontiguous region */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">add_segment</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> tbase</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> tsize</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">flag_t</span><span class="normal"> mmapped</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="comment">/* Determine locations and sizes of segment, fenceposts, old top */</span>
<span class="normal">  </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> old_top </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">msegmentptr</span><span class="normal"> oldsp </span><span class="symbol">=</span><span class="normal"> </span><span class="function">segment_holding</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> old_top</span><span class="symbol">);</span>
<span class="normal">  </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> old_end </span><span class="symbol">=</span><span class="normal"> oldsp</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">+</span><span class="normal"> oldsp</span><span class="symbol">-&gt;</span><span class="normal">size</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> ssize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">pad_request</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_segment</span><span class="symbol">));</span>
<span class="normal">  </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> rawsp </span><span class="symbol">=</span><span class="normal"> old_end </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ssize </span><span class="symbol">+</span><span class="normal"> FOUR_SIZE_T_SIZES </span><span class="symbol">+</span><span class="normal"> CHUNK_ALIGN_MASK</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> offset </span><span class="symbol">=</span><span class="normal"> </span><span class="function">align_offset</span><span class="symbol">(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">rawsp</span><span class="symbol">));</span>
<span class="normal">  </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> asp </span><span class="symbol">=</span><span class="normal"> rawsp </span><span class="symbol">+</span><span class="normal"> offset</span><span class="symbol">;</span>
<span class="normal">  </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> csp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">asp </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">old_top </span><span class="symbol">+</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">))?</span><span class="normal"> old_top </span><span class="symbol">:</span><span class="normal"> asp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> sp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mchunkptr</span><span class="symbol">)</span><span class="normal">csp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">msegmentptr</span><span class="normal"> ss </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">msegmentptr</span><span class="symbol">)(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">));</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> tnext </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">,</span><span class="normal"> ssize</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> tnext</span><span class="symbol">;</span>
<span class="normal">  </span><span class="type">int</span><span class="normal"> nfences </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">  </span><span class="comment">/* reset top to new space */</span>
<span class="normal">  </span><span class="function">init_top</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mchunkptr</span><span class="symbol">)</span><span class="normal">tbase</span><span class="symbol">,</span><span class="normal"> tsize </span><span class="symbol">-</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">);</span>

<span class="normal">  </span><span class="comment">/* Set up segment record */</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_aligned</span><span class="symbol">(</span><span class="normal">ss</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> sp</span><span class="symbol">,</span><span class="normal"> ssize</span><span class="symbol">);</span>
<span class="normal">  </span><span class="symbol">*</span><span class="normal">ss </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* Push current record */</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">base </span><span class="symbol">=</span><span class="normal"> tbase</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">size </span><span class="symbol">=</span><span class="normal"> tsize</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">sflags </span><span class="symbol">=</span><span class="normal"> mmapped</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">next </span><span class="symbol">=</span><span class="normal"> ss</span><span class="symbol">;</span>

<span class="normal">  </span><span class="comment">/* Insert trailing fenceposts */</span>
<span class="normal">  </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(;;)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> nextp </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> SIZE_T_SIZE</span><span class="symbol">);</span>
<span class="normal">    p</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> FENCEPOST_HEAD</span><span class="symbol">;</span>
<span class="normal">    </span><span class="symbol">++</span><span class="normal">nfences</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)(&amp;(</span><span class="normal">nextp</span><span class="symbol">-&gt;</span><span class="normal">head</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> old_end</span><span class="symbol">)</span>
<span class="normal">      p </span><span class="symbol">=</span><span class="normal"> nextp</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">else</span>
<span class="normal">      </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">nfences </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>

<span class="normal">  </span><span class="comment">/* Insert the rest of old top into a bin as an ordinary free chunk */</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">csp </span><span class="symbol">!=</span><span class="normal"> old_top</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> q </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mchunkptr</span><span class="symbol">)</span><span class="normal">old_top</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> psize </span><span class="symbol">=</span><span class="normal"> csp </span><span class="symbol">-</span><span class="normal"> old_top</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> tn </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">set_free_with_pinuse</span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">,</span><span class="normal"> tn</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">insert_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> q</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="function">check_top_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="comment">/* -------------------------- System allocation -------------------------- */</span>

<span class="comment">/* Get memory from system using MORECORE or MMAP */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">sys_alloc</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> nb</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> tbase </span><span class="symbol">=</span><span class="normal"> CMFAIL</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> tsize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">flag_t</span><span class="normal"> mmap_flag </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">  </span><span class="function">init_mparams</span><span class="symbol">();</span>

<span class="normal">  </span><span class="comment">/* Directly map large chunks */</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">use_mmap</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> nb </span><span class="symbol">&gt;=</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">mmap_threshold</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">mmap_alloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> mem</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="comment">/*</span>
<span class="comment">    Try getting memory in any of three ways (in most-preferred to</span>
<span class="comment">    least-preferred order):</span>
<span class="comment">    1. A call to MORECORE that can normally contiguously extend memory.</span>
<span class="comment">       (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or</span>
<span class="comment">       or main space is mmapped or a previous contiguous call failed)</span>
<span class="comment">    2. A call to MMAP new space (disabled if not HAVE_MMAP).</span>
<span class="comment">       Note that under the default settings, if MORECORE is unable to</span>
<span class="comment">       fulfill a request, and HAVE_MMAP is true, then mmap is</span>
<span class="comment">       used as a noncontiguous system allocator. This is a useful backup</span>
<span class="comment">       strategy for systems with holes in address spaces -- in this case</span>
<span class="comment">       sbrk cannot contiguously expand the heap, but mmap may be able to</span>
<span class="comment">       find space.</span>
<span class="comment">    3. A call to MORECORE that cannot usually contiguously extend memory.</span>
<span class="comment">       (disabled if not HAVE_MORECORE)</span>
<span class="comment">  */</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">MORECORE_CONTIGUOUS </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">use_noncontiguous</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> br </span><span class="symbol">=</span><span class="normal"> CMFAIL</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">msegmentptr</span><span class="normal"> ss </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)?</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="function">segment_holding</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">);</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> asize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="function">ACQUIRE_MORECORE_LOCK</span><span class="symbol">();</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ss </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">  </span><span class="comment">/* First time through or recovery */</span>
<span class="normal">      </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> base </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="function">CALL_MORECORE</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">base </span><span class="symbol">!=</span><span class="normal"> CMFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        asize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">granularity_align</span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE </span><span class="symbol">+</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">);</span>
<span class="normal">        </span><span class="comment">/* Adjust to end on a page boundary */</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">is_page_aligned</span><span class="symbol">(</span><span class="normal">base</span><span class="symbol">))</span>
<span class="normal">          asize </span><span class="symbol">+=</span><span class="normal"> </span><span class="symbol">(</span><span class="function">page_align</span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">base</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal">base</span><span class="symbol">);</span>
<span class="normal">        </span><span class="comment">/* Can't call MORECORE if size is negative when treated as signed */</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">asize </span><span class="symbol">&lt;</span><span class="normal"> HALF_MAX_SIZE_T </span><span class="symbol">&amp;&amp;</span>
<span class="normal">            </span><span class="symbol">(</span><span class="normal">br </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="function">CALL_MORECORE</span><span class="symbol">(</span><span class="normal">asize</span><span class="symbol">)))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> base</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          tbase </span><span class="symbol">=</span><span class="normal"> base</span><span class="symbol">;</span>
<span class="normal">          tsize </span><span class="symbol">=</span><span class="normal"> asize</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="comment">/* Subtract out existing available top space from MORECORE request. */</span>
<span class="normal">      asize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">granularity_align</span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">-</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE </span><span class="symbol">+</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">);</span>
<span class="normal">      </span><span class="comment">/* Use mem here only if it did continuously extend old space */</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">asize </span><span class="symbol">&lt;</span><span class="normal"> HALF_MAX_SIZE_T </span><span class="symbol">&amp;&amp;</span>
<span class="normal">          </span><span class="symbol">(</span><span class="normal">br </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="function">CALL_MORECORE</span><span class="symbol">(</span><span class="normal">asize</span><span class="symbol">)))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> ss</span><span class="symbol">-&gt;</span><span class="normal">base</span><span class="symbol">+</span><span class="normal">ss</span><span class="symbol">-&gt;</span><span class="normal">size</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        tbase </span><span class="symbol">=</span><span class="normal"> br</span><span class="symbol">;</span>
<span class="normal">        tsize </span><span class="symbol">=</span><span class="normal"> asize</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">tbase </span><span class="symbol">==</span><span class="normal"> CMFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">    </span><span class="comment">/* Cope with partial failure */</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">br </span><span class="symbol">!=</span><span class="normal"> CMFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">    </span><span class="comment">/* Try to use/extend the space we did get */</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">asize </span><span class="symbol">&lt;</span><span class="normal"> HALF_MAX_SIZE_T </span><span class="symbol">&amp;&amp;</span>
<span class="normal">            asize </span><span class="symbol">&lt;</span><span class="normal"> nb </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE </span><span class="symbol">+</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="usertype">size_t</span><span class="normal"> esize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">granularity_align</span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE </span><span class="symbol">+</span><span class="normal"> SIZE_T_ONE </span><span class="symbol">-</span><span class="normal"> asize</span><span class="symbol">);</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">esize </span><span class="symbol">&lt;</span><span class="normal"> HALF_MAX_SIZE_T</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> end </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="function">CALL_MORECORE</span><span class="symbol">(</span><span class="normal">esize</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">end </span><span class="symbol">!=</span><span class="normal"> CMFAIL</span><span class="symbol">)</span>
<span class="normal">              asize </span><span class="symbol">+=</span><span class="normal"> esize</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">            </span><span class="comment">/* Can't use; try to release */</span>
<span class="normal">              end </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="function">CALL_MORECORE</span><span class="symbol">(-</span><span class="normal">asize</span><span class="symbol">);</span>
<span class="normal">              br </span><span class="symbol">=</span><span class="normal"> CMFAIL</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">br </span><span class="symbol">!=</span><span class="normal"> CMFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">    </span><span class="comment">/* Use the space we did get */</span>
<span class="normal">        tbase </span><span class="symbol">=</span><span class="normal"> br</span><span class="symbol">;</span>
<span class="normal">        tsize </span><span class="symbol">=</span><span class="normal"> asize</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">else</span>
<span class="normal">        </span><span class="function">disable_contiguous</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span><span class="normal"> </span><span class="comment">/* Don't try contiguous path in the future */</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="function">RELEASE_MORECORE_LOCK</span><span class="symbol">();</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">HAVE_MMAP </span><span class="symbol">&amp;&amp;</span><span class="normal"> tbase </span><span class="symbol">==</span><span class="normal"> CMFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">  </span><span class="comment">/* Try MMAP */</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> req </span><span class="symbol">=</span><span class="normal"> nb </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE </span><span class="symbol">+</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> rsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">granularity_align</span><span class="symbol">(</span><span class="normal">req</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rsize </span><span class="symbol">&gt;</span><span class="normal"> nb</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* Fail if wraps around zero */</span>
<span class="normal">      </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> mp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="function">CALL_MMAP</span><span class="symbol">(</span><span class="normal">rsize</span><span class="symbol">));</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mp </span><span class="symbol">!=</span><span class="normal"> CMFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        tbase </span><span class="symbol">=</span><span class="normal"> mp</span><span class="symbol">;</span>
<span class="normal">        tsize </span><span class="symbol">=</span><span class="normal"> rsize</span><span class="symbol">;</span>
<span class="normal">        mmap_flag </span><span class="symbol">=</span><span class="normal"> IS_MMAPPED_BIT</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">HAVE_MORECORE </span><span class="symbol">&amp;&amp;</span><span class="normal"> tbase </span><span class="symbol">==</span><span class="normal"> CMFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* Try noncontiguous MORECORE */</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> asize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">granularity_align</span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE </span><span class="symbol">+</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">asize </span><span class="symbol">&lt;</span><span class="normal"> HALF_MAX_SIZE_T</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> br </span><span class="symbol">=</span><span class="normal"> CMFAIL</span><span class="symbol">;</span>
<span class="normal">      </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> end </span><span class="symbol">=</span><span class="normal"> CMFAIL</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">ACQUIRE_MORECORE_LOCK</span><span class="symbol">();</span>
<span class="normal">      br </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="function">CALL_MORECORE</span><span class="symbol">(</span><span class="normal">asize</span><span class="symbol">));</span>
<span class="normal">      end </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="function">CALL_MORECORE</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">));</span>
<span class="normal">      </span><span class="function">RELEASE_MORECORE_LOCK</span><span class="symbol">();</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">br </span><span class="symbol">!=</span><span class="normal"> CMFAIL </span><span class="symbol">&amp;&amp;</span><span class="normal"> end </span><span class="symbol">!=</span><span class="normal"> CMFAIL </span><span class="symbol">&amp;&amp;</span><span class="normal"> br </span><span class="symbol">&lt;</span><span class="normal"> end</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> ssize </span><span class="symbol">=</span><span class="normal"> end </span><span class="symbol">-</span><span class="normal"> br</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ssize </span><span class="symbol">&gt;</span><span class="normal"> nb </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          tbase </span><span class="symbol">=</span><span class="normal"> br</span><span class="symbol">;</span>
<span class="normal">          tsize </span><span class="symbol">=</span><span class="normal"> ssize</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">tbase </span><span class="symbol">!=</span><span class="normal"> CMFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">footprint </span><span class="symbol">+=</span><span class="normal"> tsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">max_footprint</span><span class="symbol">)</span>
<span class="normal">      m</span><span class="symbol">-&gt;</span><span class="normal">max_footprint </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">footprint</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">is_initialized</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* first-time initialization */</span>
<span class="normal">      m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">base </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">least_addr </span><span class="symbol">=</span><span class="normal"> tbase</span><span class="symbol">;</span>
<span class="normal">      m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">size </span><span class="symbol">=</span><span class="normal"> tsize</span><span class="symbol">;</span>
<span class="normal">      m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">sflags </span><span class="symbol">=</span><span class="normal"> mmap_flag</span><span class="symbol">;</span>
<span class="normal">      m</span><span class="symbol">-&gt;</span><span class="normal">magic </span><span class="symbol">=</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">magic</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">init_bins</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_global</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span>
<span class="normal">        </span><span class="function">init_top</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mchunkptr</span><span class="symbol">)</span><span class="normal">tbase</span><span class="symbol">,</span><span class="normal"> tsize </span><span class="symbol">-</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">/* Offset top by embedded malloc_state */</span>
<span class="normal">        </span><span class="usertype">mchunkptr</span><span class="normal"> mn </span><span class="symbol">=</span><span class="normal"> </span><span class="function">next_chunk</span><span class="symbol">(</span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">));</span>
<span class="normal">        </span><span class="function">init_top</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> mn</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)((</span><span class="normal">tbase </span><span class="symbol">+</span><span class="normal"> tsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">mn</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal">TOP_FOOT_SIZE</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="comment">/* Try to merge with an existing segment */</span>
<span class="normal">      </span><span class="usertype">msegmentptr</span><span class="normal"> sp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sp </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> tbase </span><span class="symbol">!=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">+</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">size</span><span class="symbol">)</span>
<span class="normal">        sp </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">next</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sp </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">          </span><span class="symbol">!</span><span class="function">is_extern_segment</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">          </span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">-&gt;</span><span class="normal">sflags </span><span class="symbol">&amp;</span><span class="normal"> IS_MMAPPED_BIT</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> mmap_flag </span><span class="symbol">&amp;&amp;</span>
<span class="normal">          </span><span class="function">segment_holds</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* append */</span>
<span class="normal">        sp</span><span class="symbol">-&gt;</span><span class="normal">size </span><span class="symbol">+=</span><span class="normal"> tsize</span><span class="symbol">;</span>
<span class="normal">        </span><span class="function">init_top</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">+</span><span class="normal"> tsize</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">tbase </span><span class="symbol">&lt;</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">least_addr</span><span class="symbol">)</span>
<span class="normal">          m</span><span class="symbol">-&gt;</span><span class="normal">least_addr </span><span class="symbol">=</span><span class="normal"> tbase</span><span class="symbol">;</span>
<span class="normal">        sp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sp </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">!=</span><span class="normal"> tbase </span><span class="symbol">+</span><span class="normal"> tsize</span><span class="symbol">)</span>
<span class="normal">          sp </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">next</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sp </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">            </span><span class="symbol">!</span><span class="function">is_extern_segment</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">            </span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">-&gt;</span><span class="normal">sflags </span><span class="symbol">&amp;</span><span class="normal"> IS_MMAPPED_BIT</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> mmap_flag</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> oldbase </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">base</span><span class="symbol">;</span>
<span class="normal">          sp</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">=</span><span class="normal"> tbase</span><span class="symbol">;</span>
<span class="normal">          sp</span><span class="symbol">-&gt;</span><span class="normal">size </span><span class="symbol">+=</span><span class="normal"> tsize</span><span class="symbol">;</span>
<span class="normal">          </span><span class="keyword">return</span><span class="normal"> </span><span class="function">prepend_alloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> tbase</span><span class="symbol">,</span><span class="normal"> oldbase</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span>
<span class="normal">          </span><span class="function">add_segment</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> tbase</span><span class="symbol">,</span><span class="normal"> tsize</span><span class="symbol">,</span><span class="normal"> mmap_flag</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">&lt;</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* Allocate from new or extended top space */</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> rsize </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">-=</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> r </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      r</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> rsize </span><span class="symbol">|</span><span class="normal"> PINUSE_BIT</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">check_top_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">),</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  MALLOC_FAILURE_ACTION</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* -----------------------  system deallocation -------------------------- */</span>

<span class="comment">/* Unmap and unlink any mmapped segments that don't contain used chunks */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> </span><span class="function">release_unused_segments</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> released </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">msegmentptr</span><span class="normal"> pred </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">msegmentptr</span><span class="normal"> sp </span><span class="symbol">=</span><span class="normal"> pred</span><span class="symbol">-&gt;</span><span class="normal">next</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sp </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> base </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">base</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> size </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">size</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">msegmentptr</span><span class="normal"> next </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">next</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_mmapped_segment</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">is_extern_segment</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> </span><span class="function">align_as_chunk</span><span class="symbol">(</span><span class="normal">base</span><span class="symbol">);</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> psize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="comment">/* Can unmap if first chunk holds entire segment and not pinned */</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">p </span><span class="symbol">+</span><span class="normal"> psize </span><span class="symbol">&gt;=</span><span class="normal"> base </span><span class="symbol">+</span><span class="normal"> size </span><span class="symbol">-</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">tchunkptr</span><span class="normal"> tp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">tchunkptr</span><span class="symbol">)</span><span class="normal">p</span><span class="symbol">;</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">segment_holds</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">sp</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p </span><span class="symbol">==</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          m</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">          m</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="function">unlink_large_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> tp</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">CALL_MUNMAP</span><span class="symbol">(</span><span class="normal">base</span><span class="symbol">,</span><span class="normal"> size</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          released </span><span class="symbol">+=</span><span class="normal"> size</span><span class="symbol">;</span>
<span class="normal">          m</span><span class="symbol">-&gt;</span><span class="normal">footprint </span><span class="symbol">-=</span><span class="normal"> size</span><span class="symbol">;</span>
<span class="normal">          </span><span class="comment">/* unlink obsoleted record */</span>
<span class="normal">          sp </span><span class="symbol">=</span><span class="normal"> pred</span><span class="symbol">;</span>
<span class="normal">          sp</span><span class="symbol">-&gt;</span><span class="normal">next </span><span class="symbol">=</span><span class="normal"> next</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* back out if cannot unmap */</span>
<span class="normal">          </span><span class="function">insert_large_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> tp</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    pred </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">;</span>
<span class="normal">    sp </span><span class="symbol">=</span><span class="normal"> next</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> released</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="keyword">static</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">sys_trim</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> pad</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> released </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">pad </span><span class="symbol">&lt;</span><span class="normal"> MAX_REQUEST </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">is_initialized</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    pad </span><span class="symbol">+=</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* ensure enough room for segment overhead */</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">&gt;</span><span class="normal"> pad</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="comment">/* Shrink top space in granularity-size units, keeping at least one */</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> unit </span><span class="symbol">=</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">granularity</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> extra </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">-</span><span class="normal"> pad </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">unit </span><span class="symbol">-</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> unit </span><span class="symbol">-</span>
<span class="normal">                      SIZE_T_ONE</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> unit</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">msegmentptr</span><span class="normal"> sp </span><span class="symbol">=</span><span class="normal"> </span><span class="function">segment_holding</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">);</span>

<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">is_extern_segment</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_mmapped_segment</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">HAVE_MMAP </span><span class="symbol">&amp;&amp;</span>
<span class="normal">              sp</span><span class="symbol">-&gt;</span><span class="normal">size </span><span class="symbol">&gt;=</span><span class="normal"> extra </span><span class="symbol">&amp;&amp;</span>
<span class="normal">              </span><span class="symbol">!</span><span class="function">has_segment_link</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> sp</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* can't shrink if pinned */</span>
<span class="normal">            </span><span class="usertype">size_t</span><span class="normal"> newsize </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">size </span><span class="symbol">-</span><span class="normal"> extra</span><span class="symbol">;</span>
<span class="normal">            </span><span class="comment">/* Prefer mremap, fall back to munmap */</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="function">CALL_MREMAP</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">-&gt;</span><span class="normal">base</span><span class="symbol">,</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">size</span><span class="symbol">,</span><span class="normal"> newsize</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> MFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">||</span>
<span class="normal">                </span><span class="symbol">(</span><span class="function">CALL_MUNMAP</span><span class="symbol">(</span><span class="normal">sp</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">+</span><span class="normal"> newsize</span><span class="symbol">,</span><span class="normal"> extra</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">              released </span><span class="symbol">=</span><span class="normal"> extra</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">HAVE_MORECORE</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">extra </span><span class="symbol">&gt;=</span><span class="normal"> HALF_MAX_SIZE_T</span><span class="symbol">)</span><span class="normal"> </span><span class="comment">/* Avoid wrapping negative */</span>
<span class="normal">            extra </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">HALF_MAX_SIZE_T</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> SIZE_T_ONE </span><span class="symbol">-</span><span class="normal"> unit</span><span class="symbol">;</span>
<span class="normal">          </span><span class="function">ACQUIRE_MORECORE_LOCK</span><span class="symbol">();</span>
<span class="normal">          </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">/* Make sure end of memory is where we last set it. */</span>
<span class="normal">            </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> old_br </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="function">CALL_MORECORE</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">));</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">old_br </span><span class="symbol">==</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">base </span><span class="symbol">+</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">size</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">              </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> rel_br </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="function">CALL_MORECORE</span><span class="symbol">(-</span><span class="normal">extra</span><span class="symbol">));</span>
<span class="normal">              </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> new_br </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="function">CALL_MORECORE</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">));</span>
<span class="normal">              </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rel_br </span><span class="symbol">!=</span><span class="normal"> CMFAIL </span><span class="symbol">&amp;&amp;</span><span class="normal"> new_br </span><span class="symbol">&lt;</span><span class="normal"> old_br</span><span class="symbol">)</span>
<span class="normal">                released </span><span class="symbol">=</span><span class="normal"> old_br </span><span class="symbol">-</span><span class="normal"> new_br</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">          </span><span class="function">RELEASE_MORECORE_LOCK</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="cbracket">}</span>

<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">released </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        sp</span><span class="symbol">-&gt;</span><span class="normal">size </span><span class="symbol">-=</span><span class="normal"> released</span><span class="symbol">;</span>
<span class="normal">        m</span><span class="symbol">-&gt;</span><span class="normal">footprint </span><span class="symbol">-=</span><span class="normal"> released</span><span class="symbol">;</span>
<span class="normal">        </span><span class="function">init_top</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">-</span><span class="normal"> released</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">check_top_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/* Unmap any unused mmapped segments */</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">HAVE_MMAP</span><span class="symbol">)</span><span class="normal"> </span>
<span class="normal">      released </span><span class="symbol">+=</span><span class="normal"> </span><span class="function">release_unused_segments</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/* On failure, disable autotrim to avoid repeated failed future calls */</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">released </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">      m</span><span class="symbol">-&gt;</span><span class="normal">trim_check </span><span class="symbol">=</span><span class="normal"> MAX_SIZE_T</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">released </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)?</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* ---------------------------- malloc support --------------------------- */</span>

<span class="comment">/* allocate a large request from the best fitting chunk in a treebin */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">tmalloc_large</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> nb</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">tchunkptr</span><span class="normal"> v </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> rsize </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">-</span><span class="normal">nb</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* Unsigned negation */</span>
<span class="normal">  </span><span class="usertype">tchunkptr</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">bindex_t</span><span class="normal"> idx</span><span class="symbol">;</span>
<span class="normal">  </span><span class="function">compute_tree_index</span><span class="symbol">(</span><span class="normal">nb</span><span class="symbol">,</span><span class="normal"> idx</span><span class="symbol">);</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">t </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="function">treebin_at</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> idx</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* Traverse tree for this bin looking for node with size == nb */</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> sizebits </span><span class="symbol">=</span><span class="normal"> nb </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">leftshift_for_tree_index</span><span class="symbol">(</span><span class="normal">idx</span><span class="symbol">);</span>
<span class="normal">    </span><span class="usertype">tchunkptr</span><span class="normal"> rst </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">/* The deepest untaken right subtree */</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(;;)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">tchunkptr</span><span class="normal"> rt</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> trem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">trem </span><span class="symbol">&lt;</span><span class="normal"> rsize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        v </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">rsize </span><span class="symbol">=</span><span class="normal"> trem</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">          </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      rt </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">      t </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">-&gt;</span><span class="normal">child</span><span class="symbol">[(</span><span class="normal">sizebits </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">SIZE_T_BITSIZE</span><span class="symbol">-</span><span class="normal">SIZE_T_ONE</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rt </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> rt </span><span class="symbol">!=</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">        rst </span><span class="symbol">=</span><span class="normal"> rt</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        t </span><span class="symbol">=</span><span class="normal"> rst</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* set t to least subtree holding sizes &gt; nb */</span>
<span class="normal">        </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      sizebits </span><span class="symbol">&lt;&lt;=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> v </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* set t to root of next non-empty treebin */</span>
<span class="normal">    </span><span class="usertype">binmap_t</span><span class="normal"> leftbits </span><span class="symbol">=</span><span class="normal"> </span><span class="function">left_bits</span><span class="symbol">(</span><span class="function">idx2bit</span><span class="symbol">(</span><span class="normal">idx</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">treemap</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leftbits </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">bindex_t</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">binmap_t</span><span class="normal"> leastbit </span><span class="symbol">=</span><span class="normal"> </span><span class="function">least_bit</span><span class="symbol">(</span><span class="normal">leftbits</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">compute_bit2idx</span><span class="symbol">(</span><span class="normal">leastbit</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">      t </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="function">treebin_at</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* find smallest of tree or subtree */</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> trem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">trem </span><span class="symbol">&lt;</span><span class="normal"> rsize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      rsize </span><span class="symbol">=</span><span class="normal"> trem</span><span class="symbol">;</span>
<span class="normal">      v </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    t </span><span class="symbol">=</span><span class="normal"> </span><span class="function">leftmost_child</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="comment">/*  If dv is a better fit, return 0 so malloc will use it */</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">v </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> rsize </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> v</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* split */</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> r </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> rsize </span><span class="symbol">+</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_next</span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">,</span><span class="normal"> r</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">unlink_large_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> v</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rsize </span><span class="symbol">&lt;</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">)</span>
<span class="normal">          </span><span class="function">set_inuse_and_pinuse</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> v</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rsize </span><span class="symbol">+</span><span class="normal"> nb</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> v</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">r</span><span class="symbol">,</span><span class="normal"> rsize</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">insert_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> r</span><span class="symbol">,</span><span class="normal"> rsize</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* allocate a small request from the best fitting chunk in a treebin */</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">tmalloc_small</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> nb</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">tchunkptr</span><span class="normal"> t</span><span class="symbol">,</span><span class="normal"> v</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> rsize</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">bindex_t</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">binmap_t</span><span class="normal"> leastbit </span><span class="symbol">=</span><span class="normal"> </span><span class="function">least_bit</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">treemap</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">compute_bit2idx</span><span class="symbol">(</span><span class="normal">leastbit</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>

<span class="normal">  v </span><span class="symbol">=</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="function">treebin_at</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">  rsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>

<span class="normal">  </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">t </span><span class="symbol">=</span><span class="normal"> </span><span class="function">leftmost_child</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> trem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">trem </span><span class="symbol">&lt;</span><span class="normal"> rsize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      rsize </span><span class="symbol">=</span><span class="normal"> trem</span><span class="symbol">;</span>
<span class="normal">      v </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> v</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> r </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> rsize </span><span class="symbol">+</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_next</span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">,</span><span class="normal"> r</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">unlink_large_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> v</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rsize </span><span class="symbol">&lt;</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">)</span>
<span class="normal">        </span><span class="function">set_inuse_and_pinuse</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> v</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rsize </span><span class="symbol">+</span><span class="normal"> nb</span><span class="symbol">));</span>
<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> v</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">r</span><span class="symbol">,</span><span class="normal"> rsize</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">replace_dv</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> r</span><span class="symbol">,</span><span class="normal"> rsize</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">v</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="function">CORRUPTION_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* --------------------------- realloc support --------------------------- */</span>

<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">internal_realloc</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> oldmem</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bytes </span><span class="symbol">&gt;=</span><span class="normal"> MAX_REQUEST</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    MALLOC_FAILURE_ACTION</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> oldp </span><span class="symbol">=</span><span class="normal"> </span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">oldmem</span><span class="symbol">);</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> oldsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">oldp</span><span class="symbol">);</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> next </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">oldp</span><span class="symbol">,</span><span class="normal"> oldsize</span><span class="symbol">);</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> newp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> extra </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/* Try to either shrink or extend into top. Else malloc-copy-free */</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> oldp</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">ok_cinuse</span><span class="symbol">(</span><span class="normal">oldp</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">                </span><span class="function">ok_next</span><span class="symbol">(</span><span class="normal">oldp</span><span class="symbol">,</span><span class="normal"> next</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">ok_pinuse</span><span class="symbol">(</span><span class="normal">next</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> nb </span><span class="symbol">=</span><span class="normal"> </span><span class="function">request2size</span><span class="symbol">(</span><span class="normal">bytes</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">oldp</span><span class="symbol">))</span>
<span class="normal">        newp </span><span class="symbol">=</span><span class="normal"> </span><span class="function">mmap_resize</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> oldp</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">oldsize </span><span class="symbol">&gt;=</span><span class="normal"> nb</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* already big enough */</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> rsize </span><span class="symbol">=</span><span class="normal"> oldsize </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">        newp </span><span class="symbol">=</span><span class="normal"> oldp</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rsize </span><span class="symbol">&gt;=</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="usertype">mchunkptr</span><span class="normal"> remainder </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">newp</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">set_inuse</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> newp</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">set_inuse</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> remainder</span><span class="symbol">,</span><span class="normal"> rsize</span><span class="symbol">);</span>
<span class="normal">          extra </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">remainder</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next </span><span class="symbol">==</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">&amp;&amp;</span><span class="normal"> oldsize </span><span class="symbol">+</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">&gt;</span><span class="normal"> nb</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">/* Expand into top */</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> newsize </span><span class="symbol">=</span><span class="normal"> oldsize </span><span class="symbol">+</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">topsize</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> newtopsize </span><span class="symbol">=</span><span class="normal"> newsize </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">mchunkptr</span><span class="normal"> newtop </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">oldp</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">set_inuse</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> oldp</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">        newtop</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> newtopsize </span><span class="symbol">|</span><span class="normal">PINUSE_BIT</span><span class="symbol">;</span>
<span class="normal">        m</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">=</span><span class="normal"> newtop</span><span class="symbol">;</span>
<span class="normal">        m</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">=</span><span class="normal"> newtopsize</span><span class="symbol">;</span>
<span class="normal">        newp </span><span class="symbol">=</span><span class="normal"> oldp</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> oldmem</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">newp </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">extra </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">internal_free</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> extra</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="function">check_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> newp</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">newp</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> newmem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">internal_malloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> bytes</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">newmem </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> oc </span><span class="symbol">=</span><span class="normal"> oldsize </span><span class="symbol">-</span><span class="normal"> </span><span class="function">overhead_for</span><span class="symbol">(</span><span class="normal">oldp</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">memcpy</span><span class="symbol">(</span><span class="normal">newmem</span><span class="symbol">,</span><span class="normal"> oldmem</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">oc </span><span class="symbol">&lt;</span><span class="normal"> bytes</span><span class="symbol">)?</span><span class="normal"> oc </span><span class="symbol">:</span><span class="normal"> bytes</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">internal_free</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> oldmem</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> newmem</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* --------------------------- memalign support -------------------------- */</span>

<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">internal_memalign</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> alignment</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">alignment </span><span class="symbol">&lt;=</span><span class="normal"> MALLOC_ALIGNMENT</span><span class="symbol">)</span><span class="normal">    </span><span class="comment">/* Can just use malloc */</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="function">internal_malloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> bytes</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">alignment </span><span class="symbol">&lt;</span><span class="normal">  MIN_CHUNK_SIZE</span><span class="symbol">)</span><span class="normal"> </span><span class="comment">/* must be at least a minimum chunk size */</span>
<span class="normal">    alignment </span><span class="symbol">=</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">alignment </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">alignment</span><span class="symbol">-</span><span class="normal">SIZE_T_ONE</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="comment">/* Ensure a power of 2 */</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> a </span><span class="symbol">=</span><span class="normal"> MALLOC_ALIGNMENT </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a </span><span class="symbol">&lt;</span><span class="normal"> alignment</span><span class="symbol">)</span><span class="normal"> a </span><span class="symbol">&lt;&lt;=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">    alignment </span><span class="symbol">=</span><span class="normal"> a</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bytes </span><span class="symbol">&gt;=</span><span class="normal"> MAX_REQUEST </span><span class="symbol">-</span><span class="normal"> alignment</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal">  </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* Test isn't needed but avoids compiler warning */</span>
<span class="normal">      MALLOC_FAILURE_ACTION</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> nb </span><span class="symbol">=</span><span class="normal"> </span><span class="function">request2size</span><span class="symbol">(</span><span class="normal">bytes</span><span class="symbol">);</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> req </span><span class="symbol">=</span><span class="normal"> nb </span><span class="symbol">+</span><span class="normal"> alignment </span><span class="symbol">+</span><span class="normal"> MIN_CHUNK_SIZE </span><span class="symbol">-</span><span class="normal"> CHUNK_OVERHEAD</span><span class="symbol">;</span>
<span class="normal">    </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> mem </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="function">internal_malloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> req</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> leader </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">      </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> trailer </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> </span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">);</span>

<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((((</span><span class="normal">size_t</span><span class="symbol">)(</span><span class="normal">mem</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">%</span><span class="normal"> alignment</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* misaligned */</span>
<span class="normal">        </span><span class="comment">/*</span>
<span class="comment">          Find an aligned spot inside chunk.  Since we need to give</span>
<span class="comment">          back leading space in a chunk of at least MIN_CHUNK_SIZE, if</span>
<span class="comment">          the first calculation places us at a spot with less than</span>
<span class="comment">          MIN_CHUNK_SIZE leader, we can move to the next aligned spot.</span>
<span class="comment">          We've allocated enough total room so that this is always</span>
<span class="comment">          possible.</span>
<span class="comment">        */</span>
<span class="normal">        </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> br </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="function">mem2chunk</span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)(((</span><span class="normal">size_t</span><span class="symbol">)(</span><span class="normal">mem </span><span class="symbol">+</span>
<span class="normal">                                                       alignment </span><span class="symbol">-</span>
<span class="normal">                                                       SIZE_T_ONE</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&amp;</span>
<span class="normal">                                             </span><span class="symbol">-</span><span class="normal">alignment</span><span class="symbol">));</span>
<span class="normal">        </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> pos </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">)(</span><span class="normal">br </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&gt;=</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">)?</span>
<span class="normal">          br </span><span class="symbol">:</span><span class="normal"> br</span><span class="symbol">+</span><span class="normal">alignment</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">mchunkptr</span><span class="normal"> newp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mchunkptr</span><span class="symbol">)</span><span class="normal">pos</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> leadsize </span><span class="symbol">=</span><span class="normal"> pos </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> newsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> leadsize</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* For mmapped chunks, just adjust offset */</span>
<span class="normal">          newp</span><span class="symbol">-&gt;</span><span class="normal">prev_foot </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">-&gt;</span><span class="normal">prev_foot </span><span class="symbol">+</span><span class="normal"> leadsize</span><span class="symbol">;</span>
<span class="normal">          newp</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">newsize</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* Otherwise, give back leader, use the rest */</span>
<span class="normal">          </span><span class="function">set_inuse</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> newp</span><span class="symbol">,</span><span class="normal"> newsize</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">set_inuse</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> leadsize</span><span class="symbol">);</span>
<span class="normal">          leader </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        p </span><span class="symbol">=</span><span class="normal"> newp</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>

<span class="normal">      </span><span class="comment">/* Give back spare room at the end */</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> size </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size </span><span class="symbol">&gt;</span><span class="normal"> nb </span><span class="symbol">+</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="usertype">size_t</span><span class="normal"> remainder_size </span><span class="symbol">=</span><span class="normal"> size </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">          </span><span class="usertype">mchunkptr</span><span class="normal"> remainder </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">set_inuse</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">set_inuse</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> remainder</span><span class="symbol">,</span><span class="normal"> remainder_size</span><span class="symbol">);</span>
<span class="normal">          trailer </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">remainder</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="cbracket">}</span>

<span class="normal">      </span><span class="function">assert</span><span class="normal"> </span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&gt;=</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">((((</span><span class="normal">size_t</span><span class="symbol">)(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)))</span><span class="normal"> </span><span class="symbol">%</span><span class="normal"> alignment</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">check_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">leader </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">internal_free</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> leader</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">trailer </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">internal_free</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> trailer</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/* ------------------------ comalloc/coalloc support --------------------- */</span>

<span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="symbol">**</span><span class="normal"> </span><span class="function">ialloc</span><span class="symbol">(</span><span class="usertype">mstate</span><span class="normal"> m</span><span class="symbol">,</span>
<span class="normal">                     </span><span class="usertype">size_t</span><span class="normal"> n_elements</span><span class="symbol">,</span>
<span class="normal">                     size_t</span><span class="symbol">*</span><span class="normal"> sizes</span><span class="symbol">,</span>
<span class="normal">                     </span><span class="type">int</span><span class="normal"> opts</span><span class="symbol">,</span>
<span class="normal">                     </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> chunks</span><span class="symbol">[])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="comment">/*</span>
<span class="comment">    This provides common support for independent_X routines, handling</span>
<span class="comment">    all of the combinations that can result.</span>

<span class="comment">    The opts arg has:</span>
<span class="comment">    bit 0 set if all elements are same size (using sizes[0])</span>
<span class="comment">    bit 1 set if elements should be zeroed</span>
<span class="comment">  */</span>

<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">    element_size</span><span class="symbol">;</span><span class="normal">   </span><span class="comment">/* chunksize of each element, if all same */</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">    contents_size</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">/* total size of elements */</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">    array_size</span><span class="symbol">;</span><span class="normal">     </span><span class="comment">/* request size of pointer array */</span>
<span class="normal">  </span><span class="type">void</span><span class="symbol">*</span><span class="normal">     mem</span><span class="symbol">;</span><span class="normal">            </span><span class="comment">/* malloced aggregate space */</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> p</span><span class="symbol">;</span><span class="normal">              </span><span class="comment">/* corresponding chunk */</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">    remainder_size</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* remaining bytes while splitting */</span>
<span class="normal">  </span><span class="type">void</span><span class="symbol">**</span><span class="normal">    marray</span><span class="symbol">;</span><span class="normal">         </span><span class="comment">/* either "chunks" or malloced ptr array */</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> array_chunk</span><span class="symbol">;</span><span class="normal">    </span><span class="comment">/* chunk for malloced ptr array */</span>
<span class="normal">  </span><span class="usertype">flag_t</span><span class="normal">    was_enabled</span><span class="symbol">;</span><span class="normal">    </span><span class="comment">/* to disable mmap */</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">    size</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal">    i</span><span class="symbol">;</span>

<span class="normal">  </span><span class="comment">/* compute array length, if needed */</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">chunks </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n_elements </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> chunks</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* nothing to do */</span>
<span class="normal">    marray </span><span class="symbol">=</span><span class="normal"> chunks</span><span class="symbol">;</span>
<span class="normal">    array_size </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* if empty req, must still return chunk representing empty array */</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n_elements </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="type">void</span><span class="symbol">**)</span><span class="function">internal_malloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    marray </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    array_size </span><span class="symbol">=</span><span class="normal"> </span><span class="function">request2size</span><span class="symbol">(</span><span class="normal">n_elements </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*)));</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="comment">/* compute total element size */</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">opts </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x1</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* all-same-size */</span>
<span class="normal">    element_size </span><span class="symbol">=</span><span class="normal"> </span><span class="function">request2size</span><span class="symbol">(*</span><span class="normal">sizes</span><span class="symbol">);</span>
<span class="normal">    contents_size </span><span class="symbol">=</span><span class="normal"> n_elements </span><span class="symbol">*</span><span class="normal"> element_size</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* add up all the sizes */</span>
<span class="normal">    element_size </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    contents_size </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">!=</span><span class="normal"> n_elements</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">      contents_size </span><span class="symbol">+=</span><span class="normal"> </span><span class="function">request2size</span><span class="symbol">(</span><span class="normal">sizes</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]);</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  size </span><span class="symbol">=</span><span class="normal"> contents_size </span><span class="symbol">+</span><span class="normal"> array_size</span><span class="symbol">;</span>

<span class="normal">  </span><span class="comment">/*</span>
<span class="comment">     Allocate the aggregate chunk.  First disable direct-mmapping so</span>
<span class="comment">     malloc won't use it, since we would not be able to later</span>
<span class="comment">     free/realloc space internal to a segregated mmap region.</span>
<span class="comment">  */</span>
<span class="normal">  was_enabled </span><span class="symbol">=</span><span class="normal"> </span><span class="function">use_mmap</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">disable_mmap</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">  mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">internal_malloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> size </span><span class="symbol">-</span><span class="normal"> CHUNK_OVERHEAD</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">was_enabled</span><span class="symbol">)</span>
<span class="normal">    </span><span class="function">enable_mmap</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  p </span><span class="symbol">=</span><span class="normal"> </span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">);</span>
<span class="normal">  remainder_size </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>

<span class="normal">  </span><span class="function">assert</span><span class="symbol">(!</span><span class="function">is_mmapped</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">));</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">opts </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x2</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">       </span><span class="comment">/* optionally clear the elements */</span>
<span class="normal">    </span><span class="function">memset</span><span class="symbol">((</span><span class="normal">size_t</span><span class="symbol">*)</span><span class="normal">mem</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> remainder_size </span><span class="symbol">-</span><span class="normal"> SIZE_T_SIZE </span><span class="symbol">-</span><span class="normal"> array_size</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="comment">/* If not provided, allocate the pointer array as final part of chunk */</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">marray </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal">  array_chunk_size</span><span class="symbol">;</span>
<span class="normal">    array_chunk </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> contents_size</span><span class="symbol">);</span>
<span class="normal">    array_chunk_size </span><span class="symbol">=</span><span class="normal"> remainder_size </span><span class="symbol">-</span><span class="normal"> contents_size</span><span class="symbol">;</span>
<span class="normal">    marray </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">void</span><span class="symbol">**)</span><span class="normal"> </span><span class="symbol">(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">array_chunk</span><span class="symbol">));</span>
<span class="normal">    </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> array_chunk</span><span class="symbol">,</span><span class="normal"> array_chunk_size</span><span class="symbol">);</span>
<span class="normal">    remainder_size </span><span class="symbol">=</span><span class="normal"> contents_size</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="comment">/* split out elements */</span>
<span class="normal">  </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    marray</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">!=</span><span class="normal"> n_elements</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">element_size </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">        size </span><span class="symbol">=</span><span class="normal"> element_size</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">else</span>
<span class="normal">        size </span><span class="symbol">=</span><span class="normal"> </span><span class="function">request2size</span><span class="symbol">(</span><span class="normal">sizes</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]);</span>
<span class="normal">      remainder_size </span><span class="symbol">-=</span><span class="normal"> size</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> size</span><span class="symbol">);</span>
<span class="normal">      p </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> size</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* the final element absorbs any overallocation slop */</span>
<span class="normal">      </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> remainder_size</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> DEBUG</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">marray </span><span class="symbol">!=</span><span class="normal"> chunks</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">/* final element must have exactly exhausted chunk */</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">element_size </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">remainder_size </span><span class="symbol">==</span><span class="normal"> element_size</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">remainder_size </span><span class="symbol">==</span><span class="normal"> </span><span class="function">request2size</span><span class="symbol">(</span><span class="normal">sizes</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]));</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="function">check_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">marray</span><span class="symbol">));</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">!=</span><span class="normal"> n_elements</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">    </span><span class="function">check_inuse_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">marray</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]));</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* DEBUG */</span>

<span class="normal">  </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> marray</span><span class="symbol">;</span>
<span class="cbracket">}</span>


<span class="comment">/* -------------------------- public routines ---------------------------- */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">ONLY_MSPACES</span>

<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">dlmalloc</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="comment">/*</span>
<span class="comment">     Basic algorithm:</span>
<span class="comment">     If a small request (&lt; 256 bytes minus per-chunk overhead):</span>
<span class="comment">       1. If one exists, use a remainderless chunk in associated smallbin.</span>
<span class="comment">          (Remainderless means that there are too few excess bytes to</span>
<span class="comment">          represent as a chunk.)</span>
<span class="comment">       2. If it is big enough, use the dv chunk, which is normally the</span>
<span class="comment">          chunk adjacent to the one used for the most recent small request.</span>
<span class="comment">       3. If one exists, split the smallest available chunk in a bin,</span>
<span class="comment">          saving remainder in dv.</span>
<span class="comment">       4. If it is big enough, use the top chunk.</span>
<span class="comment">       5. If available, get memory from system and use it</span>
<span class="comment">     Otherwise, for a large request:</span>
<span class="comment">       1. Find the smallest available binned chunk that fits, and use it</span>
<span class="comment">          if it is better fitting than dv chunk, splitting if necessary.</span>
<span class="comment">       2. If better fitting than any binned chunk, use the dv chunk.</span>
<span class="comment">       3. If it is big enough, use the top chunk.</span>
<span class="comment">       4. If request size &gt;= mmap threshold, try to directly mmap this chunk.</span>
<span class="comment">       5. If available, get memory from system and use it</span>

<span class="comment">     The ugly goto's here ensure that postaction occurs along all paths.</span>
<span class="comment">  */</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bytes </span><span class="symbol">&lt;=</span><span class="normal"> MAX_SMALL_REQUEST</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">bindex_t</span><span class="normal"> idx</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">binmap_t</span><span class="normal"> smallbits</span><span class="symbol">;</span>
<span class="normal">      nb </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bytes </span><span class="symbol">&lt;</span><span class="normal"> MIN_REQUEST</span><span class="symbol">)?</span><span class="normal"> MIN_CHUNK_SIZE </span><span class="symbol">:</span><span class="normal"> </span><span class="function">pad_request</span><span class="symbol">(</span><span class="normal">bytes</span><span class="symbol">);</span>
<span class="normal">      idx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">small_index</span><span class="symbol">(</span><span class="normal">nb</span><span class="symbol">);</span>
<span class="normal">      smallbits </span><span class="symbol">=</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">smallmap </span><span class="symbol">&gt;&gt;</span><span class="normal"> idx</span><span class="symbol">;</span>

<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">smallbits </span><span class="symbol">&amp;</span><span class="normal"> 0x3U</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* Remainderless fit to a smallbin. */</span>
<span class="normal">        </span><span class="usertype">mchunkptr</span><span class="normal"> b</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">;</span>
<span class="normal">        idx </span><span class="symbol">+=</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">smallbits </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal">       </span><span class="comment">/* Uses next bin if idx empty */</span>
<span class="normal">        b </span><span class="symbol">=</span><span class="normal"> </span><span class="function">smallbin_at</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> idx</span><span class="symbol">);</span>
<span class="normal">        p </span><span class="symbol">=</span><span class="normal"> b</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">;</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">idx</span><span class="symbol">));</span>
<span class="normal">        </span><span class="function">unlink_first_small_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> idx</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">set_inuse_and_pinuse</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">idx</span><span class="symbol">));</span>
<span class="normal">        mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>

<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">&gt;</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">dvsize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">smallbits </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* Use chunk in next nonempty smallbin */</span>
<span class="normal">          </span><span class="usertype">mchunkptr</span><span class="normal"> b</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> r</span><span class="symbol">;</span>
<span class="normal">          </span><span class="usertype">size_t</span><span class="normal"> rsize</span><span class="symbol">;</span>
<span class="normal">          </span><span class="usertype">bindex_t</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="normal">          </span><span class="usertype">binmap_t</span><span class="normal"> leftbits </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">smallbits </span><span class="symbol">&lt;&lt;</span><span class="normal"> idx</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">left_bits</span><span class="symbol">(</span><span class="function">idx2bit</span><span class="symbol">(</span><span class="normal">idx</span><span class="symbol">));</span>
<span class="normal">          </span><span class="usertype">binmap_t</span><span class="normal"> leastbit </span><span class="symbol">=</span><span class="normal"> </span><span class="function">least_bit</span><span class="symbol">(</span><span class="normal">leftbits</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">compute_bit2idx</span><span class="symbol">(</span><span class="normal">leastbit</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">          b </span><span class="symbol">=</span><span class="normal"> </span><span class="function">smallbin_at</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">          p </span><span class="symbol">=</span><span class="normal"> b</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">;</span>
<span class="normal">          </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">));</span>
<span class="normal">          </span><span class="function">unlink_first_small_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">          rsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">          </span><span class="comment">/* Fit here cannot be remainderless if 4byte sizes */</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">SIZE_T_SIZE </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">4</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> rsize </span><span class="symbol">&lt;</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">)</span>
<span class="normal">            </span><span class="function">set_inuse_and_pinuse</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">));</span>
<span class="normal">          </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">            r </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">r</span><span class="symbol">,</span><span class="normal"> rsize</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">replace_dv</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> r</span><span class="symbol">,</span><span class="normal"> rsize</span><span class="symbol">);</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">          mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">          </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">-&gt;</span><span class="normal">treemap </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">tmalloc_small</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">          </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bytes </span><span class="symbol">&gt;=</span><span class="normal"> MAX_REQUEST</span><span class="symbol">)</span>
<span class="normal">      nb </span><span class="symbol">=</span><span class="normal"> MAX_SIZE_T</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* Too big to allocate. Force failure (in sys alloc) */</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      nb </span><span class="symbol">=</span><span class="normal"> </span><span class="function">pad_request</span><span class="symbol">(</span><span class="normal">bytes</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">-&gt;</span><span class="normal">treemap </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">tmalloc_large</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">&lt;=</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">dvsize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> rsize </span><span class="symbol">=</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rsize </span><span class="symbol">&gt;=</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* split dv */</span>
<span class="normal">        </span><span class="usertype">mchunkptr</span><span class="normal"> r </span><span class="symbol">=</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">        gm</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> rsize</span><span class="symbol">;</span>
<span class="normal">        </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">r</span><span class="symbol">,</span><span class="normal"> rsize</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* exhaust dv */</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> dvs </span><span class="symbol">=</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">dvsize</span><span class="symbol">;</span>
<span class="normal">        gm</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        gm</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        </span><span class="function">set_inuse_and_pinuse</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> dvs</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">&lt;</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">topsize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* Split top */</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> rsize </span><span class="symbol">=</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">-=</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> r </span><span class="symbol">=</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      r</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> rsize </span><span class="symbol">|</span><span class="normal"> PINUSE_BIT</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">check_top_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">sys_alloc</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>

<span class="label">  postaction:</span>
<span class="normal">    </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> mem</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="normal"> </span><span class="function">dlfree</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="comment">/*</span>
<span class="comment">     Consolidate freed chunks with preceeding or succeeding bordering</span>
<span class="comment">     free chunks, if they exist, and then place in a bin.  Intermixed</span>
<span class="comment">     with special cases for top, dv, mmapped chunks, and usage errors.</span>
<span class="comment">  */</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> p  </span><span class="symbol">=</span><span class="normal"> </span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">);</span>
<span class="preproc">#if</span><span class="normal"> FOOTERS</span>
<span class="normal">    </span><span class="usertype">mstate</span><span class="normal"> fm </span><span class="symbol">=</span><span class="normal"> </span><span class="function">get_mstate_for</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">return</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>
<span class="preproc">#define</span><span class="normal"> fm gm</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">check_inuse_chunk</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">ok_cinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> psize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">        </span><span class="usertype">mchunkptr</span><span class="normal"> next </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="usertype">size_t</span><span class="normal"> prevsize </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">-&gt;</span><span class="normal">prev_foot</span><span class="symbol">;</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">prevsize </span><span class="symbol">&amp;</span><span class="normal"> IS_MMAPPED_BIT</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            prevsize </span><span class="symbol">&amp;=</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">IS_MMAPPED_BIT</span><span class="symbol">;</span>
<span class="normal">            psize </span><span class="symbol">+=</span><span class="normal"> prevsize </span><span class="symbol">+</span><span class="normal"> MMAP_FOOT_PAD</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">CALL_MUNMAP</span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">p </span><span class="symbol">-</span><span class="normal"> prevsize</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">              fm</span><span class="symbol">-&gt;</span><span class="normal">footprint </span><span class="symbol">-=</span><span class="normal"> psize</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">          </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">mchunkptr</span><span class="normal"> prev </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_minus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> prevsize</span><span class="symbol">);</span>
<span class="normal">            psize </span><span class="symbol">+=</span><span class="normal"> prevsize</span><span class="symbol">;</span>
<span class="normal">            p </span><span class="symbol">=</span><span class="normal"> prev</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> prev</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* consolidate backward */</span>
<span class="normal">              </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p </span><span class="symbol">!=</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">unlink_chunk</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> prevsize</span><span class="symbol">);</span>
<span class="normal">              </span><span class="cbracket">}</span>
<span class="normal">              </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">next</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">&amp;</span><span class="normal"> INUSE_BITS</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> INUSE_BITS</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                fm</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> psize</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">set_free_with_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">,</span><span class="normal"> next</span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">              </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">              </span><span class="keyword">goto</span><span class="normal"> erroraction</span><span class="symbol">;</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_next</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> next</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">ok_pinuse</span><span class="symbol">(</span><span class="normal">next</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">next</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">  </span><span class="comment">/* consolidate forward */</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next </span><span class="symbol">==</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">              </span><span class="usertype">size_t</span><span class="normal"> tsize </span><span class="symbol">=</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">+=</span><span class="normal"> psize</span><span class="symbol">;</span>
<span class="normal">              fm</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">;</span>
<span class="normal">              p</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> tsize </span><span class="symbol">|</span><span class="normal"> PINUSE_BIT</span><span class="symbol">;</span>
<span class="normal">              </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p </span><span class="symbol">==</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                fm</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                fm</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">              </span><span class="cbracket">}</span>
<span class="normal">              </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">should_trim</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> tsize</span><span class="symbol">))</span>
<span class="normal">                </span><span class="function">sys_trim</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">              </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next </span><span class="symbol">==</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">              </span><span class="usertype">size_t</span><span class="normal"> dsize </span><span class="symbol">=</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">+=</span><span class="normal"> psize</span><span class="symbol">;</span>
<span class="normal">              fm</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">;</span>
<span class="normal">              </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> dsize</span><span class="symbol">);</span>
<span class="normal">              </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">              </span><span class="usertype">size_t</span><span class="normal"> nsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">next</span><span class="symbol">);</span>
<span class="normal">              psize </span><span class="symbol">+=</span><span class="normal"> nsize</span><span class="symbol">;</span>
<span class="normal">              </span><span class="function">unlink_chunk</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> next</span><span class="symbol">,</span><span class="normal"> nsize</span><span class="symbol">);</span>
<span class="normal">              </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">);</span>
<span class="normal">              </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p </span><span class="symbol">==</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                fm</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> psize</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">              </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">          </span><span class="keyword">else</span>
<span class="normal">            </span><span class="function">set_free_with_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">,</span><span class="normal"> next</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">insert_chunk</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">check_free_chunk</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">          </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="label">    erroraction:</span>
<span class="normal">      </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="label">    postaction:</span>
<span class="normal">      </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">FOOTERS</span>
<span class="preproc">#undef</span><span class="normal"> fm</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">dlcalloc</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> n_elements</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> elem_size</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> req </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n_elements </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    req </span><span class="symbol">=</span><span class="normal"> n_elements </span><span class="symbol">*</span><span class="normal"> elem_size</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">n_elements </span><span class="symbol">|</span><span class="normal"> elem_size</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="number">0xffff</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">        </span><span class="symbol">(</span><span class="normal">req </span><span class="symbol">/</span><span class="normal"> n_elements </span><span class="symbol">!=</span><span class="normal"> elem_size</span><span class="symbol">))</span>
<span class="normal">      req </span><span class="symbol">=</span><span class="normal"> MAX_SIZE_T</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* force downstream failure on overflow */</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">dlmalloc</span><span class="symbol">(</span><span class="normal">req</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">calloc_must_clear</span><span class="symbol">(</span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">)))</span>
<span class="normal">    </span><span class="function">memset</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> req</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> mem</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">dlrealloc</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*</span><span class="normal"> oldmem</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">oldmem </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="function">dlmalloc</span><span class="symbol">(</span><span class="normal">bytes</span><span class="symbol">);</span>
<span class="preproc">#ifdef</span><span class="normal"> REALLOC_ZERO_BYTES_FREES</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bytes </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">dlfree</span><span class="symbol">(</span><span class="normal">oldmem</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* REALLOC_ZERO_BYTES_FREES */</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal"> FOOTERS</span>
<span class="normal">    </span><span class="usertype">mstate</span><span class="normal"> m </span><span class="symbol">=</span><span class="normal"> gm</span><span class="symbol">;</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>
<span class="normal">    </span><span class="usertype">mstate</span><span class="normal"> m </span><span class="symbol">=</span><span class="normal"> </span><span class="function">get_mstate_for</span><span class="symbol">(</span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">oldmem</span><span class="symbol">));</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> oldmem</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="function">internal_realloc</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> oldmem</span><span class="symbol">,</span><span class="normal"> bytes</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">dlmemalign</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> alignment</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">internal_memalign</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> alignment</span><span class="symbol">,</span><span class="normal"> bytes</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">**</span><span class="normal"> </span><span class="function">dlindependent_calloc</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> n_elements</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> elem_size</span><span class="symbol">,</span>
<span class="normal">                                 </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> chunks</span><span class="symbol">[])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> sz </span><span class="symbol">=</span><span class="normal"> elem_size</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* serves as 1-element array */</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">ialloc</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> n_elements</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">sz</span><span class="symbol">,</span><span class="normal"> </span><span class="number">3</span><span class="symbol">,</span><span class="normal"> chunks</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">**</span><span class="normal"> </span><span class="function">dlindependent_comalloc</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> n_elements</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> sizes</span><span class="symbol">[],</span>
<span class="normal">                                   </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> chunks</span><span class="symbol">[])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">ialloc</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> n_elements</span><span class="symbol">,</span><span class="normal"> sizes</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> chunks</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">dlvalloc</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> pagesz</span><span class="symbol">;</span>
<span class="normal">  </span><span class="function">init_mparams</span><span class="symbol">();</span>
<span class="normal">  pagesz </span><span class="symbol">=</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">page_size</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">dlmemalign</span><span class="symbol">(</span><span class="normal">pagesz</span><span class="symbol">,</span><span class="normal"> bytes</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">dlpvalloc</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> pagesz</span><span class="symbol">;</span>
<span class="normal">  </span><span class="function">init_mparams</span><span class="symbol">();</span>
<span class="normal">  pagesz </span><span class="symbol">=</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">page_size</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">dlmemalign</span><span class="symbol">(</span><span class="normal">pagesz</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bytes </span><span class="symbol">+</span><span class="normal"> pagesz </span><span class="symbol">-</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~(</span><span class="normal">pagesz </span><span class="symbol">-</span><span class="normal"> SIZE_T_ONE</span><span class="symbol">));</span>
<span class="cbracket">}</span>

<span class="type">int</span><span class="normal"> </span><span class="function">dlmalloc_trim</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> pad</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="type">int</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    result </span><span class="symbol">=</span><span class="normal"> </span><span class="function">sys_trim</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">,</span><span class="normal"> pad</span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> result</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="usertype">size_t</span><span class="normal"> </span><span class="function">dlmalloc_footprint</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">footprint</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="usertype">size_t</span><span class="normal"> </span><span class="function">dlmalloc_max_footprint</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> gm</span><span class="symbol">-&gt;</span><span class="normal">max_footprint</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">NO_MALLINFO</span>
<span class="keyword">struct</span><span class="normal"> </span><span class="classname">mallinfo</span><span class="normal"> </span><span class="function">dlmallinfo</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">internal_mallinfo</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">);</span>
<span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* NO_MALLINFO */</span>

<span class="type">void</span><span class="normal"> </span><span class="function">dlmalloc_stats</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="function">internal_malloc_stats</span><span class="symbol">(</span><span class="normal">gm</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="usertype">size_t</span><span class="normal"> </span><span class="function">dlmalloc_usable_size</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> </span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">))</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="function">overhead_for</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="type">int</span><span class="normal"> </span><span class="function">dlmallopt</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> param_number</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> value</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">change_mparam</span><span class="symbol">(</span><span class="normal">param_number</span><span class="symbol">,</span><span class="normal"> value</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* !ONLY_MSPACES */</span>

<span class="comment">/* ----------------------------- user mspaces ---------------------------- */</span>

<span class="preproc">#if</span><span class="normal"> MSPACES</span>

<span class="keyword">static</span><span class="normal"> </span><span class="usertype">mstate</span><span class="normal"> </span><span class="function">init_user_mstate</span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*</span><span class="normal"> tbase</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> tsize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> msize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">pad_request</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_state</span><span class="symbol">));</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> mn</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">mchunkptr</span><span class="normal"> msp </span><span class="symbol">=</span><span class="normal"> </span><span class="function">align_as_chunk</span><span class="symbol">(</span><span class="normal">tbase</span><span class="symbol">);</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> m </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)(</span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">msp</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">memset</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> msize</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">INITIAL_LOCK</span><span class="symbol">(&amp;</span><span class="normal">m</span><span class="symbol">-&gt;</span><span class="normal">mutex</span><span class="symbol">);</span>
<span class="normal">  msp</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">msize</span><span class="symbol">|</span><span class="normal">PINUSE_BIT</span><span class="symbol">|</span><span class="normal">CINUSE_BIT</span><span class="symbol">);</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">base </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">least_addr </span><span class="symbol">=</span><span class="normal"> tbase</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">size </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">footprint </span><span class="symbol">=</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">max_footprint </span><span class="symbol">=</span><span class="normal"> tsize</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">magic </span><span class="symbol">=</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">magic</span><span class="symbol">;</span>
<span class="normal">  m</span><span class="symbol">-&gt;</span><span class="normal">mflags </span><span class="symbol">=</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">default_mflags</span><span class="symbol">;</span>
<span class="normal">  </span><span class="function">disable_contiguous</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">init_bins</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">);</span>
<span class="normal">  mn </span><span class="symbol">=</span><span class="normal"> </span><span class="function">next_chunk</span><span class="symbol">(</span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">init_top</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> mn</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)((</span><span class="normal">tbase </span><span class="symbol">+</span><span class="normal"> tsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">mn</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> TOP_FOOT_SIZE</span><span class="symbol">);</span>
<span class="normal">  </span><span class="function">check_top_chunk</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> m</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="usertype">mspace</span><span class="normal"> </span><span class="function">create_mspace</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> capacity</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> locked</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> m </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> msize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">pad_request</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_state</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">init_mparams</span><span class="symbol">();</span><span class="normal"> </span><span class="comment">/* Ensure pagesize etc initialized */</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">capacity </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-(</span><span class="normal">msize </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE </span><span class="symbol">+</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">page_size</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> rs </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">capacity </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)?</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">granularity </span><span class="symbol">:</span>
<span class="normal">                 </span><span class="symbol">(</span><span class="normal">capacity </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE </span><span class="symbol">+</span><span class="normal"> msize</span><span class="symbol">));</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> tsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">granularity_align</span><span class="symbol">(</span><span class="normal">rs</span><span class="symbol">);</span>
<span class="normal">    </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> tbase </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">*)(</span><span class="function">CALL_MMAP</span><span class="symbol">(</span><span class="normal">tsize</span><span class="symbol">));</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">tbase </span><span class="symbol">!=</span><span class="normal"> CMFAIL</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      m </span><span class="symbol">=</span><span class="normal"> </span><span class="function">init_user_mstate</span><span class="symbol">(</span><span class="normal">tbase</span><span class="symbol">,</span><span class="normal"> tsize</span><span class="symbol">);</span>
<span class="normal">      m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">sflags </span><span class="symbol">=</span><span class="normal"> IS_MMAPPED_BIT</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">set_lock</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> locked</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mspace</span><span class="symbol">)</span><span class="normal">m</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="usertype">mspace</span><span class="normal"> </span><span class="function">create_mspace_with_base</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">*</span><span class="normal"> base</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> capacity</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> locked</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> m </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> msize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">pad_request</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">malloc_state</span><span class="symbol">));</span>
<span class="normal">  </span><span class="function">init_mparams</span><span class="symbol">();</span><span class="normal"> </span><span class="comment">/* Ensure pagesize etc initialized */</span>

<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">capacity </span><span class="symbol">&gt;</span><span class="normal"> msize </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE </span><span class="symbol">&amp;&amp;</span>
<span class="normal">      capacity </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-(</span><span class="normal">msize </span><span class="symbol">+</span><span class="normal"> TOP_FOOT_SIZE </span><span class="symbol">+</span><span class="normal"> mparams</span><span class="symbol">.</span><span class="normal">page_size</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    m </span><span class="symbol">=</span><span class="normal"> </span><span class="function">init_user_mstate</span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">base</span><span class="symbol">,</span><span class="normal"> capacity</span><span class="symbol">);</span>
<span class="normal">    m</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">.</span><span class="normal">sflags </span><span class="symbol">=</span><span class="normal"> EXTERN_BIT</span><span class="symbol">;</span>
<span class="normal">    </span><span class="function">set_lock</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> locked</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mspace</span><span class="symbol">)</span><span class="normal">m</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="usertype">size_t</span><span class="normal"> </span><span class="function">destroy_mspace</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> freed </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">msegmentptr</span><span class="normal"> sp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">ms</span><span class="symbol">-&gt;</span><span class="normal">seg</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sp </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> base </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">base</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> size </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">size</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">flag_t</span><span class="normal"> flag </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">sflags</span><span class="symbol">;</span>
<span class="normal">      sp </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">-&gt;</span><span class="normal">next</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">flag </span><span class="symbol">&amp;</span><span class="normal"> IS_MMAPPED_BIT</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!(</span><span class="normal">flag </span><span class="symbol">&amp;</span><span class="normal"> EXTERN_BIT</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">          </span><span class="function">CALL_MUNMAP</span><span class="symbol">(</span><span class="normal">base</span><span class="symbol">,</span><span class="normal"> size</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">        freed </span><span class="symbol">+=</span><span class="normal"> size</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> freed</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/*</span>
<span class="comment">  mspace versions of routines are near-clones of the global</span>
<span class="comment">  versions. This is not so nice but better than the alternatives.</span>
<span class="comment">*/</span>


<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">mspace_malloc</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bytes </span><span class="symbol">&lt;=</span><span class="normal"> MAX_SMALL_REQUEST</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">bindex_t</span><span class="normal"> idx</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">binmap_t</span><span class="normal"> smallbits</span><span class="symbol">;</span>
<span class="normal">      nb </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bytes </span><span class="symbol">&lt;</span><span class="normal"> MIN_REQUEST</span><span class="symbol">)?</span><span class="normal"> MIN_CHUNK_SIZE </span><span class="symbol">:</span><span class="normal"> </span><span class="function">pad_request</span><span class="symbol">(</span><span class="normal">bytes</span><span class="symbol">);</span>
<span class="normal">      idx </span><span class="symbol">=</span><span class="normal"> </span><span class="function">small_index</span><span class="symbol">(</span><span class="normal">nb</span><span class="symbol">);</span>
<span class="normal">      smallbits </span><span class="symbol">=</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">smallmap </span><span class="symbol">&gt;&gt;</span><span class="normal"> idx</span><span class="symbol">;</span>

<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">smallbits </span><span class="symbol">&amp;</span><span class="normal"> 0x3U</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* Remainderless fit to a smallbin. */</span>
<span class="normal">        </span><span class="usertype">mchunkptr</span><span class="normal"> b</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">;</span>
<span class="normal">        idx </span><span class="symbol">+=</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">smallbits </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal">       </span><span class="comment">/* Uses next bin if idx empty */</span>
<span class="normal">        b </span><span class="symbol">=</span><span class="normal"> </span><span class="function">smallbin_at</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> idx</span><span class="symbol">);</span>
<span class="normal">        p </span><span class="symbol">=</span><span class="normal"> b</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">;</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">idx</span><span class="symbol">));</span>
<span class="normal">        </span><span class="function">unlink_first_small_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> idx</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">set_inuse_and_pinuse</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">idx</span><span class="symbol">));</span>
<span class="normal">        mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>

<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">&gt;</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">dvsize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">smallbits </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* Use chunk in next nonempty smallbin */</span>
<span class="normal">          </span><span class="usertype">mchunkptr</span><span class="normal"> b</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> r</span><span class="symbol">;</span>
<span class="normal">          </span><span class="usertype">size_t</span><span class="normal"> rsize</span><span class="symbol">;</span>
<span class="normal">          </span><span class="usertype">bindex_t</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="normal">          </span><span class="usertype">binmap_t</span><span class="normal"> leftbits </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">smallbits </span><span class="symbol">&lt;&lt;</span><span class="normal"> idx</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">left_bits</span><span class="symbol">(</span><span class="function">idx2bit</span><span class="symbol">(</span><span class="normal">idx</span><span class="symbol">));</span>
<span class="normal">          </span><span class="usertype">binmap_t</span><span class="normal"> leastbit </span><span class="symbol">=</span><span class="normal"> </span><span class="function">least_bit</span><span class="symbol">(</span><span class="normal">leftbits</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">compute_bit2idx</span><span class="symbol">(</span><span class="normal">leastbit</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">          b </span><span class="symbol">=</span><span class="normal"> </span><span class="function">smallbin_at</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">          p </span><span class="symbol">=</span><span class="normal"> b</span><span class="symbol">-&gt;</span><span class="normal">fd</span><span class="symbol">;</span>
<span class="normal">          </span><span class="function">assert</span><span class="symbol">(</span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">));</span>
<span class="normal">          </span><span class="function">unlink_first_small_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">          rsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">          </span><span class="comment">/* Fit here cannot be remainderless if 4byte sizes */</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">SIZE_T_SIZE </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">4</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> rsize </span><span class="symbol">&lt;</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">)</span>
<span class="normal">            </span><span class="function">set_inuse_and_pinuse</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> </span><span class="function">small_index2size</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">));</span>
<span class="normal">          </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">            r </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">r</span><span class="symbol">,</span><span class="normal"> rsize</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">replace_dv</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> r</span><span class="symbol">,</span><span class="normal"> rsize</span><span class="symbol">);</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">          mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">          </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">-&gt;</span><span class="normal">treemap </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">tmalloc_small</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">          </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bytes </span><span class="symbol">&gt;=</span><span class="normal"> MAX_REQUEST</span><span class="symbol">)</span>
<span class="normal">      nb </span><span class="symbol">=</span><span class="normal"> MAX_SIZE_T</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* Too big to allocate. Force failure (in sys alloc) */</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      nb </span><span class="symbol">=</span><span class="normal"> </span><span class="function">pad_request</span><span class="symbol">(</span><span class="normal">bytes</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">-&gt;</span><span class="normal">treemap </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">tmalloc_large</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">&lt;=</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">dvsize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> rsize </span><span class="symbol">=</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">-</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">;</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rsize </span><span class="symbol">&gt;=</span><span class="normal"> MIN_CHUNK_SIZE</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* split dv */</span>
<span class="normal">        </span><span class="usertype">mchunkptr</span><span class="normal"> r </span><span class="symbol">=</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">        ms</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> rsize</span><span class="symbol">;</span>
<span class="normal">        </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">r</span><span class="symbol">,</span><span class="normal"> rsize</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* exhaust dv */</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> dvs </span><span class="symbol">=</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">dvsize</span><span class="symbol">;</span>
<span class="normal">        ms</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        ms</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        </span><span class="function">set_inuse_and_pinuse</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> dvs</span><span class="symbol">);</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="normal">      mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">nb </span><span class="symbol">&lt;</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">topsize</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* Split top */</span>
<span class="normal">      </span><span class="usertype">size_t</span><span class="normal"> rsize </span><span class="symbol">=</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">-=</span><span class="normal"> nb</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">;</span>
<span class="normal">      </span><span class="usertype">mchunkptr</span><span class="normal"> r </span><span class="symbol">=</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      r</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> rsize </span><span class="symbol">|</span><span class="normal"> PINUSE_BIT</span><span class="symbol">;</span>
<span class="normal">      </span><span class="function">set_size_and_pinuse_of_inuse_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk2mem</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">check_top_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">check_malloced_chunk</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> mem</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">sys_alloc</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> nb</span><span class="symbol">);</span>

<span class="label">  postaction:</span>
<span class="normal">    </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> mem</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>

<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="normal"> </span><span class="function">mspace_free</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> p  </span><span class="symbol">=</span><span class="normal"> </span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">);</span>
<span class="preproc">#if</span><span class="normal"> FOOTERS</span>
<span class="normal">    </span><span class="usertype">mstate</span><span class="normal"> fm </span><span class="symbol">=</span><span class="normal"> </span><span class="function">get_mstate_for</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>
<span class="normal">    </span><span class="usertype">mstate</span><span class="normal"> fm </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">return</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">check_inuse_chunk</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">ok_cinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">size_t</span><span class="normal"> psize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="normal">        </span><span class="usertype">mchunkptr</span><span class="normal"> next </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_plus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="usertype">size_t</span><span class="normal"> prevsize </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">-&gt;</span><span class="normal">prev_foot</span><span class="symbol">;</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">prevsize </span><span class="symbol">&amp;</span><span class="normal"> IS_MMAPPED_BIT</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            prevsize </span><span class="symbol">&amp;=</span><span class="normal"> </span><span class="symbol">~</span><span class="normal">IS_MMAPPED_BIT</span><span class="symbol">;</span>
<span class="normal">            psize </span><span class="symbol">+=</span><span class="normal"> prevsize </span><span class="symbol">+</span><span class="normal"> MMAP_FOOT_PAD</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">CALL_MUNMAP</span><span class="symbol">((</span><span class="type">char</span><span class="symbol">*)</span><span class="normal">p </span><span class="symbol">-</span><span class="normal"> prevsize</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">              fm</span><span class="symbol">-&gt;</span><span class="normal">footprint </span><span class="symbol">-=</span><span class="normal"> psize</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">          </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">mchunkptr</span><span class="normal"> prev </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunk_minus_offset</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> prevsize</span><span class="symbol">);</span>
<span class="normal">            psize </span><span class="symbol">+=</span><span class="normal"> prevsize</span><span class="symbol">;</span>
<span class="normal">            p </span><span class="symbol">=</span><span class="normal"> prev</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_address</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> prev</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">/* consolidate backward */</span>
<span class="normal">              </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p </span><span class="symbol">!=</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">unlink_chunk</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> prevsize</span><span class="symbol">);</span>
<span class="normal">              </span><span class="cbracket">}</span>
<span class="normal">              </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">next</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">&amp;</span><span class="normal"> INUSE_BITS</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> INUSE_BITS</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                fm</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> psize</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">set_free_with_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">,</span><span class="normal"> next</span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">              </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">              </span><span class="keyword">goto</span><span class="normal"> erroraction</span><span class="symbol">;</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RTCHECK</span><span class="symbol">(</span><span class="function">ok_next</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> next</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">ok_pinuse</span><span class="symbol">(</span><span class="normal">next</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">          </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">cinuse</span><span class="symbol">(</span><span class="normal">next</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">  </span><span class="comment">/* consolidate forward */</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next </span><span class="symbol">==</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">top</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">              </span><span class="usertype">size_t</span><span class="normal"> tsize </span><span class="symbol">=</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">topsize </span><span class="symbol">+=</span><span class="normal"> psize</span><span class="symbol">;</span>
<span class="normal">              fm</span><span class="symbol">-&gt;</span><span class="normal">top </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">;</span>
<span class="normal">              p</span><span class="symbol">-&gt;</span><span class="normal">head </span><span class="symbol">=</span><span class="normal"> tsize </span><span class="symbol">|</span><span class="normal"> PINUSE_BIT</span><span class="symbol">;</span>
<span class="normal">              </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p </span><span class="symbol">==</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                fm</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                fm</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">              </span><span class="cbracket">}</span>
<span class="normal">              </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">should_trim</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> tsize</span><span class="symbol">))</span>
<span class="normal">                </span><span class="function">sys_trim</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">              </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next </span><span class="symbol">==</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">              </span><span class="usertype">size_t</span><span class="normal"> dsize </span><span class="symbol">=</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">+=</span><span class="normal"> psize</span><span class="symbol">;</span>
<span class="normal">              fm</span><span class="symbol">-&gt;</span><span class="normal">dv </span><span class="symbol">=</span><span class="normal"> p</span><span class="symbol">;</span>
<span class="normal">              </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> dsize</span><span class="symbol">);</span>
<span class="normal">              </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">              </span><span class="usertype">size_t</span><span class="normal"> nsize </span><span class="symbol">=</span><span class="normal"> </span><span class="function">chunksize</span><span class="symbol">(</span><span class="normal">next</span><span class="symbol">);</span>
<span class="normal">              psize </span><span class="symbol">+=</span><span class="normal"> nsize</span><span class="symbol">;</span>
<span class="normal">              </span><span class="function">unlink_chunk</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> next</span><span class="symbol">,</span><span class="normal"> nsize</span><span class="symbol">);</span>
<span class="normal">              </span><span class="function">set_size_and_pinuse_of_free_chunk</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">);</span>
<span class="normal">              </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p </span><span class="symbol">==</span><span class="normal"> fm</span><span class="symbol">-&gt;</span><span class="normal">dv</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                fm</span><span class="symbol">-&gt;</span><span class="normal">dvsize </span><span class="symbol">=</span><span class="normal"> psize</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">              </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">          </span><span class="cbracket">}</span>
<span class="normal">          </span><span class="keyword">else</span>
<span class="normal">            </span><span class="function">set_free_with_pinuse</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">,</span><span class="normal"> next</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">insert_chunk</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> psize</span><span class="symbol">);</span>
<span class="normal">          </span><span class="function">check_free_chunk</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="normal">          </span><span class="keyword">goto</span><span class="normal"> postaction</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">      </span><span class="cbracket">}</span>
<span class="label">    erroraction:</span>
<span class="normal">      </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">,</span><span class="normal"> p</span><span class="symbol">);</span>
<span class="label">    postaction:</span>
<span class="normal">      </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">fm</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">mspace_calloc</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> n_elements</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> elem_size</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> mem</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> req </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n_elements </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    req </span><span class="symbol">=</span><span class="normal"> n_elements </span><span class="symbol">*</span><span class="normal"> elem_size</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">n_elements </span><span class="symbol">|</span><span class="normal"> elem_size</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">~(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="number">0xffff</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">        </span><span class="symbol">(</span><span class="normal">req </span><span class="symbol">/</span><span class="normal"> n_elements </span><span class="symbol">!=</span><span class="normal"> elem_size</span><span class="symbol">))</span>
<span class="normal">      req </span><span class="symbol">=</span><span class="normal"> MAX_SIZE_T</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* force downstream failure on overflow */</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  mem </span><span class="symbol">=</span><span class="normal"> </span><span class="function">internal_malloc</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> req</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mem </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">calloc_must_clear</span><span class="symbol">(</span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">)))</span>
<span class="normal">    </span><span class="function">memset</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> req</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> mem</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">mspace_realloc</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> oldmem</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">oldmem </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="function">mspace_malloc</span><span class="symbol">(</span><span class="normal">msp</span><span class="symbol">,</span><span class="normal"> bytes</span><span class="symbol">);</span>
<span class="preproc">#ifdef</span><span class="normal"> REALLOC_ZERO_BYTES_FREES</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bytes </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">mspace_free</span><span class="symbol">(</span><span class="normal">msp</span><span class="symbol">,</span><span class="normal"> oldmem</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* REALLOC_ZERO_BYTES_FREES */</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="preproc">#if</span><span class="normal"> FOOTERS</span>
<span class="normal">    </span><span class="usertype">mchunkptr</span><span class="normal"> p  </span><span class="symbol">=</span><span class="normal"> </span><span class="function">mem2chunk</span><span class="symbol">(</span><span class="normal">oldmem</span><span class="symbol">);</span>
<span class="normal">    </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="function">get_mstate_for</span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">);</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>
<span class="normal">    </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* FOOTERS */</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">      </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="function">internal_realloc</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> oldmem</span><span class="symbol">,</span><span class="normal"> bytes</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">*</span><span class="normal"> </span><span class="function">mspace_memalign</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> alignment</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> bytes</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">internal_memalign</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> alignment</span><span class="symbol">,</span><span class="normal"> bytes</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">**</span><span class="normal"> </span><span class="function">mspace_independent_calloc</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> n_elements</span><span class="symbol">,</span>
<span class="normal">                                 </span><span class="usertype">size_t</span><span class="normal"> elem_size</span><span class="symbol">,</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> chunks</span><span class="symbol">[])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> sz </span><span class="symbol">=</span><span class="normal"> elem_size</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* serves as 1-element array */</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">ialloc</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> n_elements</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">sz</span><span class="symbol">,</span><span class="normal"> </span><span class="number">3</span><span class="symbol">,</span><span class="normal"> chunks</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="symbol">**</span><span class="normal"> </span><span class="function">mspace_independent_comalloc</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> n_elements</span><span class="symbol">,</span>
<span class="normal">                                   </span><span class="usertype">size_t</span><span class="normal"> sizes</span><span class="symbol">[],</span><span class="normal"> </span><span class="type">void</span><span class="symbol">*</span><span class="normal"> chunks</span><span class="symbol">[])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">ialloc</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> n_elements</span><span class="symbol">,</span><span class="normal"> sizes</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> chunks</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="type">int</span><span class="normal"> </span><span class="function">mspace_trim</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> pad</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="type">int</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">PREACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">      result </span><span class="symbol">=</span><span class="normal"> </span><span class="function">sys_trim</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal"> pad</span><span class="symbol">);</span>
<span class="normal">      </span><span class="function">POSTACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> result</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="type">void</span><span class="normal"> </span><span class="function">mspace_malloc_stats</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">internal_malloc_stats</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="cbracket">}</span>

<span class="usertype">size_t</span><span class="normal"> </span><span class="function">mspace_footprint</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> result</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    result </span><span class="symbol">=</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">footprint</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> result</span><span class="symbol">;</span>
<span class="cbracket">}</span>


<span class="usertype">size_t</span><span class="normal"> </span><span class="function">mspace_max_footprint</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">size_t</span><span class="normal"> result</span><span class="symbol">;</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    result </span><span class="symbol">=</span><span class="normal"> ms</span><span class="symbol">-&gt;</span><span class="normal">max_footprint</span><span class="symbol">;</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> result</span><span class="symbol">;</span>
<span class="cbracket">}</span>


<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">NO_MALLINFO</span>
<span class="keyword">struct</span><span class="normal"> </span><span class="classname">mallinfo</span><span class="normal"> </span><span class="function">mspace_mallinfo</span><span class="symbol">(</span><span class="usertype">mspace</span><span class="normal"> msp</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="usertype">mstate</span><span class="normal"> ms </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">mstate</span><span class="symbol">)</span><span class="normal">msp</span><span class="symbol">;</span>
<span class="normal">  </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">ok_magic</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="function">USAGE_ERROR_ACTION</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">,</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="normal">  </span><span class="cbracket">}</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">internal_mallinfo</span><span class="symbol">(</span><span class="normal">ms</span><span class="symbol">);</span>
<span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* NO_MALLINFO */</span>

<span class="type">int</span><span class="normal"> </span><span class="function">mspace_mallopt</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> param_number</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> value</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">  </span><span class="keyword">return</span><span class="normal"> </span><span class="function">change_mparam</span><span class="symbol">(</span><span class="normal">param_number</span><span class="symbol">,</span><span class="normal"> value</span><span class="symbol">);</span>
<span class="cbracket">}</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* MSPACES */</span>

<span class="comment">/* -------------------- Alternative MORECORE functions ------------------- */</span>

<span class="comment">/*</span>
<span class="comment">  Guidelines for creating a custom version of MORECORE:</span>

<span class="comment">  * For best performance, MORECORE should allocate in multiples of pagesize.</span>
<span class="comment">  * MORECORE may allocate more memory than requested. (Or even less,</span>
<span class="comment">      but this will usually result in a malloc failure.)</span>
<span class="comment">  * MORECORE must not allocate memory when given argument zero, but</span>
<span class="comment">      instead return one past the end address of memory from previous</span>
<span class="comment">      nonzero call.</span>
<span class="comment">  * For best performance, consecutive calls to MORECORE with positive</span>
<span class="comment">      arguments should return increasing addresses, indicating that</span>
<span class="comment">      space has been contiguously extended.</span>
<span class="comment">  * Even though consecutive calls to MORECORE need not return contiguous</span>
<span class="comment">      addresses, it must be OK for malloc'ed chunks to span multiple</span>
<span class="comment">      regions in those cases where they do happen to be contiguous.</span>
<span class="comment">  * MORECORE need not handle negative arguments -- it may instead</span>
<span class="comment">      just return MFAIL when given negative arguments.</span>
<span class="comment">      Negative arguments are always multiples of pagesize. MORECORE</span>
<span class="comment">      must not misinterpret negative args as large positive unsigned</span>
<span class="comment">      args. You can suppress all such calls from even occurring by defining</span>
<span class="comment">      MORECORE_CANNOT_TRIM,</span>

<span class="comment">  As an example alternative MORECORE, here is a custom allocator</span>
<span class="comment">  kindly contributed for pre-OSX macOS.  It uses virtually but not</span>
<span class="comment">  necessarily physically contiguous non-paged memory (locked in,</span>
<span class="comment">  present and won't get swapped out).  You can use it by uncommenting</span>
<span class="comment">  this section, adding some #includes, and setting up the appropriate</span>
<span class="comment">  defines above:</span>

<span class="comment">      #define MORECORE osMoreCore</span>

<span class="comment">  There is also a shutdown routine that should somehow be called for</span>
<span class="comment">  cleanup upon program exit.</span>

<span class="comment">  #define MAX_POOL_ENTRIES 100</span>
<span class="comment">  #define MINIMUM_MORECORE_SIZE  (64 * 1024U)</span>
<span class="comment">  static int next_os_pool;</span>
<span class="comment">  void *our_os_pools[MAX_POOL_ENTRIES];</span>

<span class="comment">  void *osMoreCore(int size)</span>
<span class="comment">  {</span>
<span class="comment">    void *ptr = 0;</span>
<span class="comment">    static void *sbrk_top = 0;</span>

<span class="comment">    if (size &gt; 0)</span>
<span class="comment">    {</span>
<span class="comment">      if (size &lt; MINIMUM_MORECORE_SIZE)</span>
<span class="comment">         size = MINIMUM_MORECORE_SIZE;</span>
<span class="comment">      if (CurrentExecutionLevel() == kTaskLevel)</span>
<span class="comment">         ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);</span>
<span class="comment">      if (ptr == 0)</span>
<span class="comment">      {</span>
<span class="comment">        return (void *) MFAIL;</span>
<span class="comment">      }</span>
<span class="comment">      // save ptrs so they can be freed during cleanup</span>
<span class="comment">      our_os_pools[next_os_pool] = ptr;</span>
<span class="comment">      next_os_pool++;</span>
<span class="comment">      ptr = (void *) ((((size_t) ptr) + RM_PAGE_MASK) &amp; ~RM_PAGE_MASK);</span>
<span class="comment">      sbrk_top = (char *) ptr + size;</span>
<span class="comment">      return ptr;</span>
<span class="comment">    }</span>
<span class="comment">    else if (size &lt; 0)</span>
<span class="comment">    {</span>
<span class="comment">      // we don't currently support shrink behavior</span>
<span class="comment">      return (void *) MFAIL;</span>
<span class="comment">    }</span>
<span class="comment">    else</span>
<span class="comment">    {</span>
<span class="comment">      return sbrk_top;</span>
<span class="comment">    }</span>
<span class="comment">  }</span>

<span class="comment">  // cleanup any allocated memory pools</span>
<span class="comment">  // called as last thing before shutting down driver</span>

<span class="comment">  void osCleanupMem(void)</span>
<span class="comment">  {</span>
<span class="comment">    void **ptr;</span>

<span class="comment">    for (ptr = our_os_pools; ptr &lt; &amp;our_os_pools[MAX_POOL_ENTRIES]; ptr++)</span>
<span class="comment">      if (*ptr)</span>
<span class="comment">      {</span>
<span class="comment">         PoolDeallocate(*ptr);</span>
<span class="comment">         *ptr = 0;</span>
<span class="comment">      }</span>
<span class="comment">  }</span>

<span class="comment">*/</span>


<span class="comment">/* -----------------------------------------------------------------------</span>
<span class="comment">History:</span>
<span class="comment">    V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)</span>
<span class="comment">      * Add max_footprint functions</span>
<span class="comment">      * Ensure all appropriate literals are size_t</span>
<span class="comment">      * Fix conditional compilation problem for some #define settings</span>
<span class="comment">      * Avoid concatenating segments with the one provided</span>
<span class="comment">        in create_mspace_with_base</span>
<span class="comment">      * Rename some variables to avoid compiler shadowing warnings</span>
<span class="comment">      * Use explicit lock initialization.</span>
<span class="comment">      * Better handling of sbrk interference.</span>
<span class="comment">      * Simplify and fix segment insertion, trimming and mspace_destroy</span>
<span class="comment">      * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x</span>
<span class="comment">      * Thanks especially to Dennis Flanagan for help on these.</span>

<span class="comment">    V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)</span>
<span class="comment">      * Fix memalign brace error.</span>

<span class="comment">    V2.8.1 Wed Jun  8 16:11:46 2005  Doug Lea  (dl at gee)</span>
<span class="comment">      * Fix improper #endif nesting in C++</span>
<span class="comment">      * Add explicit casts needed for C++</span>

<span class="comment">    V2.8.0 Mon May 30 14:09:02 2005  Doug Lea  (dl at gee)</span>
<span class="comment">      * Use trees for large bins</span>
<span class="comment">      * Support mspaces</span>
<span class="comment">      * Use segments to unify sbrk-based and mmap-based system allocation,</span>
<span class="comment">        removing need for emulation on most platforms without sbrk.</span>
<span class="comment">      * Default safety checks</span>
<span class="comment">      * Optional footer checks. Thanks to William Robertson for the idea.</span>
<span class="comment">      * Internal code refactoring</span>
<span class="comment">      * Incorporate suggestions and platform-specific changes.</span>
<span class="comment">        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,</span>
<span class="comment">        Aaron Bachmann,  Emery Berger, and others.</span>
<span class="comment">      * Speed up non-fastbin processing enough to remove fastbins.</span>
<span class="comment">      * Remove useless cfree() to avoid conflicts with other apps.</span>
<span class="comment">      * Remove internal memcpy, memset. Compilers handle builtins better.</span>
<span class="comment">      * Remove some options that no one ever used and rename others.</span>

<span class="comment">    V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)</span>
<span class="comment">      * Fix malloc_state bitmap array misdeclaration</span>

<span class="comment">    V2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)</span>
<span class="comment">      * Allow tuning of FIRST_SORTED_BIN_SIZE</span>
<span class="comment">      * Use PTR_UINT as type for all ptr-&gt;int casts. Thanks to John Belmonte.</span>
<span class="comment">      * Better detection and support for non-contiguousness of MORECORE.</span>
<span class="comment">        Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger</span>
<span class="comment">      * Bypass most of malloc if no frees. Thanks To Emery Berger.</span>
<span class="comment">      * Fix freeing of old top non-contiguous chunk im sysmalloc.</span>
<span class="comment">      * Raised default trim and map thresholds to 256K.</span>
<span class="comment">      * Fix mmap-related #defines. Thanks to Lubos Lunak.</span>
<span class="comment">      * Fix copy macros; added LACKS_FCNTL_H. Thanks to Neal Walfield.</span>
<span class="comment">      * Branch-free bin calculation</span>
<span class="comment">      * Default trim and mmap thresholds now 256K.</span>

<span class="comment">    V2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)</span>
<span class="comment">      * Introduce independent_comalloc and independent_calloc.</span>
<span class="comment">        Thanks to Michael Pachos for motivation and help.</span>
<span class="comment">      * Make optional .h file available</span>
<span class="comment">      * Allow &gt; 2GB requests on 32bit systems.</span>
<span class="comment">      * new WIN32 sbrk, mmap, munmap, lock code from </span><span class="url">&lt;Walter@GeNeSys-e.de&gt;</span><span class="comment">.</span>
<span class="comment">        Thanks also to Andreas Mueller &lt;a.mueller at paradatec.de&gt;,</span>
<span class="comment">        and Anonymous.</span>
<span class="comment">      * Allow override of MALLOC_ALIGNMENT (Thanks to Ruud Waij for</span>
<span class="comment">        helping test this.)</span>
<span class="comment">      * memalign: check alignment arg</span>
<span class="comment">      * realloc: don't try to shift chunks backwards, since this</span>
<span class="comment">        leads to  more fragmentation in some programs and doesn't</span>
<span class="comment">        seem to help in any others.</span>
<span class="comment">      * Collect all cases in malloc requiring system memory into sysmalloc</span>
<span class="comment">      * Use mmap as backup to sbrk</span>
<span class="comment">      * Place all internal state in malloc_state</span>
<span class="comment">      * Introduce fastbins (although similar to 2.5.1)</span>
<span class="comment">      * Many minor tunings and cosmetic improvements</span>
<span class="comment">      * Introduce USE_PUBLIC_MALLOC_WRAPPERS, USE_MALLOC_LOCK</span>
<span class="comment">      * Introduce MALLOC_FAILURE_ACTION, MORECORE_CONTIGUOUS</span>
<span class="comment">        Thanks to Tony E. Bennett </span><span class="url">&lt;tbennett@nvidia.com&gt;</span><span class="comment"> and others.</span>
<span class="comment">      * Include errno.h to support default failure action.</span>

<span class="comment">    V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)</span>
<span class="comment">      * return null for negative arguments</span>
<span class="comment">      * Added Several WIN32 cleanups from Martin C. Fong &lt;mcfong at yahoo.com&gt;</span>
<span class="comment">         * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'</span>
<span class="comment">          (e.g. WIN32 platforms)</span>
<span class="comment">         * Cleanup header file inclusion for WIN32 platforms</span>
<span class="comment">         * Cleanup code to avoid Microsoft Visual C++ compiler complaints</span>
<span class="comment">         * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing</span>
<span class="comment">           memory allocation routines</span>
<span class="comment">         * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)</span>
<span class="comment">         * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to</span>
<span class="comment">           usage of 'assert' in non-WIN32 code</span>
<span class="comment">         * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to</span>
<span class="comment">           avoid infinite loop</span>
<span class="comment">      * Always call 'fREe()' rather than 'free()'</span>

<span class="comment">    V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)</span>
<span class="comment">      * Fixed ordering problem with boundary-stamping</span>

<span class="comment">    V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)</span>
<span class="comment">      * Added pvalloc, as recommended by H.J. Liu</span>
<span class="comment">      * Added 64bit pointer support mainly from Wolfram Gloger</span>
<span class="comment">      * Added anonymously donated WIN32 sbrk emulation</span>
<span class="comment">      * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen</span>
<span class="comment">      * malloc_extend_top: fix mask error that caused wastage after</span>
<span class="comment">        foreign sbrks</span>
<span class="comment">      * Add linux mremap support code from HJ Liu</span>

<span class="comment">    V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)</span>
<span class="comment">      * Integrated most documentation with the code.</span>
<span class="comment">      * Add support for mmap, with help from</span>
<span class="comment">        Wolfram Gloger (</span><span class="url">Gloger@lrz.uni-muenchen.de</span><span class="comment">).</span>
<span class="comment">      * Use last_remainder in more cases.</span>
<span class="comment">      * Pack bins using idea from  </span><span class="url">colin@nyx10.cs.du.edu</span>
<span class="comment">      * Use ordered bins instead of best-fit threshhold</span>
<span class="comment">      * Eliminate block-local decls to simplify tracing and debugging.</span>
<span class="comment">      * Support another case of realloc via move into top</span>
<span class="comment">      * Fix error occuring when initial sbrk_base not word-aligned.</span>
<span class="comment">      * Rely on page size for units instead of SBRK_UNIT to</span>
<span class="comment">        avoid surprises about sbrk alignment conventions.</span>
<span class="comment">      * Add mallinfo, mallopt. Thanks to Raymond Nijssen</span>
<span class="comment">        (</span><span class="url">raymond@es.ele.tue.nl</span><span class="comment">) for the suggestion.</span>
<span class="comment">      * Add `pad' argument to malloc_trim and top_pad mallopt parameter.</span>
<span class="comment">      * More precautions for cases where other routines call sbrk,</span>
<span class="comment">        courtesy of Wolfram Gloger (</span><span class="url">Gloger@lrz.uni-muenchen.de</span><span class="comment">).</span>
<span class="comment">      * Added macros etc., allowing use in linux libc from</span>
<span class="comment">        H.J. Lu (</span><span class="url">hjl@gnu.ai.mit.edu</span><span class="comment">)</span>
<span class="comment">      * Inverted this history list</span>

<span class="comment">    V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)</span>
<span class="comment">      * Re-tuned and fixed to behave more nicely with V2.6.0 changes.</span>
<span class="comment">      * Removed all preallocation code since under current scheme</span>
<span class="comment">        the work required to undo bad preallocations exceeds</span>
<span class="comment">        the work saved in good cases for most test programs.</span>
<span class="comment">      * No longer use return list or unconsolidated bins since</span>
<span class="comment">        no scheme using them consistently outperforms those that don't</span>
<span class="comment">        given above changes.</span>
<span class="comment">      * Use best fit for very large chunks to prevent some worst-cases.</span>
<span class="comment">      * Added some support for debugging</span>

<span class="comment">    V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)</span>
<span class="comment">      * Removed footers when chunks are in use. Thanks to</span>
<span class="comment">        Paul Wilson (</span><span class="url">wilson@cs.texas.edu</span><span class="comment">) for the suggestion.</span>

<span class="comment">    V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)</span>
<span class="comment">      * Added malloc_trim, with help from Wolfram Gloger</span>
<span class="comment">        (</span><span class="url">wmglo@Dent.MED.Uni-Muenchen.DE</span><span class="comment">).</span>

<span class="comment">    V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)</span>

<span class="comment">    V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)</span>
<span class="comment">      * realloc: try to expand in both directions</span>
<span class="comment">      * malloc: swap order of clean-bin strategy;</span>
<span class="comment">      * realloc: only conditionally expand backwards</span>
<span class="comment">      * Try not to scavenge used bins</span>
<span class="comment">      * Use bin counts as a guide to preallocation</span>
<span class="comment">      * Occasionally bin return list chunks in first scan</span>
<span class="comment">      * Add a few optimizations from </span><span class="url">colin@nyx10.cs.du.edu</span>

<span class="comment">    V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)</span>
<span class="comment">      * faster bin computation &amp; slightly different binning</span>
<span class="comment">      * merged all consolidations to one part of malloc proper</span>
<span class="comment">         (eliminating old malloc_find_space &amp; malloc_clean_bin)</span>
<span class="comment">      * Scan 2 returns chunks (not just 1)</span>
<span class="comment">      * Propagate failure in realloc if malloc returns 0</span>
<span class="comment">      * Add stuff to allow compilation on non-ANSI compilers</span>
<span class="comment">          from </span><span class="url">kpv@research.att.com</span>

<span class="comment">    V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)</span>
<span class="comment">      * removed potential for odd address access in prev_chunk</span>
<span class="comment">      * removed dependency on getpagesize.h</span>
<span class="comment">      * misc cosmetics and a bit more internal documentation</span>
<span class="comment">      * anticosmetics: mangled names in macros to evade debugger strangeness</span>
<span class="comment">      * tested on sparc, hp-700, dec-mips, rs6000</span>
<span class="comment">          with gcc &amp; native cc (hp, dec only) allowing</span>
<span class="comment">          Detlefs &amp; Zorn comparison study (in SIGPLAN Notices.)</span>

<span class="comment">    Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)</span>
<span class="comment">      * Based loosely on libg++-1.2X malloc. (It retains some of the overall</span>
<span class="comment">         structure of old version,  but most details differ.)</span>
<span class="comment"> </span>
<span class="comment">*/</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* !HAVE_MALLOC */</span>
</tt></pre></div><div style="text-align: right; padding: 8pt; font-size: 12px"><a href="/xmlfeed/weblog-rss20.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABQAAAADwCexKkxAAAAWUlEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMCt0ZdTU/F/7/+1HEkydFpoKVPn+93sUlUujQvP/7UcRTAuNDJ2a//s/imDqtKVZofm/1qGYSZk7sfodGwAAiobBJtffoNAAAAAASUVORK5CYII=" alt="RSS 2.0 Weblog Feed" width="80" height="15"/></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAAaklEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMDV16rTQ/H/7V//69+//v/3/9oMEI6cuAwr+fv/+/b5d///v//0eJBgWOhMo+Gs9UPAdXDBy6lSYyn9wQZCZS0GCYDPXQcykzJ1Y/Y4NAABKvL80wyoMPgAAAABJRU5ErkJggg==" alt="Atom 1.0 Weblog Feed" width="80" height="15"/></a> <a href="http://validator.w3.org/check?uri=referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABKklEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6qIGzIRiKZs9GFoEaMRuZhhrYqqJXy8uZYauRxC/VHew7e3YTPAxnI5swG6JxNrKBNjB1EFmIgV0+HA6C8pqqzhXG7BbJJROQIwViMYQ7G2oDQQNn57JyG7kxiCfObrBmS5+BHMuYLkTzMnYDm5WY4lOZZRPKZocxes+aPbuwCFsYohiICLvZsKBAMrDTQ7K/StveU8icTzrOL8JdLpOyWJ49u8Bx9ozw8DY7UYW03hhdxZAOSg2c3jN79rSJs1vSKmfOnpFXNJmynELlvExlAADnaZpLFGEC2wAAAABJRU5ErkJggg==" alt="Valid XHTML 1.1" width="80" height="15"/></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABEUlEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6mIEQCsIjwhKoga0qerW8nBm2Gkn8Ut3BvrNnN8HCcDYM2cBIogzs8uFwEJTXVHWuMGa3SC6ZgIgUqCEwdxJr4OxcVm4jNwbxxNkN1mzpM2ajGIjsPGK9PLtZiSk+lVk2oWx2GKP3rNmzC4tQwpDoIIQb2Okh2V+lbe8pZM4nHecX4S6XSVksz55d4Dh7Rnh4m52oQlpvjK5iSAelBk7vmT172sTZLWmVM2fPyCuaTFlOoXJepjIAANlljDGY/l5pAAAAAElFTkSuQmCC" alt="Valid CSS (2.1)" width="80" height="15"/></a><br/>Copyright 2005-2015 <a href="/about/">Timo Bingmann</a> - <a href="/about/impressum.html">Impressum</a></div><script type="text/javascript">var _paq = _paq || []; _paq.push(["trackPageView"]); _paq.push(["enableLinkTracking"]);(function() {var u=(("https:" == document.location.protocol) ? "https" : "http") + "://panthema.net/wik-331/"; _paq.push(["setTrackerUrl", u+"js/"]); _paq.push(["setSiteId", "2"]);var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";g.defer=true; g.async=true; g.src=u+"js/"; s.parentNode.insertBefore(g,s);})();</script><noscript><p><img src="http://panthema.net/wik-331/js/?idsite=2&amp;rec=1" style="border:0" alt="" /></p></noscript></body></html>