<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><title>/2006/SDIOS06/sdios06/lib/SDL/video/e_sqrt.h - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="stylesheet" type="text/css" href="/css/fonts.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="http://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="http://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/js/base.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body style="background-image: url(/img/bgfractal2.jpg)"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/">Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2014/">2014</a></li><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li class="nt"><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li><li class="ns"><a href="/search.html">Search</a></li></ul></li><li class="top"><a class="ni" href="/tags/">Tags</a><div style="width: 14em; margin-left: -9em; margin-top: 4px"><a style="font-size: 10pt" href="/tags/algebra.html">algebra</a> <a style="font-size: 16pt" href="/tags/c++.html">c++</a> <a style="font-size: 12pt" href="/tags/code-example.html">code-example</a> <a style="font-size: 14pt" href="/tags/code-snippet.html">code-snippet</a> <a style="font-size: 11pt" href="/tags/coding_tricks.html">coding tricks</a> <a style="font-size: 10pt" href="/tags/compsci.html">compsci</a> <a style="font-size: 10pt" href="/tags/compsci_study_thesis.html">compsci study thesis</a> <a style="font-size: 9pt" href="/tags/crypto-speedtest.html">crypto-speedtest</a> <a style="font-size: 10pt" href="/tags/cryptography.html">cryptography</a> <a style="font-size: 9pt" href="/tags/cryptote.html">cryptote</a> <a style="font-size: 12pt" href="/tags/flex-bison-cpp-example.html">flex-bison-cpp-example</a> <a style="font-size: 13pt" href="/tags/frontpage.html">frontpage</a> <a style="font-size: 13pt" href="/tags/fun.html">fun</a> <a style="font-size: 10pt" href="/tags/graphviz.html">graphviz</a> <a style="font-size: 9pt" href="http://www.hmtg.de">hartmetall</a> <a style="font-size: 9pt" href="/tags/helppc.html">helppc</a> <a style="font-size: 9pt" href="/tags/hifi_selbstbau.html">hifi selbstbau</a> <a style="font-size: 10pt" href="/tags/latex.html">latex</a> <a style="font-size: 10pt" href="/tags/librivox.html">librivox</a> <a style="font-size: 10pt" href="/tags/linux.html">linux</a> <a style="font-size: 10pt" href="/tags/maths.html">maths</a> <a style="font-size: 9pt" href="/tags/music.html">music</a> <a style="font-size: 10pt" href="/tags/netfundamentals.html">netfundamentals</a> <a style="font-size: 11pt" href="/tags/ns-3.html">ns-3</a> <a style="font-size: 10pt" href="/tags/parallel-string-sorting.html">parallel-string-sorting</a> <a style="font-size: 9pt" href="/tags/qtsqlview.html">qtsqlview</a> <a style="font-size: 10pt" href="/tags/research.html">research</a> <a style="font-size: 11pt" href="/tags/sdios06.html">sdios06</a> <a style="font-size: 9pt" href="/tags/sdlfractal.html">sdlfractal</a> <a style="font-size: 12pt" href="/tags/sorting.html">sorting</a> <a style="font-size: 10pt" href="/tags/stringology.html">stringology</a> <a style="font-size: 16pt" href="/tags/stx-btree.html">stx-btree</a> <a style="font-size: 9pt" href="/tags/stx-exparser.html">stx-exparser</a> <a style="font-size: 10pt" href="/tags/stxxl.html">stxxl</a> <a style="font-size: 15pt" href="/tags/talk.html">talk</a> <a style="font-size: 10pt" href="/tags/tutorium.html">tutorium</a> <a style="font-size: 16pt" href="/tags/university.html">university</a> <a style="font-size: 13pt" href="/tags/utilities.html">utilities</a> <a style="font-size: 9pt" href="/tags/webdesign.html">webdesign</a> </div></li><li class="top"> <a class="ni" href="#">Projects</a> <ul style="margin-left: -8em; margin-top: 4px;" class="nx"> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2013/parallel-string-sorting/">parallel-string-sorting</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2014/sqlplot-tools/">SqlPlotTools</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li class="nt"><a href="/2013/1212-stxxl-1.4.0/">STXXL 1.4</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="#">Research</a> <ul style="margin-left: -16em; margin-top: 4px" class="nx"> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP - External Memory Suffix Sorting</a></li> <li><a href="/2013/parallel-string-sorting/">Parallel String Sorting</a></li> <li><a href="/tags/stxxl.html">STXXL - External Memory Algorithms</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="/about/">About</a> <ul style="margin-left: -6em; margin-top: 4px" class="nx"> <li><a href="/about/">Timo Bingmann</a></li> <li><a href="/about/impressum.html">Impressum</a></li> </ul></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2006/">2006</a> / <a href="/2006/SDIOS06/">SDIOS06</a> / <a href="/2006/SDIOS06/sdios06/">sdios06</a> / <a href="/2006/SDIOS06/sdios06/lib/">lib</a> / <a href="/2006/SDIOS06/sdios06/lib/SDL/">SDL</a> / <a href="/2006/SDIOS06/sdios06/lib/SDL/video/">video</a> / <a href="/2006/SDIOS06/sdios06/lib/SDL/video/e_sqrt.h.html">e_sqrt.h</a> (<a href="/2006/SDIOS06/sdios06/lib/SDL/video/e_sqrt.h">Download File</a>)</div></div><div class="ptfullwidth"><pre class="codesnippet" style="font-family: monospace"><tt><span class="comment">/* @(#)e_sqrt.c 5.1 93/09/24 */</span>
<span class="comment">/*</span>
<span class="comment"> * ====================================================</span>
<span class="comment"> * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Developed at SunPro, a Sun Microsystems, Inc. business.</span>
<span class="comment"> * Permission to use, copy, modify, and distribute this</span>
<span class="comment"> * software is freely granted, provided that this notice</span>
<span class="comment"> * is preserved.</span>
<span class="comment"> * ====================================================</span>
<span class="comment"> */</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="function">defined</span><span class="symbol">(</span><span class="normal">LIBM_SCCS</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">defined</span><span class="symbol">(</span><span class="normal">lint</span><span class="symbol">)</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">char</span><span class="normal"> rcsid</span><span class="symbol">[]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="string">"$NetBSD: e_sqrt.c,v 1.8 1995/05/10 20:46:17 jtc Exp $"</span><span class="symbol">;</span>
<span class="preproc">#endif</span>

<span class="comment">/* __ieee754_sqrt(x)</span>
<span class="comment"> * Return correctly rounded sqrt.</span>
<span class="comment"> *           ------------------------------------------</span>
<span class="comment"> *	     |  Use the hardware sqrt if you have one |</span>
<span class="comment"> *           ------------------------------------------</span>
<span class="comment"> * Method:</span>
<span class="comment"> *   Bit by bit method using integer arithmetic. (Slow, but portable)</span>
<span class="comment"> *   1. Normalization</span>
<span class="comment"> *	Scale x to y in [1,4) with even powers of 2:</span>
<span class="comment"> *	find an integer k such that  1 &lt;= (y=x*2^(2k)) &lt; 4, then</span>
<span class="comment"> *		sqrt(x) = 2^k * sqrt(y)</span>
<span class="comment"> *   2. Bit by bit computation</span>
<span class="comment"> *	Let q  = sqrt(y) truncated to i bit after binary point (q = 1),</span>
<span class="comment"> *	     i							 0</span>
<span class="comment"> *                                     i+1         2</span>
<span class="comment"> *	    s  = 2*q , and	y  =  2   * ( y - q  ).		(1)</span>
<span class="comment"> *	     i      i            i                 i</span>
<span class="comment"> *</span>
<span class="comment"> *	To compute q    from q , one checks whether</span>
<span class="comment"> *		    i+1       i</span>
<span class="comment"> *</span>
<span class="comment"> *			      -(i+1) 2</span>
<span class="comment"> *			(q + 2      ) &lt;= y.			(2)</span>
<span class="comment"> *     			  i</span>
<span class="comment"> *							      -(i+1)</span>
<span class="comment"> *	If (2) is false, then q   = q ; otherwise q   = q  + 2      .</span>
<span class="comment"> *		 	       i+1   i             i+1   i</span>
<span class="comment"> *</span>
<span class="comment"> *	With some algebric manipulation, it is not difficult to see</span>
<span class="comment"> *	that (2) is equivalent to</span>
<span class="comment"> *                             -(i+1)</span>
<span class="comment"> *			s  +  2       &lt;= y			(3)</span>
<span class="comment"> *			 i                i</span>
<span class="comment"> *</span>
<span class="comment"> *	The advantage of (3) is that s  and y  can be computed by</span>
<span class="comment"> *				      i      i</span>
<span class="comment"> *	the following recurrence formula:</span>
<span class="comment"> *	    if (3) is false</span>
<span class="comment"> *</span>
<span class="comment"> *	    s     =  s  ,	y    = y   ;			(4)</span>
<span class="comment"> *	     i+1      i		 i+1    i</span>
<span class="comment"> *</span>
<span class="comment"> *	    otherwise,</span>
<span class="comment"> *                         -i                     -(i+1)</span>
<span class="comment"> *	    s	  =  s  + 2  ,  y    = y  -  s  - 2  		(5)</span>
<span class="comment"> *           i+1      i          i+1    i     i</span>
<span class="comment"> *</span>
<span class="comment"> *	One may easily use induction to prove (4) and (5).</span>
<span class="comment"> *	Note. Since the left hand side of (3) contain only i+2 bits,</span>
<span class="comment"> *	      it does not necessary to do a full (53-bit) comparison</span>
<span class="comment"> *	      in (3).</span>
<span class="comment"> *   3. Final rounding</span>
<span class="comment"> *	After generating the 53 bits result, we compute one more bit.</span>
<span class="comment"> *	Together with the remainder, we can decide whether the</span>
<span class="comment"> *	result is exact, bigger than 1/2ulp, or less than 1/2ulp</span>
<span class="comment"> *	(it will never equal to 1/2ulp).</span>
<span class="comment"> *	The rounding mode can be detected by checking whether</span>
<span class="comment"> *	huge + tiny is equal to huge, and whether huge - tiny is</span>
<span class="comment"> *	equal to huge for some floating point number "huge" and "tiny".</span>
<span class="comment"> *</span>
<span class="comment"> * Special cases:</span>
<span class="comment"> *	sqrt(+-0) = +-0 	... exact</span>
<span class="comment"> *	sqrt(inf) = inf</span>
<span class="comment"> *	sqrt(-ve) = NaN		... with invalid signal</span>
<span class="comment"> *	sqrt(NaN) = NaN		... with invalid signal for signaling NaN</span>
<span class="comment"> *</span>
<span class="comment"> * Other methods : see the appended file at the end of the program below.</span>
<span class="comment"> *---------------</span>
<span class="comment"> */</span>

<span class="comment">/*#include "math.h"*/</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">"math_private.h"</span>

<span class="preproc">#ifdef</span><span class="normal"> __STDC__</span>
<span class="normal">	</span><span class="type">double</span><span class="normal"> </span><span class="function">SDL_NAME</span><span class="symbol">(</span><span class="normal">copysign</span><span class="symbol">)(</span><span class="type">double</span><span class="normal"> x</span><span class="symbol">,</span><span class="normal"> </span><span class="type">double</span><span class="normal"> y</span><span class="symbol">)</span>
<span class="preproc">#else</span>
<span class="normal">	</span><span class="type">double</span><span class="normal"> </span><span class="function">SDL_NAME</span><span class="symbol">(</span><span class="normal">copysign</span><span class="symbol">)(</span><span class="normal">x</span><span class="symbol">,</span><span class="normal">y</span><span class="symbol">)</span>
<span class="normal">	</span><span class="type">double</span><span class="normal"> x</span><span class="symbol">,</span><span class="normal">y</span><span class="symbol">;</span>
<span class="preproc">#endif</span>
<span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">u_int32_t</span><span class="normal"> hx</span><span class="symbol">,</span><span class="normal">hy</span><span class="symbol">;</span>
<span class="normal">	</span><span class="function">GET_HIGH_WORD</span><span class="symbol">(</span><span class="normal">hx</span><span class="symbol">,</span><span class="normal">x</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">GET_HIGH_WORD</span><span class="symbol">(</span><span class="normal">hy</span><span class="symbol">,</span><span class="normal">y</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">SET_HIGH_WORD</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">,(</span><span class="normal">hx</span><span class="symbol">&amp;</span><span class="number">0x7fffffff</span><span class="symbol">)|(</span><span class="normal">hy</span><span class="symbol">&amp;</span><span class="number">0x80000000</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> x</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="preproc">#ifdef</span><span class="normal"> __STDC__</span>
<span class="normal">	</span><span class="type">double</span><span class="normal"> </span><span class="function">SDL_NAME</span><span class="symbol">(</span><span class="normal">scalbn</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">(</span><span class="type">double</span><span class="normal"> x</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> n</span><span class="symbol">)</span>
<span class="preproc">#else</span>
<span class="normal">	</span><span class="type">double</span><span class="normal"> </span><span class="function">SDL_NAME</span><span class="symbol">(</span><span class="normal">scalbn</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">,</span><span class="normal">n</span><span class="symbol">)</span>
<span class="normal">	</span><span class="type">double</span><span class="normal"> x</span><span class="symbol">;</span><span class="normal"> </span><span class="type">int</span><span class="normal"> n</span><span class="symbol">;</span>
<span class="preproc">#endif</span>
<span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">int32_t</span><span class="normal"> k</span><span class="symbol">,</span><span class="normal">hx</span><span class="symbol">,</span><span class="normal">lx</span><span class="symbol">;</span>
<span class="normal">	</span><span class="function">EXTRACT_WORDS</span><span class="symbol">(</span><span class="normal">hx</span><span class="symbol">,</span><span class="normal">lx</span><span class="symbol">,</span><span class="normal">x</span><span class="symbol">);</span>
<span class="normal">        k </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">hx</span><span class="symbol">&amp;</span><span class="number">0x7ff00000</span><span class="symbol">)&gt;&gt;</span><span class="number">20</span><span class="symbol">;</span><span class="normal">		</span><span class="comment">/* extract exponent */</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">k</span><span class="symbol">==</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">				</span><span class="comment">/* 0 or subnormal x */</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">lx</span><span class="symbol">|(</span><span class="normal">hx</span><span class="symbol">&amp;</span><span class="number">0x7fffffff</span><span class="symbol">))==</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> x</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* +-0 */</span>
<span class="normal">	    x </span><span class="symbol">*=</span><span class="normal"> two54</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="function">GET_HIGH_WORD</span><span class="symbol">(</span><span class="normal">hx</span><span class="symbol">,</span><span class="normal">x</span><span class="symbol">);</span>
<span class="normal">	    k </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">hx</span><span class="symbol">&amp;</span><span class="number">0x7ff00000</span><span class="symbol">)&gt;&gt;</span><span class="number">20</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> </span><span class="number">54</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">-</span><span class="number">50000</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> tiny</span><span class="symbol">*</span><span class="normal">x</span><span class="symbol">;</span><span class="normal"> 	</span><span class="comment">/*underflow*/</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">k</span><span class="symbol">==</span><span class="number">0x7ff</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> x</span><span class="symbol">+</span><span class="normal">x</span><span class="symbol">;</span><span class="normal">		</span><span class="comment">/* NaN or Inf */</span>
<span class="normal">        k </span><span class="symbol">=</span><span class="normal"> k</span><span class="symbol">+</span><span class="normal">n</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">k </span><span class="symbol">&gt;</span><span class="normal">  </span><span class="number">0x7fe</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> huge</span><span class="symbol">*</span><span class="function">SDL_NAME</span><span class="symbol">(</span><span class="normal">copysign</span><span class="symbol">)(</span><span class="normal">huge</span><span class="symbol">,</span><span class="normal">x</span><span class="symbol">);</span><span class="normal"> </span><span class="comment">/* overflow  */</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">k </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> 				</span><span class="comment">/* normal result */</span>
<span class="normal">	    </span><span class="cbracket">{</span><span class="function">SET_HIGH_WORD</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">,(</span><span class="normal">hx</span><span class="symbol">&amp;</span><span class="number">0x800fffff</span><span class="symbol">)|(</span><span class="normal">k</span><span class="symbol">&lt;&lt;</span><span class="number">20</span><span class="symbol">));</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> x</span><span class="symbol">;</span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">k </span><span class="symbol">&lt;=</span><span class="normal"> </span><span class="symbol">-</span><span class="number">54</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">n </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">50000</span><span class="symbol">)</span><span class="normal"> 	</span><span class="comment">/* in case integer overflow in n+k */</span>
<span class="normal">		</span><span class="keyword">return</span><span class="normal"> huge</span><span class="symbol">*</span><span class="function">SDL_NAME</span><span class="symbol">(</span><span class="normal">copysign</span><span class="symbol">)(</span><span class="normal">huge</span><span class="symbol">,</span><span class="normal">x</span><span class="symbol">);</span><span class="normal">	</span><span class="comment">/*overflow*/</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> tiny</span><span class="symbol">*</span><span class="function">SDL_NAME</span><span class="symbol">(</span><span class="normal">copysign</span><span class="symbol">)(</span><span class="normal">tiny</span><span class="symbol">,</span><span class="normal">x</span><span class="symbol">);</span><span class="normal"> 	</span><span class="comment">/*underflow*/</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">        k </span><span class="symbol">+=</span><span class="normal"> </span><span class="number">54</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* subnormal result */</span>
<span class="normal">	</span><span class="function">SET_HIGH_WORD</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">,(</span><span class="normal">hx</span><span class="symbol">&amp;</span><span class="number">0x800fffff</span><span class="symbol">)|(</span><span class="normal">k</span><span class="symbol">&lt;&lt;</span><span class="number">20</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> x</span><span class="symbol">*</span><span class="normal">twom54</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="preproc">#ifdef</span><span class="normal"> __STDC__</span>
<span class="normal">	</span><span class="type">double</span><span class="normal"> </span><span class="function">__ieee754_sqrt</span><span class="symbol">(</span><span class="type">double</span><span class="normal"> x</span><span class="symbol">)</span>
<span class="preproc">#else</span>
<span class="normal">	</span><span class="type">double</span><span class="normal"> </span><span class="function">__ieee754_sqrt</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span>
<span class="normal">	</span><span class="type">double</span><span class="normal"> x</span><span class="symbol">;</span>
<span class="preproc">#endif</span>
<span class="cbracket">{</span>
<span class="normal">	</span><span class="type">double</span><span class="normal"> z</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">int32_t</span><span class="normal"> sign </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">int</span><span class="symbol">)</span><span class="number">0x80000000</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">int32_t</span><span class="normal"> ix0</span><span class="symbol">,</span><span class="normal">s0</span><span class="symbol">,</span><span class="normal">q</span><span class="symbol">,</span><span class="normal">m</span><span class="symbol">,</span><span class="normal">t</span><span class="symbol">,</span><span class="normal">i</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">u_int32_t</span><span class="normal"> r</span><span class="symbol">,</span><span class="normal">t1</span><span class="symbol">,</span><span class="normal">s1</span><span class="symbol">,</span><span class="normal">ix1</span><span class="symbol">,</span><span class="normal">q1</span><span class="symbol">;</span>

<span class="normal">	</span><span class="function">EXTRACT_WORDS</span><span class="symbol">(</span><span class="normal">ix0</span><span class="symbol">,</span><span class="normal">ix1</span><span class="symbol">,</span><span class="normal">x</span><span class="symbol">);</span>

<span class="normal">    </span><span class="comment">/* take care of Inf and NaN */</span>
<span class="normal">	</span><span class="keyword">if</span><span class="symbol">((</span><span class="normal">ix0</span><span class="symbol">&amp;</span><span class="number">0x7ff00000</span><span class="symbol">)==</span><span class="number">0x7ff00000</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">return</span><span class="normal"> x</span><span class="symbol">*</span><span class="normal">x</span><span class="symbol">+</span><span class="normal">x</span><span class="symbol">;</span><span class="normal">		</span><span class="comment">/* sqrt(NaN)=NaN, sqrt(+inf)=+inf</span>
<span class="comment">					   sqrt(-inf)=sNaN */</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="comment">/* take care of zero */</span>
<span class="normal">	</span><span class="keyword">if</span><span class="symbol">(</span><span class="normal">ix0</span><span class="symbol">&lt;=</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="symbol">(((</span><span class="normal">ix0</span><span class="symbol">&amp;(~</span><span class="normal">sign</span><span class="symbol">))|</span><span class="normal">ix1</span><span class="symbol">)==</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> x</span><span class="symbol">;</span><span class="comment">/* sqrt(+-0) = +-0 */</span>
<span class="normal">	    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="symbol">(</span><span class="normal">ix0</span><span class="symbol">&lt;</span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">		</span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">-</span><span class="normal">x</span><span class="symbol">)/(</span><span class="normal">x</span><span class="symbol">-</span><span class="normal">x</span><span class="symbol">);</span><span class="normal">		</span><span class="comment">/* sqrt(-ve) = sNaN */</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">    </span><span class="comment">/* normalize x */</span>
<span class="normal">	m </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ix0</span><span class="symbol">&gt;&gt;</span><span class="number">20</span><span class="symbol">);</span>
<span class="normal">	</span><span class="keyword">if</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">==</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal">				</span><span class="comment">/* subnormal x */</span>
<span class="normal">	    </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">ix0</span><span class="symbol">==</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		m </span><span class="symbol">-=</span><span class="normal"> </span><span class="number">21</span><span class="symbol">;</span>
<span class="normal">		ix0 </span><span class="symbol">|=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ix1</span><span class="symbol">&gt;&gt;</span><span class="number">11</span><span class="symbol">);</span><span class="normal"> ix1 </span><span class="symbol">&lt;&lt;=</span><span class="normal"> </span><span class="number">21</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    </span><span class="keyword">for</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">=</span><span class="number">0</span><span class="symbol">;(</span><span class="normal">ix0</span><span class="symbol">&amp;</span><span class="number">0x00100000</span><span class="symbol">)==</span><span class="number">0</span><span class="symbol">;</span><span class="normal">i</span><span class="symbol">++)</span><span class="normal"> ix0</span><span class="symbol">&lt;&lt;=</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    m </span><span class="symbol">-=</span><span class="normal"> i</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	    ix0 </span><span class="symbol">|=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ix1</span><span class="symbol">&gt;&gt;(</span><span class="number">32</span><span class="symbol">-</span><span class="normal">i</span><span class="symbol">));</span>
<span class="normal">	    ix1 </span><span class="symbol">&lt;&lt;=</span><span class="normal"> i</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	m </span><span class="symbol">-=</span><span class="normal"> </span><span class="number">1023</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* unbias exponent */</span>
<span class="normal">	ix0 </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ix0</span><span class="symbol">&amp;</span><span class="number">0x000fffff</span><span class="symbol">)|</span><span class="number">0x00100000</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">if</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">&amp;</span><span class="number">1</span><span class="symbol">)</span><span class="cbracket">{</span><span class="normal">	</span><span class="comment">/* odd m, double x to make it even */</span>
<span class="normal">	    ix0 </span><span class="symbol">+=</span><span class="normal"> ix0 </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">ix1</span><span class="symbol">&amp;</span><span class="normal">sign</span><span class="symbol">)&gt;&gt;</span><span class="number">31</span><span class="symbol">);</span>
<span class="normal">	    ix1 </span><span class="symbol">+=</span><span class="normal"> ix1</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	m </span><span class="symbol">&gt;&gt;=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* m = [m/2] */</span>

<span class="normal">    </span><span class="comment">/* generate sqrt(x) bit by bit */</span>
<span class="normal">	ix0 </span><span class="symbol">+=</span><span class="normal"> ix0 </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">ix1</span><span class="symbol">&amp;</span><span class="normal">sign</span><span class="symbol">)&gt;&gt;</span><span class="number">31</span><span class="symbol">);</span>
<span class="normal">	ix1 </span><span class="symbol">+=</span><span class="normal"> ix1</span><span class="symbol">;</span>
<span class="normal">	q </span><span class="symbol">=</span><span class="normal"> q1 </span><span class="symbol">=</span><span class="normal"> s0 </span><span class="symbol">=</span><span class="normal"> s1 </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* [q,q1] = sqrt(x) */</span>
<span class="normal">	r </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0x00200000</span><span class="symbol">;</span><span class="normal">		</span><span class="comment">/* r = moving bit from right to left */</span>

<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">r</span><span class="symbol">!=</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    t </span><span class="symbol">=</span><span class="normal"> s0</span><span class="symbol">+</span><span class="normal">r</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">&lt;=</span><span class="normal">ix0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		s0   </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">+</span><span class="normal">r</span><span class="symbol">;</span>
<span class="normal">		ix0 </span><span class="symbol">-=</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">		q   </span><span class="symbol">+=</span><span class="normal"> r</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    ix0 </span><span class="symbol">+=</span><span class="normal"> ix0 </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">ix1</span><span class="symbol">&amp;</span><span class="normal">sign</span><span class="symbol">)&gt;&gt;</span><span class="number">31</span><span class="symbol">);</span>
<span class="normal">	    ix1 </span><span class="symbol">+=</span><span class="normal"> ix1</span><span class="symbol">;</span>
<span class="normal">	    r</span><span class="symbol">&gt;&gt;=</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">	r </span><span class="symbol">=</span><span class="normal"> sign</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">while</span><span class="symbol">(</span><span class="normal">r</span><span class="symbol">!=</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    t1 </span><span class="symbol">=</span><span class="normal"> s1</span><span class="symbol">+</span><span class="normal">r</span><span class="symbol">;</span>
<span class="normal">	    t  </span><span class="symbol">=</span><span class="normal"> s0</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="symbol">((</span><span class="normal">t</span><span class="symbol">&lt;</span><span class="normal">ix0</span><span class="symbol">)||((</span><span class="normal">t</span><span class="symbol">==</span><span class="normal">ix0</span><span class="symbol">)&amp;&amp;(</span><span class="normal">t1</span><span class="symbol">&lt;=</span><span class="normal">ix1</span><span class="symbol">)))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		s1  </span><span class="symbol">=</span><span class="normal"> t1</span><span class="symbol">+</span><span class="normal">r</span><span class="symbol">;</span>
<span class="normal">		</span><span class="keyword">if</span><span class="symbol">(((</span><span class="normal">int32_t</span><span class="symbol">)(</span><span class="normal">t1</span><span class="symbol">&amp;</span><span class="normal">sign</span><span class="symbol">)==</span><span class="normal">sign</span><span class="symbol">)&amp;&amp;(</span><span class="normal">s1</span><span class="symbol">&amp;</span><span class="normal">sign</span><span class="symbol">)==</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> s0 </span><span class="symbol">+=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">		ix0 </span><span class="symbol">-=</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">		</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ix1 </span><span class="symbol">&lt;</span><span class="normal"> t1</span><span class="symbol">)</span><span class="normal"> ix0 </span><span class="symbol">-=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">		ix1 </span><span class="symbol">-=</span><span class="normal"> t1</span><span class="symbol">;</span>
<span class="normal">		q1  </span><span class="symbol">+=</span><span class="normal"> r</span><span class="symbol">;</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	    ix0 </span><span class="symbol">+=</span><span class="normal"> ix0 </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">ix1</span><span class="symbol">&amp;</span><span class="normal">sign</span><span class="symbol">)&gt;&gt;</span><span class="number">31</span><span class="symbol">);</span>
<span class="normal">	    ix1 </span><span class="symbol">+=</span><span class="normal"> ix1</span><span class="symbol">;</span>
<span class="normal">	    r</span><span class="symbol">&gt;&gt;=</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	</span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/* use floating add to find out rounding direction */</span>
<span class="normal">	</span><span class="keyword">if</span><span class="symbol">((</span><span class="normal">ix0</span><span class="symbol">|</span><span class="normal">ix1</span><span class="symbol">)!=</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	    z </span><span class="symbol">=</span><span class="normal"> one</span><span class="symbol">-</span><span class="normal">tiny</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">/* trigger inexact flag */</span>
<span class="normal">	    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">z</span><span class="symbol">&gt;=</span><span class="normal">one</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	        z </span><span class="symbol">=</span><span class="normal"> one</span><span class="symbol">+</span><span class="normal">tiny</span><span class="symbol">;</span>
<span class="normal">	        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">q1</span><span class="symbol">==(</span><span class="normal">u_int32_t</span><span class="symbol">)</span><span class="number">0xffffffff</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> q1</span><span class="symbol">=</span><span class="number">0</span><span class="symbol">;</span><span class="normal"> q </span><span class="symbol">+=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="cbracket">}</span>
<span class="normal">		</span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">z</span><span class="symbol">&gt;</span><span class="normal">one</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">		    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">q1</span><span class="symbol">==(</span><span class="normal">u_int32_t</span><span class="symbol">)</span><span class="number">0xfffffffe</span><span class="symbol">)</span><span class="normal"> q</span><span class="symbol">+=</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">		    q1</span><span class="symbol">+=</span><span class="number">2</span><span class="symbol">;</span>
<span class="normal">		</span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">else</span>
<span class="normal">	            q1 </span><span class="symbol">+=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">q1</span><span class="symbol">&amp;</span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">	    </span><span class="cbracket">}</span>
<span class="normal">	</span><span class="cbracket">}</span>
<span class="normal">	ix0 </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">q</span><span class="symbol">&gt;&gt;</span><span class="number">1</span><span class="symbol">)+</span><span class="number">0x3fe00000</span><span class="symbol">;</span>
<span class="normal">	ix1 </span><span class="symbol">=</span><span class="normal">  q1</span><span class="symbol">&gt;&gt;</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">q</span><span class="symbol">&amp;</span><span class="number">1</span><span class="symbol">)==</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> ix1 </span><span class="symbol">|=</span><span class="normal"> sign</span><span class="symbol">;</span>
<span class="normal">	ix0 </span><span class="symbol">+=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m </span><span class="symbol">&lt;&lt;</span><span class="number">20</span><span class="symbol">);</span>
<span class="normal">	</span><span class="function">INSERT_WORDS</span><span class="symbol">(</span><span class="normal">z</span><span class="symbol">,</span><span class="normal">ix0</span><span class="symbol">,</span><span class="normal">ix1</span><span class="symbol">);</span>
<span class="normal">	</span><span class="keyword">return</span><span class="normal"> z</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">/*</span>
<span class="comment">Other methods  (use floating-point arithmetic)</span>
<span class="comment">-------------</span>
<span class="comment">(This is a copy of a drafted paper by Prof W. Kahan</span>
<span class="comment">and K.C. Ng, written in May, 1986)</span>

<span class="comment">	Two algorithms are given here to implement sqrt(x)</span>
<span class="comment">	(IEEE double precision arithmetic) in software.</span>
<span class="comment">	Both supply sqrt(x) correctly rounded. The first algorithm (in</span>
<span class="comment">	Section A) uses newton iterations and involves four divisions.</span>
<span class="comment">	The second one uses reciproot iterations to avoid division, but</span>
<span class="comment">	requires more multiplications. Both algorithms need the ability</span>
<span class="comment">	to chop results of arithmetic operations instead of round them,</span>
<span class="comment">	and the INEXACT flag to indicate when an arithmetic operation</span>
<span class="comment">	is executed exactly with no roundoff error, all part of the</span>
<span class="comment">	standard (IEEE 754-1985). The ability to perform shift, add,</span>
<span class="comment">	subtract and logical AND operations upon 32-bit words is needed</span>
<span class="comment">	too, though not part of the standard.</span>

<span class="comment">A.  sqrt(x) by Newton Iteration</span>

<span class="comment">   (1)	Initial approximation</span>

<span class="comment">	Let x0 and x1 be the leading and the trailing 32-bit words of</span>
<span class="comment">	a floating point number x (in IEEE double format) respectively</span>

<span class="comment">	    1    11		     52				  ...widths</span>
<span class="comment">	   ------------------------------------------------------</span>
<span class="comment">	x: |s|	  e     |	      f				|</span>
<span class="comment">	   ------------------------------------------------------</span>
<span class="comment">	      msb    lsb  msb				      lsb ...order</span>


<span class="comment">	     ------------------------  	     ------------------------</span>
<span class="comment">	x0:  |s|   e    |    f1     |	 x1: |          f2           |</span>
<span class="comment">	     ------------------------  	     ------------------------</span>

<span class="comment">	By performing shifts and subtracts on x0 and x1 (both regarded</span>
<span class="comment">	as integers), we obtain an 8-bit approximation of sqrt(x) as</span>
<span class="comment">	follows.</span>

<span class="comment">		k  := (x0&gt;&gt;1) + 0x1ff80000;</span>
<span class="comment">		y0 := k - T1[31&amp;(k&gt;&gt;15)].	... y ~ sqrt(x) to 8 bits</span>
<span class="comment">	Here k is a 32-bit integer and T1[] is an integer array containing</span>
<span class="comment">	correction terms. Now magically the floating value of y (y's</span>
<span class="comment">	leading 32-bit word is y0, the value of its trailing word is 0)</span>
<span class="comment">	approximates sqrt(x) to almost 8-bit.</span>

<span class="comment">	Value of T1:</span>
<span class="comment">	static int T1[32]= {</span>
<span class="comment">	0,	1024,	3062,	5746,	9193,	13348,	18162,	23592,</span>
<span class="comment">	29598,	36145,	43202,	50740,	58733,	67158,	75992,	85215,</span>
<span class="comment">	83599,	71378,	60428,	50647,	41945,	34246,	27478,	21581,</span>
<span class="comment">	16499,	12183,	8588,	5674,	3403,	1742,	661,	130,};</span>

<span class="comment">    (2)	Iterative refinement</span>

<span class="comment">	Apply Heron's rule three times to y, we have y approximates</span>
<span class="comment">	sqrt(x) to within 1 ulp (Unit in the Last Place):</span>

<span class="comment">		y := (y+x/y)/2		... almost 17 sig. bits</span>
<span class="comment">		y := (y+x/y)/2		... almost 35 sig. bits</span>
<span class="comment">		y := y-(y-x/y)/2	... within 1 ulp</span>


<span class="comment">	Remark 1.</span>
<span class="comment">	    Another way to improve y to within 1 ulp is:</span>

<span class="comment">		y := (y+x/y)		... almost 17 sig. bits to 2*sqrt(x)</span>
<span class="comment">		y := y - 0x00100006	... almost 18 sig. bits to sqrt(x)</span>

<span class="comment">				2</span>
<span class="comment">			    (x-y )*y</span>
<span class="comment">		y := y + 2* ----------	...within 1 ulp</span>
<span class="comment">			       2</span>
<span class="comment">			     3y  + x</span>


<span class="comment">	This formula has one division fewer than the one above; however,</span>
<span class="comment">	it requires more multiplications and additions. Also x must be</span>
<span class="comment">	scaled in advance to avoid spurious overflow in evaluating the</span>
<span class="comment">	expression 3y*y+x. Hence it is not recommended uless division</span>
<span class="comment">	is slow. If division is very slow, then one should use the</span>
<span class="comment">	reciproot algorithm given in section B.</span>

<span class="comment">    (3) Final adjustment</span>

<span class="comment">	By twiddling y's last bit it is possible to force y to be</span>
<span class="comment">	correctly rounded according to the prevailing rounding mode</span>
<span class="comment">	as follows. Let r and i be copies of the rounding mode and</span>
<span class="comment">	inexact flag before entering the square root program. Also we</span>
<span class="comment">	use the expression y+-ulp for the next representable floating</span>
<span class="comment">	numbers (up and down) of y. Note that y+-ulp = either fixed</span>
<span class="comment">	point y+-1, or multiply y by nextafter(1,+-inf) in chopped</span>
<span class="comment">	mode.</span>

<span class="comment">		I := FALSE;	... reset INEXACT flag I</span>
<span class="comment">		R := RZ;	... set rounding mode to round-toward-zero</span>
<span class="comment">		z := x/y;	... chopped quotient, possibly inexact</span>
<span class="comment">		If(not I) then {	... if the quotient is exact</span>
<span class="comment">		    if(z=y) {</span>
<span class="comment">		        I := i;	 ... restore inexact flag</span>
<span class="comment">		        R := r;  ... restore rounded mode</span>
<span class="comment">		        return sqrt(x):=y.</span>
<span class="comment">		    } else {</span>
<span class="comment">			z := z - ulp;	... special rounding</span>
<span class="comment">		    }</span>
<span class="comment">		}</span>
<span class="comment">		i := TRUE;		... sqrt(x) is inexact</span>
<span class="comment">		If (r=RN) then z=z+ulp	... rounded-to-nearest</span>
<span class="comment">		If (r=RP) then {	... round-toward-+inf</span>
<span class="comment">		    y = y+ulp; z=z+ulp;</span>
<span class="comment">		}</span>
<span class="comment">		y := y+z;		... chopped sum</span>
<span class="comment">		y0:=y0-0x00100000;	... y := y/2 is correctly rounded.</span>
<span class="comment">	        I := i;	 		... restore inexact flag</span>
<span class="comment">	        R := r;  		... restore rounded mode</span>
<span class="comment">	        return sqrt(x):=y.</span>

<span class="comment">    (4)	Special cases</span>

<span class="comment">	Square root of +inf, +-0, or NaN is itself;</span>
<span class="comment">	Square root of a negative number is NaN with invalid signal.</span>


<span class="comment">B.  sqrt(x) by Reciproot Iteration</span>

<span class="comment">   (1)	Initial approximation</span>

<span class="comment">	Let x0 and x1 be the leading and the trailing 32-bit words of</span>
<span class="comment">	a floating point number x (in IEEE double format) respectively</span>
<span class="comment">	(see section A). By performing shifs and subtracts on x0 and y0,</span>
<span class="comment">	we obtain a 7.8-bit approximation of 1/sqrt(x) as follows.</span>

<span class="comment">	    k := 0x5fe80000 - (x0&gt;&gt;1);</span>
<span class="comment">	    y0:= k - T2[63&amp;(k&gt;&gt;14)].	... y ~ 1/sqrt(x) to 7.8 bits</span>

<span class="comment">	Here k is a 32-bit integer and T2[] is an integer array</span>
<span class="comment">	containing correction terms. Now magically the floating</span>
<span class="comment">	value of y (y's leading 32-bit word is y0, the value of</span>
<span class="comment">	its trailing word y1 is set to zero) approximates 1/sqrt(x)</span>
<span class="comment">	to almost 7.8-bit.</span>

<span class="comment">	Value of T2:</span>
<span class="comment">	static int T2[64]= {</span>
<span class="comment">	0x1500,	0x2ef8,	0x4d67,	0x6b02,	0x87be,	0xa395,	0xbe7a,	0xd866,</span>
<span class="comment">	0xf14a,	0x1091b,0x11fcd,0x13552,0x14999,0x15c98,0x16e34,0x17e5f,</span>
<span class="comment">	0x18d03,0x19a01,0x1a545,0x1ae8a,0x1b5c4,0x1bb01,0x1bfde,0x1c28d,</span>
<span class="comment">	0x1c2de,0x1c0db,0x1ba73,0x1b11c,0x1a4b5,0x1953d,0x18266,0x16be0,</span>
<span class="comment">	0x1683e,0x179d8,0x18a4d,0x19992,0x1a789,0x1b445,0x1bf61,0x1c989,</span>
<span class="comment">	0x1d16d,0x1d77b,0x1dddf,0x1e2ad,0x1e5bf,0x1e6e8,0x1e654,0x1e3cd,</span>
<span class="comment">	0x1df2a,0x1d635,0x1cb16,0x1be2c,0x1ae4e,0x19bde,0x1868e,0x16e2e,</span>
<span class="comment">	0x1527f,0x1334a,0x11051,0xe951,	0xbe01,	0x8e0d,	0x5924,	0x1edd,};</span>

<span class="comment">    (2)	Iterative refinement</span>

<span class="comment">	Apply Reciproot iteration three times to y and multiply the</span>
<span class="comment">	result by x to get an approximation z that matches sqrt(x)</span>
<span class="comment">	to about 1 ulp. To be exact, we will have</span>
<span class="comment">		-1ulp &lt; sqrt(x)-z&lt;1.0625ulp.</span>

<span class="comment">	... set rounding mode to Round-to-nearest</span>
<span class="comment">	   y := y*(1.5-0.5*x*y*y)	... almost 15 sig. bits to 1/sqrt(x)</span>
<span class="comment">	   y := y*((1.5-2^-30)+0.5*x*y*y)... about 29 sig. bits to 1/sqrt(x)</span>
<span class="comment">	... special arrangement for better accuracy</span>
<span class="comment">	   z := x*y			... 29 bits to sqrt(x), with z*y&lt;1</span>
<span class="comment">	   z := z + 0.5*z*(1-z*y)	... about 1 ulp to sqrt(x)</span>

<span class="comment">	Remark 2. The constant 1.5-2^-30 is chosen to bias the error so that</span>
<span class="comment">	(a) the term z*y in the final iteration is always less than 1;</span>
<span class="comment">	(b) the error in the final result is biased upward so that</span>
<span class="comment">		-1 ulp &lt; sqrt(x) - z &lt; 1.0625 ulp</span>
<span class="comment">	    instead of |sqrt(x)-z|&lt;1.03125ulp.</span>

<span class="comment">    (3)	Final adjustment</span>

<span class="comment">	By twiddling y's last bit it is possible to force y to be</span>
<span class="comment">	correctly rounded according to the prevailing rounding mode</span>
<span class="comment">	as follows. Let r and i be copies of the rounding mode and</span>
<span class="comment">	inexact flag before entering the square root program. Also we</span>
<span class="comment">	use the expression y+-ulp for the next representable floating</span>
<span class="comment">	numbers (up and down) of y. Note that y+-ulp = either fixed</span>
<span class="comment">	point y+-1, or multiply y by nextafter(1,+-inf) in chopped</span>
<span class="comment">	mode.</span>

<span class="comment">	R := RZ;		... set rounding mode to round-toward-zero</span>
<span class="comment">	switch(r) {</span>
<span class="comment">	    case RN:		... round-to-nearest</span>
<span class="comment">	       if(x&lt;= z*(z-ulp)...chopped) z = z - ulp; else</span>
<span class="comment">	       if(x&lt;= z*(z+ulp)...chopped) z = z; else z = z+ulp;</span>
<span class="comment">	       break;</span>
<span class="comment">	    case RZ:case RM:	... round-to-zero or round-to--inf</span>
<span class="comment">	       R:=RP;		... reset rounding mod to round-to-+inf</span>
<span class="comment">	       if(x&lt;z*z ... rounded up) z = z - ulp; else</span>
<span class="comment">	       if(x&gt;=(z+ulp)*(z+ulp) ...rounded up) z = z+ulp;</span>
<span class="comment">	       break;</span>
<span class="comment">	    case RP:		... round-to-+inf</span>
<span class="comment">	       if(x&gt;(z+ulp)*(z+ulp)...chopped) z = z+2*ulp; else</span>
<span class="comment">	       if(x&gt;z*z ...chopped) z = z+ulp;</span>
<span class="comment">	       break;</span>
<span class="comment">	}</span>

<span class="comment">	Remark 3. The above comparisons can be done in fixed point. For</span>
<span class="comment">	example, to compare x and w=z*z chopped, it suffices to compare</span>
<span class="comment">	x1 and w1 (the trailing parts of x and w), regarding them as</span>
<span class="comment">	two's complement integers.</span>

<span class="comment">	...Is z an exact square root?</span>
<span class="comment">	To determine whether z is an exact square root of x, let z1 be the</span>
<span class="comment">	trailing part of z, and also let x0 and x1 be the leading and</span>
<span class="comment">	trailing parts of x.</span>

<span class="comment">	If ((z1&amp;0x03ffffff)!=0)	... not exact if trailing 26 bits of z!=0</span>
<span class="comment">	    I := 1;		... Raise Inexact flag: z is not exact</span>
<span class="comment">	else {</span>
<span class="comment">	    j := 1 - [(x0&gt;&gt;20)&amp;1]	... j = logb(x) mod 2</span>
<span class="comment">	    k := z1 &gt;&gt; 26;		... get z's 25-th and 26-th</span>
<span class="comment">					    fraction bits</span>
<span class="comment">	    I := i or (k&amp;j) or ((k&amp;(j+j+1))!=(x1&amp;3));</span>
<span class="comment">	}</span>
<span class="comment">	R:= r		... restore rounded mode</span>
<span class="comment">	return sqrt(x):=z.</span>

<span class="comment">	If multiplication is cheaper then the foregoing red tape, the</span>
<span class="comment">	Inexact flag can be evaluated by</span>

<span class="comment">	    I := i;</span>
<span class="comment">	    I := (z*z!=x) or I.</span>

<span class="comment">	Note that z*z can overwrite I; this value must be sensed if it is</span>
<span class="comment">	True.</span>

<span class="comment">	Remark 4. If z*z = x exactly, then bit 25 to bit 0 of z1 must be</span>
<span class="comment">	zero.</span>

<span class="comment">		    --------------------</span>
<span class="comment">		z1: |        f2        |</span>
<span class="comment">		    --------------------</span>
<span class="comment">		bit 31		   bit 0</span>

<span class="comment">	Further more, bit 27 and 26 of z1, bit 0 and 1 of x1, and the odd</span>
<span class="comment">	or even of logb(x) have the following relations:</span>

<span class="comment">	-------------------------------------------------</span>
<span class="comment">	bit 27,26 of z1		bit 1,0 of x1	logb(x)</span>
<span class="comment">	-------------------------------------------------</span>
<span class="comment">	00			00		odd and even</span>
<span class="comment">	01			01		even</span>
<span class="comment">	10			10		odd</span>
<span class="comment">	10			00		even</span>
<span class="comment">	11			01		even</span>
<span class="comment">	-------------------------------------------------</span>

<span class="comment">    (4)	Special cases (see (4) of Section A).</span>

<span class="comment"> */</span>

</tt></pre></div><div style="text-align: right; padding: 8pt; font-size: 12px"><a href="/xmlfeed/weblog-rss20.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABQAAAADwCexKkxAAAAWUlEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMCt0ZdTU/F/7/+1HEkydFpoKVPn+93sUlUujQvP/7UcRTAuNDJ2a//s/imDqtKVZofm/1qGYSZk7sfodGwAAiobBJtffoNAAAAAASUVORK5CYII=" alt="RSS 2.0 Weblog Feed" width="80" height="15"/></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAAaklEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMDV16rTQ/H/7V//69+//v/3/9oMEI6cuAwr+fv/+/b5d///v//0eJBgWOhMo+Gs9UPAdXDBy6lSYyn9wQZCZS0GCYDPXQcykzJ1Y/Y4NAABKvL80wyoMPgAAAABJRU5ErkJggg==" alt="Atom 1.0 Weblog Feed" width="80" height="15"/></a> <a href="http://validator.w3.org/check?uri=referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABKklEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6qIGzIRiKZs9GFoEaMRuZhhrYqqJXy8uZYauRxC/VHew7e3YTPAxnI5swG6JxNrKBNjB1EFmIgV0+HA6C8pqqzhXG7BbJJROQIwViMYQ7G2oDQQNn57JyG7kxiCfObrBmS5+BHMuYLkTzMnYDm5WY4lOZZRPKZocxes+aPbuwCFsYohiICLvZsKBAMrDTQ7K/StveU8icTzrOL8JdLpOyWJ49u8Bx9ozw8DY7UYW03hhdxZAOSg2c3jN79rSJs1vSKmfOnpFXNJmynELlvExlAADnaZpLFGEC2wAAAABJRU5ErkJggg==" alt="Valid XHTML 1.1" width="80" height="15"/></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABEUlEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6mIEQCsIjwhKoga0qerW8nBm2Gkn8Ut3BvrNnN8HCcDYM2cBIogzs8uFwEJTXVHWuMGa3SC6ZgIgUqCEwdxJr4OxcVm4jNwbxxNkN1mzpM2ajGIjsPGK9PLtZiSk+lVk2oWx2GKP3rNmzC4tQwpDoIIQb2Okh2V+lbe8pZM4nHecX4S6XSVksz55d4Dh7Rnh4m52oQlpvjK5iSAelBk7vmT172sTZLWmVM2fPyCuaTFlOoXJepjIAANlljDGY/l5pAAAAAElFTkSuQmCC" alt="Valid CSS (2.1)" width="80" height="15"/></a><br/>Copyright 2005-2014 <a href="/about/">Timo Bingmann</a> - <a href="/about/impressum.html">Impressum</a></div><script type="text/javascript">var _paq = _paq || []; _paq.push(["trackPageView"]); _paq.push(["enableLinkTracking"]);(function() {var u=(("https:" == document.location.protocol) ? "https" : "http") + "://panthema.net/wik-331/"; _paq.push(["setTrackerUrl", u+"js/"]); _paq.push(["setSiteId", "2"]);var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";g.defer=true; g.async=true; g.src=u+"js/"; s.parentNode.insertBefore(g,s);})();</script><noscript><p><img src="http://panthema.net/wik-331/js/?idsite=2&amp;rec=1" style="border:0" alt="" /></p></noscript></body></html>