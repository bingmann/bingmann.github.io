<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><title>/2006/SDIOS06/sdios06/include/SDL/SDL_video.h - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="stylesheet" type="text/css" href="/css/fonts.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="http://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="http://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/js/base.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body style="background-image: url(/img/bgfractal4.jpg)"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/"><i class="icon-book"></i> Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2014/">2014</a></li><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li class="nt"><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li><li class="ns"><a href="/search.html">Search</a></li></ul></li><li class="top"><a class="ni" href="/tags/"><i class="icon-tags"></i> Tags</a><div style="width: 14em; margin-left: -9em; margin-top: 4px"><a style="font-size: 10pt" href="/tags/algebra.html">algebra</a> <a style="font-size: 16pt" href="/tags/c++.html">c++</a> <a style="font-size: 12pt" href="/tags/code-example.html">code-example</a> <a style="font-size: 14pt" href="/tags/code-snippet.html">code-snippet</a> <a style="font-size: 11pt" href="/tags/coding_tricks.html">coding tricks</a> <a style="font-size: 10pt" href="/tags/compsci.html">compsci</a> <a style="font-size: 10pt" href="/tags/compsci_study_thesis.html">compsci study thesis</a> <a style="font-size: 9pt" href="/tags/crypto-speedtest.html">crypto-speedtest</a> <a style="font-size: 10pt" href="/tags/cryptography.html">cryptography</a> <a style="font-size: 9pt" href="/tags/cryptote.html">cryptote</a> <a style="font-size: 12pt" href="/tags/flex-bison-cpp-example.html">flex-bison-cpp-example</a> <a style="font-size: 13pt" href="/tags/frontpage.html">frontpage</a> <a style="font-size: 13pt" href="/tags/fun.html">fun</a> <a style="font-size: 10pt" href="/tags/graphviz.html">graphviz</a> <a style="font-size: 9pt" href="http://www.hmtg.de">hartmetall</a> <a style="font-size: 9pt" href="/tags/helppc.html">helppc</a> <a style="font-size: 9pt" href="/tags/hifi_selbstbau.html">hifi selbstbau</a> <a style="font-size: 10pt" href="/tags/latex.html">latex</a> <a style="font-size: 10pt" href="/tags/librivox.html">librivox</a> <a style="font-size: 10pt" href="/tags/linux.html">linux</a> <a style="font-size: 10pt" href="/tags/maths.html">maths</a> <a style="font-size: 9pt" href="/tags/music.html">music</a> <a style="font-size: 10pt" href="/tags/netfundamentals.html">netfundamentals</a> <a style="font-size: 11pt" href="/tags/ns-3.html">ns-3</a> <a style="font-size: 10pt" href="/tags/parallel-string-sorting.html">parallel-string-sorting</a> <a style="font-size: 9pt" href="/tags/qtsqlview.html">qtsqlview</a> <a style="font-size: 10pt" href="/tags/research.html">research</a> <a style="font-size: 11pt" href="/tags/sdios06.html">sdios06</a> <a style="font-size: 9pt" href="/tags/sdlfractal.html">sdlfractal</a> <a style="font-size: 12pt" href="/tags/sorting.html">sorting</a> <a style="font-size: 10pt" href="/tags/stringology.html">stringology</a> <a style="font-size: 16pt" href="/tags/stx-btree.html">stx-btree</a> <a style="font-size: 9pt" href="/tags/stx-exparser.html">stx-exparser</a> <a style="font-size: 11pt" href="/tags/stxxl.html">stxxl</a> <a style="font-size: 16pt" href="/tags/talk.html">talk</a> <a style="font-size: 10pt" href="/tags/tutorium.html">tutorium</a> <a style="font-size: 16pt" href="/tags/university.html">university</a> <a style="font-size: 13pt" href="/tags/utilities.html">utilities</a> <a style="font-size: 10pt" href="/tags/vncrec.html">vncrec</a> <a style="font-size: 9pt" href="/tags/webdesign.html">webdesign</a> </div></li><li class="top"> <a class="ni" href="#"><i class="icon-cubes"></i> Projects</a> <ul style="margin-left: -8em; margin-top: 4px;" class="nx"> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2013/parallel-string-sorting/">parallel-string-sorting</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2014/sqlplot-tools/">SqlPlotTools</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li><a href="/2013/1212-stxxl-1.4.0/">STXXL 1.4</a></li> <li class="nt"><a href="/2014/vncrec-rgb/">VNCrec RGB 0.4</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="#"><i class="icon-graduation-cap"></i> Research</a> <ul style="margin-left: -16em; margin-top: 4px" class="nx"> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP - External Memory Suffix Sorting</a></li> <li><a href="/2013/parallel-string-sorting/">Parallel String Sorting</a></li> <li><a href="/tags/stxxl.html">STXXL - External Memory Algorithms</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="/about/"><i class="icon-info-circled"></i> About</a> <ul style="margin-left: -6em; margin-top: 4px" class="nx"> <li><a href="/about/">Timo Bingmann</a></li> <li><a href="/about/impressum.html">Impressum</a></li> </ul></li><li class="top"> <a class="ni" href="/subscribe.html"><i class="icon-rss-squared"></i> Subscribe</a></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2006/">2006</a> / <a href="/2006/SDIOS06/">SDIOS06</a> / <a href="/2006/SDIOS06/sdios06/">sdios06</a> / <a href="/2006/SDIOS06/sdios06/include/">include</a> / <a href="/2006/SDIOS06/sdios06/include/SDL/">SDL</a> / <a href="/2006/SDIOS06/sdios06/include/SDL/SDL_video.h.html">SDL_video.h</a> (<a href="/2006/SDIOS06/sdios06/include/SDL/SDL_video.h">Download File</a>)</div></div><div class="ptfullwidth"><pre class="codesnippet" style="font-family: monospace"><tt><span class="comment">/*</span>
<span class="comment">    SDL - Simple DirectMedia Layer</span>
<span class="comment">    Copyright (C) 1997-2006 Sam Lantinga</span>

<span class="comment">    This library is free software; you can redistribute it and/or</span>
<span class="comment">    modify it under the terms of the GNU Lesser General Public</span>
<span class="comment">    License as published by the Free Software Foundation; either</span>
<span class="comment">    version 2.1 of the License, or (at your option) any later version.</span>

<span class="comment">    This library is distributed in the hope that it will be useful,</span>
<span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="comment">    Lesser General Public License for more details.</span>

<span class="comment">    You should have received a copy of the GNU Lesser General Public</span>
<span class="comment">    License along with this library; if not, write to the Free Software</span>
<span class="comment">    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>

<span class="comment">    Sam Lantinga</span>
<span class="comment">    </span><span class="url">slouken@libsdl.org</span>
<span class="comment">*/</span>

<span class="comment">/* Header file for access to the SDL raw framebuffer window */</span>

<span class="preproc">#ifndef</span><span class="normal"> _SDL_video_h</span>
<span class="preproc">#define</span><span class="normal"> _SDL_video_h</span>

<span class="preproc">#include</span><span class="normal"> </span><span class="string">"SDL_stdinc.h"</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">"SDL_error.h"</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">"SDL_rwops.h"</span>

<span class="preproc">#include</span><span class="normal"> </span><span class="string">"begin_code.h"</span>
<span class="comment">/* Set up for C function definitions, even when using C++ */</span>
<span class="preproc">#ifdef</span><span class="normal"> __cplusplus</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="string">"C"</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="preproc">#endif</span>

<span class="comment">/* Transparency definitions: These define alpha as the opacity of a surface */</span>
<span class="preproc">#define</span><span class="normal"> SDL_ALPHA_OPAQUE </span><span class="number">255</span>
<span class="preproc">#define</span><span class="normal"> SDL_ALPHA_TRANSPARENT </span><span class="number">0</span>

<span class="comment">/* Useful data types */</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SDL_Rect</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">Sint16</span><span class="normal"> x</span><span class="symbol">,</span><span class="normal"> y</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint16</span><span class="normal"> w</span><span class="symbol">,</span><span class="normal"> h</span><span class="symbol">;</span>
<span class="cbracket">}</span><span class="normal"> SDL_Rect</span><span class="symbol">;</span>

<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SDL_Color</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal"> r</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal"> g</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal"> b</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal"> unused</span><span class="symbol">;</span>
<span class="cbracket">}</span><span class="normal"> SDL_Color</span><span class="symbol">;</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">SDL_Colour</span><span class="normal"> SDL_Color</span>

<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SDL_Palette</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="type">int</span><span class="normal">       ncolors</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">SDL_Color</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">colors</span><span class="symbol">;</span>
<span class="cbracket">}</span><span class="normal"> SDL_Palette</span><span class="symbol">;</span>

<span class="comment">/* Everything in the pixel format structure is read-only */</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SDL_PixelFormat</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">SDL_Palette</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">palette</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal">  BitsPerPixel</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal">  BytesPerPixel</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal">  Rloss</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal">  Gloss</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal">  Bloss</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal">  Aloss</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal">  Rshift</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal">  Gshift</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal">  Bshift</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal">  Ashift</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> Rmask</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> Gmask</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> Bmask</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> Amask</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/* RGB color key information */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> colorkey</span><span class="symbol">;</span>
<span class="normal">	</span><span class="comment">/* Alpha value information (per-surface alpha) */</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal">  alpha</span><span class="symbol">;</span>
<span class="cbracket">}</span><span class="normal"> SDL_PixelFormat</span><span class="symbol">;</span>

<span class="comment">/* This structure should be treated as read-only, except for 'pixels',</span>
<span class="comment">   which, if not NULL, contains the raw pixel data for the surface.</span>
<span class="comment">*/</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SDL_Surface</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> flags</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* Read-only */</span>
<span class="normal">	</span><span class="usertype">SDL_PixelFormat</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">format</span><span class="symbol">;</span><span class="normal">		</span><span class="comment">/* Read-only */</span>
<span class="normal">	</span><span class="type">int</span><span class="normal"> w</span><span class="symbol">,</span><span class="normal"> h</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* Read-only */</span>
<span class="normal">	</span><span class="usertype">Uint16</span><span class="normal"> pitch</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* Read-only */</span>
<span class="normal">	</span><span class="type">void</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">pixels</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* Read-write */</span>
<span class="normal">	</span><span class="type">int</span><span class="normal"> offset</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* Private */</span>

<span class="normal">	</span><span class="comment">/* Hardware-specific surface info */</span>
<span class="normal">	</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">private_hwdata</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">hwdata</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/* clipping information */</span>
<span class="normal">	</span><span class="usertype">SDL_Rect</span><span class="normal"> clip_rect</span><span class="symbol">;</span><span class="normal">			</span><span class="comment">/* Read-only */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> unused1</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* for binary compatibility */</span>

<span class="normal">	</span><span class="comment">/* Allow recursive locks */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> locked</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* Private */</span>

<span class="normal">	</span><span class="comment">/* info for fast blit mapping to other surfaces */</span>
<span class="normal">	</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SDL_BlitMap</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">map</span><span class="symbol">;</span><span class="normal">		</span><span class="comment">/* Private */</span>

<span class="normal">	</span><span class="comment">/* format version, bumped at every change to invalidate blit maps */</span>
<span class="normal">	</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> format_version</span><span class="symbol">;</span><span class="normal">		</span><span class="comment">/* Private */</span>

<span class="normal">	</span><span class="comment">/* Reference count -- used when freeing surface */</span>
<span class="normal">	</span><span class="type">int</span><span class="normal"> refcount</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* Read-mostly */</span>
<span class="cbracket">}</span><span class="normal"> SDL_Surface</span><span class="symbol">;</span>

<span class="comment">/* These are the currently supported flags for the SDL_surface */</span>
<span class="comment">/* Available for SDL_CreateRGBSurface() or SDL_SetVideoMode() */</span>
<span class="preproc">#define</span><span class="normal"> SDL_SWSURFACE	</span><span class="number">0x00000000</span><span class="normal">	</span><span class="comment">/* Surface is in system memory */</span>
<span class="preproc">#define</span><span class="normal"> SDL_HWSURFACE	</span><span class="number">0x00000001</span><span class="normal">	</span><span class="comment">/* Surface is in video memory */</span>
<span class="preproc">#define</span><span class="normal"> SDL_ASYNCBLIT	</span><span class="number">0x00000004</span><span class="normal">	</span><span class="comment">/* Use asynchronous blits if possible */</span>
<span class="comment">/* Available for SDL_SetVideoMode() */</span>
<span class="preproc">#define</span><span class="normal"> SDL_ANYFORMAT	</span><span class="number">0x10000000</span><span class="normal">	</span><span class="comment">/* Allow any video depth/pixel-format */</span>
<span class="preproc">#define</span><span class="normal"> SDL_HWPALETTE	</span><span class="number">0x20000000</span><span class="normal">	</span><span class="comment">/* Surface has exclusive palette */</span>
<span class="preproc">#define</span><span class="normal"> SDL_DOUBLEBUF	</span><span class="number">0x40000000</span><span class="normal">	</span><span class="comment">/* Set up double-buffered video mode */</span>
<span class="preproc">#define</span><span class="normal"> SDL_FULLSCREEN	</span><span class="number">0x80000000</span><span class="normal">	</span><span class="comment">/* Surface is a full screen display */</span>
<span class="preproc">#define</span><span class="normal"> SDL_OPENGL      </span><span class="number">0x00000002</span><span class="normal">      </span><span class="comment">/* Create an OpenGL rendering context */</span>
<span class="preproc">#define</span><span class="normal"> SDL_OPENGLBLIT	</span><span class="number">0x0000000A</span><span class="normal">	</span><span class="comment">/* Create an OpenGL rendering context and use it for blitting */</span>
<span class="preproc">#define</span><span class="normal"> SDL_RESIZABLE	</span><span class="number">0x00000010</span><span class="normal">	</span><span class="comment">/* This video mode may be resized */</span>
<span class="preproc">#define</span><span class="normal"> SDL_NOFRAME	</span><span class="number">0x00000020</span><span class="normal">	</span><span class="comment">/* No window caption or edge frame */</span>
<span class="comment">/* Used internally (read-only) */</span>
<span class="preproc">#define</span><span class="normal"> SDL_HWACCEL	</span><span class="number">0x00000100</span><span class="normal">	</span><span class="comment">/* Blit uses hardware acceleration */</span>
<span class="preproc">#define</span><span class="normal"> SDL_SRCCOLORKEY	</span><span class="number">0x00001000</span><span class="normal">	</span><span class="comment">/* Blit uses a source color key */</span>
<span class="preproc">#define</span><span class="normal"> SDL_RLEACCELOK	</span><span class="number">0x00002000</span><span class="normal">	</span><span class="comment">/* Private flag */</span>
<span class="preproc">#define</span><span class="normal"> SDL_RLEACCEL	</span><span class="number">0x00004000</span><span class="normal">	</span><span class="comment">/* Surface is RLE encoded */</span>
<span class="preproc">#define</span><span class="normal"> SDL_SRCALPHA	</span><span class="number">0x00010000</span><span class="normal">	</span><span class="comment">/* Blit uses source alpha blending */</span>
<span class="preproc">#define</span><span class="normal"> SDL_PREALLOC	</span><span class="number">0x01000000</span><span class="normal">	</span><span class="comment">/* Surface uses preallocated memory */</span>

<span class="comment">/* Evaluates to true if the surface needs to be locked before access */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">SDL_MUSTLOCK</span><span class="symbol">(</span><span class="normal">surface</span><span class="symbol">)</span><span class="normal">	</span><span class="symbol">\</span>
<span class="normal">  </span><span class="symbol">(</span><span class="normal">surface</span><span class="symbol">-&gt;</span><span class="normal">offset </span><span class="symbol">||</span><span class="normal">		</span><span class="symbol">\</span>
<span class="normal">  </span><span class="symbol">((</span><span class="normal">surface</span><span class="symbol">-&gt;</span><span class="normal">flags </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">SDL_HWSURFACE</span><span class="symbol">|</span><span class="normal">SDL_ASYNCBLIT</span><span class="symbol">|</span><span class="normal">SDL_RLEACCEL</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">))</span>

<span class="comment">/* typedef for private surface blitting functions */</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">SDL_blit</span><span class="symbol">)(</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">src</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">srcrect</span><span class="symbol">,</span>
<span class="normal">			</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dst</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dstrect</span><span class="symbol">);</span>


<span class="comment">/* Useful for determining the video hardware capabilities */</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SDL_VideoInfo</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> hw_available </span><span class="symbol">:</span><span class="number">1</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Flag: Can you create hardware surfaces? */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> wm_available </span><span class="symbol">:</span><span class="number">1</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Flag: Can you talk to a window manager? */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> UnusedBits1  </span><span class="symbol">:</span><span class="number">6</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> UnusedBits2  </span><span class="symbol">:</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> blit_hw      </span><span class="symbol">:</span><span class="number">1</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Flag: Accelerated blits HW --&gt; HW */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> blit_hw_CC   </span><span class="symbol">:</span><span class="number">1</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Flag: Accelerated blits with Colorkey */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> blit_hw_A    </span><span class="symbol">:</span><span class="number">1</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Flag: Accelerated blits with Alpha */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> blit_sw      </span><span class="symbol">:</span><span class="number">1</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Flag: Accelerated blits SW --&gt; HW */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> blit_sw_CC   </span><span class="symbol">:</span><span class="number">1</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Flag: Accelerated blits with Colorkey */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> blit_sw_A    </span><span class="symbol">:</span><span class="number">1</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Flag: Accelerated blits with Alpha */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> blit_fill    </span><span class="symbol">:</span><span class="number">1</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Flag: Accelerated color fill */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> UnusedBits3  </span><span class="symbol">:</span><span class="number">16</span><span class="symbol">;</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> video_mem</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* The total amount of video memory (in K) */</span>
<span class="normal">	</span><span class="usertype">SDL_PixelFormat</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">vfmt</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Value: The format of the video surface */</span>
<span class="normal">	</span><span class="type">int</span><span class="normal">    current_w</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Value: The current video mode width */</span>
<span class="normal">	</span><span class="type">int</span><span class="normal">    current_h</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Value: The current video mode height */</span>
<span class="cbracket">}</span><span class="normal"> SDL_VideoInfo</span><span class="symbol">;</span>


<span class="comment">/* The most common video overlay formats.</span>
<span class="comment">   For an explanation of these pixel formats, see:</span>
<span class="comment">	</span><span class="url">http://www.webartz.com/fourcc/indexyuv.htm</span>

<span class="comment">   For information on the relationship between color spaces, see:</span>
<span class="comment">   </span><span class="url">http://www.neuro.sfc.keio.ac.jp/~aly/polygon/info/color-space-faq.html</span>
<span class="comment"> */</span>
<span class="preproc">#define</span><span class="normal"> SDL_YV12_OVERLAY  </span><span class="number">0x32315659</span><span class="normal">	</span><span class="comment">/* Planar mode: Y + V + U  (3 planes) */</span>
<span class="preproc">#define</span><span class="normal"> SDL_IYUV_OVERLAY  </span><span class="number">0x56555949</span><span class="normal">	</span><span class="comment">/* Planar mode: Y + U + V  (3 planes) */</span>
<span class="preproc">#define</span><span class="normal"> SDL_YUY2_OVERLAY  </span><span class="number">0x32595559</span><span class="normal">	</span><span class="comment">/* Packed mode: Y0+U0+Y1+V0 (1 plane) */</span>
<span class="preproc">#define</span><span class="normal"> SDL_UYVY_OVERLAY  </span><span class="number">0x59565955</span><span class="normal">	</span><span class="comment">/* Packed mode: U0+Y0+V0+Y1 (1 plane) */</span>
<span class="preproc">#define</span><span class="normal"> SDL_YVYU_OVERLAY  </span><span class="number">0x55595659</span><span class="normal">	</span><span class="comment">/* Packed mode: Y0+V0+Y1+U0 (1 plane) */</span>

<span class="comment">/* The YUV hardware video overlay */</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SDL_Overlay</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> format</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* Read-only */</span>
<span class="normal">	</span><span class="type">int</span><span class="normal"> w</span><span class="symbol">,</span><span class="normal"> h</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* Read-only */</span>
<span class="normal">	</span><span class="type">int</span><span class="normal"> planes</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* Read-only */</span>
<span class="normal">	</span><span class="usertype">Uint16</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">pitches</span><span class="symbol">;</span><span class="normal">			</span><span class="comment">/* Read-only */</span>
<span class="normal">	</span><span class="usertype">Uint8</span><span class="normal"> </span><span class="symbol">**</span><span class="normal">pixels</span><span class="symbol">;</span><span class="normal">				</span><span class="comment">/* Read-write */</span>

<span class="normal">	</span><span class="comment">/* Hardware-specific surface info */</span>
<span class="normal">	</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">private_yuvhwfuncs</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">hwfuncs</span><span class="symbol">;</span>
<span class="normal">	</span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">private_yuvhwdata</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">hwdata</span><span class="symbol">;</span>

<span class="normal">	</span><span class="comment">/* Special flags */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> hw_overlay </span><span class="symbol">:</span><span class="number">1</span><span class="symbol">;</span><span class="normal">	</span><span class="comment">/* Flag: This overlay hardware accelerated? */</span>
<span class="normal">	</span><span class="usertype">Uint32</span><span class="normal"> UnusedBits </span><span class="symbol">:</span><span class="number">31</span><span class="symbol">;</span>
<span class="cbracket">}</span><span class="normal"> SDL_Overlay</span><span class="symbol">;</span>


<span class="comment">/* Public enumeration for setting the OpenGL window attributes. */</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">enum</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    SDL_GL_RED_SIZE</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_GREEN_SIZE</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_BLUE_SIZE</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_ALPHA_SIZE</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_BUFFER_SIZE</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_DOUBLEBUFFER</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_DEPTH_SIZE</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_STENCIL_SIZE</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_ACCUM_RED_SIZE</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_ACCUM_GREEN_SIZE</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_ACCUM_BLUE_SIZE</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_ACCUM_ALPHA_SIZE</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_STEREO</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_MULTISAMPLEBUFFERS</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_MULTISAMPLESAMPLES</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_ACCELERATED_VISUAL</span><span class="symbol">,</span>
<span class="normal">    SDL_GL_SWAP_CONTROL</span>
<span class="cbracket">}</span><span class="normal"> SDL_GLattr</span><span class="symbol">;</span>

<span class="comment">/* flags for SDL_SetPalette() */</span>
<span class="preproc">#define</span><span class="normal"> SDL_LOGPAL </span><span class="number">0x01</span>
<span class="preproc">#define</span><span class="normal"> SDL_PHYSPAL </span><span class="number">0x02</span>

<span class="comment">/* Function prototypes */</span>

<span class="comment">/* These functions are used internally, and should not be used unless you</span>
<span class="comment"> * have a specific need to specify the video driver you want to use.</span>
<span class="comment"> * You should normally use SDL_Init() or SDL_InitSubSystem().</span>
<span class="comment"> *</span>
<span class="comment"> * SDL_VideoInit() initializes the video subsystem -- sets up a connection</span>
<span class="comment"> * to the window manager, etc, and determines the current video mode and</span>
<span class="comment"> * pixel format, but does not initialize a window or graphics mode.</span>
<span class="comment"> * Note that event handling is activated by this routine.</span>
<span class="comment"> *</span>
<span class="comment"> * If you use both sound and video in your application, you need to call</span>
<span class="comment"> * SDL_Init() before opening the sound device, otherwise under Win32 DirectX,</span>
<span class="comment"> * you won't be able to set full-screen display modes.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_VideoInit</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">driver_name</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> flags</span><span class="symbol">);</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_VideoQuit</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">);</span>

<span class="comment">/* This function fills the given character buffer with the name of the</span>
<span class="comment"> * video driver, and returns a pointer to it if the video driver has</span>
<span class="comment"> * been initialized.  It returns NULL if no driver has been initialized.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> </span><span class="type">char</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_VideoDriverName</span><span class="symbol">(</span><span class="type">char</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">namebuf</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> maxlen</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * This function returns a pointer to the current display surface.</span>
<span class="comment"> * If SDL is doing format conversion on the display surface, this</span>
<span class="comment"> * function returns the publicly visible surface, not the real video</span>
<span class="comment"> * surface.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_Surface </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GetVideoSurface</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * This function returns a read-only pointer to information about the</span>
<span class="comment"> * video hardware.  If this is called before SDL_SetVideoMode(), the 'vfmt'</span>
<span class="comment"> * member of the returned structure will contain the pixel format of the</span>
<span class="comment"> * "best" video mode.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="usertype">const</span><span class="normal"> SDL_VideoInfo </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GetVideoInfo</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">);</span>

<span class="comment">/* </span>
<span class="comment"> * Check to see if a particular video mode is supported.</span>
<span class="comment"> * It returns 0 if the requested mode is not supported under any bit depth,</span>
<span class="comment"> * or returns the bits-per-pixel of the closest available mode with the</span>
<span class="comment"> * given width and height.  If this bits-per-pixel is different from the</span>
<span class="comment"> * one used when setting the video mode, SDL_SetVideoMode() will succeed,</span>
<span class="comment"> * but will emulate the requested bits-per-pixel with a shadow surface.</span>
<span class="comment"> *</span>
<span class="comment"> * The arguments to SDL_VideoModeOK() are the same ones you would pass to</span>
<span class="comment"> * SDL_SetVideoMode()</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_VideoModeOK</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> width</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> height</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> bpp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> flags</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Return a pointer to an array of available screen dimensions for the</span>
<span class="comment"> * given format and video flags, sorted largest to smallest.  Returns </span>
<span class="comment"> * NULL if there are no dimensions available for a particular format, </span>
<span class="comment"> * or (SDL_Rect **)-1 if any dimension is okay for the given format.</span>
<span class="comment"> *</span>
<span class="comment"> * If 'format' is NULL, the mode list will be for the format given </span>
<span class="comment"> * by SDL_GetVideoInfo()-&gt;vfmt</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_Rect </span><span class="symbol">**</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_ListModes</span><span class="symbol">(</span><span class="usertype">SDL_PixelFormat</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">format</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> flags</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Set up a video mode with the specified width, height and bits-per-pixel.</span>
<span class="comment"> *</span>
<span class="comment"> * If 'bpp' is 0, it is treated as the current display bits per pixel.</span>
<span class="comment"> *</span>
<span class="comment"> * If SDL_ANYFORMAT is set in 'flags', the SDL library will try to set the</span>
<span class="comment"> * requested bits-per-pixel, but will return whatever video pixel format is</span>
<span class="comment"> * available.  The default is to emulate the requested pixel format if it</span>
<span class="comment"> * is not natively available.</span>
<span class="comment"> *</span>
<span class="comment"> * If SDL_HWSURFACE is set in 'flags', the video surface will be placed in</span>
<span class="comment"> * video memory, if possible, and you may have to call SDL_LockSurface()</span>
<span class="comment"> * in order to access the raw framebuffer.  Otherwise, the video surface</span>
<span class="comment"> * will be created in system memory.</span>
<span class="comment"> *</span>
<span class="comment"> * If SDL_ASYNCBLIT is set in 'flags', SDL will try to perform rectangle</span>
<span class="comment"> * updates asynchronously, but you must always lock before accessing pixels.</span>
<span class="comment"> * SDL will wait for updates to complete before returning from the lock.</span>
<span class="comment"> *</span>
<span class="comment"> * If SDL_HWPALETTE is set in 'flags', the SDL library will guarantee</span>
<span class="comment"> * that the colors set by SDL_SetColors() will be the colors you get.</span>
<span class="comment"> * Otherwise, in 8-bit mode, SDL_SetColors() may not be able to set all</span>
<span class="comment"> * of the colors exactly the way they are requested, and you should look</span>
<span class="comment"> * at the video surface structure to determine the actual palette.</span>
<span class="comment"> * If SDL cannot guarantee that the colors you request can be set, </span>
<span class="comment"> * i.e. if the colormap is shared, then the video surface may be created</span>
<span class="comment"> * under emulation in system memory, overriding the SDL_HWSURFACE flag.</span>
<span class="comment"> *</span>
<span class="comment"> * If SDL_FULLSCREEN is set in 'flags', the SDL library will try to set</span>
<span class="comment"> * a fullscreen video mode.  The default is to create a windowed mode</span>
<span class="comment"> * if the current graphics system has a window manager.</span>
<span class="comment"> * If the SDL library is able to set a fullscreen video mode, this flag </span>
<span class="comment"> * will be set in the surface that is returned.</span>
<span class="comment"> *</span>
<span class="comment"> * If SDL_DOUBLEBUF is set in 'flags', the SDL library will try to set up</span>
<span class="comment"> * two surfaces in video memory and swap between them when you call </span>
<span class="comment"> * SDL_Flip().  This is usually slower than the normal single-buffering</span>
<span class="comment"> * scheme, but prevents "tearing" artifacts caused by modifying video </span>
<span class="comment"> * memory while the monitor is refreshing.  It should only be used by </span>
<span class="comment"> * applications that redraw the entire screen on every update.</span>
<span class="comment"> *</span>
<span class="comment"> * If SDL_RESIZABLE is set in 'flags', the SDL library will allow the</span>
<span class="comment"> * window manager, if any, to resize the window at runtime.  When this</span>
<span class="comment"> * occurs, SDL will send a SDL_VIDEORESIZE event to you application,</span>
<span class="comment"> * and you must respond to the event by re-calling SDL_SetVideoMode()</span>
<span class="comment"> * with the requested size (or another size that suits the application).</span>
<span class="comment"> *</span>
<span class="comment"> * If SDL_NOFRAME is set in 'flags', the SDL library will create a window</span>
<span class="comment"> * without any title bar or frame decoration.  Fullscreen video modes have</span>
<span class="comment"> * this flag set automatically.</span>
<span class="comment"> *</span>
<span class="comment"> * This function returns the video framebuffer surface, or NULL if it fails.</span>
<span class="comment"> *</span>
<span class="comment"> * If you rely on functionality provided by certain video flags, check the</span>
<span class="comment"> * flags of the returned surface to make sure that functionality is available.</span>
<span class="comment"> * SDL will fall back to reduced functionality if the exact flags you wanted</span>
<span class="comment"> * are not available.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_Surface </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> SDL_SetVideoMode</span>
<span class="normal">			</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> width</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> height</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> bpp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> flags</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Makes sure the given list of rectangles is updated on the given screen.</span>
<span class="comment"> * If 'x', 'y', 'w' and 'h' are all 0, SDL_UpdateRect will update the entire</span>
<span class="comment"> * screen.</span>
<span class="comment"> * These functions should not be called while 'screen' is locked.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> SDL_UpdateRects</span>
<span class="normal">		</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">screen</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> numrects</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">rects</span><span class="symbol">);</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> SDL_UpdateRect</span>
<span class="normal">		</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">screen</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Sint32</span><span class="normal"> x</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Sint32</span><span class="normal"> y</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> w</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> h</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * On hardware that supports double-buffering, this function sets up a flip</span>
<span class="comment"> * and returns.  The hardware will wait for vertical retrace, and then swap</span>
<span class="comment"> * video buffers before the next video surface blit or lock will return.</span>
<span class="comment"> * On hardware that doesn not support double-buffering, this is equivalent</span>
<span class="comment"> * to calling SDL_UpdateRect(screen, 0, 0, 0, 0);</span>
<span class="comment"> * The SDL_DOUBLEBUF flag must have been passed to SDL_SetVideoMode() when</span>
<span class="comment"> * setting the video mode for this function to perform hardware flipping.</span>
<span class="comment"> * This function returns 0 if successful, or -1 if there was an error.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_Flip</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">screen</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Set the gamma correction for each of the color channels.</span>
<span class="comment"> * The gamma values range (approximately) between 0.1 and 10.0</span>
<span class="comment"> * </span>
<span class="comment"> * If this function isn't supported directly by the hardware, it will</span>
<span class="comment"> * be emulated using gamma ramps, if available.  If successful, this</span>
<span class="comment"> * function returns 0, otherwise it returns -1.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_SetGamma</span><span class="symbol">(</span><span class="type">float</span><span class="normal"> red</span><span class="symbol">,</span><span class="normal"> </span><span class="type">float</span><span class="normal"> green</span><span class="symbol">,</span><span class="normal"> </span><span class="type">float</span><span class="normal"> blue</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Set the gamma translation table for the red, green, and blue channels</span>
<span class="comment"> * of the video hardware.  Each table is an array of 256 16-bit quantities,</span>
<span class="comment"> * representing a mapping between the input and output for that channel.</span>
<span class="comment"> * The input is the index into the array, and the output is the 16-bit</span>
<span class="comment"> * gamma value at that index, scaled to the output color precision.</span>
<span class="comment"> * </span>
<span class="comment"> * You may pass NULL for any of the channels to leave it unchanged.</span>
<span class="comment"> * If the call succeeds, it will return 0.  If the display driver or</span>
<span class="comment"> * hardware does not support gamma translation, or otherwise fails,</span>
<span class="comment"> * this function will return -1.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_SetGammaRamp</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">Uint16</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">red</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">Uint16</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">green</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">Uint16</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">blue</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Retrieve the current values of the gamma translation tables.</span>
<span class="comment"> * </span>
<span class="comment"> * You must pass in valid pointers to arrays of 256 16-bit quantities.</span>
<span class="comment"> * Any of the pointers may be NULL to ignore that channel.</span>
<span class="comment"> * If the call succeeds, it will return 0.  If the display driver or</span>
<span class="comment"> * hardware does not support gamma translation, or otherwise fails,</span>
<span class="comment"> * this function will return -1.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GetGammaRamp</span><span class="symbol">(</span><span class="usertype">Uint16</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">red</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint16</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">green</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint16</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">blue</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Sets a portion of the colormap for the given 8-bit surface.  If 'surface'</span>
<span class="comment"> * is not a palettized surface, this function does nothing, returning 0.</span>
<span class="comment"> * If all of the colors were set as passed to SDL_SetColors(), it will</span>
<span class="comment"> * return 1.  If not all the color entries were set exactly as given,</span>
<span class="comment"> * it will return 0, and you should look at the surface palette to</span>
<span class="comment"> * determine the actual color palette.</span>
<span class="comment"> *</span>
<span class="comment"> * When 'surface' is the surface associated with the current display, the</span>
<span class="comment"> * display colormap will be updated with the requested colors.  If </span>
<span class="comment"> * SDL_HWPALETTE was set in SDL_SetVideoMode() flags, SDL_SetColors()</span>
<span class="comment"> * will always return 1, and the palette is guaranteed to be set the way</span>
<span class="comment"> * you desire, even if the window colormap has to be warped or run under</span>
<span class="comment"> * emulation.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_SetColors</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">,</span><span class="normal"> </span>
<span class="normal">			</span><span class="usertype">SDL_Color</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">colors</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> firstcolor</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> ncolors</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Sets a portion of the colormap for a given 8-bit surface.</span>
<span class="comment"> * 'flags' is one or both of:</span>
<span class="comment"> * SDL_LOGPAL  -- set logical palette, which controls how blits are mapped</span>
<span class="comment"> *                to/from the surface,</span>
<span class="comment"> * SDL_PHYSPAL -- set physical palette, which controls how pixels look on</span>
<span class="comment"> *                the screen</span>
<span class="comment"> * Only screens have physical palettes. Separate change of physical/logical</span>
<span class="comment"> * palettes is only possible if the screen has SDL_HWPALETTE set.</span>
<span class="comment"> *</span>
<span class="comment"> * The return value is 1 if all colours could be set as requested, and 0</span>
<span class="comment"> * otherwise.</span>
<span class="comment"> *</span>
<span class="comment"> * SDL_SetColors() is equivalent to calling this function with</span>
<span class="comment"> *     flags = (SDL_LOGPAL|SDL_PHYSPAL).</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_SetPalette</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> flags</span><span class="symbol">,</span>
<span class="normal">				   </span><span class="usertype">SDL_Color</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">colors</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> firstcolor</span><span class="symbol">,</span>
<span class="normal">				   </span><span class="type">int</span><span class="normal"> ncolors</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Maps an RGB triple to an opaque pixel value for a given pixel format</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC Uint32 </span><span class="usertype">SDLCALL</span><span class="normal"> SDL_MapRGB</span>
<span class="normal">			</span><span class="symbol">(</span><span class="usertype">SDL_PixelFormat</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">format</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> r</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> g</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> b</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Maps an RGBA quadruple to a pixel value for a given pixel format</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC Uint32 </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_MapRGBA</span><span class="symbol">(</span><span class="usertype">SDL_PixelFormat</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">format</span><span class="symbol">,</span>
<span class="normal">				   </span><span class="usertype">Uint8</span><span class="normal"> r</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> g</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> b</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> a</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Maps a pixel value into the RGB components for a given pixel format</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GetRGB</span><span class="symbol">(</span><span class="usertype">Uint32</span><span class="normal"> pixel</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_PixelFormat</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">fmt</span><span class="symbol">,</span>
<span class="normal">				</span><span class="usertype">Uint8</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">r</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">g</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">b</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Maps a pixel value into the RGBA components for a given pixel format</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GetRGBA</span><span class="symbol">(</span><span class="usertype">Uint32</span><span class="normal"> pixel</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_PixelFormat</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">fmt</span><span class="symbol">,</span>
<span class="normal">				 </span><span class="usertype">Uint8</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">r</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">g</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">b</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">a</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Allocate and free an RGB surface (must be called after SDL_SetVideoMode)</span>
<span class="comment"> * If the depth is 4 or 8 bits, an empty palette is allocated for the surface.</span>
<span class="comment"> * If the depth is greater than 8 bits, the pixel format is set using the</span>
<span class="comment"> * flags '[RGB]mask'.</span>
<span class="comment"> * If the function runs out of memory, it will return NULL.</span>
<span class="comment"> *</span>
<span class="comment"> * The 'flags' tell what kind of surface to create.</span>
<span class="comment"> * SDL_SWSURFACE means that the surface should be created in system memory.</span>
<span class="comment"> * SDL_HWSURFACE means that the surface should be created in video memory,</span>
<span class="comment"> * with the same format as the display surface.  This is useful for surfaces</span>
<span class="comment"> * that will not change much, to take advantage of hardware acceleration</span>
<span class="comment"> * when being blitted to the display surface.</span>
<span class="comment"> * SDL_ASYNCBLIT means that SDL will try to perform asynchronous blits with</span>
<span class="comment"> * this surface, but you must always lock it before accessing the pixels.</span>
<span class="comment"> * SDL will wait for current blits to finish before returning from the lock.</span>
<span class="comment"> * SDL_SRCCOLORKEY indicates that the surface will be used for colorkey blits.</span>
<span class="comment"> * If the hardware supports acceleration of colorkey blits between</span>
<span class="comment"> * two surfaces in video memory, SDL will try to place the surface in</span>
<span class="comment"> * video memory. If this isn't possible or if there is no hardware</span>
<span class="comment"> * acceleration available, the surface will be placed in system memory.</span>
<span class="comment"> * SDL_SRCALPHA means that the surface will be used for alpha blits and </span>
<span class="comment"> * if the hardware supports hardware acceleration of alpha blits between</span>
<span class="comment"> * two surfaces in video memory, to place the surface in video memory</span>
<span class="comment"> * if possible, otherwise it will be placed in system memory.</span>
<span class="comment"> * If the surface is created in video memory, blits will be _much_ faster,</span>
<span class="comment"> * but the surface format must be identical to the video surface format,</span>
<span class="comment"> * and the only way to access the pixels member of the surface is to use</span>
<span class="comment"> * the SDL_LockSurface() and SDL_UnlockSurface() calls.</span>
<span class="comment"> * If the requested surface actually resides in video memory, SDL_HWSURFACE</span>
<span class="comment"> * will be set in the flags member of the returned surface.  If for some</span>
<span class="comment"> * reason the surface could not be placed in video memory, it will not have</span>
<span class="comment"> * the SDL_HWSURFACE flag set, and will be created in system memory instead.</span>
<span class="comment"> */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">SDL_AllocSurface</span><span class="normal">    SDL_CreateRGBSurface</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_Surface </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> SDL_CreateRGBSurface</span>
<span class="normal">			</span><span class="symbol">(</span><span class="usertype">Uint32</span><span class="normal"> flags</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> width</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> height</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> depth</span><span class="symbol">,</span><span class="normal"> </span>
<span class="normal">			</span><span class="usertype">Uint32</span><span class="normal"> Rmask</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> Gmask</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> Bmask</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> Amask</span><span class="symbol">);</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_Surface </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_CreateRGBSurfaceFrom</span><span class="symbol">(</span><span class="type">void</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">pixels</span><span class="symbol">,</span>
<span class="normal">			</span><span class="type">int</span><span class="normal"> width</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> height</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> depth</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> pitch</span><span class="symbol">,</span>
<span class="normal">			</span><span class="usertype">Uint32</span><span class="normal"> Rmask</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> Gmask</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> Bmask</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> Amask</span><span class="symbol">);</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_FreeSurface</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * SDL_LockSurface() sets up a surface for directly accessing the pixels.</span>
<span class="comment"> * Between calls to SDL_LockSurface()/SDL_UnlockSurface(), you can write</span>
<span class="comment"> * to and read from 'surface-&gt;pixels', using the pixel format stored in </span>
<span class="comment"> * 'surface-&gt;format'.  Once you are done accessing the surface, you should </span>
<span class="comment"> * use SDL_UnlockSurface() to release it.</span>
<span class="comment"> *</span>
<span class="comment"> * Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates</span>
<span class="comment"> * to 0, then you can read and write to the surface at any time, and the</span>
<span class="comment"> * pixel format of the surface will not change.  In particular, if the</span>
<span class="comment"> * SDL_HWSURFACE flag is not given when calling SDL_SetVideoMode(), you</span>
<span class="comment"> * will not need to lock the display surface before accessing it.</span>
<span class="comment"> * </span>
<span class="comment"> * No operating system or library calls should be made between lock/unlock</span>
<span class="comment"> * pairs, as critical system locks may be held during this time.</span>
<span class="comment"> *</span>
<span class="comment"> * SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_LockSurface</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">);</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_UnlockSurface</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Load a surface from a seekable SDL data source (memory or file.)</span>
<span class="comment"> * If 'freesrc' is non-zero, the source will be closed after being read.</span>
<span class="comment"> * Returns the new surface, or NULL if there was an error.</span>
<span class="comment"> * The new surface should be freed with SDL_FreeSurface().</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_Surface </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_LoadBMP_RW</span><span class="symbol">(</span><span class="usertype">SDL_RWops</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">src</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> freesrc</span><span class="symbol">);</span>

<span class="comment">/* Convenience macro -- load a surface from a file */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">SDL_LoadBMP</span><span class="symbol">(</span><span class="normal">file</span><span class="symbol">)</span><span class="normal">	</span><span class="function">SDL_LoadBMP_RW</span><span class="symbol">(</span><span class="function">SDL_RWFromFile</span><span class="symbol">(</span><span class="normal">file</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"rb"</span><span class="symbol">),</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span>

<span class="comment">/*</span>
<span class="comment"> * Save a surface to a seekable SDL data source (memory or file.)</span>
<span class="comment"> * If 'freedst' is non-zero, the source will be closed after being written.</span>
<span class="comment"> * Returns 0 if successful or -1 if there was an error.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> SDL_SaveBMP_RW</span>
<span class="normal">		</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_RWops</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dst</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> freedst</span><span class="symbol">);</span>

<span class="comment">/* Convenience macro -- save a surface to a file */</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">SDL_SaveBMP</span><span class="symbol">(</span><span class="normal">surface</span><span class="symbol">,</span><span class="normal"> file</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">		</span><span class="function">SDL_SaveBMP_RW</span><span class="symbol">(</span><span class="normal">surface</span><span class="symbol">,</span><span class="normal"> </span><span class="function">SDL_RWFromFile</span><span class="symbol">(</span><span class="normal">file</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"wb"</span><span class="symbol">),</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span>

<span class="comment">/*</span>
<span class="comment"> * Sets the color key (transparent pixel) in a blittable surface.</span>
<span class="comment"> * If 'flag' is SDL_SRCCOLORKEY (optionally OR'd with SDL_RLEACCEL), </span>
<span class="comment"> * 'key' will be the transparent pixel in the source image of a blit.</span>
<span class="comment"> * SDL_RLEACCEL requests RLE acceleration for the surface if present,</span>
<span class="comment"> * and removes RLE acceleration if absent.</span>
<span class="comment"> * If 'flag' is 0, this function clears any current color key.</span>
<span class="comment"> * This function returns 0, or -1 if there was an error.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> SDL_SetColorKey</span>
<span class="normal">			</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> flag</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> key</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * This function sets the alpha value for the entire surface, as opposed to</span>
<span class="comment"> * using the alpha component of each pixel. This value measures the range</span>
<span class="comment"> * of transparency of the surface, 0 being completely transparent to 255</span>
<span class="comment"> * being completely opaque. An 'alpha' value of 255 causes blits to be</span>
<span class="comment"> * opaque, the source pixels copied to the destination (the default). Note</span>
<span class="comment"> * that per-surface alpha can be combined with colorkey transparency.</span>
<span class="comment"> *</span>
<span class="comment"> * If 'flag' is 0, alpha blending is disabled for the surface.</span>
<span class="comment"> * If 'flag' is SDL_SRCALPHA, alpha blending is enabled for the surface.</span>
<span class="comment"> * OR:ing the flag with SDL_RLEACCEL requests RLE acceleration for the</span>
<span class="comment"> * surface; if SDL_RLEACCEL is not specified, the RLE accel will be removed.</span>
<span class="comment"> *</span>
<span class="comment"> * The 'alpha' parameter is ignored for surfaces that have an alpha channel.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_SetAlpha</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> flag</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> alpha</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Sets the clipping rectangle for the destination surface in a blit.</span>
<span class="comment"> *</span>
<span class="comment"> * If the clip rectangle is NULL, clipping will be disabled.</span>
<span class="comment"> * If the clip rectangle doesn't intersect the surface, the function will</span>
<span class="comment"> * return SDL_FALSE and blits will be completely clipped.  Otherwise the</span>
<span class="comment"> * function returns SDL_TRUE and blits to the surface will be clipped to</span>
<span class="comment"> * the intersection of the surface area and the clipping rectangle.</span>
<span class="comment"> *</span>
<span class="comment"> * Note that blits are automatically clipped to the edges of the source</span>
<span class="comment"> * and destination surfaces.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_bool </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_SetClipRect</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">rect</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Gets the clipping rectangle for the destination surface in a blit.</span>
<span class="comment"> * 'rect' must be a pointer to a valid rectangle which will be filled</span>
<span class="comment"> * with the correct values.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GetClipRect</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">rect</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Creates a new surface of the specified format, and then copies and maps </span>
<span class="comment"> * the given surface to it so the blit of the converted surface will be as </span>
<span class="comment"> * fast as possible.  If this function fails, it returns NULL.</span>
<span class="comment"> *</span>
<span class="comment"> * The 'flags' parameter is passed to SDL_CreateRGBSurface() and has those </span>
<span class="comment"> * semantics.  You can also pass SDL_RLEACCEL in the flags parameter and</span>
<span class="comment"> * SDL will try to RLE accelerate colorkey and alpha blits in the resulting</span>
<span class="comment"> * surface.</span>
<span class="comment"> *</span>
<span class="comment"> * This function is used internally by SDL_DisplayFormat().</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_Surface </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> SDL_ConvertSurface</span>
<span class="normal">			</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">src</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_PixelFormat</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">fmt</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> flags</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * This performs a fast blit from the source surface to the destination</span>
<span class="comment"> * surface.  It assumes that the source and destination rectangles are</span>
<span class="comment"> * the same size.  If either 'srcrect' or 'dstrect' are NULL, the entire</span>
<span class="comment"> * surface (src or dst) is copied.  The final blit rectangles are saved</span>
<span class="comment"> * in 'srcrect' and 'dstrect' after all clipping is performed.</span>
<span class="comment"> * If the blit is successful, it returns 0, otherwise it returns -1.</span>
<span class="comment"> *</span>
<span class="comment"> * The blit function should not be called on a locked surface.</span>
<span class="comment"> *</span>
<span class="comment"> * The blit semantics for surfaces with and without alpha and colorkey</span>
<span class="comment"> * are defined as follows:</span>
<span class="comment"> *</span>
<span class="comment"> * RGBA-&gt;RGB:</span>
<span class="comment"> *     SDL_SRCALPHA set:</span>
<span class="comment"> * 	alpha-blend (using alpha-channel).</span>
<span class="comment"> * 	SDL_SRCCOLORKEY ignored.</span>
<span class="comment"> *     SDL_SRCALPHA not set:</span>
<span class="comment"> * 	copy RGB.</span>
<span class="comment"> * 	if SDL_SRCCOLORKEY set, only copy the pixels matching the</span>
<span class="comment"> * 	RGB values of the source colour key, ignoring alpha in the</span>
<span class="comment"> * 	comparison.</span>
<span class="comment"> * </span>
<span class="comment"> * RGB-&gt;RGBA:</span>
<span class="comment"> *     SDL_SRCALPHA set:</span>
<span class="comment"> * 	alpha-blend (using the source per-surface alpha value);</span>
<span class="comment"> * 	set destination alpha to opaque.</span>
<span class="comment"> *     SDL_SRCALPHA not set:</span>
<span class="comment"> * 	copy RGB, set destination alpha to source per-surface alpha value.</span>
<span class="comment"> *     both:</span>
<span class="comment"> * 	if SDL_SRCCOLORKEY set, only copy the pixels matching the</span>
<span class="comment"> * 	source colour key.</span>
<span class="comment"> * </span>
<span class="comment"> * RGBA-&gt;RGBA:</span>
<span class="comment"> *     SDL_SRCALPHA set:</span>
<span class="comment"> * 	alpha-blend (using the source alpha channel) the RGB values;</span>
<span class="comment"> * 	leave destination alpha untouched. [Note: is this correct?]</span>
<span class="comment"> * 	SDL_SRCCOLORKEY ignored.</span>
<span class="comment"> *     SDL_SRCALPHA not set:</span>
<span class="comment"> * 	copy all of RGBA to the destination.</span>
<span class="comment"> * 	if SDL_SRCCOLORKEY set, only copy the pixels matching the</span>
<span class="comment"> * 	RGB values of the source colour key, ignoring alpha in the</span>
<span class="comment"> * 	comparison.</span>
<span class="comment"> * </span>
<span class="comment"> * RGB-&gt;RGB: </span>
<span class="comment"> *     SDL_SRCALPHA set:</span>
<span class="comment"> * 	alpha-blend (using the source per-surface alpha value).</span>
<span class="comment"> *     SDL_SRCALPHA not set:</span>
<span class="comment"> * 	copy RGB.</span>
<span class="comment"> *     both:</span>
<span class="comment"> * 	if SDL_SRCCOLORKEY set, only copy the pixels matching the</span>
<span class="comment"> * 	source colour key.</span>
<span class="comment"> *</span>
<span class="comment"> * If either of the surfaces were in video memory, and the blit returns -2,</span>
<span class="comment"> * the video memory was lost, so it should be reloaded with artwork and </span>
<span class="comment"> * re-blitted:</span>
<span class="comment">	while ( SDL_BlitSurface(image, imgrect, screen, dstrect) == -2 ) {</span>
<span class="comment">		while ( SDL_LockSurface(image) &lt; 0 )</span>
<span class="comment">			Sleep(10);</span>
<span class="comment">		-- Write image pixels to image-&gt;pixels --</span>
<span class="comment">		SDL_UnlockSurface(image);</span>
<span class="comment">	}</span>
<span class="comment"> * This happens under DirectX 5.0 when the system switches away from your</span>
<span class="comment"> * fullscreen application.  The lock will also fail until you have access</span>
<span class="comment"> * to the video memory again.</span>
<span class="comment"> */</span>
<span class="comment">/* You should call SDL_BlitSurface() unless you know exactly how SDL</span>
<span class="comment">   blitting works internally and how to use the other blit functions.</span>
<span class="comment">*/</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">SDL_BlitSurface</span><span class="normal"> SDL_UpperBlit</span>

<span class="comment">/* This is the public blit function, SDL_BlitSurface(), and it performs</span>
<span class="comment">   rectangle validation and clipping before passing it to SDL_LowerBlit()</span>
<span class="comment">*/</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> SDL_UpperBlit</span>
<span class="normal">			</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">src</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">srcrect</span><span class="symbol">,</span>
<span class="normal">			 </span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dst</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dstrect</span><span class="symbol">);</span>
<span class="comment">/* This is a semi-private blit function and it performs low-level surface</span>
<span class="comment">   blitting only.</span>
<span class="comment">*/</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> SDL_LowerBlit</span>
<span class="normal">			</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">src</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">srcrect</span><span class="symbol">,</span>
<span class="normal">			 </span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dst</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dstrect</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * This function performs a fast fill of the given rectangle with 'color'</span>
<span class="comment"> * The given rectangle is clipped to the destination surface clip area</span>
<span class="comment"> * and the final fill rectangle is saved in the passed in pointer.</span>
<span class="comment"> * If 'dstrect' is NULL, the whole surface will be filled with 'color'</span>
<span class="comment"> * The color should be a pixel of the format used by the surface, and </span>
<span class="comment"> * can be generated by the SDL_MapRGB() function.</span>
<span class="comment"> * This function returns 0 on success, or -1 on error.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> SDL_FillRect</span>
<span class="normal">		</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dst</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dstrect</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint32</span><span class="normal"> color</span><span class="symbol">);</span>

<span class="comment">/* </span>
<span class="comment"> * This function takes a surface and copies it to a new surface of the</span>
<span class="comment"> * pixel format and colors of the video framebuffer, suitable for fast</span>
<span class="comment"> * blitting onto the display surface.  It calls SDL_ConvertSurface()</span>
<span class="comment"> *</span>
<span class="comment"> * If you want to take advantage of hardware colorkey or alpha blit</span>
<span class="comment"> * acceleration, you should set the colorkey and alpha value before</span>
<span class="comment"> * calling this function.</span>
<span class="comment"> *</span>
<span class="comment"> * If the conversion fails or runs out of memory, it returns NULL</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_Surface </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_DisplayFormat</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">);</span>

<span class="comment">/* </span>
<span class="comment"> * This function takes a surface and copies it to a new surface of the</span>
<span class="comment"> * pixel format and colors of the video framebuffer (if possible),</span>
<span class="comment"> * suitable for fast alpha blitting onto the display surface.</span>
<span class="comment"> * The new surface will always have an alpha channel.</span>
<span class="comment"> *</span>
<span class="comment"> * If you want to take advantage of hardware colorkey or alpha blit</span>
<span class="comment"> * acceleration, you should set the colorkey and alpha value before</span>
<span class="comment"> * calling this function.</span>
<span class="comment"> *</span>
<span class="comment"> * If the conversion fails or runs out of memory, it returns NULL</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_Surface </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_DisplayFormatAlpha</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">);</span>


<span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>
<span class="comment">/* YUV video surface overlay functions                                       */</span>
<span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="comment">/* This function creates a video output overlay</span>
<span class="comment">   Calling the returned surface an overlay is something of a misnomer because</span>
<span class="comment">   the contents of the display surface underneath the area where the overlay</span>
<span class="comment">   is shown is undefined - it may be overwritten with the converted YUV data.</span>
<span class="comment">*/</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_Overlay </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_CreateYUVOverlay</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> width</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> height</span><span class="symbol">,</span>
<span class="normal">				</span><span class="usertype">Uint32</span><span class="normal"> format</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">display</span><span class="symbol">);</span>

<span class="comment">/* Lock an overlay for direct access, and unlock it when you are done */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_LockYUVOverlay</span><span class="symbol">(</span><span class="usertype">SDL_Overlay</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">overlay</span><span class="symbol">);</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_UnlockYUVOverlay</span><span class="symbol">(</span><span class="usertype">SDL_Overlay</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">overlay</span><span class="symbol">);</span>

<span class="comment">/* Blit a video overlay to the display surface.</span>
<span class="comment">   The contents of the video surface underneath the blit destination are</span>
<span class="comment">   not defined.  </span>
<span class="comment">   The width and height of the destination rectangle may be different from</span>
<span class="comment">   that of the overlay, but currently only 2x scaling is supported.</span>
<span class="comment">*/</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_DisplayYUVOverlay</span><span class="symbol">(</span><span class="usertype">SDL_Overlay</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">overlay</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dstrect</span><span class="symbol">);</span>

<span class="comment">/* Free a video overlay */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_FreeYUVOverlay</span><span class="symbol">(</span><span class="usertype">SDL_Overlay</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">overlay</span><span class="symbol">);</span>


<span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>
<span class="comment">/* OpenGL support functions.                                                 */</span>
<span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="comment">/*</span>
<span class="comment"> * Dynamically load an OpenGL library, or the default one if path is NULL</span>
<span class="comment"> *</span>
<span class="comment"> * If you do this, you need to retrieve all of the GL functions used in</span>
<span class="comment"> * your program from the dynamic library using SDL_GL_GetProcAddress().</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GL_LoadLibrary</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">path</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Get the address of a GL function</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GL_GetProcAddress</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> proc</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Set an attribute of the OpenGL subsystem before intialization.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GL_SetAttribute</span><span class="symbol">(</span><span class="usertype">SDL_GLattr</span><span class="normal"> attr</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> value</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Get an attribute of the OpenGL subsystem from the windowing</span>
<span class="comment"> * interface, such as glX. This is of course different from getting</span>
<span class="comment"> * the values from SDL's internal OpenGL subsystem, which only</span>
<span class="comment"> * stores the values you request before initialization.</span>
<span class="comment"> *</span>
<span class="comment"> * Developers should track the values they pass into SDL_GL_SetAttribute</span>
<span class="comment"> * themselves if they want to retrieve these values.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GL_GetAttribute</span><span class="symbol">(</span><span class="usertype">SDL_GLattr</span><span class="normal"> attr</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="symbol">*</span><span class="normal"> value</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Swap the OpenGL buffers, if double-buffering is supported.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GL_SwapBuffers</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Internal functions that should not be called unless you have read</span>
<span class="comment"> * and understood the source code for these functions.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GL_UpdateRects</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> numrects</span><span class="symbol">,</span><span class="normal"> SDL_Rect</span><span class="symbol">*</span><span class="normal"> rects</span><span class="symbol">);</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GL_Lock</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">);</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_GL_Unlock</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">);</span>

<span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>
<span class="comment">/* These functions allow interaction with the window manager, if any.        */</span>
<span class="comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="comment">/*</span>
<span class="comment"> * Sets/Gets the title and icon text of the display window (UTF-8 encoded)</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_WM_SetCaption</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">title</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">icon</span><span class="symbol">);</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_WM_GetCaption</span><span class="symbol">(</span><span class="type">char</span><span class="normal"> </span><span class="symbol">**</span><span class="normal">title</span><span class="symbol">,</span><span class="normal"> </span><span class="type">char</span><span class="normal"> </span><span class="symbol">**</span><span class="normal">icon</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Sets the icon for the display window.</span>
<span class="comment"> * This function must be called before the first call to SDL_SetVideoMode().</span>
<span class="comment"> * It takes an icon surface, and a mask in MSB format.</span>
<span class="comment"> * If 'mask' is NULL, the entire icon surface will be used as the icon.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">void</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_WM_SetIcon</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">icon</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Uint8</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">mask</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * This function iconifies the window, and returns 1 if it succeeded.</span>
<span class="comment"> * If the function succeeds, it generates an SDL_APPACTIVE loss event.</span>
<span class="comment"> * This function is a noop and returns 0 in non-windowed environments.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_WM_IconifyWindow</span><span class="symbol">(</span><span class="type">void</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * Toggle fullscreen mode without changing the contents of the screen.</span>
<span class="comment"> * If the display surface does not require locking before accessing</span>
<span class="comment"> * the pixel information, then the memory pointers will not change.</span>
<span class="comment"> *</span>
<span class="comment"> * If this function was able to toggle fullscreen mode (change from </span>
<span class="comment"> * running in a window to fullscreen, or vice-versa), it will return 1.</span>
<span class="comment"> * If it is not implemented, or fails, it returns 0.</span>
<span class="comment"> *</span>
<span class="comment"> * The next call to SDL_SetVideoMode() will set the mode fullscreen</span>
<span class="comment"> * attribute based on the flags parameter - if SDL_FULLSCREEN is not</span>
<span class="comment"> * set, then the display will be windowed by default where supported.</span>
<span class="comment"> *</span>
<span class="comment"> * This is currently only implemented in the X11 video driver.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_WM_ToggleFullScreen</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">surface</span><span class="symbol">);</span>

<span class="comment">/*</span>
<span class="comment"> * This function allows you to set and query the input grab state of</span>
<span class="comment"> * the application.  It returns the new input grab state.</span>
<span class="comment"> */</span>
<span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">enum</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">	SDL_GRAB_QUERY </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span>
<span class="normal">	SDL_GRAB_OFF </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span>
<span class="normal">	SDL_GRAB_ON </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">,</span>
<span class="normal">	SDL_GRAB_FULLSCREEN	</span><span class="comment">/* Used internally */</span>
<span class="cbracket">}</span><span class="normal"> SDL_GrabMode</span><span class="symbol">;</span>
<span class="comment">/*</span>
<span class="comment"> * Grabbing means that the mouse is confined to the application window,</span>
<span class="comment"> * and nearly all keyboard input is passed directly to the application,</span>
<span class="comment"> * and not interpreted by a window manager, if any.</span>
<span class="comment"> */</span>
<span class="keyword">extern</span><span class="normal"> </span><span class="usertype">DECLSPEC</span><span class="normal"> SDL_GrabMode </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_WM_GrabInput</span><span class="symbol">(</span><span class="usertype">SDL_GrabMode</span><span class="normal"> mode</span><span class="symbol">);</span>

<span class="comment">/* Not in public API at the moment - do not use! */</span>
<span class="keyword">extern</span><span class="normal"> DECLSPEC </span><span class="type">int</span><span class="normal"> </span><span class="usertype">SDLCALL</span><span class="normal"> </span><span class="function">SDL_SoftStretch</span><span class="symbol">(</span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">src</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">srcrect</span><span class="symbol">,</span>
<span class="normal">                                    </span><span class="usertype">SDL_Surface</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dst</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">SDL_Rect</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">dstrect</span><span class="symbol">);</span>
<span class="normal">                    </span>
<span class="comment">/* Ends C function definitions when using C++ */</span>
<span class="preproc">#ifdef</span><span class="normal"> __cplusplus</span>
<span class="cbracket">}</span>
<span class="preproc">#endif</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">"close_code.h"</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* _SDL_video_h */</span>
</tt></pre></div><div style="text-align: right; padding: 8pt; font-size: 12px"><a href="/xmlfeed/weblog-rss20.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABQAAAADwCexKkxAAAAWUlEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMCt0ZdTU/F/7/+1HEkydFpoKVPn+93sUlUujQvP/7UcRTAuNDJ2a//s/imDqtKVZofm/1qGYSZk7sfodGwAAiobBJtffoNAAAAAASUVORK5CYII=" alt="RSS 2.0 Weblog Feed" width="80" height="15"/></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAAaklEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMDV16rTQ/H/7V//69+//v/3/9oMEI6cuAwr+fv/+/b5d///v//0eJBgWOhMo+Gs9UPAdXDBy6lSYyn9wQZCZS0GCYDPXQcykzJ1Y/Y4NAABKvL80wyoMPgAAAABJRU5ErkJggg==" alt="Atom 1.0 Weblog Feed" width="80" height="15"/></a> <a href="http://validator.w3.org/check?uri=referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABKklEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6qIGzIRiKZs9GFoEaMRuZhhrYqqJXy8uZYauRxC/VHew7e3YTPAxnI5swG6JxNrKBNjB1EFmIgV0+HA6C8pqqzhXG7BbJJROQIwViMYQ7G2oDQQNn57JyG7kxiCfObrBmS5+BHMuYLkTzMnYDm5WY4lOZZRPKZocxes+aPbuwCFsYohiICLvZsKBAMrDTQ7K/StveU8icTzrOL8JdLpOyWJ49u8Bx9ozw8DY7UYW03hhdxZAOSg2c3jN79rSJs1vSKmfOnpFXNJmynELlvExlAADnaZpLFGEC2wAAAABJRU5ErkJggg==" alt="Valid XHTML 1.1" width="80" height="15"/></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABEUlEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6mIEQCsIjwhKoga0qerW8nBm2Gkn8Ut3BvrNnN8HCcDYM2cBIogzs8uFwEJTXVHWuMGa3SC6ZgIgUqCEwdxJr4OxcVm4jNwbxxNkN1mzpM2ajGIjsPGK9PLtZiSk+lVk2oWx2GKP3rNmzC4tQwpDoIIQb2Okh2V+lbe8pZM4nHecX4S6XSVksz55d4Dh7Rnh4m52oQlpvjK5iSAelBk7vmT172sTZLWmVM2fPyCuaTFlOoXJepjIAANlljDGY/l5pAAAAAElFTkSuQmCC" alt="Valid CSS (2.1)" width="80" height="15"/></a><br/>Copyright 2005-2014 <a href="/about/">Timo Bingmann</a> - <a href="/about/impressum.html">Impressum</a></div><script type="text/javascript">var _paq = _paq || []; _paq.push(["trackPageView"]); _paq.push(["enableLinkTracking"]);(function() {var u=(("https:" == document.location.protocol) ? "https" : "http") + "://panthema.net/wik-331/"; _paq.push(["setTrackerUrl", u+"js/"]); _paq.push(["setSiteId", "2"]);var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";g.defer=true; g.async=true; g.src=u+"js/"; s.parentNode.insertBefore(g,s);})();</script><noscript><p><img src="http://panthema.net/wik-331/js/?idsite=2&amp;rec=1" style="border:0" alt="" /></p></noscript></body></html>