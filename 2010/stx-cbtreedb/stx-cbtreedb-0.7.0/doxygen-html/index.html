<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>stx-cbtreedb: stx::CBTreeDB - STX Constant B-Tree Database Template Classes README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="el" href="classstx_1_1CBTreeDB.html" title="Template super-class enclosing all classes which can operate on a constant B-tree...">stx::CBTreeDB</a> - STX Constant B-Tree Database Template Classes README </h1><h3 class="version">0.7.0 </h3><dl class="author"><dt><b>Author:</b></dt><dd>Timo Bingmann (Mail: tb a-with-circle idlebox dot net) </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010-04-14</dd></dl>
<h2><a class="anchor" id="sec_summary">
Summary</a></h2>
<p>The <a class="el" href="classstx_1_1CBTreeDB.html" title="Template super-class enclosing all classes which can operate on a constant B-tree...">stx::CBTreeDB</a> is a collection of C++ classes with which read-only key-value database files can be created and read. A database efficiently maps a large number of integral fixed-length keys to opaque binary value blobs. Variable-length or duplicate keys are currently not supported. Keys are organized into a highly compact index structure, which is very similar to a B-tree and allows very fast key lookups. Both keys and values are stored in order and thus queries in a local proximity can benefit from caching effects. All applications mapping a large number of constant, integral keys to string or data blobs can benefit from this library.</p>
<p>Key features of the database classes are:</p>
<ul>
<li>key locality due to ordered storage of keys and values</li>
<li>lookups in close proximity benefit from caching effects</li>
<li>fixed-length integral keys</li>
<li>opaque binary blobs as values</li>
<li>compact B-tree-like index structure</li>
<li>sequential storage of value data with minimal overhead</li>
<li>O(1) page cache to keep hot pages in memory</li>
<li>simple C++ API for <a class="el" href="classstx_1_1CBTreeDB_1_1Reader.html">Reader</a> and two <a class="el" href="classstx_1_1CBTreeDB_1_1Writer.html">Writer</a> classes</li>
<li>CRC32 checksum of header and SHA256 digest of b-tree and value data for integrity</li>
<li>extensive test suite with 91.3% line coverage</li>
</ul>
<p>The complete source code is contained in the header file <a class="el" href="stx-cbtreedb_8h.html" title="Contains all classes of the constant B-tree database implementation.">include/stx-cbtreedb.h</a>.</p>
<h2><a class="anchor" id="sec_website">
Website / API Docs / Bugs / License</a></h2>
<p>The current source package can be downloaded from <a href="http://idlebox.net/2010/stx-cbtreedb/">http://idlebox.net/2010/stx-cbtreedb/</a></p>
<p>The classes are extensively documented using doxygen. The compiled doxygen HTML documentation is included in the source package or can be viewed online at <a href="http://idlebox.net/2010/stx-cbtreedb/stx-cbtreedb-0.7.0/doxygen-html/">http://idlebox.net/2010/stx-cbtreedb/stx-cbtreedb-0.7.0/doxygen-html/</a> (if you are not reading it right now).</p>
<p>The tools directory contains an <a class="el" href="example1_8cc.html">example1.cc</a>, which is further documented below (<a class="el" href="index.html#sec_example">Example Usage</a>) and an all-purpose <code>cbtreedb-tool</code> for use with standard database formats.</p>
<p>If bugs should become known they will be posted on the above web page together with patches or corrected versions.</p>
<p>The B-tree source code is released under the GNU Lesser General Public License v2.1 (LGPL) which can be found in the file COPYING. Other parts of the source code were copied from the Botan library and are under a BSD-license.</p>
<h2><a class="anchor" id="sec_application">
Original Application</a></h2>
<p>The original purpose of this library is to organize lookups of 32-bit integer identifiers to constant data blobs. In my application a few million non-sequential identifier keys are mapping to data blobs, which are unalterable short strings or small (1-10 kb) data files. Most key lookups occur in close proximity, usually in ascending order.</p>
<p>The resulting data volume is around 20 GB in size and was previously stored using the BerkeleyDB library. However, since the key and values in my application are read-only, the overhead both in file size and processing time introduced by BerkeleyDB became unacceptable. Using <a class="el" href="classstx_1_1CBTreeDB.html" title="Template super-class enclosing all classes which can operate on a constant B-tree...">stx::CBTreeDB</a> access to the value records is faster than before, and file sizes were reduced to a minimum due to the compact sequential storage in the read-only databases.</p>
<p>An alternative to the B-tree database classes are the well-known cdb or tinycdb libraries. However, these are basically hash tables and thus do not preserve key locality. Thus retrieval of 10 keys in ascending order requires 10 disk accesses at pseudo-random places in the database. With the B-tree library the disk areas read are stored in ascending order, just like the keys.</p>
<h2><a class="anchor" id="sec_architecture">
Design Principles and Database Architecture</a></h2>
<p>Most design principles follow directly from the intended application.</p>
<p>Maybe the most important design aspect was to store the data blobs without separation in the most compact way possible. Thus the read-only database file simply stores all data blobs in sequence, without putting them onto data pages or similar overhead typical of a read-write database.</p>
<p>To accelerate key lookups an index structure very similar to a B-tree is prepended to the data area. This "packed, sequential" B-tree is constructed by the Writer classes and only differs from the original B-tree in one aspect. The nodes of each level containing the highest keys may be less than half full. The basic idea of the "packed, sequential" B-tree is to use only full nodes and creating inner nodes and levels as needed. All nodes except the one with the highest key are full! Thus the number of nodes used by the search tree is minimal and all lookup properties of the B-tree are retained. A drawing of the B-tree structure can be seen below:</p>
 
<div style="text-align: center">
<p>Structure of the packed, sequential B-tree</p>
<object type="image/svg+xml" data="drawing-2.svg" style="width: 90%; max-height: 20em"><p>SVG viewer required</p></object>
</div>
<p>All B-tree nodes are stored "in order" after the database file's header. The root node is always first, followed by all nodes of the next level, which in turn are followed by the next level until the leaf level is reached.</p>
<p>See the corresponding structures for the data fields in these nodes: <a class="el" href="structstx_1_1CBTreeDB_1_1InnerNode.html">stx::CBTreeDB::InnerNode</a> and <a class="el" href="structstx_1_1CBTreeDB_1_1LeafNode.html">stx::CBTreeDB::LeafNode</a>. These structures use some less obvious optimizations to further reduce overhead:</p>
<p>The in order storage of all B-tree nodes makes saving of offsets for each child node of an inner node unnecessary: the n+1 children nodes are stored consecutively starting after the first node. Thus the page offset of a child node can be calculated from only the first node's offset and the child number. This optimization removes about half of ordinarily needed fields in an inner node (<a class="el" href="structstx_1_1CBTreeDB_1_1InnerNode.html">stx::CBTreeDB::InnerNode</a>) and allows a higher fan-out.</p>
<p>Each leaf node (<a class="el" href="structstx_1_1CBTreeDB_1_1LeafNode.html">stx::CBTreeDB::LeafNode</a>) contains both an array of keys and corresponding data offsets. For size optimization all data offsets are 32-bit values relative to a base 64-bit starting offset. This reduces the size of the offset array and allows more keys to fit into a leaf node. This also imposes a restriction on data size: the sum of all data handled by one leaf must not exceed 2^32. This constraint is currently unchecked by the library, but should not occur in practice. Data sizes are calculated from subsequent data offsets. Furthermore, each leaf node contains one more offset number than strictly necessary: the offset of the data item following the highest key in the leaf. This offset is used to calculate the data size for the highest key without requiring retrieval of the following leaf.</p>
<h2><a class="anchor" id="sec_implementation">
Implementation Overview</a></h2>
<p>All classes of the cbtreedb library are enclosed in the top-level template class <a class="el" href="classstx_1_1CBTreeDB.html">stx::CBTreeDB</a>. This class is parametrized by two types and two integer values. See the <a class="el" href="classstx_1_1CBTreeDB.html">class documentation</a> for more information on the template parameters.</p>
<p>The library contains two writer classes, which are used to create read-only databases from a set of key-value pairs. The difference between the two classes is the order in which key-value pairs are delivered to the class. The <a class="el" href="classstx_1_1CBTreeDB_1_1Writer.html" title="Writer is used to construct an constant B-tree database from an unsorted input sequence...">stx::CBTreeDB::Writer</a> allows keys to be added in <b>random order</b> to the internal std::map. When finished the B-tree is constructed and the whole set is written to the database in one function call.</p>
<p>The obvious problem with Writer is that with large databases all key-value data must be stored in memory until written. This prohibits use of this writer class for very large databases, which are a main goal of the library. For purpose of writing large databases the sequential writer class <a class="el" href="classstx_1_1CBTreeDB_1_1WriterSequential.html">stx::CBTreeDB::WriterSequential</a> can be used. With this writer the key sequence must be delivered <b>in ascending order</b> and the database is constructed in two phases: in the first phase key and value-lengths are <em>declared</em> and the B-tree is constructed, and in the second phase the key-value pairs are <em>delivered</em> and written directly to the file with no extra buffering.</p>
<p>Note that both writer classes create _identical_ databases for equal input sets.</p>
<p>There is only one <a class="el" href="classstx_1_1CBTreeDB_1_1Reader.html">stx::CBTreeDB::Reader</a> class. The Reader class itself is a pointer implementation to a referenced counted implementation object (<a class="el" href="classstx_1_1CBTreeDB_1_1ReaderImpl.html" title="Implementation class used to read constant B-tree database files.">stx::CBTreeDB::ReaderImpl</a>), so you can easily copy Reader objects. Note however, that non of the classes are reentrent or thread-safe. For multi-threaded applications access must be guarded by mutexes, patches welcome.</p>
<p>Each Reader object may optionally have an associated <a class="el" href="classstx_1_1CBTreeDB_1_1PageCache.html">stx::CBTreeDB::PageCache</a> object, which is then used to cache hot B-tree pages like the root. The PageCache contains the most recently used pages (LRU replacement strategy) up to the maximum number specified. It features a structure allowing O(1) Store() and Retrieve() functions. A PageCache object can be shared between different database Readers. For more information see the corresponding documentation page.</p>
<p>A Reader object can load exactly one database using the <a class="el" href="classstx_1_1CBTreeDB_1_1Reader.html#ad4653b248da59d01ef55890f2004047c">Open()</a> function. Note that the class template parameters must match those used to write the database. Some parameters are checked by the <a class="el" href="classstx_1_1CBTreeDB_1_1Reader.html#ad4653b248da59d01ef55890f2004047c">Open()</a> function and appropriate error messages are returned.</p>
<p>Once opened the database can be queried using <a class="el" href="classstx_1_1CBTreeDB_1_1Reader.html#a2da743e3f6302a950f0ce26d01268b80">Exists()</a>, <a class="el" href="classstx_1_1CBTreeDB_1_1Reader.html#ac4473a0cdd049876c7f8f98de452841b">Lookup()</a>, <a class="el" href="classstx_1_1CBTreeDB_1_1Reader.html#affb374aed822d0552e16c7627a8acdf1">GetIndex()</a> and the operator[] functions as if it were a map.</p>
<h2><a class="anchor" id="sec_testsuite">
Test Suite</a></h2>
<p>The B-tree distribution contains an extensive test suite. According to gcov 91.9% of the <a class="el" href="stx-cbtreedb_8h.html" title="Contains all classes of the constant B-tree database implementation.">stx-cbtreedb.h</a> implementation is covered. The remaining lines are all copies or unimportant.</p>
<h2><a class="anchor" id="sec_example">
Example Usage</a></h2>
<p>These example snippets are based on code from <a class="el" href="example1_8cc.html">tools/example1.cc</a></p>
<p>Most programs will first use a typedef to specify the template parameters of <a class="el" href="classstx_1_1CBTreeDB.html" title="Template super-class enclosing all classes which can operate on a constant B-tree...">stx::CBTreeDB</a>. In this example simple uint32_t keys are used in ascending order:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// declare cbtreedb parameters</span>
<span class="keyword">typedef</span> <a class="code" href="classstx_1_1CBTreeDB.html" title="Template super-class enclosing all classes which can operate on a constant B-tree...">stx::CBTreeDB&lt; uint32_t, std::less&lt;uint32_t&gt;</a> &gt; cbtreedb;
</pre></div><p>A read-only database can be created using <a class="el" href="classstx_1_1CBTreeDB_1_1Writer.html" title="Writer is used to construct an constant B-tree database from an unsorted input sequence...">stx::CBTreeDB::Writer</a> as follows:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> items = 64;

<span class="comment">// create random order writer object</span>
cbtreedb::Writer writer;

<span class="comment">// add some key-values into writer map</span>
<span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; items; ++i)
{
    std::ostringstream oss;
    oss &lt;&lt; <span class="stringliteral">&quot;value &quot;</span> &lt;&lt; i;

    writer.Add(i * i, oss.str());
}

<span class="comment">// write out database via ofstream</span>
std::ofstream testdb(<span class="stringliteral">&quot;example1.db&quot;</span>);
writer.Write(testdb);
</pre></div><p>Once created the database file can be opened and read by a <a class="el" href="classstx_1_1CBTreeDB_1_1Reader.html" title="Class used to read constant B-tree database files.">stx::CBTreeDB::Reader</a> object. Note that the file ifstream must exist as long as the Reader is used.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// create reader object</span>
cbtreedb::Reader reader;

<span class="comment">// set up page cache to keep hot pages in memory</span>
cbtreedb::PageCache cache(128);
reader.SetPageCache(&amp;cache);

<span class="comment">// attach an ifstream to the reader and open db</span>
std::ifstream testdb(<span class="stringliteral">&quot;example1.db&quot;</span>);
std::string errorstring;
<span class="keywordflow">if</span> (!reader.Open(testdb, &amp;errorstring))
{
    std::cout &lt;&lt; <span class="stringliteral">&quot;Error loading database: &quot;</span> &lt;&lt; errorstring &lt;&lt; std::endl;
    <span class="keywordflow">return</span> -1;
}          
</pre></div><p>The key-value pairs in the database can then be accessed by different functions.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// pick out some items via operator[]</span>
std::cout &lt;&lt; <span class="stringliteral">&quot;sqrt(2500) -&gt; &quot;</span> &lt;&lt; reader[2500] &lt;&lt; std::endl;
std::cout &lt;&lt; <span class="stringliteral">&quot;sqrt(2501) -&gt; &quot;</span> &lt;&lt; reader[2501] &lt;&lt; std::endl;
std::cout &lt;&lt; <span class="stringliteral">&quot;sqrt(2601) -&gt; &quot;</span> &lt;&lt; reader[2601] &lt;&lt; std::endl;

<span class="comment">// check existance of keys</span>
std::cout &lt;&lt; <span class="stringliteral">&quot;isSquare(2704) -&gt; &quot;</span> &lt;&lt; reader.Exists(2704) &lt;&lt; std::endl;
std::cout &lt;&lt; <span class="stringliteral">&quot;isSquare(2705) -&gt; &quot;</span> &lt;&lt; reader.Exists(2705) &lt;&lt; std::endl;

<span class="comment">// full lookup function</span>
std::string out;

<span class="keywordflow">if</span> (reader.Lookup(2809, out))
    std::cout &lt;&lt; <span class="stringliteral">&quot;Lookup 2809 -&gt; &quot;</span> &lt;&lt; out &lt;&lt; <span class="stringliteral">&quot; (was found.)&quot;</span> &lt;&lt; std::endl;
<span class="keywordflow">else</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;Lookup 2809 has failed.&quot;</span> &lt;&lt; std::endl;
</pre></div><p>All pairs can also be enumerated using the GetIndex() functions:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// iterate through all items in the database</span>
std::cout &lt;&lt; <span class="stringliteral">&quot;Full listing:&quot;</span> &lt;&lt; std::endl;
<span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; reader.Size(); ++i)
{
    uint32_t key;
    std::string value;
    
    reader.GetIndex(i, key, value);

    std::cout &lt;&lt; <span class="stringliteral">&quot;key &quot;</span> &lt;&lt; key &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; value &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
}
std::cout &lt;&lt; std::endl;
</pre></div><p>Data integrity is protected by the database format using CRC32 and SHA256 checksums of both B-tree keys and data area. The full database check is rather expensive and can be run using the Verify() function.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// run all internal checks</span>
<span class="keywordflow">if</span> (!reader.Verify())
{
    std::cout &lt;&lt; <span class="stringliteral">&quot;Database integrity failed!&quot;</span> &lt;&lt; std::endl;
}
</pre></div><p>When no longer needed the Reader object can either be destroyed or Close() can explicitly be called to release the file association.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// release file stream</span>
reader.Close();
</pre></div><p>Alternatively, the sequential order writer <a class="el" href="classstx_1_1CBTreeDB_1_1WriterSequential.html" title="WriterSequential is used to construct a constant B-tree database from an _ordered_...">stx::CBTreeDB::WriterSequential</a> can be used to create the same database. Note that the value data is not necessary during phase 1.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> items = 64;

<span class="comment">// create sequential order writer object</span>
cbtreedb::WriterSequential writer;

<span class="comment">// phase 1: declare key and values lengths</span>
<span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; items; ++i)
{
    writer.Add(i*i, strlen(<span class="stringliteral">&quot;value &quot;</span>) + (i &gt; 0 ? (log10(i) + 1) : 1));
}

<span class="comment">// write out header and B-tree to database via ofstream</span>
std::ofstream testdb(<span class="stringliteral">&quot;example1.db&quot;</span>);
writer.WriteHeader(testdb);

<span class="comment">// phase 2: deliver key and value data</span>
<span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; items; ++i)
{
    std::ostringstream oss;
    oss &lt;&lt; <span class="stringliteral">&quot;value &quot;</span> &lt;&lt; i;

    writer.WriteValue(i*i, oss.str());
}

<span class="comment">// finalize database by updating signature page</span>
writer.WriteFinalize();
</pre></div> </div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Apr 14 13:43:40 2010 for stx-cbtreedb by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
