<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>STX Execution Pipe: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>STX Execution Pipe Documentation</h1><h3 class="version">0.7 </h3><p>The STX ExecPipe library provides a convenient C++ interface to execute child programs connected via pipes. It is a front-end to the system calls fork(), pipe(), select() and execv() and hides all the complexity of these low-level functions. It allows a program to build a sequence of connected children programs with input and output of the pipe sequence redirected to a file, string or file descriptor. The library also allows custom asynchronous data processing classes to be inserted into the pipe or placed at source or sink of the sequence.</p>
<p>An execution pipe consists of an input stream, a number of pipe stages and an output stream. The input and output streams can be a plain file descriptor, a file, a std::string or a special processing class. Each pipe stage is either an executed child program or an intermediate function class. At the junction between each stage in the pipeline the following program's stdin is connected to the preceding stage's stdout. The input and output streams are connected to the start and end of the pipe line.</p>
<table  style="margin: 0 auto; border: 0px">
<tr>
<td><pre>
 Input Stream                   Pipe Stages                   Output Stream
     none    |                                                |    none
      fd     |                 exec()                         |     fd
     file    |--&gt; stage --&gt;      or      --&gt; stage --&gt; ... --&gt;|    file
    string   |              PipeFunction                      |   string
  PipeSource |                                                |  PipeSink
</pre> </td></tr>
</table>
<p>All this functionality is wrapped into a flexible C++ class, which can be used in an application to construct complex sequences of external programs similar to shell piping. Some common operations would be calls of mkisofs or tar coupled with gzip or gpg and possibly send the output to a remote host via ssh or ncftpput.</p>
<h2><a class="anchor" id="sec_usage">
Library Usage Tutorial</a></h2>
<p>The following tutorial shows some simple examples on how an execution pipe can be set up.</p>
<p>To use the library a program must</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;stx-execpipe.h&quot;</span>
</pre></div><p>and later link against libstx-execpipe.a or include the corresponding .o / .cc in the project's dependencies.</p>
<p>To run a sequence of programs you must first initialize a new ExecPipe object. The ExecPipe object is referenced counted so you can easily pass it around without deep-duplicating the object.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="a00005.html" title="Main library interface (reference counted pointer).">stx::ExecPipe</a> ep;               <span class="comment">// creates new pipe</span>

<a class="code" href="a00005.html" title="Main library interface (reference counted pointer).">stx::ExecPipe</a> ep_ref1 = ep;     <span class="comment">// reference to the same pipe.</span>
</pre></div><p>Once created the input stream source can be set using one of the four set_input_*() functions. Note that these are mutually exclusive, you must call at most one of the following functions!</p>
<div class="fragment"><pre class="fragment"><span class="comment">// you can designate an existing file as input stream</span>
ep.<a class="code" href="a00005.html#a9afb508b49785a7ee6b664148588014b" title="Assign a file as input stream source.">set_input_file</a>(<span class="stringliteral">&quot;/path/to/file&quot;</span>);

<span class="comment">// or directly assign an already opened file descriptor</span>
<span class="keywordtype">int</span> fd = ...;
ep.<a class="code" href="a00005.html#aff77e25ccbb4e666ed4f0342a059b9dd" title="Assign an already opened file descriptor as input stream for the first exec stage...">set_input_fd</a>(fd);

<span class="comment">// or pass the contents of a std::string as input</span>
std::string str = ...;
ep.<a class="code" href="a00005.html#a9a0f38ea61b4cbc86aecc5f04e037fa2" title="Assign a std::string as input stream source.">set_input_string</a>(&amp;str);

<span class="comment">// or attach a data generating source class (details later).</span>
PipeSource source;
ep.<a class="code" href="a00005.html#ab1de27be9540428386031c0378405037" title="Assign a PipeSource as input stream source.">set_input_source</a>(&amp;source);
</pre></div><p>The input stream objects are _not_ copied. The fd, string or source object must still exist when calling run().</p>
<p>After setting up the input you specify the individual stages in the pipe by adding children programs to exec() or function classes. The <a class="el" href="a00005.html" title="Main library interface (reference counted pointer).">stx::ExecPipe</a> provides different variants of add_exec*(), which are derived from the exec*() system call variants.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// add simple exec() call with full path.</span>
ep.<a class="code" href="a00005.html#abef69ffbc8c00ed14536c1474f182175" title="Add an exec() stage to the pipe with given arguments.">add_exec</a>(<span class="stringliteral">&quot;/bin/cat&quot;</span>);

<span class="comment">// add exec() call with up to three direct parameters.</span>
ep.<a class="code" href="a00005.html#abef69ffbc8c00ed14536c1474f182175" title="Add an exec() stage to the pipe with given arguments.">add_exec</a>(<span class="stringliteral">&quot;/bin/echo&quot;</span>, <span class="stringliteral">&quot;one&quot;</span>, <span class="stringliteral">&quot;two&quot;</span>, <span class="stringliteral">&quot;three&quot;</span>);

<span class="comment">// add exec() call with many parameters. the vector is _not_ copied.</span>
std::vector&lt;std::string&gt; tarargs;
tarargs.push_back(<span class="stringliteral">&quot;/bin/tar&quot;</span>);
tarargs.push_back(<span class="stringliteral">&quot;--create&quot;</span>);
tarargs.push_back(<span class="stringliteral">&quot;--verbose&quot;</span>);
tarargs.push_back(<span class="stringliteral">&quot;--gzip&quot;</span>);
tarargs.push_back(<span class="stringliteral">&quot;--file&quot;</span>);
tarargs.push_back(<span class="stringliteral">&quot;/path/to/file&quot;</span>);
ep.<a class="code" href="a00005.html#abef69ffbc8c00ed14536c1474f182175" title="Add an exec() stage to the pipe with given arguments.">add_exec</a>(&amp;tarargs);

<span class="comment">// add execp() call which searches $PATH. see man 3 execvp.</span>
ep.<a class="code" href="a00005.html#a02209f5cbef544191957d95c6f2eb27b" title="Add an execp() stage to the pipe with given arguments.">add_execp</a>(<span class="stringliteral">&quot;cat&quot;</span>);

<span class="comment">// same with up to three parameters.</span>
ep.<a class="code" href="a00005.html#a02209f5cbef544191957d95c6f2eb27b" title="Add an execp() stage to the pipe with given arguments.">add_execp</a>(<span class="stringliteral">&quot;echo&quot;</span>, <span class="stringliteral">&quot;one&quot;</span>, <span class="stringliteral">&quot;two&quot;</span>, <span class="stringliteral">&quot;three&quot;</span>);

<span class="comment">// and also works with a vector of arguments.</span>
ep.<a class="code" href="a00005.html#a02209f5cbef544191957d95c6f2eb27b" title="Add an execp() stage to the pipe with given arguments.">add_execp</a>(&amp;tarargs);

<span class="comment">// most versatile function: call execve() with program name, argv[] arguments</span>
<span class="comment">// and a set of environment variables.</span>
std::vector&lt;std::string&gt; gzipargs;
gzipargs.push_back(<span class="stringliteral">&quot;gunzip&quot;</span>);           <span class="comment">// this changes argv[0]</span>

std::vector&lt;std::string&gt; gzipenvs;      <span class="comment">// set environment variable</span>
gzipenvs.push_back(<span class="stringliteral">&quot;GZIP=-d --name&quot;</span>);

ep.<a class="code" href="a00005.html#add73caa3ad28e575227e212c23dde72b" title="Add an exece() stage to the pipe with the given arguments and environments.">add_exece</a>(<span class="stringliteral">&quot;/bin/gzip&quot;</span>, &amp;gzipargs, &amp;gzipenvs);

<span class="comment">// insert an intermediate data processing class into the pipe (details later).</span>
PipeFunction function;
ep.<a class="code" href="a00005.html#ad4ace2eacec24c0a07694d3503dcf03d" title="Add a function stage to the pipe.">add_function</a>(&amp;function);
</pre></div><p>After configuring the pipe stages the user program can redirect the pipe's output using one of the four set_output_*() functions. These correspond directly the to input functions.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// designate a file as output, it will be over-written,</span>
ep.<a class="code" href="a00005.html#ad8bc4dd1a0f2e137544876ae0ba78ee9" title="Assign a file as output stream destination.">set_output_file</a>(<span class="stringliteral">&quot;/path/to/file&quot;</span>);

<span class="comment">// or directly assign an already opened file descriptor</span>
<span class="keywordtype">int</span> fd = ...;
ep.<a class="code" href="a00005.html#a1668a23be41fea81f7899dcbebbe767d" title="Assign an already opened file descriptor as output stream for the last exec stage...">set_output_fd</a>(fd);

<span class="comment">// or save output in a std::string object</span>
std::string str = ...;
ep.<a class="code" href="a00005.html#a9536d076bbf9e82dd17e09c9aa77f7a8" title="Assign a std::string as output stream destination.">set_output_string</a>(&amp;str);

<span class="comment">// or attach a sink class (details later).</span>
PipeSink sink;
ep.<a class="code" href="a00005.html#a313a290fea965ec30b6c159a74973945" title="Assign a PipeSink as output stream destination.">set_output_sink</a>(&amp;sink);
</pre></div><p>The three steps above can be done in any order. Once the pipeline is configured as required, a call to run() will set up the input and output file descriptors, launch all children programs, wait until these finish and concurrently process data passed between parent and children.</p>
<p>If any system calls fail while running the pipe, the run() function will throw() a std::runtime_error exception. So wrap run() in a try-catch block.</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">try</span> {
    ep.<a class="code" href="a00005.html#a305267e99ac1f905b673da3997960543" title="Run the configured pipe sequence and wait for all children processes to complete...">run</a>();
}
<span class="keywordflow">catch</span> (std::runtime_error &amp;e) {
    std::cerr &lt;&lt; <span class="stringliteral">&quot;Pipe execution failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;
}
</pre></div><p>After running all children their return status should be checked. These can be inspected using the following functions. The integer parameter specifies the exec stage in the pipe sequence.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// get plain return status as indicated by wait().</span>
<span class="keywordtype">int</span> rs = ep.<a class="code" href="a00005.html#ad4c4c5f819976489131c45611578594f" title="Get the return status of exec() stage&amp;#39;s program run after pipe execution as indicated...">get_return_status</a>(0)

<span class="comment">// get return code for normally terminated program.</span>
<span class="keywordtype">int</span> rc = ep.<a class="code" href="a00005.html#a26720fa668df3398398f10c503a52f9d" title="Get the return code of exec() stage&amp;#39;s program run after pipe execution, or -1...">get_return_code</a>(1);

<span class="comment">// get signal for abnormally terminated program (like segfault).</span>
<span class="keywordtype">int</span> rg = ep.<a class="code" href="a00005.html#a477d189d73e8344ca4fa4b333207bc15" title="Get the signal of the abnormally terminated exec() stage&amp;#39;s program run after...">get_return_signal</a>(1);
</pre></div><p>Most program have a return code of 0 when no error occurred. Therefore, a convenience function is available which checks whether all program stages returned zero. This is what would usually be used.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// check all that program returned zero</span>
<span class="keywordflow">if</span> (ep.<a class="code" href="a00005.html#aac626dcd623778ce5a1475cc12ac596f" title="Return true if the return code of all exec() stages were zero.">all_return_codes_zero</a>()) {
    <span class="comment">// run was ok.</span>
}
<span class="keywordflow">else</span> {
    <span class="comment">// error handling.</span>
}
</pre></div><p>After checking the return error codes the pipe's results can be used.</p>
<p>The tarball contains three simple examples of using the different exec() variants and input/output redirections. See <a class="el" href="a00001.html">examples/simple1.cc</a>, <a class="el" href="a00002.html">examples/simple2.cc</a> or <a class="el" href="a00003.html">examples/simple3.cc</a>. More a more elaborate example using data processing classes see the continued tutorial below.</p>
<h2><a class="anchor" id="sec_functionals">
Data Processing Classes</a></h2>
<p>One of the big features of the STX ExecPipe classes is the ability to insert intermediate asynchronous data processing classes into the pipe sequence. The data of the pipe line is returned to the parent process and, after arbitrary computations, can be sent on to the following execution stages. Besides intermediate processing, the input and output stream can be attached to source or sink classes.</p>
<p>This feature can be used to generate input data, e.g. binary data or file listing, or peek at the data flowing between stages, e.g. to compute a SHA1 digest, or to directly processes output data while the children are running.</p>
<p>The data processing classes must be derived from one of the three abstract classes: <a class="el" href="a00009.html" title="Abstract class used as an input stream source for an ExecPipe.">stx::PipeSource</a> for generating input streams, <a class="el" href="a00007.html" title="Abstract class used as an intermediate pipe stage between executed processes.">stx::PipeFunction</a> for intermediate processing between stages or <a class="el" href="a00008.html" title="Abstract class used as an output stream source for an ExecPipe.">stx::PipeSink</a> for receiving output.</p>
<p>For generating an input stream a class must derive from <a class="el" href="a00009.html" title="Abstract class used as an input stream source for an ExecPipe.">stx::PipeSource</a> and implement the <a class="el" href="a00009.html#a95df51330c144a7782efc103ace6d453">poll()</a> function. This function is called when new data can be pushed into the pipe. When <a class="el" href="a00009.html#a95df51330c144a7782efc103ace6d453">poll()</a> is called, new data must be generated and delivered via the <a class="el" href="a00009.html#a356519e2fbbeacbf06b6e33c78dde7ad">write()</a> function of <a class="el" href="a00009.html" title="Abstract class used as an input stream source for an ExecPipe.">stx::PipeSource</a>. If more data is available <a class="el" href="a00009.html#a95df51330c144a7782efc103ace6d453">poll()</a> must return true, otherwise the input stream is terminated.</p>
<p>Intermediate data processing classes must derive from <a class="el" href="a00007.html" title="Abstract class used as an intermediate pipe stage between executed processes.">stx::PipeFunction</a> and implement the two pure virtual function <a class="el" href="a00008.html#aad674114373316816576fe4f8a64e23f">process()</a> and <a class="el" href="a00008.html#a7704c6b4f69a974236bd0ed771b659a3">eof()</a>. As the name suggests, data is delivered to the class via the <a class="el" href="a00008.html#aad674114373316816576fe4f8a64e23f">process()</a> function. After processing the data it may be forwarded to the next pipe stage via the inherited<a class="el" href="a00007.html#af188fdba0b40670aedb24ad5fddc64dc">write()</a> function. Note that the library does not automatically forward data, so if you forget to write() data, then the following stage does not receive anything. When the preceding processing stage closes its data stream the function <a class="el" href="a00008.html#a7704c6b4f69a974236bd0ed771b659a3">eof()</a> is called.</p>
<p>To receive the output stream a class must derive from <a class="el" href="a00008.html" title="Abstract class used as an output stream source for an ExecPipe.">stx::PipeSink</a>. Similar to <a class="el" href="a00007.html" title="Abstract class used as an intermediate pipe stage between executed processes.">stx::PipeFunction</a>, an output sink must implement the two pure virtual function <a class="el" href="a00008.html#aad674114373316816576fe4f8a64e23f">process()</a> and <a class="el" href="a00008.html#a7704c6b4f69a974236bd0ed771b659a3">eof()</a>. However, different from an intermediate class the <a class="el" href="a00008.html" title="Abstract class used as an output stream source for an ExecPipe.">stx::PipeSink</a> does not provide a write() function, so no data can be forwarded.</p>
<p>For a full example of using <a class="el" href="a00009.html" title="Abstract class used as an input stream source for an ExecPipe.">stx::PipeSource</a> to iterate through a file list and <a class="el" href="a00007.html" title="Abstract class used as an intermediate pipe stage between executed processes.">stx::PipeFunction</a> to compute an intermediate SHA1 digest see <a class="el" href="a00004.html">examples/functions1.cc</a>. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Jul 30 17:07:12 2010 for STX Execution Pipe by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
