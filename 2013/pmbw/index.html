<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><title>pmbw - Parallel Memory Bandwidth Benchmark / Measurement - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="http://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="http://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/js/base.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body style="background-image: url(/img/bgfractal2.jpg)"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/">Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li class="nt"><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li><li class="ns"><a href="/search.html">Search</a></li></ul></li><li class="top"><a class="ni" href="/tags/">Tags</a><div style="width: 14em; margin-left: -9em; margin-top: 4px"><a style="font-size: 10pt" href="/tags/algebra.html">algebra</a> <a style="font-size: 16pt" href="/tags/c++.html">c++</a> <a style="font-size: 12pt" href="/tags/code-example.html">code-example</a> <a style="font-size: 14pt" href="/tags/code-snippet.html">code-snippet</a> <a style="font-size: 11pt" href="/tags/coding_tricks.html">coding tricks</a> <a style="font-size: 10pt" href="/tags/compsci.html">compsci</a> <a style="font-size: 10pt" href="/tags/compsci_study_thesis.html">compsci study thesis</a> <a style="font-size: 9pt" href="/tags/crypto-speedtest.html">crypto-speedtest</a> <a style="font-size: 10pt" href="/tags/cryptography.html">cryptography</a> <a style="font-size: 9pt" href="/tags/cryptote.html">cryptote</a> <a style="font-size: 12pt" href="/tags/flex-bison-cpp-example.html">flex-bison-cpp-example</a> <a style="font-size: 13pt" href="/tags/frontpage.html">frontpage</a> <a style="font-size: 13pt" href="/tags/fun.html">fun</a> <a style="font-size: 10pt" href="/tags/graphviz.html">graphviz</a> <a style="font-size: 9pt" href="http://www.hmtg.de">hartmetall</a> <a style="font-size: 9pt" href="/tags/helppc.html">helppc</a> <a style="font-size: 9pt" href="/tags/hifi_selbstbau.html">hifi selbstbau</a> <a style="font-size: 10pt" href="/tags/latex.html">latex</a> <a style="font-size: 10pt" href="/tags/librivox.html">librivox</a> <a style="font-size: 10pt" href="/tags/linux.html">linux</a> <a style="font-size: 10pt" href="/tags/maths.html">maths</a> <a style="font-size: 9pt" href="/tags/music.html">music</a> <a style="font-size: 10pt" href="/tags/netfundamentals.html">netfundamentals</a> <a style="font-size: 11pt" href="/tags/ns-3.html">ns-3</a> <a style="font-size: 9pt" href="/tags/parallel-string-sorting.html">parallel-string-sorting</a> <a style="font-size: 9pt" href="/tags/qtsqlview.html">qtsqlview</a> <a style="font-size: 10pt" href="/tags/research.html">research</a> <a style="font-size: 11pt" href="/tags/sdios06.html">sdios06</a> <a style="font-size: 9pt" href="/tags/sdlfractal.html">sdlfractal</a> <a style="font-size: 11pt" href="/tags/sorting.html">sorting</a> <a style="font-size: 10pt" href="/tags/stringology.html">stringology</a> <a style="font-size: 16pt" href="/tags/stx-btree.html">stx-btree</a> <a style="font-size: 9pt" href="/tags/stx-exparser.html">stx-exparser</a> <a style="font-size: 10pt" href="/tags/stxxl.html">stxxl</a> <a style="font-size: 15pt" href="/tags/talk.html">talk</a> <a style="font-size: 10pt" href="/tags/tutorium.html">tutorium</a> <a style="font-size: 16pt" href="/tags/university.html">university</a> <a style="font-size: 13pt" href="/tags/utilities.html">utilities</a> <a style="font-size: 9pt" href="/tags/webdesign.html">webdesign</a> </div></li><li class="top"> <a class="ni" href="#">Projects</a> <ul style="margin-left: -8em; margin-top: 4px;" class="nx"> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2013/parallel-string-sorting/">parallel-string-sorting</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li class="nt"><a href="/2013/1212-stxxl-1.4.0/">STXXL 1.4</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="#">Research</a> <ul style="margin-left: -16em; margin-top: 4px" class="nx"> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP - External Memory Suffix Sorting</a></li> <li><a href="/2013/parallel-string-sorting/">pS5 - Parallel String Sorting</a></li> <li><a href="/tags/stxxl.html">STXXL - External Memory Algorithms</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="/about/">About</a> <ul style="margin-left: -6em; margin-top: 4px" class="nx"> <li><a href="/about/">Timo Bingmann</a></li> <li><a href="/about/impressum.html">Impressum</a></li> </ul></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2013/">2013</a> / <a href="/2013/pmbw/">pmbw</a></div></div><div class="pttextcontent"><div style="float: right; clear: right;"> <ul class="vlinks"> <li><a href="index.html#top">pmbw</a></li> <li><a href="index.html#downloads">Downloads</a></li> <li><a href="index.html#description">Benchmarks</a></li> <li><a href="results.html" class="last">Results</a></li> </ul></div><div style="float: right; clear: right; margin: 12pt 0pt 12pt 12pt; font-size: smaller; text-align: center"><a href="/2013/pmbw/"><img src="/2013/pmbw/thumb.png" width="300" height="248" alt="Thumbnail of a pmbw plot showing memory bandwidth benchmark results of an Intel i7-920" title="Thumbnail of a pmbw plot showing memory bandwidth benchmark results of an Intel i7-920" /></a></div><h1>pmbw - Parallel Memory Bandwidth Benchmark / Measurement</h1><p class="info">Posted on 2013-07-08, last updated 2013-12-12 by <a href="/about/">Timo Bingmann</a><a href="http://plus.google.com/+TimoBingmann?rel=author"></a> at <a href="/2013/pmbw/">Permlink</a>.</p><h2><a id="summary"></a>Summary</h2><p>The tool <strong><code>pmbw</code></strong> is a set of assembler routines to measure the <strong>parallel memory (cache and RAM) bandwidth</strong> of modern multi-core machines. Memory bandwidth is one of the key performance factors of any computer system. And today, measuring the memory performance often gives a <strong>more realistic view</strong> on the overall speed of a machine <strong>than pure arithmetic or floating-point benchmarks</strong>. This is due to the speed of computation units in modern CPUs growing faster than the memory bandwidth, which however is required to get more information to the CPU. The bigger the processed data amount gets, the more important memory bandwidth becomes!</p><p>The <strong><code>pmbw</code></strong> tool contains a set of very basic functions, which are all <strong>hand-coded in assembler</strong> to avoid any compiler optimizations. These basic functions are modeled after the <strong>basic inner loops</strong> found in any data processing: <strong>sequential scanning</strong> and <strong>pure random access</strong>. Any application will have a memory access pattern that is somewhere between these two extremes.</p><p>Besides these two access patterns, the basic functions benchmark different modes of memory access. Depending on the architecture, <strong>16- / 32- / 64- / 128- or 256-bit memory transfers</strong> are tested by using different machine instructions, like MMX, SSE or AVX. Furthermore, iterating by pointers is compared against access via array index. The current version of <code>pmbw</code> supports benchmarking <strong>x86_32-bit</strong>, <strong>x86_64-bit</strong> and <strong>ARMv6</strong> systems.</p><p>Most important feature of this benchmark is that it will perform the tests <strong>in parallel with growing number of threads</strong>. The results of these scalability tests highlight the basic problem which parallel multi-core algorithms must cope with: <strong>scanning memory bandwidth does not scale</strong> with the number of cores in current systems. The <strong>ratio</strong> of bandwidth <strong>to cache</strong> over the bandwidth <strong>to RAM</strong> determines the amount of local cache-based processing which must be done between RAM accesses for an algorithm to scale well.</p><p>This web page also contain a <a href="results.html">set of <strong>pmbw results from various multi-core machines</strong></a>.</p><p>See below for a <a href="#description">description of the benchmark routines</a>. The assembler code for <a href="pmbw-0.6/funcs_x86_32.h.html">x86_32</a>, <a href="pmbw-0.6/funcs_x86_64.h.html">x86_64</a> and <a href="pmbw-0.6/funcs_arm.h.html">ARM</a> can also be viewed online.</p><p>The basic idea of measuring memory bandwidth is not new, however, none of the existing benchmarks target multi-core parallelism, growing array sizes and simple program loops. The <a href="http://www.streambench.org/">STREAM benchmark</a> allows tuning for specific hardware and is not in assembler code. <a href="http://zsmith.co/bandwidth.html">Zack Smith&apos;s bandwidth</a> benchmark is limited to sequential bandwidth and was the starting point for designing <code>pmbw</code>.</p><h2><a id="downloads"></a>Downloads</h2><table class="darkfullframe"> <tr> <td colspan="3"><b>pmbw 0.6.2</b> (current) released 2013-12-12</td> </tr> <tr> <td>Source Code Archive:</td> <td><a title="Download pmbw-0.6.2.tar.bz2 (104 KiB)" href="pmbw-0.6.2.tar.bz2">pmbw-0.6.2.tar.bz2 <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAARCAYAAAAG/yacAAAAAXNSR0IArs4c6QAAAmhJREFUKM+Nks9LVFEcxT/3vfGNP7LGcpDGqZmrthBahETQQgkEW4WFkdF+RBgqcOOyCFq0qEWLaNGvXZuihS7Uf8B0UZAwEYM49TRNZ/K9mXz63sx7t4U5jkHQd3G5fM/3fDn3ngM1NTo6yv+U+LuRTqcXBwcHO5qbm5mcnGR2dnZlfn6+IxqNektLS//elEqlVmzbVr29vT8TicQ1KWWPlDK0h4dqh5PJJLlcjndv33QLIZZN07ynaZqnlPoKVPbwA6Sbdx9Tp4k2ywuZm+qwYHpqDqFnhRCFWmnVNz16OYEKKidKvvFNHGrj1qXT9D/IbHyaM8uVHU+Rz7Tw+U5TVd7DVxN4rtvlaY3ZtniC4d5Ohp9ksUwrGmlpoFxYxmmP0ulEzu6ISCYE4JZ+nRsevDAXaztGadtn5MUi1moJ6g3q3DzWVp6KdhRfhLuFEIshAFs1nErEopiFLX6UfK73J1kohlkt6zy7PU6gNwDbAJpSaleepR1B13Wa6sMcFqDvgBEWlH0I/ACUD5Xi7icIsUsqBk0A5D3FxpaGo2C9pJGzAT8Av4zu59cV2r5Pq349+e2AtSJsVQSZYoiP6z4504dAgSp6SXfqvi/q1wB3l7TwIWg//7riOZuiaoL4cwhd73AnxwNhZIFZpZRT9UkmE10gegBdoRgYuPh8ZmZ6RCACJUQBpd4Ddi6X20+DlFKXUjYC4VQqtWzbturr6/sej8ePSykbpJTVWb0mc8qyrHI6nf4yNDSUcBwH13WbHce5aprmU8MwvEgkgmVZB9M9Nja2dz1pGMbl1tbWG7FY7IqU8kxtyn8DMLsNssRtKd0AAAAASUVORK5CYII=" alt="pmbw-0.6.2.tar.bz2" style="margin-bottom: -2px" width="13" height="17"/></a> (104 KiB)</td> <td><a href="pmbw-0.6.2/">Browse online</a><br /> <a href="https://github.com/bingmann/pmbw/compare/pmbw-0.6...pmbw-0.6.2">CommitLog</a></td> </tr> <tr> <td>Binary Executables:<br />(statically linked)</td> <td colspan="2"><a title="Download pmbw-0.6.2-linux_x86-64.tar.bz2 (1.04 MiB)" href="pmbw-0.6.2-linux_x86-64.tar.bz2">pmbw-0.6.2-linux_x86-64.tar.bz2 <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAARCAYAAAAG/yacAAAAAXNSR0IArs4c6QAAAmhJREFUKM+Nks9LVFEcxT/3vfGNP7LGcpDGqZmrthBahETQQgkEW4WFkdF+RBgqcOOyCFq0qEWLaNGvXZuihS7Uf8B0UZAwEYM49TRNZ/K9mXz63sx7t4U5jkHQd3G5fM/3fDn3ngM1NTo6yv+U+LuRTqcXBwcHO5qbm5mcnGR2dnZlfn6+IxqNektLS//elEqlVmzbVr29vT8TicQ1KWWPlDK0h4dqh5PJJLlcjndv33QLIZZN07ynaZqnlPoKVPbwA6Sbdx9Tp4k2ywuZm+qwYHpqDqFnhRCFWmnVNz16OYEKKidKvvFNHGrj1qXT9D/IbHyaM8uVHU+Rz7Tw+U5TVd7DVxN4rtvlaY3ZtniC4d5Ohp9ksUwrGmlpoFxYxmmP0ulEzu6ISCYE4JZ+nRsevDAXaztGadtn5MUi1moJ6g3q3DzWVp6KdhRfhLuFEIshAFs1nErEopiFLX6UfK73J1kohlkt6zy7PU6gNwDbAJpSaleepR1B13Wa6sMcFqDvgBEWlH0I/ACUD5Xi7icIsUsqBk0A5D3FxpaGo2C9pJGzAT8Av4zu59cV2r5Pq349+e2AtSJsVQSZYoiP6z4504dAgSp6SXfqvi/q1wB3l7TwIWg//7riOZuiaoL4cwhd73AnxwNhZIFZpZRT9UkmE10gegBdoRgYuPh8ZmZ6RCACJUQBpd4Ddi6X20+DlFKXUjYC4VQqtWzbturr6/sej8ePSykbpJTVWb0mc8qyrHI6nf4yNDSUcBwH13WbHce5aprmU8MwvEgkgmVZB9M9Nja2dz1pGMbl1tbWG7FY7IqU8kxtyn8DMLsNssRtKd0AAAAASUVORK5CYII=" alt="pmbw-0.6.2-linux_x86-64.tar.bz2" style="margin-bottom: -2px" width="13" height="17"/></a> (1.04 MiB) for x86-64 bit Linux systems<br /> <a title="Download pmbw-0.6.2-win64.zip (329 KiB)" href="pmbw-0.6.2-win64.zip">pmbw-0.6.2-win64.zip <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAARCAYAAAAG/yacAAAAAXNSR0IArs4c6QAAAmhJREFUKM+Nks9LVFEcxT/3vfGNP7LGcpDGqZmrthBahETQQgkEW4WFkdF+RBgqcOOyCFq0qEWLaNGvXZuihS7Uf8B0UZAwEYM49TRNZ/K9mXz63sx7t4U5jkHQd3G5fM/3fDn3ngM1NTo6yv+U+LuRTqcXBwcHO5qbm5mcnGR2dnZlfn6+IxqNektLS//elEqlVmzbVr29vT8TicQ1KWWPlDK0h4dqh5PJJLlcjndv33QLIZZN07ynaZqnlPoKVPbwA6Sbdx9Tp4k2ywuZm+qwYHpqDqFnhRCFWmnVNz16OYEKKidKvvFNHGrj1qXT9D/IbHyaM8uVHU+Rz7Tw+U5TVd7DVxN4rtvlaY3ZtniC4d5Ohp9ksUwrGmlpoFxYxmmP0ulEzu6ISCYE4JZ+nRsevDAXaztGadtn5MUi1moJ6g3q3DzWVp6KdhRfhLuFEIshAFs1nErEopiFLX6UfK73J1kohlkt6zy7PU6gNwDbAJpSaleepR1B13Wa6sMcFqDvgBEWlH0I/ACUD5Xi7icIsUsqBk0A5D3FxpaGo2C9pJGzAT8Av4zu59cV2r5Pq349+e2AtSJsVQSZYoiP6z4504dAgSp6SXfqvi/q1wB3l7TwIWg//7riOZuiaoL4cwhd73AnxwNhZIFZpZRT9UkmE10gegBdoRgYuPh8ZmZ6RCACJUQBpd4Ddi6X20+DlFKXUjYC4VQqtWzbturr6/sej8ePSykbpJTVWb0mc8qyrHI6nf4yNDSUcBwH13WbHce5aprmU8MwvEgkgmVZB9M9Nja2dz1pGMbl1tbWG7FY7IqU8kxtyn8DMLsNssRtKd0AAAAASUVORK5CYII=" alt="pmbw-0.6.2-win64.zip" style="margin-bottom: -2px" width="13" height="17"/></a> (329 KiB) for 64-bit Windows systems<br /> <a title="Download pmbw-0.6.2-linux_armv6.tar.bz2 (859 KiB)" href="pmbw-0.6.2-linux_armv6.tar.bz2">pmbw-0.6.2-linux_armv6.tar.bz2 <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAARCAYAAAAG/yacAAAAAXNSR0IArs4c6QAAAmhJREFUKM+Nks9LVFEcxT/3vfGNP7LGcpDGqZmrthBahETQQgkEW4WFkdF+RBgqcOOyCFq0qEWLaNGvXZuihS7Uf8B0UZAwEYM49TRNZ/K9mXz63sx7t4U5jkHQd3G5fM/3fDn3ngM1NTo6yv+U+LuRTqcXBwcHO5qbm5mcnGR2dnZlfn6+IxqNektLS//elEqlVmzbVr29vT8TicQ1KWWPlDK0h4dqh5PJJLlcjndv33QLIZZN07ynaZqnlPoKVPbwA6Sbdx9Tp4k2ywuZm+qwYHpqDqFnhRCFWmnVNz16OYEKKidKvvFNHGrj1qXT9D/IbHyaM8uVHU+Rz7Tw+U5TVd7DVxN4rtvlaY3ZtniC4d5Ohp9ksUwrGmlpoFxYxmmP0ulEzu6ISCYE4JZ+nRsevDAXaztGadtn5MUi1moJ6g3q3DzWVp6KdhRfhLuFEIshAFs1nErEopiFLX6UfK73J1kohlkt6zy7PU6gNwDbAJpSaleepR1B13Wa6sMcFqDvgBEWlH0I/ACUD5Xi7icIsUsqBk0A5D3FxpaGo2C9pJGzAT8Av4zu59cV2r5Pq349+e2AtSJsVQSZYoiP6z4504dAgSp6SXfqvi/q1wB3l7TwIWg//7riOZuiaoL4cwhd73AnxwNhZIFZpZRT9UkmE10gegBdoRgYuPh8ZmZ6RCACJUQBpd4Ddi6X20+DlFKXUjYC4VQqtWzbturr6/sej8ePSykbpJTVWb0mc8qyrHI6nf4yNDSUcBwH13WbHce5aprmU8MwvEgkgmVZB9M9Nja2dz1pGMbl1tbWG7FY7IqU8kxtyn8DMLsNssRtKd0AAAAASUVORK5CYII=" alt="pmbw-0.6.2-linux_armv6.tar.bz2" style="margin-bottom: -2px" width="13" height="17"/></a> (859 KiB) for 32-bit ARMv6 Linux systems </td> </tr></table><p>The source code is published under the <a href="http://opensource.org/licenses/GPL-3.0">GNU General Public License v3 (GPL)</a>, which can also be found in the file COPYING.</p><p>A git repository containing all sources and revisions is fetchable by running<br /> <code>git clone <a href="https://github.com/bingmann/pmbw">https://github.com/bingmann/pmbw.git</a></code></p><h2><a id="description"></a>Description of the Benchmark Functions</h2><p>When started, <code>pmbw</code> detects how much physical RAM is available and allocates an array, which spans almost all RAM. The allocated array size is the highest power of two, which still fits into RAM. Note that for machines with lots of RAM, this phase can take several minutes.</p><p>Thereafter, one of the assembler benchmark routines is selected and run with</p><ol><li>increasing array size <em>n</em> and</li><li>increasing thread count <em>p</em>, dividing the array evenly among threads.</li></ol><p>The array size is usually doubled after each iteration, with some additional test points inserted between powers of two. The array size starts at 1024 and ends at the total allocated RAM size. For large thread counts, the array size is rounded up so that at least one cache line is allocated to each thread.</p><p>Each benchmark routine contains a repeat loop, because very short tests cannot be measured due to limited timer resolution. Therefore, the <code>pmbw</code> tool repeats the inner loop many, many times, so that a whole test instance requires at least one second. The actual number of repeats of a test instance is estimated by <code>pmbw</code> depending on the bandwidth result of the previous test. Thus, each test routine runs at least approximately 1.5 seconds. However, larger benchmark instances can take considerably longer even for one repetition.</p><p>The names of the benchmark routines is composed of several abbreviated components, which together specify the exact operations:</p><ul><li><strong>Scan</strong> indicates scanning operations, while <strong>Perm</strong> are permutation walking tests (see below).</li><li><strong>Write/Read</strong> specifies the operation done.</li><li><strong>16/32/64/128/256</strong> indicates the number of bits transfered by a single instruction in the benchmark routine. Which exactly are available depends on the architecture.</li><li><strong>Ptr</strong> represents pointer-based iteration, while <strong>Index</strong> is index-based array access.</li><li><strong>SimpleLoop</strong> routines contain only one operation per loop, after which the end condition is checked. <strong>UnrollLoop</strong> benchmarks contain 16 operations per loop, followed by the end check.</li></ul><p>Thus, for example, <strong><code>ScanWrite64PtrUnrollLoop</code></strong> is a benchmark routing with scanning pointer-based access pattern, performing 16 operations per loop, and writing 64-bit per instruction. This benchmark routine comes closest to what <code>memset()</code> would do on a 64-bit machine.</p><h3>Scanning Operation</h3><p>A side-goal of <code>pmbw</code> was to check which kind of access loop is faster: running iterators/pointers like <code>*ptr++</code> or array indexes like <code>array[i++]</code>. Just about any C/C++ program uses both of these access loops, and most STL documentations say that pointer access is faster. I decided to put this folk wisdom to the test. Obviously, pointer access requires one register less than index-based access, but is it really faster?</p><p>Another goal was to check whether loop unrolling really has a positive effect. Generally, this was the case for all routines, thus for pure memory bandwidth results, one should concentrate on the <code>UnrollLoop</code> benchmarks.</p><p>The benchmark routines are coded in gcc inline assembly, however, for easier exposition, the same routines are shown in C/C++ syntax below. We first set <span class="codesnippet codeframe" style="font-size: 10pt; font-family: monospace"><tt><span class="usertype">size_t</span><span class="normal"> an </span><span class="symbol">=</span><span class="normal"> n </span><span class="symbol">/</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">uint64_t</span><span class="symbol">);</span></tt></span> to correctly count the number of 64-bit integers in the array.</p><p>A selection of the 64-bit scanning benchmarks in C/C++ representation are shown below. The first batch use pointer-based iteration, as would be used with STL iterators:</p><table><tr><td style="vertical-align: middle"><div class="codesnippet codeframe" style="font-size: 10pt; font-family: monospace"><pre><tt><span class="comment">// ScanRead64PtrSimpleLoop</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">uint64_t</span><span class="symbol">*</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> array</span><span class="symbol">;</span><span class="normal"> p </span><span class="symbol">&lt;</span><span class="normal"> array </span><span class="symbol">+</span><span class="normal"> an</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">p</span><span class="symbol">)</span>
<span class="normal">    </span><span class="usertype">uint64_t</span><span class="normal"> x </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">p</span><span class="symbol">;</span></tt></pre></div><div class="codesnippet codeframe" style="font-size: 10pt; font-family: monospace"><pre><tt><span class="comment">// ScanWrite64PtrSimpleLoop</span>
<span class="usertype">uint64_t</span><span class="normal"> x </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0xC0FFEE00C0FFEE00</span><span class="symbol">;</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">uint64_t</span><span class="symbol">*</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> array</span><span class="symbol">;</span><span class="normal"> p </span><span class="symbol">&lt;</span><span class="normal"> array </span><span class="symbol">+</span><span class="normal"> an</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">p</span><span class="symbol">)</span>
<span class="normal">    </span><span class="symbol">*</span><span class="normal">p </span><span class="symbol">=</span><span class="normal"> x</span><span class="symbol">;</span></tt></pre></div></td><td style="vertical-align: middle"><div class="codesnippet codeframe" style="font-size: 10pt; font-family: monospace"><pre><tt><span class="comment">// ScanRead64PtrUnrollLoop</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">uint64_t</span><span class="symbol">*</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> array</span><span class="symbol">;</span><span class="normal"> p </span><span class="symbol">&lt;</span><span class="normal"> array </span><span class="symbol">+</span><span class="normal"> an</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">p</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">uint64_t</span><span class="normal"> x0 </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">p</span><span class="symbol">+</span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="usertype">uint64_t</span><span class="normal"> x1 </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">p</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">    </span><span class="comment">// ... 13 times</span>
<span class="normal">    </span><span class="usertype">uint64_t</span><span class="normal"> x15 </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">p</span><span class="symbol">+</span><span class="number">15</span><span class="symbol">);</span>
<span class="cbracket">}</span>
<span class="comment">// ScanWrite64PtrUnrollLoop omitted</span></tt></pre></div></td></tr></table><p>The following second batch of benchmark routines use array index-based access operations:</p><table><tr><td style="vertical-align: middle"><div class="codesnippet codeframe" style="font-size: 10pt; font-family: monospace"><pre><tt><span class="comment">// ScanRead64IndexSimpleLoop</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> an</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">    </span><span class="usertype">uint64_t</span><span class="normal"> x </span><span class="symbol">=</span><span class="normal"> array</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span></tt></pre></div><div class="codesnippet codeframe" style="font-size: 10pt; font-family: monospace"><pre><tt><span class="comment">// ScanWrite64IndexSimpleLoop</span>
<span class="usertype">uint64_t</span><span class="normal"> x </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0xC0FFEE00C0FFEE00</span><span class="symbol">;</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> an</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">    array</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> x</span><span class="symbol">;</span></tt></pre></div></td><td style="vertical-align: middle"><div class="codesnippet codeframe" style="font-size: 10pt; font-family: monospace"><pre><tt><span class="comment">// ScanRead64IndexUnrollLoop</span>
<span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> an</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">+=</span><span class="normal"> </span><span class="number">16</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="usertype">uint64_t</span><span class="normal"> x0 </span><span class="symbol">=</span><span class="normal"> array</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">+</span><span class="number">0</span><span class="symbol">];</span>
<span class="normal">    </span><span class="usertype">uint64_t</span><span class="normal"> x1 </span><span class="symbol">=</span><span class="normal"> array</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">    </span><span class="comment">// ... 13 times</span>
<span class="normal">    </span><span class="usertype">uint64_t</span><span class="normal"> x15 </span><span class="symbol">=</span><span class="normal"> array</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">+</span><span class="number">15</span><span class="symbol">];</span>
<span class="cbracket">}</span>
<span class="comment">// ScanWrite64IndexUnrollLoop omitted</span></tt></pre></div></td></tr></table><p>Note that gcc&apos;s optimization will detect that the <code>Read</code> variants of these C/C++ loops don&apos;t accomplish anything and completely remove the loop. Likewise it will optimize writing depending on the <code>-march=</code> switch. However, for <code>pmbw</code> all these optimizations are irrelevant, as the benchmark routines are coded in assembler. Loops with 16-/32-/128-/256-bit data types look similar, but use special CPU instructions.</p><p>When using multiple threads, the scanned array is divided evenly among threads. The following figure illustrates the access pattern:</p><p><img alt="Scanning an array with multiple threads" src="scan-array.png" title="Scanning an array with multiple threads" width="700" height="51" /></p><p>To avoid side effects due to adjoint array regions, for smaller test instance sizes the thread&apos;s individual areas are spaced out! This is necessary, as otherwise cache line thrashing effects show in the <code>Write</code> tests. The spacing between thread areas is irregular, which helps to avoid cache associativity problems.</p><p>Modern CPUs will heavily optimize the scanning access pattern using prefetching (look-ahead reading) and write combining of cache lines. Benchmarking of these effects is intentional, but most programs do not use pure scanning operations.</p><h3>Random Permutation Walking</h3><p>The second set of benchmark tests walk a random pointer permutation: each array cell accessed in the array yields the position of the next access. For this pattern all look-ahead optimizations of modern CPUs are useless and the measured time is the raw bandwidth and latency of a single memory fetch cycle, without tricks. Though this benchmark may seem artificial, it is really much closer to a real-world data processing application than plain scanning. Nevertheless, it is probably the access pattern where all optimizations must fail.</p><p>Before the test benchmark routine is called, the array area of each thread is filled with a random cyclic permutation of pointers. Thus for two threads, the allocated array will have the following layout:</p><p><img alt="Walking separate random pointer permutations with multiple threads" src="perm-walk.png" title="Walking separate random pointer permutations with multiple threads" width="700" height="72" /></p><p>Then the benchmark routine walks the permutation, it finishes when the cycle is complete. The C/C++ representations of this benchmark&apos;s two routines is shown below:</p><table><tr><td style="vertical-align: top"><div class="codesnippet codeframe" style="font-size: 10pt; font-family: monospace"><pre><tt><span class="comment">// PermRead64SimpleLoop</span>
<span class="usertype">uint64_t</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">array</span><span class="symbol">;</span>
<span class="keyword">while</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">uint64_t</span><span class="symbol">*)</span><span class="normal">p </span><span class="symbol">!=</span><span class="normal"> array </span><span class="symbol">)</span>
<span class="normal">    p </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">uint64_t</span><span class="symbol">*)</span><span class="normal">p</span><span class="symbol">;</span></tt></pre></div></td><td style="vertical-align: top"><div class="codesnippet codeframe" style="font-size: 10pt; font-family: monospace"><pre><tt><span class="comment">// PermRead64UnrollLoop</span>
<span class="usertype">uint64_t</span><span class="normal"> p </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">array</span><span class="symbol">;</span>
<span class="keyword">while</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">uint64_t</span><span class="symbol">*)</span><span class="normal">p </span><span class="symbol">!=</span><span class="normal"> array </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">    p </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">uint64_t</span><span class="symbol">*)</span><span class="normal">p</span><span class="symbol">;</span>
<span class="normal">    </span><span class="comment">// ... 14 more times</span>
<span class="normal">    p </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">uint64_t</span><span class="symbol">*)</span><span class="normal">p</span><span class="symbol">;</span>
<span class="cbracket">}</span></tt></pre></div></td></tr></table><p>There currently is no <code>Write</code> version of this benchmark. Obviously, no <code>Index</code> variant makes sense.</p><h1>Compiling and Running <code>pmbw</code></h1><p>The benchmark tool is simple to compile, because it only requires <code>pthreads</code> and the <code>rt</code> libraries. The standard <code>./configure &amp;&amp; make</code> sequence will build <code>pmbw</code> and <code>stats2gnuplot</code> binaries.</p><p>Running <code>pmbw</code> will <strong>immediately start</strong> the benchmark. All statistical output of <code>pmbw</code> is written to the file <code>stats.txt</code> in the current directory. To correctly run the benchmark, all but the most important system daemons must be stopped. It is also recommended to run with higher nice priority:</p><div class="codesnippet termframe" style="font-size: 10pt; font-family: monospace"><pre><tt># nice -n -2 ./pmbw -s 0
CPUID: mmx sse
Detected 5967 MiB physical RAM and 8 CPUs. 
Allocating 4096 MiB for testing.
Running nthreads=1 factor=1073741824 areasize=1024 thrsize=1152 testsize=1152 repeats=932068 testvol=1073742336 testaccess=134217792
run time = 0.108137 -&gt; rerunning test with repeat factor=14894262055
Running nthreads=1 factor=14894262055 areasize=1024 thrsize=1152 testsize=1152 repeats=12929047 testvol=14894262144 testaccess=1861782768
run time = 1.25262 -&gt; next test with repeat factor=17835729058
[...]
# </tt></pre></div><p>The benchmark continuously outputs <code>RESULT</code> lines to <strong><code>stats.txt</code></strong>, which contain <code>key=value</code> pairs specifying all information about a single benchmark routine run.</p><p>The <code>pmbw -s 0</code> call above contains <code>-s 0</code>, which instructs <code>pmbw</code> to test all array sizes. Without this option, only sizes up to 4 GiB are benchmarked. This is safety flag, because <code>pmbw</code> runs very long on systems with lots of RAM.</p><p>To visualize the statistical output, the <code>stats2gnuplot</code> program can create a PDF via gnuplot. The output PDF is called <code>plots-<em>host</em>.pdf</code> and can be generated by calling:</p><div class="codesnippet termframe" style="font-size: 10pt; font-family: monospace"><pre><tt># ./stats2gnuplot stats.txt | gnuplot</tt></pre></div><p>Running <code>pmbw -h</code> yields some additional command line options:</p><div class="codesnippet termframe" style="font-size: 10pt; font-family: monospace"><pre><tt>Usage: ./pmbw [options]
Options:
  -f &lt;match&gt;     Run only benchmarks containing this substring, can be used multile times. Try &quot;list&quot;.
  -M &lt;size&gt;      Limit the maximum amount of memory allocated at startup.
  -p &lt;nthrs&gt;     Run benchmarks with at least this thread count.
  -P &lt;nthrs&gt;     Run benchmarks with at most this thread count (overrides detected processor count).
  -Q             Run benchmarks with quadratically increasing thread count.
  -s &lt;size&gt;      Limit the maximum test array size. Set to 0 for no limit.</tt></pre></div><h2><a id="old_downloads"></a>Older Downloads</h2><table class="darkfullframe"> <tr> <td colspan="3"><b>pmbw 0.6</b> released 2013-07-08</td> </tr> <tr> <td>Source code archive:</td> <td><a title="Download pmbw-0.6.tar.bz2 (81.9 KiB)" href="pmbw-0.6.tar.bz2">pmbw-0.6.tar.bz2 <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAARCAYAAAAG/yacAAAAAXNSR0IArs4c6QAAAmhJREFUKM+Nks9LVFEcxT/3vfGNP7LGcpDGqZmrthBahETQQgkEW4WFkdF+RBgqcOOyCFq0qEWLaNGvXZuihS7Uf8B0UZAwEYM49TRNZ/K9mXz63sx7t4U5jkHQd3G5fM/3fDn3ngM1NTo6yv+U+LuRTqcXBwcHO5qbm5mcnGR2dnZlfn6+IxqNektLS//elEqlVmzbVr29vT8TicQ1KWWPlDK0h4dqh5PJJLlcjndv33QLIZZN07ynaZqnlPoKVPbwA6Sbdx9Tp4k2ywuZm+qwYHpqDqFnhRCFWmnVNz16OYEKKidKvvFNHGrj1qXT9D/IbHyaM8uVHU+Rz7Tw+U5TVd7DVxN4rtvlaY3ZtniC4d5Ohp9ksUwrGmlpoFxYxmmP0ulEzu6ISCYE4JZ+nRsevDAXaztGadtn5MUi1moJ6g3q3DzWVp6KdhRfhLuFEIshAFs1nErEopiFLX6UfK73J1kohlkt6zy7PU6gNwDbAJpSaleepR1B13Wa6sMcFqDvgBEWlH0I/ACUD5Xi7icIsUsqBk0A5D3FxpaGo2C9pJGzAT8Av4zu59cV2r5Pq349+e2AtSJsVQSZYoiP6z4504dAgSp6SXfqvi/q1wB3l7TwIWg//7riOZuiaoL4cwhd73AnxwNhZIFZpZRT9UkmE10gegBdoRgYuPh8ZmZ6RCACJUQBpd4Ddi6X20+DlFKXUjYC4VQqtWzbturr6/sej8ePSykbpJTVWb0mc8qyrHI6nf4yNDSUcBwH13WbHce5aprmU8MwvEgkgmVZB9M9Nja2dz1pGMbl1tbWG7FY7IqU8kxtyn8DMLsNssRtKd0AAAAASUVORK5CYII=" alt="pmbw-0.6.tar.bz2" style="margin-bottom: -2px" width="13" height="17"/></a> (81.9 KiB)</td> <td><a href="pmbw-0.6/">Browse online</a></td> </tr></table></div><div style="text-align: right; padding: 8pt; font-size: 12px"><a href="/xmlfeed/weblog-rss20.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABQAAAADwCexKkxAAAAWUlEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMCt0ZdTU/F/7/+1HEkydFpoKVPn+93sUlUujQvP/7UcRTAuNDJ2a//s/imDqtKVZofm/1qGYSZk7sfodGwAAiobBJtffoNAAAAAASUVORK5CYII=" alt="RSS 2.0 Weblog Feed" width="80" height="15"/></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAAaklEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMDV16rTQ/H/7V//69+//v/3/9oMEI6cuAwr+fv/+/b5d///v//0eJBgWOhMo+Gs9UPAdXDBy6lSYyn9wQZCZS0GCYDPXQcykzJ1Y/Y4NAABKvL80wyoMPgAAAABJRU5ErkJggg==" alt="Atom 1.0 Weblog Feed" width="80" height="15"/></a> <a href="http://validator.w3.org/check?uri=referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABKklEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6qIGzIRiKZs9GFoEaMRuZhhrYqqJXy8uZYauRxC/VHew7e3YTPAxnI5swG6JxNrKBNjB1EFmIgV0+HA6C8pqqzhXG7BbJJROQIwViMYQ7G2oDQQNn57JyG7kxiCfObrBmS5+BHMuYLkTzMnYDm5WY4lOZZRPKZocxes+aPbuwCFsYohiICLvZsKBAMrDTQ7K/StveU8icTzrOL8JdLpOyWJ49u8Bx9ozw8DY7UYW03hhdxZAOSg2c3jN79rSJs1vSKmfOnpFXNJmynELlvExlAADnaZpLFGEC2wAAAABJRU5ErkJggg==" alt="Valid XHTML 1.1" width="80" height="15"/></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABEUlEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6mIEQCsIjwhKoga0qerW8nBm2Gkn8Ut3BvrNnN8HCcDYM2cBIogzs8uFwEJTXVHWuMGa3SC6ZgIgUqCEwdxJr4OxcVm4jNwbxxNkN1mzpM2ajGIjsPGK9PLtZiSk+lVk2oWx2GKP3rNmzC4tQwpDoIIQb2Okh2V+lbe8pZM4nHecX4S6XSVksz55d4Dh7Rnh4m52oQlpvjK5iSAelBk7vmT172sTZLWmVM2fPyCuaTFlOoXJepjIAANlljDGY/l5pAAAAAElFTkSuQmCC" alt="Valid CSS (2.1)" width="80" height="15"/></a><br/>Copyright 2005-2014 <a href="/about/">Timo Bingmann</a> - <a href="/about/impressum.html">Impressum</a></div><script type="text/javascript">var _paq = _paq || []; _paq.push(["trackPageView"]); _paq.push(["enableLinkTracking"]);(function() {var u=(("https:" == document.location.protocol) ? "https" : "http") + "://panthema.net/wik-331/"; _paq.push(["setTrackerUrl", u+"js/"]); _paq.push(["setSiteId", "2"]);var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";g.defer=true; g.async=true; g.src=u+"js/"; s.parentNode.insertBefore(g,s);})();</script><noscript><p><img src="http://panthema.net/wik-331/js/?idsite=2&amp;rec=1" style="border:0" alt="" /></p></noscript></body></html>