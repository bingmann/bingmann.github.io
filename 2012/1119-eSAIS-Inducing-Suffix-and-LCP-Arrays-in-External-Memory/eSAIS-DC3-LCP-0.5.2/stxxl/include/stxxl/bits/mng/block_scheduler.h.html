<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><title>/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/include/stxxl/bits/mng/block_scheduler.h - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="http://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="http://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/js/base.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body style="background-image: url(/img/bgfractal8.jpg)"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/">Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2014/">2014</a></li><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li class="nt"><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li><li class="ns"><a href="/search.html">Search</a></li></ul></li><li class="top"><a class="ni" href="/tags/">Tags</a><div style="width: 14em; margin-left: -9em; margin-top: 4px"><a style="font-size: 10pt" href="/tags/algebra.html">algebra</a> <a style="font-size: 16pt" href="/tags/c++.html">c++</a> <a style="font-size: 12pt" href="/tags/code-example.html">code-example</a> <a style="font-size: 14pt" href="/tags/code-snippet.html">code-snippet</a> <a style="font-size: 11pt" href="/tags/coding_tricks.html">coding tricks</a> <a style="font-size: 10pt" href="/tags/compsci.html">compsci</a> <a style="font-size: 10pt" href="/tags/compsci_study_thesis.html">compsci study thesis</a> <a style="font-size: 9pt" href="/tags/crypto-speedtest.html">crypto-speedtest</a> <a style="font-size: 10pt" href="/tags/cryptography.html">cryptography</a> <a style="font-size: 9pt" href="/tags/cryptote.html">cryptote</a> <a style="font-size: 12pt" href="/tags/flex-bison-cpp-example.html">flex-bison-cpp-example</a> <a style="font-size: 13pt" href="/tags/frontpage.html">frontpage</a> <a style="font-size: 13pt" href="/tags/fun.html">fun</a> <a style="font-size: 10pt" href="/tags/graphviz.html">graphviz</a> <a style="font-size: 9pt" href="http://www.hmtg.de">hartmetall</a> <a style="font-size: 9pt" href="/tags/helppc.html">helppc</a> <a style="font-size: 9pt" href="/tags/hifi_selbstbau.html">hifi selbstbau</a> <a style="font-size: 10pt" href="/tags/latex.html">latex</a> <a style="font-size: 10pt" href="/tags/librivox.html">librivox</a> <a style="font-size: 10pt" href="/tags/linux.html">linux</a> <a style="font-size: 10pt" href="/tags/maths.html">maths</a> <a style="font-size: 9pt" href="/tags/music.html">music</a> <a style="font-size: 10pt" href="/tags/netfundamentals.html">netfundamentals</a> <a style="font-size: 11pt" href="/tags/ns-3.html">ns-3</a> <a style="font-size: 10pt" href="/tags/parallel-string-sorting.html">parallel-string-sorting</a> <a style="font-size: 9pt" href="/tags/qtsqlview.html">qtsqlview</a> <a style="font-size: 10pt" href="/tags/research.html">research</a> <a style="font-size: 11pt" href="/tags/sdios06.html">sdios06</a> <a style="font-size: 9pt" href="/tags/sdlfractal.html">sdlfractal</a> <a style="font-size: 12pt" href="/tags/sorting.html">sorting</a> <a style="font-size: 10pt" href="/tags/stringology.html">stringology</a> <a style="font-size: 16pt" href="/tags/stx-btree.html">stx-btree</a> <a style="font-size: 9pt" href="/tags/stx-exparser.html">stx-exparser</a> <a style="font-size: 10pt" href="/tags/stxxl.html">stxxl</a> <a style="font-size: 15pt" href="/tags/talk.html">talk</a> <a style="font-size: 10pt" href="/tags/tutorium.html">tutorium</a> <a style="font-size: 16pt" href="/tags/university.html">university</a> <a style="font-size: 13pt" href="/tags/utilities.html">utilities</a> <a style="font-size: 9pt" href="/tags/webdesign.html">webdesign</a> </div></li><li class="top"> <a class="ni" href="#">Projects</a> <ul style="margin-left: -8em; margin-top: 4px;" class="nx"> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2013/parallel-string-sorting/">parallel-string-sorting</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li class="nt"><a href="/2013/1212-stxxl-1.4.0/">STXXL 1.4</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="#">Research</a> <ul style="margin-left: -16em; margin-top: 4px" class="nx"> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP - External Memory Suffix Sorting</a></li> <li><a href="/2013/parallel-string-sorting/">Parallel String Sorting</a></li> <li><a href="/tags/stxxl.html">STXXL - External Memory Algorithms</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="/about/">About</a> <ul style="margin-left: -6em; margin-top: 4px" class="nx"> <li><a href="/about/">Timo Bingmann</a></li> <li><a href="/about/impressum.html">Impressum</a></li> </ul></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2012/">2012</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/">eSAIS-DC3-LCP-0.5.2</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/">stxxl</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/include/">include</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/include/stxxl/">stxxl</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/include/stxxl/bits/">bits</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/include/stxxl/bits/mng/">mng</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/include/stxxl/bits/mng/block_scheduler.h.html">block_scheduler.h</a> (<a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/include/stxxl/bits/mng/block_scheduler.h">Download File</a>)</div></div><div class="ptfullwidth"><pre class="codesnippet" style="font-family: monospace"><tt><span class="comment">/***************************************************************************</span>
<span class="comment"> *  include/stxxl/bits/mng/block_scheduler.h</span>
<span class="comment"> *</span>
<span class="comment"> *  Part of the STXXL. See </span><span class="url">http://stxxl.sourceforge.net</span>
<span class="comment"> *</span>
<span class="comment"> *  Copyright (C) 2010-2011 Raoul Steffen </span><span class="url">&lt;R-Steffen@gmx.de&gt;</span>
<span class="comment"> *</span>
<span class="comment"> *  Distributed under the Boost Software License, Version 1.0.</span>
<span class="comment"> *  (See accompanying file LICENSE_1_0.txt or copy at</span>
<span class="comment"> *  </span><span class="url">http://www.boost.org/LICENSE_1_0.txt</span><span class="comment">)</span>
<span class="comment"> **************************************************************************/</span>

<span class="preproc">#ifndef</span><span class="normal"> STXXL_BLOCK_SCHEDULER_HEADER</span>
<span class="preproc">#define</span><span class="normal"> STXXL_BLOCK_SCHEDULER_HEADER</span>

<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;stack&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;queue&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;limits&gt;</span>

<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;stxxl/bits/mng/mng.h&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;stxxl/bits/mng/typed_block.h&gt;</span>
<span class="preproc">#include</span><span class="normal"> </span><span class="string">&lt;stxxl/bits/common/addressable_queues.h&gt;</span>

<span class="normal">__STXXL_BEGIN_NAMESPACE</span>

<span class="comment">//! \brief Virtualization of a block of data.</span>
<span class="comment">//! Holds information for allocating and swapping. To use in cooperation with block_scheduler.</span>
<span class="comment">//!</span>
<span class="comment">//! A swappable_block can be uninitialized, i.e. it holds no data.</span>
<span class="comment">//! When access is required, is has to be acquired first, and released afterwards, so it can be swapped in and out as required.</span>
<span class="comment">//! If the stored data is no longer needed, it can get uninitialized, freeing both internal and external memory.</span>
<span class="comment">//! \tparam ValueType type of contained objects (POD with no references to internal memory).</span>
<span class="comment">//! \tparam BlockSize Number of objects in one block.</span>
<span class="comment">//!         BlockSize*sizeof(ValueType) must be divisible by 4096.</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">ValueType</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> BlockSize</span><span class="symbol">&gt;</span>
<span class="keyword">class</span><span class="normal"> </span><span class="classname">swappable_block</span>
<span class="cbracket">{</span>
<span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">unsigned_type</span><span class="normal"> raw_block_size </span><span class="symbol">=</span><span class="normal"> BlockSize </span><span class="symbol">*</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">ValueType</span><span class="symbol">);</span>
<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">typed_block&lt;raw_block_size, ValueType&gt;</span><span class="normal"> internal_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">internal_block_type</span><span class="symbol">::</span><span class="usertype">bid_type</span><span class="normal"> external_block_type</span><span class="symbol">;</span>

<span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">    </span><span class="usertype">external_block_type</span><span class="normal"> external_data</span><span class="symbol">;</span><span class="normal">      </span><span class="comment">//!external_data.valid if no associated space on disk</span>
<span class="normal">    internal_block_type </span><span class="symbol">*</span><span class="normal"> internal_data</span><span class="symbol">;</span><span class="normal">    </span><span class="comment">//NULL if there is no internal memory reserved</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> dirty</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">int_type</span><span class="normal"> reference_count</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">unsigned_type</span><span class="normal"> disk_allocation_offset</span><span class="symbol">;</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">get_external_block</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> block_manager</span><span class="symbol">::</span><span class="function">get_instance</span><span class="symbol">()-&gt;</span><span class="function">new_block</span><span class="symbol">(</span><span class="function">striping</span><span class="symbol">(),</span><span class="normal"> external_data</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">disk_allocation_offset</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">free_external_block</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        block_manager</span><span class="symbol">::</span><span class="function">get_instance</span><span class="symbol">()-&gt;</span><span class="function">delete_block</span><span class="symbol">(</span><span class="normal">external_data</span><span class="symbol">);</span>
<span class="normal">        external_data </span><span class="symbol">=</span><span class="normal"> </span><span class="function">external_block_type</span><span class="symbol">();</span><span class="normal"> </span><span class="comment">// make invalid</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">//! \brief Create in uninitialized state.</span>
<span class="normal">    </span><span class="function">swappable_block</span><span class="symbol">()</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">external_data</span><span class="symbol">()</span><span class="normal"> </span><span class="comment">/*!valid*/</span><span class="symbol">,</span><span class="normal"> </span><span class="function">internal_data</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">),</span><span class="normal"> </span><span class="function">dirty</span><span class="symbol">(</span><span class="keyword">false</span><span class="symbol">),</span><span class="normal"> </span><span class="function">reference_count</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">    </span><span class="symbol">~</span><span class="function">swappable_block</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">    </span><span class="comment">//! \brief If it has an internal_block. The internal_block implicitly holds valid data.</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_internal</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> internal_data</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief If the external_block does not hold valid data.</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_dirty</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> dirty</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief If it has an external_block.</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">has_external_block</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> external_data</span><span class="symbol">.</span><span class="function">valid</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief If it has an external_block that holds valid data.</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_external</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="function">has_external_block</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal"> </span><span class="function">is_dirty</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief If it is acquired.</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_acquired</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> reference_count </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief If it holds an internal_block but does not need it.</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_evictable</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">!</span><span class="normal"> </span><span class="function">is_acquired</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">is_internal</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief If it has some valid data (in- or external).</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_initialized</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="function">is_internal</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="function">is_external</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Invalidate external data if true.</span>
<span class="normal">    </span><span class="comment">//! \return is_dirty()</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">make_dirty_if</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> make_dirty</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_acquired</span><span class="symbol">());</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> dirty </span><span class="symbol">=</span><span class="normal"> make_dirty </span><span class="symbol">||</span><span class="normal"> dirty</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Acquire the block, i.e. add a reference. Has to be internal.</span>
<span class="normal">    </span><span class="comment">//! \return A reference to the data-block.</span>
<span class="normal">    internal_block_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">acquire</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_internal</span><span class="symbol">());</span>
<span class="normal">        </span><span class="symbol">++</span><span class="normal"> reference_count</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> internal_data</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Release the block, i.e. subduct a reference. Has to be acquired.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">release</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_acquired</span><span class="symbol">());</span>
<span class="normal">        </span><span class="symbol">--</span><span class="normal"> reference_count</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Get a reference to the data-block. Has to be acquired.</span>
<span class="normal">    </span><span class="keyword">const</span><span class="normal"> internal_block_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">get_internal_block</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_acquired</span><span class="symbol">());</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> internal_data</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Get a reference to the data-block. Has to be acquired.</span>
<span class="normal">    internal_block_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">get_internal_block</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_acquired</span><span class="symbol">());</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> internal_data</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Fill block with default data, is supposed to be overwritten by subclass. Has to be internal.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">fill_default</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">    </span><span class="comment">//! \brief Read asyncronusly from external_block to internal_block. Has to be internal and have an external_block.</span>
<span class="normal">    </span><span class="comment">//! \return A request pointer to the I/O.</span>
<span class="normal">    </span><span class="usertype">request_ptr</span><span class="normal"> </span><span class="function">read_async</span><span class="symbol">(</span><span class="usertype">completion_handler</span><span class="normal"> on_cmpl </span><span class="symbol">=</span><span class="normal"> </span><span class="function">default_completion_handler</span><span class="symbol">())</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_internal</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">has_external_block</span><span class="symbol">());</span>
<span class="preproc">        #ifdef</span><span class="normal"> RW_VERBOSE</span>
<span class="normal">        </span><span class="function">STXXL_MSG</span><span class="symbol">(</span><span class="string">"reading block"</span><span class="symbol">);</span>
<span class="preproc">        #endif</span>
<span class="normal">        dirty </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> internal_data</span><span class="symbol">-&gt;</span><span class="function">read</span><span class="symbol">(</span><span class="normal">external_data</span><span class="symbol">,</span><span class="normal"> on_cmpl</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Read synchronously from external_block to internal_block. Has to be internal and have an external_block.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">read_sync</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">read_async</span><span class="symbol">()-&gt;</span><span class="function">wait</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Write asyncronusly from internal_block to external_block if necessary.</span>
<span class="normal">    </span><span class="comment">//! \return A request pointer to the I/O, an invalid request pointer if not necessary.</span>
<span class="normal">    </span><span class="usertype">request_ptr</span><span class="normal"> </span><span class="function">clean_async</span><span class="symbol">(</span><span class="usertype">completion_handler</span><span class="normal"> on_cmpl </span><span class="symbol">=</span><span class="normal"> </span><span class="function">default_completion_handler</span><span class="symbol">())</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> </span><span class="function">is_dirty</span><span class="symbol">())</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="function">request_ptr</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> </span><span class="function">has_external_block</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">get_external_block</span><span class="symbol">();</span>
<span class="preproc">        #ifdef</span><span class="normal"> RW_VERBOSE</span>
<span class="normal">        </span><span class="function">STXXL_MSG</span><span class="symbol">(</span><span class="string">"writing block"</span><span class="symbol">);</span>
<span class="preproc">        #endif</span>
<span class="normal">        dirty </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> internal_data</span><span class="symbol">-&gt;</span><span class="function">write</span><span class="symbol">(</span><span class="normal">external_data</span><span class="symbol">,</span><span class="normal"> on_cmpl</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Write synchronously from internal_block to external_block if necessary.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">clean_sync</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">request_ptr</span><span class="normal"> rp </span><span class="symbol">=</span><span class="normal"> </span><span class="function">clean_async</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rp</span><span class="symbol">.</span><span class="function">valid</span><span class="symbol">())</span>
<span class="normal">            rp</span><span class="symbol">-&gt;</span><span class="function">wait</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Attach an internal_block, making the block internal. Has to be not internal.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">attach_internal_block</span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> </span><span class="function">is_internal</span><span class="symbol">());</span>
<span class="normal">        internal_data </span><span class="symbol">=</span><span class="normal"> iblock</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Detach the internal_block. Writes to external_block if necessary. Has to be evictable.</span>
<span class="normal">    </span><span class="comment">//! \return A pointer to the internal_block.</span>
<span class="normal">    internal_block_type </span><span class="symbol">*</span><span class="normal"> </span><span class="function">detach_internal_block</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="function">is_evictable</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">clean_sync</span><span class="symbol">();</span>
<span class="normal">        internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> internal_data</span><span class="symbol">;</span>
<span class="normal">        internal_data </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> iblock</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Bring the block in uninitialized state, freeing external and internal memory.</span>
<span class="normal">    </span><span class="comment">//! Returns a pointer to the internal_block, NULL if it had none.</span>
<span class="normal">    </span><span class="comment">//! \return A pointer to the freed internal_block, NULL if it had none.</span>
<span class="normal">    internal_block_type </span><span class="symbol">*</span><span class="normal"> </span><span class="function">deinitialize</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> </span><span class="function">is_acquired</span><span class="symbol">());</span>
<span class="normal">        dirty </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">        </span><span class="comment">// free external_block (so that it becomes invalid and the disk-space can be used again)</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">has_external_block</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">free_external_block</span><span class="symbol">();</span>
<span class="normal">        </span><span class="comment">// free internal_block</span>
<span class="normal">        internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> internal_data</span><span class="symbol">;</span>
<span class="normal">        internal_data </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> iblock</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Set the external_block that holds the swappable_block's data. The block gets initialized with it.</span>
<span class="normal">    </span><span class="comment">//! \param eblock The external_block holding initial data.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">initialize</span><span class="symbol">(</span><span class="usertype">external_block_type</span><span class="normal"> eblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> </span><span class="function">is_initialized</span><span class="symbol">());</span>
<span class="normal">        external_data </span><span class="symbol">=</span><span class="normal"> eblock</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Extract the swappable_blocks data in an external_block. The block gets uninitialized.</span>
<span class="normal">    </span><span class="comment">//! \return The external_block that holds the swappable_block's data.</span>
<span class="normal">    </span><span class="usertype">external_block_type</span><span class="normal"> </span><span class="function">extract_external_block</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> </span><span class="function">is_internal</span><span class="symbol">());</span>
<span class="normal">        </span><span class="usertype">external_block_type</span><span class="normal"> eblock </span><span class="symbol">=</span><span class="normal"> external_data</span><span class="symbol">;</span>
<span class="normal">        external_data </span><span class="symbol">=</span><span class="normal"> </span><span class="function">external_block_type</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> eblock</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">ValueType</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> BlockSize</span><span class="symbol">&gt;</span>
<span class="usertype">unsigned_type</span><span class="normal"> swappable_block</span><span class="symbol">&lt;</span><span class="normal">ValueType</span><span class="symbol">,</span><span class="normal"> BlockSize</span><span class="symbol">&gt;::</span><span class="normal">disk_allocation_offset </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">SwappableBlockType</span><span class="symbol">&gt;</span><span class="normal"> </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">block_scheduler_algorithm</span><span class="symbol">;</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">SwappableBlockType</span><span class="symbol">&gt;</span><span class="normal"> </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">block_scheduler_algorithm_online_lru</span><span class="symbol">;</span>

<span class="comment">//! \brief Schedules swapping of blocks and provides blocks for temporary storage.</span>
<span class="comment">//!</span>
<span class="comment">//! In simple mode, it tries to save I/Os through caching only.</span>
<span class="comment">//! In simulation mode, it records access patterns into a prediction sequence.</span>
<span class="comment">//! The prediction sequence can then be used for prefetching in the (offline) execute mode.</span>
<span class="comment">//! This will only work for algorithms with deterministic, data oblivious access patterns.</span>
<span class="comment">//! In simulation mode, no I/O is performed; the data provided is accessible but undefined.</span>
<span class="comment">//! In execute mode, it does caching, prefetching, and possibly other optimizations.</span>
<span class="comment">//! \tparam SwappableBlockType Type of swappable_blocks to manage. Can be some specialized subclass.</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">SwappableBlockType</span><span class="symbol">&gt;</span>
<span class="keyword">class</span><span class="normal"> </span><span class="classname">block_scheduler</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">private</span><span class="normal"> noncopyable</span>
<span class="cbracket">{</span>
<span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// tuning-parameter: To acquire blocks, internal memory has to be allocated.</span>
<span class="normal">    </span><span class="comment">// This constant limits the number of internal_blocks allocated at once.</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">int_type</span><span class="normal"> max_internal_blocks_alloc_at_once</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">int_type</span><span class="normal"> time_type</span><span class="symbol">;</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SwappableBlockType</span><span class="symbol">::</span><span class="usertype">internal_block_type</span><span class="normal"> internal_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SwappableBlockType</span><span class="symbol">::</span><span class="usertype">external_block_type</span><span class="normal"> external_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">vector</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;::</span><span class="usertype">size_type</span><span class="normal"> swappable_block_identifier_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/*/! Mode the block scheduler currently works in</span>
<span class="comment">    enum mode</span>
<span class="comment">    {</span>
<span class="comment">        online,         //serve requests immediately, without any prediction, LRU caching</span>
<span class="comment">        simulation,     //record prediction sequence only, do not serve requests, (returned blocks must not be accessed)</span>
<span class="comment">        offline_lfd,    //serve requests based on prediction sequence, using longest-forward-distance caching</span>
<span class="comment">        offline_lfd_prefetch     //serve requests based on prediction sequence, using longest-forward-distance caching, and prefetching</span>
<span class="comment">    };*/</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">// -------- prediction_sequence -------</span>
<span class="normal">    </span><span class="keyword">enum</span><span class="normal"> block_scheduler_operation</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        op_acquire</span><span class="symbol">,</span>
<span class="normal">        op_acquire_uninitialized</span><span class="symbol">,</span>
<span class="normal">        op_release</span><span class="symbol">,</span>
<span class="normal">        op_release_dirty</span><span class="symbol">,</span>
<span class="normal">        op_deinitialize</span><span class="symbol">,</span>
<span class="normal">        op_initialize</span><span class="symbol">,</span>
<span class="normal">        op_extract_external_block</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">prediction_sequence_element</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">block_scheduler_operation</span><span class="normal"> op</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> id</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">time_type</span><span class="normal"> time</span><span class="symbol">;</span>

<span class="normal">        </span><span class="function">prediction_sequence_element</span><span class="symbol">(</span><span class="usertype">block_scheduler_operation</span><span class="normal"> op</span><span class="symbol">,</span>
<span class="normal">                </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> id</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">int_type</span><span class="normal"> time</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">op</span><span class="symbol">(</span><span class="normal">op</span><span class="symbol">),</span><span class="normal"> </span><span class="function">id</span><span class="symbol">(</span><span class="normal">id</span><span class="symbol">),</span><span class="normal"> </span><span class="function">time</span><span class="symbol">(</span><span class="normal">time</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">deque&lt;prediction_sequence_element&gt;</span><span class="normal"> prediction_sequence_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="comment">// ---- end prediction_sequence -------</span>

<span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">SBT</span><span class="symbol">&gt;</span><span class="normal"> </span><span class="keyword">friend</span><span class="normal"> </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">block_scheduler_algorithm</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">int_type</span><span class="normal"> max_internal_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">int_type</span><span class="normal"> remaining_internal_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="comment">//! \brief Stores pointers to arrays of internal_blocks. Used to deallocate them only.</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="usertype">stack&lt;internal_block_type *&gt;</span><span class="normal"> internal_blocks_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="comment">//! \brief holds free internal_blocks with attributes reset</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="usertype">stack&lt;internal_block_type * &gt;</span><span class="normal"> free_internal_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="comment">//! \brief temporary blocks that will not be needed after algorithm termination</span>
<span class="normal">    </span><span class="keyword">mutable</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">vector&lt;SwappableBlockType&gt;</span><span class="normal"> swappable_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="comment">//! \brief holds indices of free swappable_blocks with attributes reset</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="normal">priority_queue</span><span class="symbol">&lt;</span><span class="normal">swappable_block_identifier_type</span><span class="symbol">,</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">vector</span><span class="symbol">&lt;</span><span class="normal">swappable_block_identifier_type</span><span class="symbol">&gt;,</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">greater&lt;swappable_block_identifier_type&gt; &gt;</span><span class="normal"> free_swappable_blocks</span><span class="symbol">;</span>
<span class="normal">    block_manager </span><span class="symbol">*</span><span class="normal"> bm</span><span class="symbol">;</span>
<span class="normal">    block_scheduler_algorithm</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> algo</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">//! \brief Get an internal_block from the freelist or a newly allocated one if available.</span>
<span class="normal">    </span><span class="comment">//! \return Pointer to the internal_block. NULL if none available.</span>
<span class="normal">    internal_block_type </span><span class="symbol">*</span><span class="normal"> </span><span class="function">get_free_internal_block</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> free_internal_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// =&gt; there are internal_blocks in the free-list</span>
<span class="normal">            internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> free_internal_blocks</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">();</span>
<span class="normal">            free_internal_blocks</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> iblock</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">remaining_internal_blocks </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// =&gt; more internal_blocks can be allocated</span>
<span class="normal">            </span><span class="usertype">int_type</span><span class="normal"> num_blocks </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">max_internal_blocks_alloc_at_once</span><span class="symbol">,</span><span class="normal"> remaining_internal_blocks</span><span class="symbol">);</span>
<span class="normal">            remaining_internal_blocks </span><span class="symbol">-=</span><span class="normal"> num_blocks</span><span class="symbol">;</span>
<span class="normal">            internal_block_type </span><span class="symbol">*</span><span class="normal"> iblocks </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> internal_block_type</span><span class="symbol">[</span><span class="normal">num_blocks</span><span class="symbol">];</span>
<span class="normal">            internal_blocks_blocks</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">iblocks</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">int_type</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> num_blocks </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">--</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">                free_internal_blocks</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">iblocks </span><span class="symbol">+</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> iblocks</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// =&gt; no internal_block available</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Return an internal_block to the freelist.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> free_internal_blocks</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">//! \brief create a block_scheduler with empty prediction sequence in simple mode.</span>
<span class="normal">    </span><span class="comment">//! \param max_internal_memory Amount of internal memory (in bytes) the scheduler is allowed to use for acquiring, prefetching and caching.</span>
<span class="normal">    </span><span class="keyword">explicit</span><span class="normal"> </span><span class="function">block_scheduler</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">int_type</span><span class="normal"> max_internal_memory</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">max_internal_blocks</span><span class="symbol">(</span><span class="function">div_ceil</span><span class="symbol">(</span><span class="normal">max_internal_memory</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">internal_block_type</span><span class="symbol">))),</span>
<span class="normal">          </span><span class="function">remaining_internal_blocks</span><span class="symbol">(</span><span class="normal">max_internal_blocks</span><span class="symbol">),</span>
<span class="normal">          </span><span class="function">bm</span><span class="symbol">(</span><span class="normal">block_manager</span><span class="symbol">::</span><span class="function">get_instance</span><span class="symbol">()),</span>
<span class="normal">          </span><span class="function">algo</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> algo </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> block_scheduler_algorithm_online_lru</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;(*</span><span class="keyword">this</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="symbol">~</span><span class="function">block_scheduler</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">delete</span><span class="normal"> algo</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">int_type</span><span class="normal"> num_freed_internal_blocks </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">free_swappable_blocks</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> swappable_blocks</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// =&gt; not all swappable_blocks are free, at least deinitialize them</span>
<span class="normal">            </span><span class="function">STXXL_ERRMSG</span><span class="symbol">(</span><span class="string">"not all swappable_blocks are free, those not acquired will be deinitialized"</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">vector</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;::</span><span class="usertype">iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">();</span><span class="normal"> </span><span class="comment">// evictable_blocks would suffice</span>
<span class="normal">                    it </span><span class="symbol">!=</span><span class="normal"> swappable_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">it</span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> it</span><span class="symbol">-&gt;</span><span class="function">is_acquired</span><span class="symbol">())</span>
<span class="normal">                    num_freed_internal_blocks </span><span class="symbol">+=</span><span class="normal"> </span><span class="type">bool</span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">-&gt;</span><span class="function">deinitialize</span><span class="symbol">());</span><span class="normal"> </span><span class="comment">// count internal_blocks that get freed</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">int_type</span><span class="normal"> nlost </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">max_internal_blocks </span><span class="symbol">-</span><span class="normal"> remaining_internal_blocks</span><span class="symbol">)</span>
<span class="normal">                </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">free_internal_blocks</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> num_freed_internal_blocks</span><span class="symbol">))</span>
<span class="normal">            </span><span class="function">STXXL_ERRMSG</span><span class="symbol">(</span><span class="normal">nlost </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" internal_blocks are lost. They will get deallocated."</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> internal_blocks_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">delete</span><span class="normal"> </span><span class="symbol">[]</span><span class="normal"> internal_blocks_blocks</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">();</span>
<span class="normal">            internal_blocks_blocks</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Acquire the given block.</span>
<span class="normal">    </span><span class="comment">//! Has to be in pairs with release. Pairs may be nested and interleaved.</span>
<span class="normal">    </span><span class="comment">//! \return Reference to the block's data.</span>
<span class="normal">    </span><span class="comment">//! \param sblock Swappable block to acquire.</span>
<span class="normal">    internal_block_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">acquire</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> uninitialized </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> algo</span><span class="symbol">-&gt;</span><span class="function">acquire</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">,</span><span class="normal"> uninitialized</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Release the given block.</span>
<span class="normal">    </span><span class="comment">//! Has to be in pairs with acquire. Pairs may be nested and interleaved.</span>
<span class="normal">    </span><span class="comment">//! \param sblock Swappable block to release.</span>
<span class="normal">    </span><span class="comment">//! \param dirty If the data has been changed, invalidating possible data in external storage.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">release</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> dirty</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> algo</span><span class="symbol">-&gt;</span><span class="function">release</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">,</span><span class="normal"> dirty</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Drop all data in the given block, freeing in- and external memory.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">deinitialize</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> algo</span><span class="symbol">-&gt;</span><span class="function">deinitialize</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Initialize the swappable_block with the given external_block.</span>
<span class="normal">    </span><span class="comment">//!</span>
<span class="normal">    </span><span class="comment">//! It will use the the external_block for swapping and take care about it's deallocation. Has to be uninitialized.</span>
<span class="normal">    </span><span class="comment">//! \param sbid identifier to the swappable_block</span>
<span class="normal">    </span><span class="comment">//! \param eblock external_block a.k.a. bid</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">initialize</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">external_block_type</span><span class="normal"> eblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> algo</span><span class="symbol">-&gt;</span><span class="function">initialize</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">,</span><span class="normal"> eblock</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief deinitialize the swappable_block and return it's contents in an external_block.</span>
<span class="normal">    </span><span class="comment">//!</span>
<span class="normal">    </span><span class="comment">//! \param sbid identifier to the swappable_block</span>
<span class="normal">    </span><span class="comment">//! \return external_block a.k.a. bid</span>
<span class="normal">    </span><span class="usertype">external_block_type</span><span class="normal"> </span><span class="function">extract_external_block</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> algo</span><span class="symbol">-&gt;</span><span class="function">extract_external_block</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief check if the swappable_block is initialized</span>
<span class="normal">    </span><span class="comment">//! \param sbid identifier to the swappable_block</span>
<span class="normal">    </span><span class="comment">//! \return if the swappable_block is initialized</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_initialized</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> algo</span><span class="symbol">-&gt;</span><span class="function">is_initialized</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Record a timestep in the prediction sequence to seperate consecutive acquire rsp. release-operations.</span>
<span class="normal">    </span><span class="comment">//! Has an effect only in simulation mode.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">explicit_timestep</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> algo</span><span class="symbol">-&gt;</span><span class="function">explicit_timestep</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Get a const reference to given block's data. Block has to be already acquired.</span>
<span class="normal">    </span><span class="comment">//! \param sblock Swappable block to access.</span>
<span class="normal">    internal_block_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">get_internal_block</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">].</span><span class="function">get_internal_block</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Allocate an uninitialized swappable_block.</span>
<span class="normal">    </span><span class="comment">//! \return An identifier of the block.</span>
<span class="normal">    </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> </span><span class="function">allocate_swappable_block</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">free_swappable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// create new swappable_block</span>
<span class="normal">            sbid </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span>
<span class="normal">            swappable_blocks</span><span class="symbol">.</span><span class="function">resize</span><span class="symbol">(</span><span class="normal">sbid </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">            algo</span><span class="symbol">-&gt;</span><span class="function">swappable_blocks_resize</span><span class="symbol">(</span><span class="normal">sbid </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// take swappable_block from freelist</span>
<span class="normal">            sbid </span><span class="symbol">=</span><span class="normal"> free_swappable_blocks</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">();</span>
<span class="normal">            free_swappable_blocks</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> sbid</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Free given no longer used temporary swappable_block.</span>
<span class="normal">    </span><span class="comment">//! \param sblock Temporary swappable_block to free.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">free_swappable_block</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">deinitialize</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">        free_swappable_blocks</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Returns if simulation mode is on, i.e. if a prediction sequence is being recorded.</span>
<span class="normal">    </span><span class="comment">//! \return If simulation mode is on.</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_simulating</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> algo</span><span class="symbol">-&gt;</span><span class="function">is_simulating</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Switch the used algorithm, e.g. to simulation etc..</span>
<span class="normal">    </span><span class="comment">//! \param new_algo Pointer to the new algorithm object. Has to be instantiated to the block scheduler (or the old algorithm object).</span>
<span class="normal">    </span><span class="comment">//! \return Pointer to the old algorithm object.</span>
<span class="normal">    block_scheduler_algorithm</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="function">switch_algorithm_to</span><span class="symbol">(</span><span class="normal">block_scheduler_algorithm</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> new_algo</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(&amp;</span><span class="normal">new_algo</span><span class="symbol">-&gt;</span><span class="normal">bs </span><span class="symbol">==</span><span class="normal"> </span><span class="keyword">this</span><span class="symbol">);</span>
<span class="normal">        block_scheduler_algorithm</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> old_algo </span><span class="symbol">=</span><span class="normal"> algo</span><span class="symbol">;</span>
<span class="normal">        algo </span><span class="symbol">=</span><span class="normal"> new_algo</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> old_algo</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief get the prediction_sequence</span>
<span class="normal">    </span><span class="comment">//! \return reference to the prediction_sequence</span>
<span class="normal">    </span><span class="keyword">const</span><span class="normal"> prediction_sequence_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">get_prediction_sequence</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> algo</span><span class="symbol">-&gt;</span><span class="function">get_prediction_sequence</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">flush</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        std</span><span class="symbol">::</span><span class="usertype">vector&lt;request_ptr&gt;</span><span class="normal"> requests</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> algo</span><span class="symbol">-&gt;</span><span class="function">evictable_blocks_empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid </span><span class="symbol">=</span><span class="normal"> algo</span><span class="symbol">-&gt;</span><span class="function">evictable_blocks_pop</span><span class="symbol">();</span>
<span class="normal">            </span><span class="usertype">request_ptr</span><span class="normal"> rq </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">].</span><span class="function">clean_async</span><span class="symbol">();</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rq</span><span class="symbol">.</span><span class="function">valid</span><span class="symbol">())</span>
<span class="normal">                requests</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">rq</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">].</span><span class="function">detach_internal_block</span><span class="symbol">());</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">vector</span><span class="symbol">&lt;</span><span class="normal">request_ptr</span><span class="symbol">&gt;::</span><span class="usertype">reverse_iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> requests</span><span class="symbol">.</span><span class="function">rbegin</span><span class="symbol">();</span>
<span class="normal">                it </span><span class="symbol">!=</span><span class="normal"> requests</span><span class="symbol">.</span><span class="function">rend</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">it</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">(*</span><span class="normal">it</span><span class="symbol">)-&gt;</span><span class="function">wait</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">SwappableBlockType</span><span class="symbol">&gt;</span>
<span class="keyword">const</span><span class="normal"> </span><span class="usertype">int_type</span><span class="normal"> block_scheduler</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;::</span><span class="normal">max_internal_blocks_alloc_at_once </span><span class="symbol">=</span><span class="normal"> </span><span class="number">128</span><span class="symbol">;</span>

<span class="comment">//! \brief Interface of a block scheduling algorithm.</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">SwappableBlockType</span><span class="symbol">&gt;</span>
<span class="keyword">class</span><span class="normal"> </span><span class="classname">block_scheduler_algorithm</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">private</span><span class="normal"> noncopyable</span>
<span class="cbracket">{</span>
<span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">block_scheduler&lt;SwappableBlockType&gt;</span><span class="normal"> block_scheduler_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">internal_block_type</span><span class="normal"> internal_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">external_block_type</span><span class="normal"> external_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> swappable_block_identifier_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">prediction_sequence_type</span><span class="normal"> prediction_sequence_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">time_type</span><span class="normal"> time_type</span><span class="symbol">;</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    block_scheduler_type </span><span class="symbol">&amp;</span><span class="normal"> bs</span><span class="symbol">;</span>
<span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="normal">vector</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> swappable_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">prediction_sequence_type</span><span class="normal"> prediction_sequence</span><span class="symbol">;</span>

<span class="normal">    block_scheduler_algorithm </span><span class="symbol">*</span><span class="normal"> </span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> bs</span><span class="symbol">.</span><span class="normal">algo</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Get an internal_block from the block_scheduler.</span>
<span class="normal">    </span><span class="comment">//! \return Pointer to the internal_block. NULL if none available.</span>
<span class="normal">    internal_block_type </span><span class="symbol">*</span><span class="normal"> </span><span class="function">get_free_internal_block_from_block_scheduler</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> bs</span><span class="symbol">.</span><span class="function">get_free_internal_block</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Return an internal_block to the block_scheduler.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">return_free_internal_block_to_block_scheduler</span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> bs</span><span class="symbol">.</span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="function">block_scheduler_algorithm</span><span class="symbol">(</span><span class="normal">block_scheduler_type </span><span class="symbol">&amp;</span><span class="normal"> bs</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">bs</span><span class="symbol">(</span><span class="normal">bs</span><span class="symbol">),</span>
<span class="normal">          </span><span class="function">swappable_blocks</span><span class="symbol">(</span><span class="normal">bs</span><span class="symbol">.</span><span class="normal">swappable_blocks</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{}</span>

<span class="normal">    </span><span class="function">block_scheduler_algorithm</span><span class="symbol">(</span><span class="normal">block_scheduler_algorithm </span><span class="symbol">*</span><span class="normal"> old</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">bs</span><span class="symbol">(</span><span class="normal">old</span><span class="symbol">-&gt;</span><span class="normal">bs</span><span class="symbol">),</span>
<span class="normal">          </span><span class="function">swappable_blocks</span><span class="symbol">(</span><span class="normal">bs</span><span class="symbol">.</span><span class="normal">swappable_blocks</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="symbol">~</span><span class="function">block_scheduler_algorithm</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">evictable_blocks_empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> </span><span class="function">evictable_blocks_pop</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">swappable_blocks_resize</span><span class="symbol">(</span><span class="normal">swappable_block_identifier_type </span><span class="comment">/*size*/</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> internal_block_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">acquire</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> uninitialized </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">release</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> dirty</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">deinitialize</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">initialize</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">external_block_type</span><span class="normal"> eblock</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="usertype">external_block_type</span><span class="normal"> </span><span class="function">extract_external_block</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_initialized</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">].</span><span class="function">is_initialized</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">explicit_timestep</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{}</span>
<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_simulating</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> prediction_sequence_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">get_prediction_sequence</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> prediction_sequence</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">//! \brief Block scheduling algorithm caching via the least recently used policy (online).</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">SwappableBlockType</span><span class="symbol">&gt;</span>
<span class="keyword">class</span><span class="normal"> </span><span class="classname">block_scheduler_algorithm_online_lru</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">public</span><span class="normal"> block_scheduler_algorithm</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;</span>
<span class="cbracket">{</span>
<span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">block_scheduler&lt;SwappableBlockType&gt;</span><span class="normal"> block_scheduler_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">block_scheduler_algorithm&lt;SwappableBlockType&gt;</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">internal_block_type</span><span class="normal"> internal_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">external_block_type</span><span class="normal"> external_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> swappable_block_identifier_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">bs</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">swappable_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">get_algorithm_from_block_scheduler</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">get_free_internal_block_from_block_scheduler</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">return_free_internal_block_to_block_scheduler</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">//! \brief Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired.</span>
<span class="normal">    </span><span class="usertype">addressable_fifo_queue&lt;swappable_block_identifier_type&gt;</span><span class="normal"> evictable_blocks</span><span class="symbol">;</span>

<span class="normal">    internal_block_type </span><span class="symbol">*</span><span class="normal"> </span><span class="function">get_free_internal_block</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// try to get a free internal_block</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> </span><span class="function">get_free_internal_block_from_block_scheduler</span><span class="symbol">())</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> iblock</span><span class="symbol">;</span>
<span class="normal">        </span><span class="comment">// evict block</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">());</span><span class="normal"> </span><span class="comment">// fails it there is not enough memory available</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">evictable_blocks</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">()].</span><span class="function">detach_internal_block</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">return_free_internal_block_to_block_scheduler</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">init</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">())</span>
<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> </span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">()-&gt;</span><span class="function">evictable_blocks_empty</span><span class="symbol">())</span>
<span class="normal">                evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">()-&gt;</span><span class="function">evictable_blocks_pop</span><span class="symbol">());</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="function">block_scheduler_algorithm_online_lru</span><span class="symbol">(</span><span class="normal">block_scheduler_type </span><span class="symbol">&amp;</span><span class="normal"> bs</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">block_scheduler_algorithm_type</span><span class="symbol">(</span><span class="normal">bs</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">init</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="function">block_scheduler_algorithm_online_lru</span><span class="symbol">(</span><span class="normal">block_scheduler_algorithm_type </span><span class="symbol">*</span><span class="normal"> old</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">block_scheduler_algorithm_type</span><span class="symbol">(</span><span class="normal">old</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">init</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="symbol">~</span><span class="function">block_scheduler_algorithm_online_lru</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">STXXL_ERRMSG</span><span class="symbol">(</span><span class="string">"Destructing block_scheduler_algorithm_online that still holds evictable blocks. They get deinitialized."</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">evictable_blocks</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">()];</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">deinitialize</span><span class="symbol">())</span>
<span class="normal">                </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">evictable_blocks_empty</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> </span><span class="function">evictable_blocks_pop</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> internal_block_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">acquire</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> uninitialized </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        </span><span class="comment">/* acquired =&gt; internal -&gt; increase reference count</span>
<span class="comment">           internal but not acquired -&gt; remove from evictable_blocks, increase reference count</span>
<span class="comment">           not internal =&gt; uninitialized or external -&gt; get internal_block, increase reference count</span>
<span class="comment">           uninitialized -&gt; fill with default value</span>
<span class="comment">           external -&gt; read */</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_internal</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">is_acquired</span><span class="symbol">())</span>
<span class="normal">                </span><span class="comment">// not acquired yet -&gt; remove from evictable_blocks</span>
<span class="normal">                evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">acquire</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_initialized</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// =&gt; external but not internal</span>
<span class="normal">            </span><span class="comment">//get internal_block</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">attach_internal_block</span><span class="symbol">(</span><span class="function">get_free_internal_block</span><span class="symbol">());</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> uninitialized</span><span class="symbol">)</span>
<span class="normal">                </span><span class="comment">//load block synchronously</span>
<span class="normal">                sblock</span><span class="symbol">.</span><span class="function">read_sync</span><span class="symbol">();</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">acquire</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// =&gt; ! sblock.is_initialized()</span>
<span class="normal">            </span><span class="comment">//get internal_block</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">attach_internal_block</span><span class="symbol">(</span><span class="function">get_free_internal_block</span><span class="symbol">());</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">acquire</span><span class="symbol">();</span>
<span class="normal">            </span><span class="comment">//initialize new block</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> uninitialized</span><span class="symbol">)</span>
<span class="normal">                sblock</span><span class="symbol">.</span><span class="function">fill_default</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">get_internal_block</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">release</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> dirty</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        sblock</span><span class="symbol">.</span><span class="function">make_dirty_if</span><span class="symbol">(</span><span class="normal">dirty</span><span class="symbol">);</span>
<span class="normal">        sblock</span><span class="symbol">.</span><span class="function">release</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">is_acquired</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_dirty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">is_external</span><span class="symbol">())</span>
<span class="normal">                </span><span class="comment">// =&gt; evictable, put in pq</span>
<span class="normal">                evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">                </span><span class="comment">// =&gt; uninitialized, release internal block and put it in freelist</span>
<span class="normal">                </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">detach_internal_block</span><span class="symbol">());</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">deinitialize</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_evictable</span><span class="symbol">())</span>
<span class="normal">            evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">deinitialize</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">initialize</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">external_block_type</span><span class="normal"> eblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        sblock</span><span class="symbol">.</span><span class="function">initialize</span><span class="symbol">(</span><span class="normal">eblock</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="usertype">external_block_type</span><span class="normal"> </span><span class="function">extract_external_block</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_evictable</span><span class="symbol">())</span>
<span class="normal">            evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_internal</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">detach_internal_block</span><span class="symbol">());</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">extract_external_block</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">//! \brief Pseudo block scheduling algorithm only recording the request sequence.</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">SwappableBlockType</span><span class="symbol">&gt;</span>
<span class="keyword">class</span><span class="normal"> </span><span class="classname">block_scheduler_algorithm_simulation</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">public</span><span class="normal"> block_scheduler_algorithm</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;</span>
<span class="cbracket">{</span>
<span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">block_scheduler&lt;SwappableBlockType&gt;</span><span class="normal"> block_scheduler_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">block_scheduler_algorithm&lt;SwappableBlockType&gt;</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">internal_block_type</span><span class="normal"> internal_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">external_block_type</span><span class="normal"> external_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> swappable_block_identifier_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">prediction_sequence_element</span><span class="normal"> prediction_sequence_element_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="usertype">time_type</span><span class="normal"> time_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">bs</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">prediction_sequence</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">swappable_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">get_algorithm_from_block_scheduler</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">get_free_internal_block_from_block_scheduler</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">return_free_internal_block_to_block_scheduler</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">//! \brief Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired.</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="usertype">stack&lt;swappable_block_identifier_type&gt;</span><span class="normal"> evictable_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">time_type</span><span class="normal"> time_count</span><span class="symbol">;</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> last_op_release</span><span class="symbol">;</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="usertype">vector&lt;int_type&gt;</span><span class="normal"> reference_counts</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">internal_block_type</span><span class="normal"> dummy_block</span><span class="symbol">;</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">return_free_internal_block_to_block_scheduler</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">init</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">())</span>
<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> </span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">()-&gt;</span><span class="function">evictable_blocks_empty</span><span class="symbol">())</span>
<span class="normal">                evictable_blocks</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">()-&gt;</span><span class="function">evictable_blocks_pop</span><span class="symbol">());</span>
<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> reference_counts</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">            reference_counts</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">].</span><span class="function">is_initialized</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="function">block_scheduler_algorithm_simulation</span><span class="symbol">(</span><span class="normal">block_scheduler_type </span><span class="symbol">&amp;</span><span class="normal"> bs</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">block_scheduler_algorithm_type</span><span class="symbol">(</span><span class="normal">bs</span><span class="symbol">),</span>
<span class="normal">          </span><span class="function">time_count</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">),</span>
<span class="normal">          </span><span class="function">last_op_release</span><span class="symbol">(</span><span class="keyword">false</span><span class="symbol">),</span>
<span class="normal">          </span><span class="function">reference_counts</span><span class="symbol">(</span><span class="normal">swappable_blocks</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">())</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">init</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="function">block_scheduler_algorithm_simulation</span><span class="symbol">(</span><span class="normal">block_scheduler_algorithm_type </span><span class="symbol">*</span><span class="normal"> old</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">block_scheduler_algorithm_type</span><span class="symbol">(</span><span class="normal">old</span><span class="symbol">),</span>
<span class="normal">          </span><span class="function">time_count</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">),</span>
<span class="normal">          </span><span class="function">last_op_release</span><span class="symbol">(</span><span class="keyword">false</span><span class="symbol">),</span>
<span class="normal">          </span><span class="function">reference_counts</span><span class="symbol">(</span><span class="normal">swappable_blocks</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">())</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">init</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="symbol">~</span><span class="function">block_scheduler_algorithm_simulation</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">STXXL_ERRMSG</span><span class="symbol">(</span><span class="string">"Destructing block_scheduler_algorithm_record_prediction_sequence that still holds evictable blocks. They get deinitialized."</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">evictable_blocks</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">()];</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">deinitialize</span><span class="symbol">())</span>
<span class="normal">                </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span>
<span class="normal">            evictable_blocks</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">evictable_blocks_empty</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> </span><span class="function">evictable_blocks_pop</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid </span><span class="symbol">=</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">();</span>
<span class="normal">        evictable_blocks</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> sbid</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> internal_block_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">acquire</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> uninitialized </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="symbol">++</span><span class="normal">reference_counts</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        last_op_release </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">uninitialized</span><span class="symbol">)</span>
<span class="normal">            prediction_sequence</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">prediction_sequence_element_type</span>
<span class="normal">                    </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire_uninitialized</span><span class="symbol">,</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> time_count</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">else</span>
<span class="normal">            prediction_sequence</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">prediction_sequence_element_type</span>
<span class="normal">                    </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire</span><span class="symbol">,</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> time_count</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> dummy_block</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">release</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> dirty</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="symbol">--</span><span class="normal">reference_counts</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">+=</span><span class="normal"> dirty</span><span class="symbol">;</span>
<span class="normal">        time_count </span><span class="symbol">+=</span><span class="normal"> </span><span class="symbol">!</span><span class="normal"> last_op_release</span><span class="symbol">;</span>
<span class="normal">        last_op_release </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">dirty</span><span class="symbol">)</span>
<span class="normal">            prediction_sequence</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">prediction_sequence_element_type</span>
<span class="normal">                    </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release_dirty</span><span class="symbol">,</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> time_count</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">else</span>
<span class="normal">            prediction_sequence</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">prediction_sequence_element_type</span>
<span class="normal">                    </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release</span><span class="symbol">,</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> time_count</span><span class="symbol">));</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">deinitialize</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        reference_counts</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">        prediction_sequence</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">prediction_sequence_element_type</span>
<span class="normal">                </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_deinitialize</span><span class="symbol">,</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> time_count</span><span class="symbol">));</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">initialize</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> external_block_type</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        reference_counts</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">        prediction_sequence</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">prediction_sequence_element_type</span>
<span class="normal">                </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_initialize</span><span class="symbol">,</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> time_count</span><span class="symbol">));</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="usertype">external_block_type</span><span class="normal"> </span><span class="function">extract_external_block</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        reference_counts</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">        prediction_sequence</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">prediction_sequence_element_type</span>
<span class="normal">                </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_extract_external_block</span><span class="symbol">,</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> time_count</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="function">external_block_type</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">swappable_blocks_resize</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> size</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        reference_counts</span><span class="symbol">.</span><span class="function">resize</span><span class="symbol">(</span><span class="normal">size</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_initialized</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> reference_counts</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">explicit_timestep</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">time_count</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">is_simulating</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">//! \brief Block scheduling algorithm caching via the longest forward distance policy (offline).</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">SwappableBlockType</span><span class="symbol">&gt;</span>
<span class="keyword">class</span><span class="normal"> </span><span class="classname">block_scheduler_algorithm_offline_lfd</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">public</span><span class="normal"> block_scheduler_algorithm</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;</span>
<span class="cbracket">{</span>
<span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">block_scheduler&lt;SwappableBlockType&gt;</span><span class="normal"> block_scheduler_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">block_scheduler_algorithm&lt;SwappableBlockType&gt;</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">internal_block_type</span><span class="normal"> internal_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">external_block_type</span><span class="normal"> external_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> swappable_block_identifier_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="usertype">time_type</span><span class="normal"> time_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">prediction_sequence_type</span><span class="normal"> prediction_sequence_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">bs</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">swappable_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">get_algorithm_from_block_scheduler</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">get_free_internal_block_from_block_scheduler</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">return_free_internal_block_to_block_scheduler</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">priority</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">unsigned_type</span><span class="normal"> p</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">        </span><span class="function">priority</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">pair</span><span class="symbol">&lt;</span><span class="type">bool</span><span class="symbol">,</span><span class="normal"> time_type</span><span class="symbol">&gt;</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// p larger =&gt; evict earlier</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// most significant: next use</span>
<span class="normal">                p </span><span class="symbol">=</span><span class="normal"> </span><span class="function">unsigned_type</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>
<span class="normal">                </span><span class="comment">// less significant: not dirty</span>
<span class="normal">                p </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">unsigned_type</span><span class="symbol">(!</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">is_dirty</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                </span><span class="comment">// less significant: has external_block</span>
<span class="normal">                p </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">unsigned_type</span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">has_external_block</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// most significant: next use</span>
<span class="normal">                p </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">unsigned_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>
<span class="normal">                </span><span class="comment">// less significant: next operation: extract &gt; accessed no more &gt; deinitialize</span>
<span class="normal">                p </span><span class="symbol">|=</span><span class="normal"> </span><span class="function">unsigned_type</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// less =&gt; evict earlier</span>
<span class="normal">        </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> priority </span><span class="symbol">&amp;</span><span class="normal"> right</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> p </span><span class="symbol">&gt;</span><span class="normal"> right</span><span class="symbol">.</span><span class="normal">p</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">//! \brief Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired.</span>
<span class="normal">    </span><span class="usertype">addressable_priority_queue&lt;swappable_block_identifier_type, priority&gt;</span><span class="normal"> evictable_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="comment">/*! \brief stores for the sequence of releases extracted from the prediction_sequence:</span>
<span class="comment">            (true, timestamp of the blocks next acquire) if it is acquired next</span>
<span class="comment">            (false, 0) if it is deinitialized next</span>
<span class="comment">            (false, 1) if it is not accessed any more</span>
<span class="comment">            (false, 2) if it is extracted next</span>
<span class="comment">            (false, 3) if it is initialized next */</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="usertype">deque&lt; std::pair&lt;bool, time_type&gt; &gt;</span><span class="normal"> next_use</span><span class="symbol">;</span>

<span class="normal">    internal_block_type </span><span class="symbol">*</span><span class="normal"> </span><span class="function">get_free_internal_block</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// try to get a free internal_block</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> </span><span class="function">get_free_internal_block_from_block_scheduler</span><span class="symbol">())</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> iblock</span><span class="symbol">;</span>
<span class="normal">        </span><span class="comment">// evict block</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">());</span><span class="normal"> </span><span class="comment">// fails it there is not enough memory available</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">evictable_blocks</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">()].</span><span class="function">detach_internal_block</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">return_free_internal_block_to_block_scheduler</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">init</span><span class="symbol">(</span><span class="normal">block_scheduler_algorithm_type </span><span class="symbol">*</span><span class="normal"> old_algo</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        std</span><span class="symbol">::</span><span class="normal">vector</span><span class="symbol">&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">pair</span><span class="symbol">&lt;</span><span class="type">bool</span><span class="symbol">,</span><span class="normal"> time_type</span><span class="symbol">&gt;</span><span class="normal"> </span><span class="symbol">&gt;</span>
<span class="normal">                </span><span class="function">blocks_next_acquire</span><span class="symbol">(</span><span class="normal">swappable_blocks</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">(),</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">make_pair</span><span class="symbol">(</span><span class="keyword">false</span><span class="symbol">,</span><span class="normal"> </span><span class="number">1</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">if</span><span class="symbol">(</span><span class="normal">old_algo</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// precomputations for priorities: init next_acquires</span>
<span class="normal">            </span><span class="keyword">const</span><span class="normal"> prediction_sequence_type </span><span class="symbol">&amp;</span><span class="normal"> ps </span><span class="symbol">=</span><span class="normal"> old_algo</span><span class="symbol">-&gt;</span><span class="function">get_prediction_sequence</span><span class="symbol">();</span>
<span class="normal">            </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">prediction_sequence_type</span><span class="symbol">::</span><span class="usertype">const_reverse_iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> ps</span><span class="symbol">.</span><span class="function">rbegin</span><span class="symbol">();</span><span class="normal"> it </span><span class="symbol">!=</span><span class="normal"> ps</span><span class="symbol">.</span><span class="function">rend</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">it</span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">switch</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">-&gt;</span><span class="normal">op</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">case</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire</span><span class="symbol">):</span>
<span class="normal">                </span><span class="keyword">case</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire_uninitialized</span><span class="symbol">):</span>
<span class="normal">                    blocks_next_acquire</span><span class="symbol">[</span><span class="normal">it</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">make_pair</span><span class="symbol">(</span><span class="keyword">true</span><span class="symbol">,</span><span class="normal"> it</span><span class="symbol">-&gt;</span><span class="normal">time</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">case</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release</span><span class="symbol">):</span>
<span class="normal">                </span><span class="keyword">case</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release_dirty</span><span class="symbol">):</span>
<span class="normal">                    next_use</span><span class="symbol">.</span><span class="function">push_front</span><span class="symbol">(</span><span class="normal">blocks_next_acquire</span><span class="symbol">[</span><span class="normal">it</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">]);</span>
<span class="normal">                    </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">case</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_deinitialize</span><span class="symbol">):</span>
<span class="normal">                    blocks_next_acquire</span><span class="symbol">[</span><span class="normal">it</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">make_pair</span><span class="symbol">(</span><span class="keyword">false</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">case</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_initialize</span><span class="symbol">):</span>
<span class="normal">                    blocks_next_acquire</span><span class="symbol">[</span><span class="normal">it</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">make_pair</span><span class="symbol">(</span><span class="keyword">false</span><span class="symbol">,</span><span class="normal"> </span><span class="number">3</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">case</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_extract_external_block</span><span class="symbol">):</span>
<span class="normal">                    blocks_next_acquire</span><span class="symbol">[</span><span class="normal">it</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">make_pair</span><span class="symbol">(</span><span class="keyword">false</span><span class="symbol">,</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> </span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">()-&gt;</span><span class="function">evictable_blocks_empty</span><span class="symbol">())</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// insert already evictable blocks with the right priority</span>
<span class="normal">                </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid </span><span class="symbol">=</span><span class="normal"> </span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">()-&gt;</span><span class="function">evictable_blocks_pop</span><span class="symbol">();</span>
<span class="normal">                evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="function">priority</span><span class="symbol">(</span><span class="normal">swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">],</span><span class="normal"> blocks_next_acquire</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">]));</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="function">block_scheduler_algorithm_offline_lfd</span><span class="symbol">(</span><span class="normal">block_scheduler_type </span><span class="symbol">&amp;</span><span class="normal"> bs</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">block_scheduler_algorithm_type</span><span class="symbol">(</span><span class="normal">bs</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">init</span><span class="symbol">(</span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">());</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">// It is possible to keep an old simulation-algorithm object and reuse it's prediction sequence</span>
<span class="normal">    </span><span class="function">block_scheduler_algorithm_offline_lfd</span><span class="symbol">(</span><span class="normal">block_scheduler_algorithm_type </span><span class="symbol">*</span><span class="normal"> old</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">block_scheduler_algorithm_type</span><span class="symbol">(</span><span class="normal">old</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">init</span><span class="symbol">(</span><span class="normal">old</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="symbol">~</span><span class="function">block_scheduler_algorithm_offline_lfd</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">STXXL_ERRMSG</span><span class="symbol">(</span><span class="string">"Destructing block_scheduler_algorithm_offline_lfd that still holds evictable blocks. They get deinitialized."</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">evictable_blocks</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">()];</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">deinitialize</span><span class="symbol">())</span>
<span class="normal">                </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">evictable_blocks_empty</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> </span><span class="function">evictable_blocks_pop</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> evictable_blocks</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> internal_block_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">acquire</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> uninitialized </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        </span><span class="comment">/* acquired =&gt; internal -&gt; increase reference count</span>
<span class="comment">           internal but not acquired -&gt; remove from evictable_blocks, increase reference count</span>
<span class="comment">           not intern =&gt; uninitialized or external -&gt; get internal_block, increase reference count</span>
<span class="comment">           uninitialized -&gt; fill with default value</span>
<span class="comment">           external -&gt; read */</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_internal</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">is_acquired</span><span class="symbol">())</span>
<span class="normal">                </span><span class="comment">// not acquired yet -&gt; remove from evictable_blocks</span>
<span class="normal">                evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">acquire</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_initialized</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// =&gt; external but not internal</span>
<span class="normal">            </span><span class="comment">//get internal_block</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">attach_internal_block</span><span class="symbol">(</span><span class="function">get_free_internal_block</span><span class="symbol">());</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> uninitialized</span><span class="symbol">)</span>
<span class="normal">                </span><span class="comment">//load block synchronously</span>
<span class="normal">                sblock</span><span class="symbol">.</span><span class="function">read_sync</span><span class="symbol">();</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">acquire</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// =&gt; ! sblock.is_initialized()</span>
<span class="normal">            </span><span class="comment">//get internal_block</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">attach_internal_block</span><span class="symbol">(</span><span class="function">get_free_internal_block</span><span class="symbol">());</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">acquire</span><span class="symbol">();</span>
<span class="normal">            </span><span class="comment">//initialize new block</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> uninitialized</span><span class="symbol">)</span>
<span class="normal">                sblock</span><span class="symbol">.</span><span class="function">fill_default</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">get_internal_block</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">release</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> dirty</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next_use</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">STXXL_ERRMSG</span><span class="symbol">(</span><span class="string">"block_scheduler_algorithm_offline_lfd got release-request but prediction sequence ended. Switching to block_scheduler_algorithm_online."</span><span class="symbol">);</span>
<span class="normal">            </span><span class="comment">// switch algorithm</span>
<span class="normal">            block_scheduler_algorithm_type </span><span class="symbol">*</span><span class="normal"> new_algo</span><span class="symbol">,</span>
<span class="normal">                                           </span><span class="symbol">*</span><span class="normal"> old_algo</span><span class="symbol">;</span>
<span class="normal">            new_algo </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> block_scheduler_algorithm_online_lru</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;(</span><span class="normal">bs</span><span class="symbol">);</span>
<span class="normal">            old_algo </span><span class="symbol">=</span><span class="normal"> bs</span><span class="symbol">.</span><span class="function">switch_algorithm_to</span><span class="symbol">(</span><span class="normal">new_algo</span><span class="symbol">);</span>
<span class="normal">            </span><span class="comment">// redirect call</span>
<span class="normal">            new_algo</span><span class="symbol">-&gt;</span><span class="function">release</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">,</span><span class="normal"> dirty</span><span class="symbol">);</span>
<span class="normal">            </span><span class="comment">// delete self</span>
<span class="normal">            </span><span class="keyword">delete</span><span class="normal"> old_algo</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">return</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        sblock</span><span class="symbol">.</span><span class="function">make_dirty_if</span><span class="symbol">(</span><span class="normal">dirty</span><span class="symbol">);</span>
<span class="normal">        sblock</span><span class="symbol">.</span><span class="function">release</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">is_acquired</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_dirty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">is_external</span><span class="symbol">())</span>
<span class="normal">                </span><span class="comment">// =&gt; evictable, put in pq</span>
<span class="normal">                evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="function">priority</span><span class="symbol">(</span><span class="normal">swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">],</span><span class="normal"> next_use</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">()));</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">                </span><span class="comment">// =&gt; uninitialized, release internal block and put it in freelist</span>
<span class="normal">                </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">detach_internal_block</span><span class="symbol">());</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        next_use</span><span class="symbol">.</span><span class="function">pop_front</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">deinitialize</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_evictable</span><span class="symbol">())</span>
<span class="normal">            evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">deinitialize</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">initialize</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">external_block_type</span><span class="normal"> eblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        sblock</span><span class="symbol">.</span><span class="function">initialize</span><span class="symbol">(</span><span class="normal">eblock</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="usertype">external_block_type</span><span class="normal"> </span><span class="function">extract_external_block</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_evictable</span><span class="symbol">())</span>
<span class="normal">            evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_internal</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">detach_internal_block</span><span class="symbol">());</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">extract_external_block</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">//! \brief Block scheduling algorithm caching via the least recently used policy (offline),</span>
<span class="comment">//! and prefetching in addition.</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">SwappableBlockType</span><span class="symbol">&gt;</span>
<span class="keyword">class</span><span class="normal"> </span><span class="classname">block_scheduler_algorithm_offline_lru_prefetching</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">public</span><span class="normal"> block_scheduler_algorithm</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;</span>
<span class="cbracket">{</span>
<span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">scheduled_block_meta</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">write_read_request</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">block_scheduler&lt;SwappableBlockType&gt;</span><span class="normal"> block_scheduler_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">block_scheduler_algorithm&lt;SwappableBlockType&gt;</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">internal_block_type</span><span class="normal"> internal_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">external_block_type</span><span class="normal"> external_block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> swappable_block_identifier_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="usertype">time_type</span><span class="normal"> time_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">prediction_sequence_type</span><span class="normal"> prediction_sequence_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">block_scheduler_type</span><span class="symbol">::</span><span class="usertype">block_scheduler_operation</span><span class="normal"> block_scheduler_operation</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">vector</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;::</span><span class="usertype">iterator</span><span class="normal"> swappable_blocks_iterator</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">map&lt;swappable_block_identifier_type, scheduled_block_meta&gt;</span><span class="normal"> scheduled_blocks_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">scheduled_blocks_type</span><span class="symbol">::</span><span class="usertype">iterator</span><span class="normal"> scheduled_blocks_iterator</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">scheduled_blocks_type</span><span class="symbol">::</span><span class="usertype">reference</span><span class="normal"> scheduled_blocks_reference</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">map&lt;swappable_block_identifier_type, write_read_request *&gt;</span><span class="normal"> write_scheduled_blocks_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">write_scheduled_blocks_type</span><span class="symbol">::</span><span class="usertype">iterator</span><span class="normal"> write_scheduled_blocks_iterator</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">write_scheduled_blocks_type</span><span class="symbol">::</span><span class="usertype">reference</span><span class="normal"> write_scheduled_blocks_reference</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">bs</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">swappable_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">get_algorithm_from_block_scheduler</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">get_free_internal_block_from_block_scheduler</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">return_free_internal_block_to_block_scheduler</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">using</span><span class="normal"> block_scheduler_algorithm_type</span><span class="symbol">::</span><span class="normal">prediction_sequence</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">write_read_request</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="type">bool</span><span class="normal"> write_done_soon</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// set by read_after_write, checked by schedule_read()</span>
<span class="normal">        </span><span class="type">bool</span><span class="normal"> shall_read</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// checked by read_after_write, set by schedule_read()</span>
<span class="normal">        </span><span class="usertype">swappable_blocks_iterator</span><span class="normal"> block_to_start_read</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// used by read_after_write, set by schedule_read()</span>
<span class="normal">        </span><span class="usertype">scheduled_blocks_iterator</span><span class="normal"> taker</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// read_req set by read_after_write</span>
<span class="normal">        </span><span class="usertype">request_ptr</span><span class="normal"> write_req</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// completes with read_after_write</span>

<span class="normal">        </span><span class="function">write_read_request</span><span class="symbol">()</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">write_done_soon</span><span class="symbol">(</span><span class="keyword">false</span><span class="symbol">),</span><span class="normal"> </span><span class="function">shall_read</span><span class="symbol">(</span><span class="keyword">false</span><span class="symbol">),</span><span class="normal"> </span><span class="function">block_to_start_read</span><span class="symbol">(),</span><span class="normal"> </span><span class="function">taker</span><span class="symbol">(),</span><span class="normal"> </span><span class="function">write_req</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">read_after_write</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        write_read_request </span><span class="symbol">*</span><span class="normal"> wrr</span><span class="symbol">;</span>

<span class="normal">        </span><span class="function">read_after_write</span><span class="symbol">(</span><span class="normal">write_read_request </span><span class="symbol">*</span><span class="normal"> write_read_req</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">wrr</span><span class="symbol">(</span><span class="normal">write_read_req</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="keyword">operator</span><span class="normal"> </span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">request </span><span class="symbol">*)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            wrr</span><span class="symbol">-&gt;</span><span class="normal">write_done_soon </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">wrr</span><span class="symbol">-&gt;</span><span class="normal">shall_read</span><span class="symbol">)</span>
<span class="normal">                wrr</span><span class="symbol">-&gt;</span><span class="normal">taker</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">read_req </span><span class="symbol">=</span><span class="normal"> wrr</span><span class="symbol">-&gt;</span><span class="normal">block_to_start_read</span><span class="symbol">-&gt;</span><span class="function">read_async</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">scheduled_block_meta</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        internal_block_type </span><span class="symbol">*</span><span class="normal"> reserved_iblock</span><span class="symbol">;</span>
<span class="normal">        std</span><span class="symbol">::</span><span class="usertype">pair&lt;bool, swappable_block_identifier_type&gt;</span><span class="normal"> giver</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">request_ptr</span><span class="normal"> read_req</span><span class="symbol">;</span>
<span class="normal">        std</span><span class="symbol">::</span><span class="usertype">deque&lt;block_scheduler_operation&gt;</span><span class="normal"> operations</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// invariant: not empty; front: last scheduled operation, back: upcoming operation</span>

<span class="normal">        </span><span class="function">scheduled_block_meta</span><span class="symbol">(</span><span class="usertype">block_scheduler_operation</span><span class="normal"> op</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">reserved_iblock</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">giver</span><span class="symbol">(</span><span class="keyword">false</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">read_req</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">operations</span><span class="symbol">()</span>
<span class="normal">        </span><span class="cbracket">{</span><span class="normal"> operations</span><span class="symbol">.</span><span class="function">push_front</span><span class="symbol">(</span><span class="normal">op</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">//! \brief Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired.</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="usertype">set&lt;swappable_block_identifier_type&gt;</span><span class="normal"> free_evictable_blocks</span><span class="symbol">;</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="usertype">set&lt;swappable_block_identifier_type&gt;</span><span class="normal"> scheduled_evictable_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="comment">//! \brief Holds not internal swappable_blocks, whose next access has already been scheduled.</span>
<span class="normal">    </span><span class="usertype">scheduled_blocks_type</span><span class="normal"> scheduled_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="comment">//! \brief Holds swappable_blocks, whose internal block has been taken away but the clean did not finish yet.</span>
<span class="normal">    </span><span class="usertype">write_scheduled_blocks_type</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">prediction_sequence_type</span><span class="symbol">::</span><span class="usertype">iterator</span><span class="normal"> next_op_to_schedule</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">//! \brief Schedule an internal, possibly dirty swappable_block to write.</span>
<span class="normal">    </span><span class="comment">//!</span>
<span class="normal">    </span><span class="comment">//! The block becomes not dirty. if it was dirty, an entry in write_scheduled_blocks is made referencing the write_read_request.</span>
<span class="normal">    </span><span class="comment">//! \param sbid block to write</span>
<span class="normal">    </span><span class="comment">//! \return pointer to the write_read_request</span>
<span class="normal">    write_read_request </span><span class="symbol">*</span><span class="normal"> </span><span class="function">schedule_write</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        write_read_request </span><span class="symbol">*</span><span class="normal"> wrr </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> write_read_request</span><span class="symbol">;</span>
<span class="normal">        wrr</span><span class="symbol">-&gt;</span><span class="normal">write_req </span><span class="symbol">=</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">clean_async</span><span class="symbol">(</span><span class="function">read_after_write</span><span class="symbol">(</span><span class="normal">wrr</span><span class="symbol">));</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">wrr</span><span class="symbol">-&gt;</span><span class="normal">write_req</span><span class="symbol">.</span><span class="function">valid</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="type">bool</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="function">make_pair</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">,</span><span class="normal"> wrr</span><span class="symbol">)).</span><span class="normal">second</span><span class="symbol">;</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> wrr</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">delete</span><span class="normal"> wrr</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief try to interrupt a read scheduled in a write_read_request</span>
<span class="normal">    </span><span class="comment">//!</span>
<span class="normal">    </span><span class="comment">//! side-effect: possibly erases entry from write_scheduled_blocks, so the iterator writing_block may become invalid</span>
<span class="normal">    </span><span class="comment">//! \return if successful</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">try_interrupt_read</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> write_scheduled_blocks_iterator </span><span class="symbol">&amp;</span><span class="normal"> writing_block</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// stop read</span>
<span class="normal">        writing_block</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">shall_read </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">        </span><span class="comment">// check if stopped</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> writing_block</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">write_done_soon</span><span class="symbol">)</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">        </span><span class="comment">// =&gt; possibly to late</span>
<span class="normal">        </span><span class="usertype">scheduled_blocks_reference</span><span class="normal"> taker </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">writing_block</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">taker</span><span class="symbol">;</span>
<span class="normal">        </span><span class="comment">// wait</span>
<span class="normal">        </span><span class="function">wait_on_write</span><span class="symbol">(</span><span class="normal">writing_block</span><span class="symbol">);</span>
<span class="normal">        </span><span class="comment">// check if read started</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">taker</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">read_req</span><span class="symbol">.</span><span class="function">valid</span><span class="symbol">())</span>
<span class="normal">            </span><span class="comment">// =&gt; read started, to late</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">else</span>
<span class="normal">            </span><span class="comment">// =&gt; just in time</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Schedule an internal and external block to read.</span>
<span class="normal">    </span><span class="comment">//!</span>
<span class="normal">    </span><span class="comment">//! If the giver is still writing, schedule read via its write_read_request.</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">schedule_read</span><span class="symbol">(</span><span class="usertype">scheduled_blocks_iterator</span><span class="normal"> block_to_read</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// first check if block_to_read is still writing. do not read before write finished</span>
<span class="normal">        </span><span class="comment">// wait_on_write(block_to_read-&gt;first);</span>

<span class="normal">        </span><span class="usertype">write_scheduled_blocks_iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">it </span><span class="symbol">!=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">scheduled_blocks_iterator</span><span class="normal"> other_block_to_read </span><span class="symbol">=</span><span class="normal"> it</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">taker</span><span class="symbol">;</span>
<span class="normal">            </span><span class="comment">// check if scheduled to read</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">shall_read</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">try_interrupt_read</span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">))</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// =&gt; interrupted, swap internal_blocks</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">,</span><span class="normal"> block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="usertype">write_scheduled_blocks_iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">it </span><span class="symbol">!=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">                            it</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">taker </span><span class="symbol">=</span><span class="normal"> other_block_to_read</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="keyword">else</span>
<span class="normal">                            other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="usertype">write_scheduled_blocks_iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">it </span><span class="symbol">!=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">                            it</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">taker </span><span class="symbol">=</span><span class="normal"> block_to_read</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="keyword">else</span>
<span class="normal">                            block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    internal_block_type </span><span class="symbol">*</span><span class="normal"> tmp_iblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">].</span><span class="function">detach_internal_block</span><span class="symbol">();</span>
<span class="normal">                    swappable_blocks</span><span class="symbol">[</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">].</span><span class="function">attach_internal_block</span><span class="symbol">(</span>
<span class="normal">                            swappable_blocks</span><span class="symbol">[</span><span class="normal">other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">].</span><span class="function">detach_internal_block</span><span class="symbol">());</span>
<span class="normal">                    swappable_blocks</span><span class="symbol">[</span><span class="normal">other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">].</span><span class="function">attach_internal_block</span><span class="symbol">(</span><span class="normal">tmp_iblock</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="comment">// =&gt; this block has its internal_block back, no need to read</span>
<span class="normal">                    </span><span class="comment">// reschedule other</span>
<span class="normal">                    </span><span class="function">schedule_read</span><span class="symbol">(</span><span class="normal">other_block_to_read</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="comment">// else =&gt; read already started, but write done -&gt; read this</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// =&gt; no read scheduled, swap internal_blocks</span>
<span class="normal">                std</span><span class="symbol">::</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">,</span><span class="normal"> block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">write_scheduled_blocks_iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">it </span><span class="symbol">!=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">                        it</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">taker </span><span class="symbol">=</span><span class="normal"> other_block_to_read</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                        other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">write_scheduled_blocks_iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">it </span><span class="symbol">!=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">                        it</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">taker </span><span class="symbol">=</span><span class="normal"> block_to_read</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                        block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                internal_block_type </span><span class="symbol">*</span><span class="normal"> tmp_iblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">].</span><span class="function">detach_internal_block</span><span class="symbol">();</span>
<span class="normal">                swappable_blocks</span><span class="symbol">[</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">].</span><span class="function">attach_internal_block</span><span class="symbol">(</span>
<span class="normal">                        other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock</span><span class="symbol">);</span>
<span class="normal">                other_block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock </span><span class="symbol">=</span><span class="normal"> tmp_iblock</span><span class="symbol">;</span>
<span class="normal">                </span><span class="comment">// =&gt; this block has its internal_block back, no need to read</span>
<span class="normal">                </span><span class="keyword">return</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// schedule block_to_read to read</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">write_scheduled_blocks_iterator</span><span class="normal"> writing_block </span><span class="symbol">=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">writing_block </span><span class="symbol">!=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// =&gt; there is a write scheduled</span>
<span class="normal">                </span><span class="comment">// tell the completion handler that we want a read</span>
<span class="normal">                writing_block</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">block_to_start_read </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> block_to_read</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">;</span>
<span class="normal">                writing_block</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">taker </span><span class="symbol">=</span><span class="normal"> block_to_read</span><span class="symbol">;</span>
<span class="normal">                writing_block</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">shall_read </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">                </span><span class="comment">// and check if it is not to late</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">writing_block</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">write_done_soon</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// =&gt; the completion handler may have missed our wish to read</span>
<span class="normal">                    </span><span class="comment">// so wait for it to finish and check</span>
<span class="normal">                    </span><span class="function">wait_on_write</span><span class="symbol">(</span><span class="normal">writing_block</span><span class="symbol">);</span>
<span class="normal">                    block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">read_req</span><span class="symbol">.</span><span class="function">valid</span><span class="symbol">())</span>
<span class="normal">                        </span><span class="comment">// read scheduled</span>
<span class="normal">                        </span><span class="keyword">return</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="comment">// read scheduled</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">                block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="comment">// =&gt; read could not be scheduled through the completion handler</span>
<span class="normal">        block_to_read</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">read_req </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">block_to_read</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">].</span><span class="function">read_async</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief wait for the write to finish</span>
<span class="normal">    </span><span class="comment">//!</span>
<span class="normal">    </span><span class="comment">//! side-effect: erases entry from write_scheduled_blocks</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">wait_on_write</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> write_scheduled_blocks_iterator </span><span class="symbol">&amp;</span><span class="normal"> writing_block</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        writing_block</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">-&gt;</span><span class="normal">write_req</span><span class="symbol">-&gt;</span><span class="function">wait</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">delete</span><span class="normal"> writing_block</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">;</span>
<span class="normal">        write_scheduled_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">writing_block</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief wait for the write to finish</span>
<span class="normal">    </span><span class="comment">//!</span>
<span class="normal">    </span><span class="comment">//! side-effect: erases entry from write_scheduled_blocks</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">wait_on_write</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> swappable_block_identifier_type </span><span class="symbol">&amp;</span><span class="normal"> writing_block</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">write_scheduled_blocks_iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">writing_block</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">it </span><span class="symbol">!=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">wait_on_write</span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief wait for the write of the giver to finish</span>
<span class="normal">    </span><span class="comment">//!</span>
<span class="normal">    </span><span class="comment">//! side-effect: erases entry from write_scheduled_blocks</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">wait_on_write</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> scheduled_blocks_iterator </span><span class="symbol">&amp;</span><span class="normal"> schedule_meta</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">wait_on_write</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">            schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief wait for the read to finish</span>
<span class="normal">    </span><span class="comment">//!</span>
<span class="normal">    </span><span class="comment">//! side-effect: erases entry for the write of the giver from write_scheduled_blocks</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">wait_on_read</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> scheduled_blocks_iterator </span><span class="symbol">&amp;</span><span class="normal"> schedule_meta</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">wait_on_write</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">read_req</span><span class="symbol">.</span><span class="function">valid</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">read_req</span><span class="symbol">-&gt;</span><span class="function">wait</span><span class="symbol">();</span>
<span class="normal">            schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">read_req </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief wait for the write of the giver to finish and return reserved internal_block</span>
<span class="normal">    </span><span class="comment">//!</span>
<span class="normal">    </span><span class="comment">//! side-effect: erases entry for the write of the giver from write_scheduled_blocks</span>
<span class="normal">    internal_block_type </span><span class="symbol">*</span><span class="normal"> </span><span class="function">get_ready_block</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> scheduled_blocks_iterator </span><span class="symbol">&amp;</span><span class="normal"> schedule_meta</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">wait_on_write</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">);</span>
<span class="normal">        internal_block_type </span><span class="symbol">*</span><span class="normal"> r </span><span class="symbol">=</span><span class="normal"> schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock</span><span class="symbol">;</span>
<span class="normal">        schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> r</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">shall_keep_internal_block</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> scheduled_blocks_iterator </span><span class="symbol">&amp;</span><span class="normal"> schedule_meta</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> ignore_first </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// returns true iif there is an acquire or acquire_uninitialized scheduled or there is a deinitialize scheduled and the block is dirty</span>
<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">deque</span><span class="symbol">&lt;</span><span class="normal">block_scheduler_operation</span><span class="symbol">&gt;::</span><span class="normal">reverse_iterator</span>
<span class="normal">                rit </span><span class="symbol">=</span><span class="normal"> schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">rbegin</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> ignore_first</span><span class="symbol">;</span>
<span class="normal">                rit </span><span class="symbol">!=</span><span class="normal"> schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">rend</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">rit</span><span class="symbol">)</span>
<span class="normal">            </span><span class="keyword">switch</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">rit</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire</span><span class="symbol">:</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire_uninitialized</span><span class="symbol">:</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span><span class="normal"> </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release</span><span class="symbol">:</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release_dirty</span><span class="symbol">:</span>
<span class="normal">                </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_deinitialize</span><span class="symbol">:</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">swappable_blocks</span><span class="symbol">[</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">].</span><span class="function">is_dirty</span><span class="symbol">())</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span><span class="normal"> </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_initialize</span><span class="symbol">:</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_extract_external_block</span><span class="symbol">:</span>
<span class="normal">                </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">// assumes the current operation to be still in operations</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">shall_be_cleaned</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> scheduled_blocks_iterator </span><span class="symbol">&amp;</span><span class="normal"> schedule_meta</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// returns true iif there is an extract_external_block scheduled and no release_dirty, deinitialize or initialize before</span>
<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">deque</span><span class="symbol">&lt;</span><span class="normal">block_scheduler_operation</span><span class="symbol">&gt;::</span><span class="normal">reverse_iterator</span>
<span class="normal">                rit </span><span class="symbol">=</span><span class="normal"> schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">rbegin</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                rit </span><span class="symbol">!=</span><span class="normal"> schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">rend</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">rit</span><span class="symbol">)</span>
<span class="normal">            </span><span class="keyword">switch</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">rit</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire</span><span class="symbol">:</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire_uninitialized</span><span class="symbol">:</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release</span><span class="symbol">:</span>
<span class="normal">                </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release_dirty</span><span class="symbol">:</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_deinitialize</span><span class="symbol">:</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_initialize</span><span class="symbol">:</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span><span class="normal"> </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">case</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_extract_external_block</span><span class="symbol">:</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span><span class="normal"> </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">shall_be_read</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> scheduled_blocks_iterator </span><span class="symbol">&amp;</span><span class="normal"> schedule_meta</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> ignore_first </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// returns true iif there is an acquire scheduled next and the block is initialized</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">].</span><span class="function">is_initialized</span><span class="symbol">()</span>
<span class="normal">                </span><span class="symbol">&amp;&amp;</span><span class="normal"> schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">rbegin</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> ignore_first </span><span class="symbol">!=</span><span class="normal"> schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">rend</span><span class="symbol">()</span>
<span class="normal">                </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">rbegin</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> ignore_first</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">operation_done</span><span class="symbol">(</span><span class="normal">scheduled_blocks_iterator </span><span class="symbol">&amp;</span><span class="normal"> schedule_meta</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">pop_back</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">);</span>
<span class="normal">            scheduled_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    block_scheduler_algorithm_type </span><span class="symbol">*</span><span class="normal"> </span><span class="function">give_up</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="usertype">string</span><span class="normal"> err_msg </span><span class="symbol">=</span><span class="normal"> </span><span class="string">"detected some error in the prediction sequence"</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">STXXL_ERRMSG</span><span class="symbol">(</span><span class="string">"block_scheduler_algorithm_offline_lru_prefetching: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> err_msg </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">". Switching to block_scheduler_algorithm_online."</span><span class="symbol">);</span>
<span class="normal">        </span><span class="comment">// switch algorithm</span>
<span class="normal">        block_scheduler_algorithm_type </span><span class="symbol">*</span><span class="normal"> new_algo</span>
<span class="normal">                </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> block_scheduler_algorithm_online_lru</span><span class="symbol">&lt;</span><span class="normal">SwappableBlockType</span><span class="symbol">&gt;(</span><span class="normal">bs</span><span class="symbol">);</span>
<span class="normal">        </span><span class="comment">// and delete self</span>
<span class="normal">        </span><span class="keyword">delete</span><span class="normal"> bs</span><span class="symbol">.</span><span class="function">switch_algorithm_to</span><span class="symbol">(</span><span class="normal">new_algo</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> new_algo</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">return_free_internal_block_to_block_scheduler</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">schedule_next_operations</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next_op_to_schedule </span><span class="symbol">!=</span><span class="normal"> prediction_sequence</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// list operation in scheduled_blocks</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">pair&lt;scheduled_blocks_iterator, bool&gt;</span><span class="normal"> ins_res </span><span class="symbol">=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="function">make_pair</span><span class="symbol">(</span><span class="normal">next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">,</span><span class="normal"> next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">op</span><span class="symbol">));</span>
<span class="normal">            </span><span class="usertype">scheduled_blocks_iterator</span><span class="normal"> schedule_meta </span><span class="symbol">=</span><span class="normal"> ins_res</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> ins_res</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">)</span>
<span class="normal">                schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">push_front</span><span class="symbol">(</span><span class="normal">next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">op</span><span class="symbol">);</span>
<span class="normal">            SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">];</span>

<span class="normal">            </span><span class="comment">// do appropriate preparations</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">op </span><span class="symbol">==</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire</span>
<span class="normal">                    </span><span class="symbol">||</span><span class="normal"> next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">op </span><span class="symbol">==</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire_uninitialized</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_internal</span><span class="symbol">())</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">free_evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">))</span>
<span class="normal">                        scheduled_evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="comment">// =&gt; needs internal_block -&gt; try to get one</span>
<span class="normal">                        </span><span class="comment">// -&gt; try to get one from block_scheduler</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock </span><span class="symbol">=</span><span class="normal"> </span><span class="function">get_free_internal_block_from_block_scheduler</span><span class="symbol">()))</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="comment">// -&gt; try to get one by evicting</span>
<span class="normal">                            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">free_evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">                            </span><span class="cbracket">{</span>
<span class="normal">                                </span><span class="comment">// =&gt; can not schedule acquire</span>
<span class="normal">                                </span><span class="comment">// remove operation from scheduled_blocks</span>
<span class="normal">                                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ins_res</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">)</span>
<span class="normal">                                    scheduled_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">ins_res</span><span class="symbol">.</span><span class="normal">first</span><span class="symbol">);</span>
<span class="normal">                                </span><span class="keyword">else</span>
<span class="normal">                                    schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">pop_front</span><span class="symbol">();</span>
<span class="normal">                                </span><span class="comment">// stop scheduling</span>
<span class="normal">                                </span><span class="keyword">return</span><span class="symbol">;</span>
<span class="normal">                            </span><span class="cbracket">}</span>
<span class="normal">                            </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> giver </span><span class="symbol">=</span><span class="normal"> </span><span class="function">pop_begin</span><span class="symbol">(</span><span class="normal">free_evictable_blocks</span><span class="symbol">);</span>
<span class="normal">                            </span><span class="cbracket">{</span>
<span class="normal">                                </span><span class="usertype">scheduled_blocks_iterator</span><span class="normal"> giver_meta</span><span class="symbol">;</span>
<span class="normal">                                </span><span class="function">assert</span><span class="symbol">((</span><span class="normal">giver_meta </span><span class="symbol">=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">giver</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">()</span>
<span class="normal">                                        </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">!</span><span class="normal"> </span><span class="function">shall_keep_internal_block</span><span class="symbol">(</span><span class="normal">giver_meta</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">));</span>
<span class="normal">                            </span><span class="cbracket">}</span>
<span class="normal">                            write_read_request </span><span class="symbol">*</span><span class="normal"> wrr </span><span class="symbol">=</span><span class="normal"> </span><span class="function">schedule_write</span><span class="symbol">(</span><span class="normal">giver</span><span class="symbol">);</span>
<span class="normal">                            schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">=</span><span class="normal"> </span><span class="type">bool</span><span class="symbol">(</span><span class="normal">wrr</span><span class="symbol">);</span>
<span class="normal">                            schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">giver</span><span class="symbol">.</span><span class="normal">second </span><span class="symbol">=</span><span class="normal"> giver</span><span class="symbol">;</span>
<span class="normal">                            schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">giver</span><span class="symbol">].</span><span class="function">detach_internal_block</span><span class="symbol">();</span>
<span class="normal">                            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">wrr</span><span class="symbol">)</span>
<span class="normal">                                wrr</span><span class="symbol">-&gt;</span><span class="normal">taker </span><span class="symbol">=</span><span class="normal"> schedule_meta</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="comment">// read if desired</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">shall_be_read</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">))</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="comment">// =&gt; there is no operation scheduled for this block before this acquire and it is initialized</span>
<span class="normal">                            </span><span class="comment">// -&gt; start prefetching now</span>
<span class="normal">                            sblock</span><span class="symbol">.</span><span class="function">attach_internal_block</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock</span><span class="symbol">);</span>
<span class="normal">                            schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                            scheduled_evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">);</span>
<span class="normal">                            </span><span class="function">schedule_read</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">op </span><span class="symbol">==</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_deinitialize</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_dirty</span><span class="symbol">())</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">free_evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">))</span>
<span class="normal">                        scheduled_evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">next_op_to_schedule</span><span class="symbol">-&gt;</span><span class="normal">id</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="symbol">++</span><span class="normal"> next_op_to_schedule</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">set</span><span class="symbol">&lt;</span><span class="normal">swappable_block_identifier_type</span><span class="symbol">&gt;::</span><span class="usertype">iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> free_evictable_blocks</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">();</span>
<span class="normal">                it </span><span class="symbol">!=</span><span class="normal"> free_evictable_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">it</span><span class="symbol">)</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">count</span><span class="symbol">(*</span><span class="normal">it</span><span class="symbol">))</span>
<span class="normal">                </span><span class="function">schedule_write</span><span class="symbol">(*</span><span class="normal">it</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">init</span><span class="symbol">(</span><span class="normal">block_scheduler_algorithm_type </span><span class="symbol">*</span><span class="normal"> old_algo</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="symbol">(</span><span class="normal">old_algo</span><span class="symbol">)</span>
<span class="normal">            </span><span class="comment">// copy prediction sequence</span>
<span class="normal">            prediction_sequence </span><span class="symbol">=</span><span class="normal"> old_algo</span><span class="symbol">-&gt;</span><span class="function">get_prediction_sequence</span><span class="symbol">();</span>
<span class="normal">        next_op_to_schedule </span><span class="symbol">=</span><span class="normal"> prediction_sequence</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">())</span>
<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> </span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">()-&gt;</span><span class="function">evictable_blocks_empty</span><span class="symbol">())</span>
<span class="normal">                free_evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">()-&gt;</span><span class="function">evictable_blocks_pop</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">schedule_next_operations</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">deinit</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// todo remove</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">STXXL_MSG</span><span class="symbol">(</span><span class="string">"deinit while scheduled_blocks not empty"</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> scheduled_evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">STXXL_MSG</span><span class="symbol">(</span><span class="string">"deinit while scheduled_evictable_blocks not empty"</span><span class="symbol">);</span>

<span class="normal">        </span><span class="comment">// empty scheduled_blocks</span>
<span class="normal">        free_evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">scheduled_evictable_blocks</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> scheduled_evictable_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>
<span class="normal">        </span><span class="comment">//for (typename std::set&lt;swappable_block_identifier_type&gt;::iterator it = scheduled_evictable_blocks.begin();</span>
<span class="normal">        </span><span class="comment">//        it != scheduled_evictable_blocks.end(); ++it)</span>
<span class="normal">        </span><span class="comment">//    free_evictable_blocks.insert(*it);</span>
<span class="normal">        scheduled_evictable_blocks</span><span class="symbol">.</span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">scheduled_blocks_iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">();</span>
<span class="normal">            </span><span class="function">wait_on_read</span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock</span><span class="symbol">)</span>
<span class="normal">                </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock</span><span class="symbol">);</span>
<span class="normal">            scheduled_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">write_scheduled_blocks_iterator</span><span class="normal"> it </span><span class="symbol">=</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">();</span>
<span class="normal">            </span><span class="function">wait_on_write</span><span class="symbol">(</span><span class="normal">it</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">    </span><span class="function">block_scheduler_algorithm_offline_lru_prefetching</span><span class="symbol">(</span><span class="normal">block_scheduler_type </span><span class="symbol">&amp;</span><span class="normal"> bs</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">block_scheduler_algorithm_type</span><span class="symbol">(</span><span class="normal">bs</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">init</span><span class="symbol">(</span><span class="function">get_algorithm_from_block_scheduler</span><span class="symbol">());</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">// It is possible to keep an old simulation-algorithm object and reuse it's prediction sequence</span>
<span class="normal">    </span><span class="function">block_scheduler_algorithm_offline_lru_prefetching</span><span class="symbol">(</span><span class="normal">block_scheduler_algorithm_type </span><span class="symbol">*</span><span class="normal"> old</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">block_scheduler_algorithm_type</span><span class="symbol">(</span><span class="normal">old</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="function">init</span><span class="symbol">(</span><span class="normal">old</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="symbol">~</span><span class="function">block_scheduler_algorithm_offline_lru_prefetching</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">deinit</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> free_evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">            </span><span class="function">STXXL_ERRMSG</span><span class="symbol">(</span><span class="string">"Destructing block_scheduler_algorithm_offline_lru_prefetching that still holds evictable blocks. They get deinitialized."</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> free_evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="function">pop_begin</span><span class="symbol">(</span><span class="normal">free_evictable_blocks</span><span class="symbol">)];</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">deinitialize</span><span class="symbol">())</span>
<span class="normal">                </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">evictable_blocks_empty</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">deinit</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> free_evictable_blocks</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> </span><span class="function">evictable_blocks_pop</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="function">pop_begin</span><span class="symbol">(</span><span class="normal">free_evictable_blocks</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> internal_block_type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">acquire</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> uninitialized </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> prediction_sequence</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prediction_sequence</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">op </span><span class="symbol">==</span>
<span class="normal">                </span><span class="symbol">((</span><span class="normal">uninitialized</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire_uninitialized </span><span class="symbol">:</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire</span><span class="symbol">));</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prediction_sequence</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">id </span><span class="symbol">==</span><span class="normal"> sbid</span><span class="symbol">);</span>
<span class="normal">        prediction_sequence</span><span class="symbol">.</span><span class="function">pop_front</span><span class="symbol">();</span>
<span class="normal">        </span><span class="usertype">scheduled_blocks_iterator</span><span class="normal"> schedule_meta </span><span class="symbol">=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">schedule_meta </span><span class="symbol">!=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span><span class="normal"> </span><span class="comment">// acquire not scheduled or out of internal_blocks (i.e. not enough internal memory)</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">back</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">==</span>
<span class="normal">                        </span><span class="symbol">((</span><span class="normal">uninitialized</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire_uninitialized </span><span class="symbol">:</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_acquire</span><span class="symbol">));</span><span class="normal"> </span><span class="comment">// acquire not scheduled or out of internal_blocks (i.e. not enough internal memory)</span>

<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        </span><span class="comment">/* acquired =&gt; internal -&gt; increase reference count</span>
<span class="comment">           internal but not acquired -&gt; remove from scheduled_evictable_blocks, increase reference count</span>
<span class="comment">           not internal =&gt; uninitialized or external -&gt; get internal_block, increase reference count</span>
<span class="comment">           uninitialized -&gt; fill with default value</span>
<span class="comment">           external -&gt; read */</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_internal</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">is_acquired</span><span class="symbol">())</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// not acquired yet -&gt; remove from scheduled_evictable_blocks</span>
<span class="normal">                </span><span class="type">bool</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> scheduled_evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">                </span><span class="function">wait_on_read</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">acquire</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">uninitialized </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">!</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">is_initialized</span><span class="symbol">());</span><span class="normal"> </span><span class="comment">// initialized blocks should be scheduled to read and thus internal</span>
<span class="normal">            </span><span class="comment">//get internal_block</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">attach_internal_block</span><span class="symbol">(</span><span class="function">get_ready_block</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">));</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">acquire</span><span class="symbol">();</span>
<span class="normal">            </span><span class="comment">//initialize new block</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> uninitialized</span><span class="symbol">)</span>
<span class="normal">                sblock</span><span class="symbol">.</span><span class="function">fill_default</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="function">operation_done</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">get_internal_block</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">release</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> dirty</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> prediction_sequence</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prediction_sequence</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">op </span><span class="symbol">==</span>
<span class="normal">                </span><span class="symbol">((</span><span class="normal">dirty</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release_dirty </span><span class="symbol">:</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release</span><span class="symbol">));</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prediction_sequence</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">id </span><span class="symbol">==</span><span class="normal"> sbid</span><span class="symbol">);</span>
<span class="normal">        prediction_sequence</span><span class="symbol">.</span><span class="function">pop_front</span><span class="symbol">();</span>
<span class="normal">        </span><span class="usertype">scheduled_blocks_iterator</span><span class="normal"> schedule_meta </span><span class="symbol">=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">schedule_meta </span><span class="symbol">!=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">back</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">==</span>
<span class="normal">                        </span><span class="symbol">((</span><span class="normal">dirty</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release_dirty </span><span class="symbol">:</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_release</span><span class="symbol">));</span>

<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        sblock</span><span class="symbol">.</span><span class="function">make_dirty_if</span><span class="symbol">(</span><span class="normal">dirty</span><span class="symbol">);</span>
<span class="normal">        sblock</span><span class="symbol">.</span><span class="function">release</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">is_acquired</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_dirty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">is_external</span><span class="symbol">())</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// =&gt; evictable</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">shall_keep_internal_block</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">))</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// =&gt; swappable_block shall keep its internal_block</span>
<span class="normal">                    scheduled_evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">shall_be_cleaned</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">))</span>
<span class="normal">                        </span><span class="function">schedule_write</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// give block to scheduler</span>
<span class="normal">                    free_evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next_op_to_schedule </span><span class="symbol">!=</span><span class="normal"> prediction_sequence</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">                        </span><span class="function">schedule_next_operations</span><span class="symbol">();</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> write_scheduled_blocks</span><span class="symbol">.</span><span class="function">count</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">))</span>
<span class="normal">                            </span><span class="function">schedule_write</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// =&gt; uninitialized</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">shall_keep_internal_block</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">))</span>
<span class="normal">                    </span><span class="comment">// =&gt; swappable_block shall keep its internal_block</span>
<span class="normal">                    schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock </span><span class="symbol">=</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">detach_internal_block</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// release internal block and give it to prefetcher</span>
<span class="normal">                    </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">detach_internal_block</span><span class="symbol">());</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next_op_to_schedule </span><span class="symbol">!=</span><span class="normal"> prediction_sequence</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">                        </span><span class="function">schedule_next_operations</span><span class="symbol">();</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="function">operation_done</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">deinitialize</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> prediction_sequence</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prediction_sequence</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">op </span><span class="symbol">==</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_deinitialize</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prediction_sequence</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">id </span><span class="symbol">==</span><span class="normal"> sbid</span><span class="symbol">);</span>
<span class="normal">        prediction_sequence</span><span class="symbol">.</span><span class="function">pop_front</span><span class="symbol">();</span>
<span class="normal">        </span><span class="usertype">scheduled_blocks_iterator</span><span class="normal"> schedule_meta </span><span class="symbol">=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">schedule_meta </span><span class="symbol">!=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">back</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_deinitialize</span><span class="symbol">);</span>

<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sblock</span><span class="symbol">.</span><span class="function">is_evictable</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="type">bool</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">shall_keep_internal_block</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">))</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t </span><span class="symbol">=</span><span class="normal"> scheduled_evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">)))</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">STXXL_ERRMSG</span><span class="symbol">(</span><span class="string">"dirty block not scheduled on deinitialize"</span><span class="symbol">);</span>
<span class="normal">                    t </span><span class="symbol">=</span><span class="normal"> free_evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">                t </span><span class="symbol">=</span><span class="normal"> free_evictable_blocks</span><span class="symbol">.</span><span class="function">erase</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">internal_block_type </span><span class="symbol">*</span><span class="normal"> iblock </span><span class="symbol">=</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">deinitialize</span><span class="symbol">())</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">shall_keep_internal_block</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">))</span>
<span class="normal">                </span><span class="comment">// =&gt; swappable_block shall keep its internal_block</span>
<span class="normal">                schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock </span><span class="symbol">=</span><span class="normal"> iblock</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// release internal block and give it to prefetcher</span>
<span class="normal">                </span><span class="function">return_free_internal_block</span><span class="symbol">(</span><span class="normal">iblock</span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">next_op_to_schedule </span><span class="symbol">!=</span><span class="normal"> prediction_sequence</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">                    </span><span class="function">schedule_next_operations</span><span class="symbol">();</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="function">operation_done</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">initialize</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">external_block_type</span><span class="normal"> eblock</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> prediction_sequence</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prediction_sequence</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">op </span><span class="symbol">==</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_initialize</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prediction_sequence</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">id </span><span class="symbol">==</span><span class="normal"> sbid</span><span class="symbol">);</span>
<span class="normal">        prediction_sequence</span><span class="symbol">.</span><span class="function">pop_front</span><span class="symbol">();</span>
<span class="normal">        </span><span class="usertype">scheduled_blocks_iterator</span><span class="normal"> schedule_meta </span><span class="symbol">=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">schedule_meta </span><span class="symbol">!=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">back</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_initialize</span><span class="symbol">);</span>

<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        sblock</span><span class="symbol">.</span><span class="function">initialize</span><span class="symbol">(</span><span class="normal">eblock</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="function">shall_be_read</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">))</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            sblock</span><span class="symbol">.</span><span class="function">attach_internal_block</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock</span><span class="symbol">);</span>
<span class="normal">            schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">reserved_iblock </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            scheduled_evictable_blocks</span><span class="symbol">.</span><span class="function">insert</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">schedule_read</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="function">operation_done</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="usertype">external_block_type</span><span class="normal"> </span><span class="function">extract_external_block</span><span class="symbol">(</span><span class="usertype">swappable_block_identifier_type</span><span class="normal"> sbid</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal"> prediction_sequence</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prediction_sequence</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">op </span><span class="symbol">==</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_extract_external_block</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prediction_sequence</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">id </span><span class="symbol">==</span><span class="normal"> sbid</span><span class="symbol">);</span>
<span class="normal">        prediction_sequence</span><span class="symbol">.</span><span class="function">pop_front</span><span class="symbol">();</span>
<span class="normal">        </span><span class="usertype">scheduled_blocks_iterator</span><span class="normal"> schedule_meta </span><span class="symbol">=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">schedule_meta </span><span class="symbol">!=</span><span class="normal"> scheduled_blocks</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">.</span><span class="normal">operations</span><span class="symbol">.</span><span class="function">back</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> block_scheduler_type</span><span class="symbol">::</span><span class="normal">op_extract_external_block</span><span class="symbol">);</span>

<span class="normal">        SwappableBlockType </span><span class="symbol">&amp;</span><span class="normal"> sblock </span><span class="symbol">=</span><span class="normal"> swappable_blocks</span><span class="symbol">[</span><span class="normal">sbid</span><span class="symbol">];</span>
<span class="normal">        </span><span class="function">wait_on_write</span><span class="symbol">(</span><span class="normal">sbid</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">operation_done</span><span class="symbol">(</span><span class="normal">schedule_meta</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> sblock</span><span class="symbol">.</span><span class="function">extract_external_block</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">__STXXL_END_NAMESPACE</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">/* STXXL_BLOCK_SCHEDULER_HEADER */</span>
</tt></pre></div><div style="text-align: right; padding: 8pt; font-size: 12px"><a href="/xmlfeed/weblog-rss20.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABQAAAADwCexKkxAAAAWUlEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMCt0ZdTU/F/7/+1HEkydFpoKVPn+93sUlUujQvP/7UcRTAuNDJ2a//s/imDqtKVZofm/1qGYSZk7sfodGwAAiobBJtffoNAAAAAASUVORK5CYII=" alt="RSS 2.0 Weblog Feed" width="80" height="15"/></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAAaklEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMDV16rTQ/H/7V//69+//v/3/9oMEI6cuAwr+fv/+/b5d///v//0eJBgWOhMo+Gs9UPAdXDBy6lSYyn9wQZCZS0GCYDPXQcykzJ1Y/Y4NAABKvL80wyoMPgAAAABJRU5ErkJggg==" alt="Atom 1.0 Weblog Feed" width="80" height="15"/></a> <a href="http://validator.w3.org/check?uri=referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABKklEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6qIGzIRiKZs9GFoEaMRuZhhrYqqJXy8uZYauRxC/VHew7e3YTPAxnI5swG6JxNrKBNjB1EFmIgV0+HA6C8pqqzhXG7BbJJROQIwViMYQ7G2oDQQNn57JyG7kxiCfObrBmS5+BHMuYLkTzMnYDm5WY4lOZZRPKZocxes+aPbuwCFsYohiICLvZsKBAMrDTQ7K/StveU8icTzrOL8JdLpOyWJ49u8Bx9ozw8DY7UYW03hhdxZAOSg2c3jN79rSJs1vSKmfOnpFXNJmynELlvExlAADnaZpLFGEC2wAAAABJRU5ErkJggg==" alt="Valid XHTML 1.1" width="80" height="15"/></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABEUlEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6mIEQCsIjwhKoga0qerW8nBm2Gkn8Ut3BvrNnN8HCcDYM2cBIogzs8uFwEJTXVHWuMGa3SC6ZgIgUqCEwdxJr4OxcVm4jNwbxxNkN1mzpM2ajGIjsPGK9PLtZiSk+lVk2oWx2GKP3rNmzC4tQwpDoIIQb2Okh2V+lbe8pZM4nHecX4S6XSVksz55d4Dh7Rnh4m52oQlpvjK5iSAelBk7vmT172sTZLWmVM2fPyCuaTFlOoXJepjIAANlljDGY/l5pAAAAAElFTkSuQmCC" alt="Valid CSS (2.1)" width="80" height="15"/></a><br/>Copyright 2005-2014 <a href="/about/">Timo Bingmann</a> - <a href="/about/impressum.html">Impressum</a></div><script type="text/javascript">var _paq = _paq || []; _paq.push(["trackPageView"]); _paq.push(["enableLinkTracking"]);(function() {var u=(("https:" == document.location.protocol) ? "https" : "http") + "://panthema.net/wik-331/"; _paq.push(["setTrackerUrl", u+"js/"]); _paq.push(["setSiteId", "2"]);var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";g.defer=true; g.async=true; g.src=u+"js/"; s.parentNode.insertBefore(g,s);})();</script><noscript><p><img src="http://panthema.net/wik-331/js/?idsite=2&amp;rec=1" style="border:0" alt="" /></p></noscript></body></html>