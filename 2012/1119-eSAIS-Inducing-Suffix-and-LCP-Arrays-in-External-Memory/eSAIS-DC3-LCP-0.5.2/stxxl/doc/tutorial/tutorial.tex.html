<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><meta name="viewport" content="initial-scale=1"><title>/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/doc/tutorial/tutorial.tex - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="stylesheet" type="text/css" href="/css/fonts.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="https://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="https://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/js/base.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body lang="en"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/timeline/"><i class="icon-book"></i> Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2020/">2020</a></li><li><a href="/2019/">2019</a></li><li><a href="/2018/">2018</a></li><li><a href="/2017/">2017</a></li><li><a href="/2016/">2016</a></li><li><a href="/2015/">2015</a></li><li><a href="/2014/">2014</a></li><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li class="nt"><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li></ul></li><li class="top"> <a class="ni" href="/tags/"><i class="icon-tags"></i> Tags</a></li><li class="top"> <a class="ni" href="#"><i class="icon-cubes"></i> Projects</a> <ul style="margin-left: -8em; margin-top: 4px;" class="nx"> <li><a href="/2019/1008-COBS-A-Compact-Bit-Sliced-Signature-Index/">COBS</a></li> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2016/0114-diploma-thesis/">On Bispanning Graphs</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2013/parallel-string-sorting/">Parallel String Sorting</a></li> <li><a href="/2014/sqlplot-tools/">SqlPlotTools</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li><a href="/tags/stxxl.html">STXXL 1.4</a></li> <li><a href="/tags/thrill.html">Thrill - Big Data Framework</a></li> <li class="nt"><a href="/2014/vncrec-rgb/">VNCrec RGB 0.4</a></li> </ul></li><li class="top"> <a class="ni" href="/publications.html"><i class="icon-graduation-cap"></i> Publications</a></li><li class="top"> <a class="ni" href="/search.html"><i class="icon-search"></i> Search</a></li><li class="top"> <a class="ni" href="/subscribe.html"><i class="icon-rss-squared"></i> Subscribe</a></li><li class="top"> <a class="ni" href="/about/"><i class="icon-info-circled"></i> About</a></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2012/">2012</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/">eSAIS-DC3-LCP-0.5.2</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/">stxxl</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/doc/">doc</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/doc/tutorial/">tutorial</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/doc/tutorial/tutorial.tex.html">tutorial.tex</a> (<a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/stxxl/doc/tutorial/tutorial.tex">Download File</a>)</div></div><div class="ptfullwidth"><pre class="codesnippet" style="font-family: monospace"><tt><span class="keyword">\documentclass</span><span class="optionalargument">[twoside]</span><span class="argument">{book}</span>
<span class="comment">%\usepackage{algorithmic}</span>
<span class="comment">%\usepackage{eepic}</span>
<span class="comment">%\usepackage{epic}</span>
<span class="keyword">\usepackage</span><span class="argument">{amsmath}</span>
<span class="keyword">\usepackage</span><span class="argument">{amssymb}</span>

<span class="keyword">\usepackage</span><span class="argument">{latexsym}</span>
<span class="keyword">\usepackage</span><span class="argument">{times}</span>
<span class="keyword">\usepackage</span><span class="argument">{mathptm}</span>
<span class="keyword">\usepackage</span><span class="argument">{bbold}</span>
<span class="keyword">\usepackage</span><span class="argument">{comment}</span>
<span class="keyword">\usepackage</span><span class="argument">{epsfig}</span>
<span class="comment">%\usepackage{fancyheadings}</span>
<span class="keyword">\usepackage</span><span class="argument">{fancyhdr}</span>
<span class="keyword">\usepackage</span><span class="argument">{float}</span>
<span class="comment">%Floatflt was apparently removed for licencing problems. </span>
<span class="comment">%http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=565457</span>
<span class="comment">%\usepackage{floatflt} </span>
<span class="keyword">\usepackage</span><span class="argument">{graphics}</span>
<span class="keyword">\usepackage</span><span class="argument">{moreverb}</span>
<span class="keyword">\usepackage</span><span class="argument">{epic}</span>
<span class="keyword">\usepackage</span><span class="argument">{eepic}</span>
<span class="keyword">\usepackage</span><span class="argument">{theorem}</span>
<span class="keyword">\usepackage</span><span class="argument">{url}</span>
<span class="comment">%\usepackage{html}</span>
<span class="keyword">\usepackage</span><span class="argument">{listings}</span>
<span class="keyword">\usepackage</span><span class="argument">{graphicx}</span>

<span class="keyword">\hoffset</span><span class="normal">=-1in</span>
<span class="keyword">\voffset</span><span class="normal">=-1in</span>
<span class="comment">%-- Textbreite</span>
<span class="keyword">\setlength</span><span class="argument">{\textwidth}{120mm}</span><span class="normal">           </span><span class="comment">% 9/12 * 160mm</span>
<span class="keyword">\setlength</span><span class="argument">{\oddsidemargin}{23.3mm}</span><span class="normal">      </span><span class="comment">% 1/12 * 160mm + 10 ungesehene</span>
<span class="keyword">\setlength</span><span class="argument">{\evensidemargin}{26.6mm}</span><span class="normal">     </span><span class="comment">% 2/12 * 160mm</span>
<span class="comment">%-- Texthoehe</span>
<span class="comment">%\setlength{\textheight}{180mm}          % 9/12 * 240mm</span>
<span class="keyword">\setlength</span><span class="argument">{\textheight}{220mm}</span><span class="normal">          </span><span class="comment">% 9/12 * 240mm</span>
<span class="keyword">\setlength</span><span class="argument">{\topmargin}{20mm}</span><span class="normal">            </span><span class="comment">% 1/12 * 240mm</span>


<span class="keyword">\addtolength</span><span class="argument">{\textheight}{-\headheight}</span>
<span class="keyword">\addtolength</span><span class="argument">{\textheight}{-\headsep}</span>

<span class="keyword">\hfuzz</span><span class="normal"> 1.5pt</span>
<span class="keyword">\renewcommand</span><span class="argument">{\topfraction}{0.999}</span>
<span class="keyword">\renewcommand</span><span class="argument">{\bottomfraction}{0.999}</span>
<span class="keyword">\renewcommand</span><span class="argument">{\textfraction}{0.001}</span>


<span class="keyword">\pagestyle</span><span class="argument">{fancyplain}</span>

<span class="keyword">\renewcommand</span><span class="argument">{\chaptermark}</span><span class="optionalargument">[1]</span><span class="argument">{\markboth{#1}{#1}}</span>
<span class="keyword">\renewcommand</span><span class="argument">{\sectionmark}</span><span class="optionalargument">[1]</span><span class="argument">{\markright{\thesection\ #1}}</span>
<span class="keyword">\lhead</span><span class="optionalargument">[\fancyplain{{\tiny Dementiev \today} \bf\thepage}{\bf\thepage}]</span><span class="normal">{</span>
<span class="keyword">\fancyplain</span><span class="argument">{\rightmark}</span><span class="normal">}</span>
<span class="keyword">\rhead</span><span class="optionalargument">[\fancyplain{}{\leftmark}]</span><span class="argument">{\fancyplain{{\tiny Dementiev \today}</span>
<span class="argument">\bf\thepage}{\bf\thepage}}</span><span class="normal"> </span>
<span class="keyword">\cfoot</span><span class="optionalargument">[{\fancyplain{}{}}]</span><span class="argument">{\fancyplain{}{}}</span>

<span class="keyword">\renewcommand</span><span class="argument">{\labelenumi}{\alph{enumi})}</span>

<span class="keyword">\include</span><span class="argument">{allmakros}</span>

<span class="keyword">\makeindex</span>

<span class="comment">%\newcommand{\stxxl}{{S{\small TXXL} }}</span>
<span class="comment">%\newcommand{\stxxll}{S{\fontsize{11pt}{11pt}\selectfont TXXL} }</span>
<span class="keyword">\newcommand</span><span class="argument">{\stxxl}{{\sc Stxxl} }</span>

<span class="keyword">\begin</span><span class="argument">{document}</span>
<span class="keyword">\lstset</span><span class="argument">{language=C++,frame=single,tabsize=4,basicstyle=\ttfamily\small,</span>
<span class="argument">        moredelim=[is][\underbar]{@}{@}}</span>

<span class="keyword">\pagenumbering</span><span class="argument">{roman}</span><span class="comment">%</span>
<span class="comment">% \pagestyle{empty}</span>
<span class="keyword">\setcounter</span><span class="argument">{page}{-2}</span><span class="comment">%</span>
<span class="keyword">\begin</span><span class="argument">{titlepage}</span><span class="comment">%</span>
<span class="normal">under development</span>
<span class="keyword">\large</span>
<span class="keyword">\vspace</span><span class="symbol">*</span><span class="argument">{1cm}</span>
<span class="keyword">\vspace</span><span class="symbol">*</span><span class="argument">{1cm}</span>
<span class="keyword">\vspace</span><span class="symbol">*</span><span class="argument">{1cm}</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="argument">{\huge \stxxl Tutorial}</span><span class="symbol">\\</span>

<span class="normal">for </span><span class="keyword">\stxxl</span><span class="normal"> 1.1</span>

<span class="keyword">\vspace</span><span class="argument">{3mm}</span>

<span class="argument">{\LARGE Roman Dementiev\\[2mm]}</span>

<span class="keyword">\vspace</span><span class="symbol">*</span><span class="argument">{\fill}</span>

<span class="argument">{\normalsize under development}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\thispagestyle</span><span class="argument">{empty}</span>
<span class="keyword">\end</span><span class="argument">{titlepage}</span>


<span class="keyword">\thispagestyle</span><span class="argument">{empty}</span>

<span class="comment">%\chapter*{Foreword}</span>

<span class="keyword">\setcounter</span><span class="argument">{tocdepth}{1}</span>
<span class="keyword">\tableofcontents</span>
<span class="keyword">\clearpage</span>
<span class="keyword">\pagenumbering</span><span class="argument">{arabic}</span>
<span class="comment">% \pagestyle{empty}</span>
<span class="keyword">\setcounter</span><span class="argument">{page}{1}</span>


<span class="keyword">\chapter</span><span class="argument">{Introduction}</span>

<span class="normal">There exist many application that have to process data sets which</span>
<span class="normal">can not fit into the main memory of a computer, but external memory</span>
<span class="normal">(e.g.</span><span class="symbol">\ </span><span class="normal">hard disks). The examples are Geographic Information</span>
<span class="normal">Systems, Internet and telecommunication billing</span>
<span class="normal">systems, Information Retrieval systems</span>
<span class="normal">manipulating terabytes of data. </span>

<span class="normal">The most of engineering efforts have been spent on designing</span>
<span class="normal">algorithms which work on data that </span><span class="keyword">\emph</span><span class="argument">{completely}</span><span class="normal"> resides in the main</span>
<span class="normal">memory. The algorithms assume that the execution time of any</span>
<span class="normal">memory access is a </span><span class="keyword">\emph</span><span class="argument">{small}</span><span class="normal"> constant (1--20 ns). But it is no more</span>
<span class="normal">true when </span>
<span class="normal">an application needs to access external memory (EM). Because of the</span>
<span class="normal">mechanical nature of the position seeking routine, a random hard disk</span>
<span class="normal">access takes about 3--20 ms. This </span>
<span class="normal">is about </span><span class="argument">{\bf 1~000~000}</span><span class="normal"> longer than a main memory access. Since the I/Os</span>
<span class="normal">are apparently the major bottleneck of applications that handle large</span>
<span class="normal">data sets, they minimize the number of performed I/Os.</span>
<span class="normal">A new measure of program performance is becoming sound -- the I/O</span>
<span class="normal">complexity. </span>

<span class="normal">Vitter and Shriver </span><span class="keyword">\cite</span><span class="argument">{VitShr94both}</span><span class="normal"> came up with a model for designing I/O</span>
<span class="normal">efficient algorithms. In order to amortize the high cost of a random</span>
<span class="normal">disk access</span><span class="keyword">\footnote</span><span class="argument">{Modern disks after locating the position of the</span>
<span class="argument">data on the surface can deliver the contiguous data blocks at speed</span>
<span class="argument">50-60 MiB/s. For example with the seek time 10~ms, 1~MiB can be read or</span>
<span class="argument">written in $10~+~1000~\times~1/50~=~30$~ms, 1~byte -- in 10.02~ms.}</span><span class="normal">,</span>
<span class="normal">external data loaded in contiguous chunks of size </span><span class="math">$B$</span><span class="normal">. To increase</span>
<span class="normal">bandwidth external memory algorithms use multiple parallel disks. The</span>
<span class="normal">algorithms try in each I/O step transfer </span><span class="math">$D$</span><span class="normal"> blocks between the main</span>
<span class="normal">memory and disks (one block per each disk).</span>


<span class="normal">I/O efficient algorithms have been developed for many</span>
<span class="normal">problem domains, including fundamental ones like sorting </span><span class="keyword">\cite</span><span class="argument">{}</span><span class="normal">,</span>
<span class="normal">graph algorithms </span><span class="keyword">\cite</span><span class="argument">{}</span><span class="normal">, string processing </span><span class="keyword">\cite</span><span class="argument">{}</span><span class="normal">, computational</span>
<span class="normal">geometry </span><span class="keyword">\cite</span><span class="argument">{}</span><span class="normal">. </span>

<span class="normal">However there is the ever increasing gap between theoretical</span>
<span class="normal">nouveau of external memory algorithms and their use in practice.   </span>
<span class="normal">Several EM software library projects (LEDA-SM </span><span class="keyword">\cite</span><span class="argument">{CraMeh99}</span><span class="normal"> and TPIE</span>
<span class="keyword">\cite</span><span class="argument">{APV02}</span><span class="normal">) attempted to </span>
<span class="normal">reduce this gap. They offer frameworks which aim to speed up the</span>
<span class="normal">process of implementing I/O efficient algorithms giving a high level</span>
<span class="normal">abstraction away the details of how I/O is performed. Implementations</span>
<span class="normal">of many EM algorithms and data structures are offered as well.</span>

<span class="normal">Those projects are excellent proofs of EM paradigm, but have</span>
<span class="normal">some drawbacks which </span><span class="keyword">\emph</span><span class="argument">{impede}</span><span class="normal"> their practical use.</span>

<span class="normal">Therefore we started to develop </span><span class="keyword">\stxxl</span><span class="normal"> library, which tries to avoid</span>
<span class="normal">those obstacles. The objectives of </span><span class="keyword">\stxxl</span><span class="normal"> project (distinguishing</span>
<span class="normal">it from other libraries): </span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> Make the library able to handle problems of </span><span class="keyword">\emph</span><span class="argument">{real world size}</span>
<span class="normal">(up to dozens of terabytes). </span>

<span class="keyword">\item</span><span class="normal"> Offer </span><span class="keyword">\emph</span><span class="argument">{transparent}</span><span class="normal"> support of parallel disks. This feature</span>
<span class="normal">although announced has not been implemented in any library.</span>
<span class="keyword">\item</span><span class="normal"> Implement </span><span class="keyword">\emph</span><span class="argument">{parallel}</span><span class="normal"> disk algorithms. LEDA-SM and TPIE</span>
<span class="normal">libraries offer only implementations of single disk EM algorithms.</span>
<span class="keyword">\item</span><span class="normal"> Use computer resources more efficiently. </span><span class="keyword">\stxxl</span><span class="normal"> allows </span>
<span class="normal">transparent </span><span class="keyword">\emph</span><span class="argument">{overlapping}</span><span class="normal"> of I/O and computation in many algorithms and</span>
<span class="normal">data structures.</span>
<span class="keyword">\item</span><span class="normal"> Care about constant factors in I/O volume. A unique library</span>
<span class="normal">feature </span><span class="keyword">\emph</span><span class="argument">{``pipelining''}</span><span class="normal"> can </span><span class="keyword">\emph</span><span class="argument">{half}</span><span class="normal"> the number of I/Os</span>
<span class="normal">performed by an algorithm.</span>
<span class="keyword">\item</span><span class="normal"> Care about the </span><span class="keyword">\emph</span><span class="argument">{internal work}</span><span class="normal">, improve the in-memory</span>
<span class="normal">algorithms. Having many disks can hide the latency and increase the</span>
<span class="normal">I/O bandwidth, s.t. internal work becomes a bottleneck.</span>
<span class="keyword">\item</span><span class="normal"> Care about operating system overheads. Use </span><span class="keyword">\emph</span><span class="argument">{unbuffered disk</span>
<span class="argument">access}</span><span class="normal"> to avoid superfluous copying of data.</span>
<span class="keyword">\item</span><span class="normal"> Shorten </span><span class="keyword">\emph</span><span class="argument">{development times}</span><span class="normal"> providing well known interface for EM</span>
<span class="normal">algorithms and data structures. We provide STL-compatible</span><span class="keyword">\footnote</span><span class="argument">{STL</span>
<span class="argument">-- Standard Template Library \cite{stepanov94standard} is freely available library of</span>
<span class="argument">algorithms and data structures delivered with almost any C++</span>
<span class="argument">compiler.}</span><span class="normal"> interfaces for our implementations.</span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>

<span class="keyword">\chapter</span><span class="argument">{Prerequisites}</span>

<span class="normal">The intended audience of this tutorial are developers or researchers who</span>
<span class="normal">develop applications or implement algorithms processing large data sets</span>
<span class="normal">which do not fit into the main memory of a computer. They must have</span>
<span class="normal">basic knowledge in the theory of external memory computing and </span>
<span class="normal">have working knowledge of C++ and an experience with programming using</span>
<span class="normal">STL. Familiarity with key concepts of generic programming and</span>
<span class="normal">C++ template mechanism is assumed.</span>


<span class="keyword">\chapter</span><span class="argument">{Installation}</span>

<span class="normal">See the </span><span class="keyword">\stxxl</span><span class="normal"> home page </span><span class="keyword">\url</span><span class="argument">{stxxl.sourceforge.net}</span><span class="normal"> for the installation</span>
<span class="normal">instruction for your compiler and operating system.</span>


<span class="keyword">\chapter</span><span class="argument">{A Starting Example}</span>
<span class="comment">% A billing system for phone calls</span>
<span class="comment">% AT&amp;T Gecko 60G records, 2.6 TB</span>

<span class="normal">Let us start with a toy but pretty relevant problem: the phone</span>
<span class="normal">call billing problem. You are given a sequence of event</span>
<span class="normal">records. Each record has a time stamp (time when the event had</span>
<span class="normal">happened), type of event ('call begin' or 'call end'), the callers</span>
<span class="normal">number, and the destination number. The event sequence is</span>
<span class="normal">time-ordered. Your task is to generate a bill for each subscriber</span>
<span class="normal">that includes cost of all her calls. The solution is uncomplicated:</span>
<span class="normal">sort the records by the callers number. Since the sort brings all records</span>
<span class="normal">of a subscriber together, we </span><span class="keyword">\emph</span><span class="argument">{scan}</span><span class="normal"> the sorted result computing</span>
<span class="normal">and summing up the costs of all calls of a particular subscriber.</span>
<span class="normal">The phone companies record up to 300 million transactions per</span>
<span class="normal">day. AT</span><span class="symbol">\&amp;</span><span class="normal">T billing system Gecko </span><span class="keyword">\cite</span><span class="argument">{BillingLarge}</span><span class="normal"> has to </span>
<span class="normal">process databases with about 60 billion records, occupying 2.6</span>
<span class="normal">terabytes. Certainly this volume can not be sorted in the main memory</span>
<span class="normal">of a single computer</span><span class="keyword">\footnote</span><span class="argument">{Except may be in the main memory of an</span>
<span class="argument">expensive \emph{super}computer.}</span><span class="normal">. </span>
<span class="normal">Therefore we need to sort those huge data sets out-of-memory. Now</span>
<span class="normal">we show how </span><span class="keyword">\stxxl</span><span class="normal"> can be useful here, since it can handle large</span>
<span class="normal">volumes I/O efficiently. </span>

<span class="keyword">\section</span><span class="argument">{STL Code}</span>
<span class="normal">If you are familiar with STL your the </span><span class="argument">{\tt main}</span><span class="normal"> function of bill</span>
<span class="normal">generation program will probably look like this:</span>

<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">int main(int argc, char </span><span class="symbol">*</span><span class="normal"> argv</span><span class="optionalargument">[]</span><span class="normal">)</span>
<span class="normal">{</span>
<span class="normal">  if(argc &lt; 4) // check if all parameters are given </span>
<span class="normal">  </span><span class="argument">{            // in the command line</span>
<span class="argument">          print_usage(argv[0]);</span>
<span class="argument">          return 0;</span>
<span class="argument">  }</span>
<span class="normal">  // open file with the event log</span>
<span class="normal">  std::fstream in(argv</span><span class="optionalargument">[1]</span><span class="normal">,std::ios::in);</span>
<span class="normal">  // create a vector of log entries to read in</span>
<span class="normal">  std::vector&lt;LogEntry&gt; v;</span>
<span class="normal">  // read the input file and push the records</span>
<span class="normal">  // into the vector</span>
<span class="normal">  std::copy(std::istream_iterator&lt;LogEntry&gt;(in),</span>
<span class="normal">            std::istream_iterator&lt;LogEntry&gt;(),</span>
<span class="normal">            std::back_inserter(v));</span>
<span class="normal">  // sort records by callers number</span>
<span class="normal">  std::sort(v.begin(),v.end(),SortByCaller());</span>
<span class="normal">  // open bill file for output</span>
<span class="normal">  std::fstream out(argv</span><span class="optionalargument">[3]</span><span class="normal">,std::ios::out);</span>
<span class="normal">  // scan the vector and output bills</span>
<span class="normal">  std::for_each(v.begin(),v.end(),ProduceBill(out));</span>
<span class="normal">  return 0;</span>
<span class="normal">}</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="normal">To complete the code we need to define the log entry data type </span>
<span class="argument">{\tt LogEntry}</span><span class="normal">, input operator </span><span class="argument">{\tt &gt;&gt;}</span><span class="normal"> for </span><span class="argument">{\tt LogEntry}</span><span class="normal">, comparison</span>
<span class="normal">functor </span><span class="argument">{\tt SortByCaller}</span><span class="normal">, unary functor </span><span class="argument">{\tt ProduceBills}</span><span class="normal"> used</span>
<span class="normal">for computing bills, and the </span><span class="argument">{\tt print\_usage}</span><span class="normal"> function. </span>

<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">#include &lt;algorithm&gt; // for STL std::sort</span>
<span class="normal">#include &lt;vector&gt;    // for STL std::vector</span>
<span class="normal">#include &lt;fstream&gt;   // for std::fstream</span>
<span class="normal">#include &lt;limits&gt;</span>
<span class="normal">#include &lt;ctime&gt;     // for time_t type</span>
<span class="normal">#define CT_PER_MIN 2 // subscribers pay 2 cent per minute</span>

<span class="normal">struct LogEntry // the event log data structure</span>
<span class="normal">{</span>
<span class="normal">  long long int from; // callers number (64 bit integer)</span>
<span class="normal">  long long int to;   // destination number (64 bit int)</span>
<span class="normal">  time_t timestamp;   // time of event</span>
<span class="normal">  int event;          // event type 1 - call started</span>
<span class="normal">                      //            2 - call ended</span>
<span class="normal">};</span>

<span class="normal">// input operator used for reading from the file</span>
<span class="normal">std::istream </span><span class="symbol">&amp;</span><span class="normal"> operator &gt;&gt; (std::istream </span><span class="symbol">&amp;</span><span class="normal"> i, </span>
<span class="normal">                            LogEntry </span><span class="symbol">&amp;</span><span class="normal"> entry)</span>
<span class="normal">{</span>
<span class="normal">  i &gt;&gt; entry.from;</span>
<span class="normal">  i &gt;&gt; entry.to;</span>
<span class="normal">  i &gt;&gt; entry.timestamp;</span>
<span class="normal">  i &gt;&gt; entry.event;</span>
<span class="normal">  return i;</span>
<span class="normal">}</span>






<span class="normal">struct SortByCaller // comparison function</span>
<span class="normal">{</span>
<span class="normal">  bool operator() (     const LogEntry </span><span class="symbol">&amp;</span><span class="normal"> a, </span>
<span class="normal">                        const LogEntry </span><span class="symbol">&amp;</span><span class="normal"> b) const</span>
<span class="normal">  {</span>
<span class="normal">        return  a.from &lt; b.from ||</span>
<span class="normal">        (a.from == b.from </span><span class="symbol">&amp;&amp;</span><span class="normal"> a.timestamp &lt; b.timestamp) ||</span>
<span class="normal">        (a.from == b.from </span><span class="symbol">&amp;&amp;</span><span class="normal"> a.timestamp == b.timestamp </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span>
<span class="normal">            a.event &lt; b.event);</span>
<span class="normal">  }</span>
<span class="normal">  static LogEntry min_value()</span>
<span class="normal">  { </span>
<span class="normal">	LogEntry dummy;</span>
<span class="normal">	dummy.from = (std::numeric_limits&lt;long long int&gt;::min)();</span>
<span class="normal">	return dummy;</span>
<span class="normal">  }</span>
<span class="normal">  static LogEntry max_value()</span>
<span class="normal">  { </span>
<span class="normal">	LogEntry dummy;</span>
<span class="normal">	dummy.from = (std::numeric_limits&lt;long long int&gt;::max)();</span>
<span class="normal">	return dummy;</span>
<span class="normal">  }</span>
<span class="normal">  </span>
<span class="normal">}</span>

<span class="normal">// unary function used for producing the bills</span>
<span class="normal">struct ProduceBill</span>
<span class="normal">{</span>
<span class="normal">        std::ostream </span><span class="symbol">&amp;</span><span class="normal"> out; // stream for outputting </span>
<span class="normal">                            // the bills</span>
<span class="normal">        unsigned sum;       // current subscribers debit</span>
<span class="normal">        LogEntry last;      // the last record </span>
<span class="normal">        </span>
<span class="normal">        ProduceBill(std::ostream </span><span class="symbol">&amp;</span><span class="normal"> o_):out(o_),sum(0)</span>
<span class="normal">        { </span>
<span class="normal">                last.from = -1; </span>
<span class="normal">        }</span>
<span class="normal">        </span>
<span class="normal">        void operator () (const LogEntry </span><span class="symbol">&amp;</span><span class="normal"> e)</span>
<span class="normal">        {</span>
<span class="normal">                if(last.from == e.from)</span>
<span class="normal">                {</span>
<span class="normal">                    // either the last event was 'call started' </span>
<span class="normal">                    // and current event is 'call ended' or the </span>
<span class="normal">                    // last event was 'call ended' and current </span>
<span class="normal">                    // event is 'call started'</span>
<span class="normal">                    assert( (last.event == 1 </span><span class="symbol">&amp;&amp;</span><span class="normal"> e.event == 2) || </span>
<span class="normal">                            (last.event == 2 </span><span class="symbol">&amp;&amp;</span><span class="normal"> e.event == 1));     </span>
<span class="normal">                        </span>
<span class="normal">                    if(e.event == 2) // call ended</span>
<span class="normal">                            sum += CT_PER_MIN</span><span class="symbol">*</span>
<span class="normal">                            (e.timestamp - last.timestamp)/60;</span>
<span class="normal">                }</span>
<span class="normal">                else if(last.from != -1)</span>
<span class="normal">                {</span>
<span class="normal">                   // must be 'call ended'</span>
<span class="normal">                   assert(last.event == 2);</span>
<span class="normal">                   // must be 'call started'</span>
<span class="normal">                   assert(e.event == 1);</span>
<span class="normal">                        </span>
<span class="normal">                   // output the total sum</span>
<span class="normal">                   out &lt;&lt; last.from &lt;&lt;</span><span class="string">"; "</span><span class="normal">&lt;&lt; (sum/100)&lt;&lt;</span><span class="string">" EUR "</span>
<span class="normal">                             &lt;&lt; (sum</span><span class="comment">%100)&lt;&lt; " ct"&lt;&lt; std::endl;</span>
<span class="normal">                        </span>
<span class="normal">                   sum = 0; // reset the sum</span>
<span class="normal">                }</span>
<span class="normal">                        </span>
<span class="normal">                last = e;</span>
<span class="normal">        }</span>
<span class="normal">};</span>


<span class="normal">void print_usage(const char </span><span class="symbol">*</span><span class="normal"> program)</span>
<span class="normal">{</span>
<span class="normal">          std::cout &lt;&lt; </span><span class="string">"Usage: "</span><span class="normal">&lt;&lt;program&lt;&lt;</span>
<span class="normal">                </span><span class="string">" logfile main billfile"</span><span class="normal"> &lt;&lt; std::endl;</span>
<span class="normal">          std::cout &lt;&lt;</span><span class="string">" logfile  - file name of the input"</span>
<span class="normal">                &lt;&lt; std::endl;</span>
<span class="normal">          std::cout &lt;&lt;</span><span class="string">" main     - memory to use (in MiB)"</span>
<span class="normal">                &lt;&lt; std::endl;</span>
<span class="normal">          std::cout &lt;&lt;</span><span class="string">" billfile - file name of the output"</span>
<span class="normal">                &lt;&lt; std::endl;</span>
<span class="normal">}</span>

<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="normal">measure the running time for in-core and out-of-core case,</span>
<span class="normal">point the I/O inefficiency of the code</span>

<span class="keyword">\section</span><span class="argument">{Going Large -- Use \stxxl}</span>
<span class="normal">In order to make the program I/O efficient we will replace the STL</span>
<span class="normal">internal memory data structures and algorithms by their </span><span class="keyword">\stxxl</span>
<span class="normal">counterparts. The changes are underlined.</span>

<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">@#include &lt;stxxl.h&gt;@</span>
<span class="normal">// the rest of the code remains the same</span>
<span class="normal">int main(int argc, char </span><span class="symbol">*</span><span class="normal"> argv</span><span class="optionalargument">[]</span><span class="normal">)</span>
<span class="normal">{</span>
<span class="normal">  if(argc &lt; 4) // check if all parameters are given </span>
<span class="normal">  </span><span class="argument">{            // in the command line</span>
<span class="argument">          print_usage(argv[0]);</span>
<span class="argument">          return 0;</span>
<span class="argument">  }</span>
<span class="normal">  // open file with the event log</span>
<span class="normal">  std::fstream in(argv</span><span class="optionalargument">[1]</span><span class="normal">,std::ios::in);</span>
<span class="normal">  // create a vector of log entries to read in</span>
<span class="normal">  @stxxl@::vector&lt;LogEntry&gt; v;</span>
<span class="normal">  // read the input file and push the records</span>
<span class="normal">  // into the vector</span>
<span class="normal">  std::copy(std::istream_iterator&lt;LogEntry&gt;(in),</span>
<span class="normal">            std::istream_iterator&lt;LogEntry&gt;(),</span>
<span class="normal">            std::back_inserter(v));</span>
<span class="normal">  // bound the main memory consumption by M </span>
<span class="normal">  // during sorting</span>
<span class="normal">  const unsigned M = atol(argv</span><span class="optionalargument">[2]</span><span class="normal">)</span><span class="symbol">*</span><span class="normal">1024</span><span class="symbol">*</span><span class="normal">1024;</span>
<span class="normal">  // sort records by callers number</span>
<span class="normal">  @stxxl@::sort(v.begin(),v.end(),SortByCaller()@,M@);</span>
<span class="normal">  // open bill file for output</span>
<span class="normal">  std::fstream out(argv</span><span class="optionalargument">[3]</span><span class="normal">,std::ios::out);</span>
<span class="normal">  // scan the vector and output bills</span>
<span class="normal">  // the last parameter tells how many buffers </span>
<span class="normal">  // to use for overlapping I/O and computation</span>
<span class="normal">  @stxxl@::for_each(v.begin(),v.end(),ProduceBill(out)@,2@);</span>
<span class="normal">  return 0;</span>
<span class="normal">}</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="normal">As you note the changes are minimal. Only the namespaces and some</span>
<span class="normal">memory specific parameters had to be changed.</span>

<span class="normal">To compile the </span><span class="keyword">\stxxl</span><span class="normal"> billing program you may use the following </span><span class="argument">{\tt</span>
<span class="argument">Makefile}</span><span class="normal">: </span>


<span class="keyword">\begin</span><span class="argument">{verbatim}</span>
<span class="normal">all: phonebills</span>
<span class="normal"># path to stxxl.mk file</span>
<span class="normal"># from your stxxl installation</span>
<span class="normal">include </span><span class="symbol">~</span><span class="normal">/stxxl/stxxl.mk</span>

<span class="normal">phonebills: phonebills.cpp</span>
<span class="normal">        </span><span class="math">$(STXXL_CXX) -c phonebills.cpp $</span><span class="normal">(STXXL_CPPFLAGS)</span>
<span class="normal">        </span><span class="math">$(STXXL_CXX) phonebills.o -o phonebills.bin $</span><span class="normal">(STXXL_LDLIBS)</span>
<span class="normal">clean:</span>
<span class="normal">        rm -f phonebills.bin phonebills.o</span>
<span class="keyword">\end</span><span class="argument">{verbatim}</span>


<span class="normal">Do not forget to configure you external memory space in file </span><span class="argument">{\tt</span>
<span class="argument">.stxxl}</span><span class="normal">. You can copy the </span><span class="argument">{\tt config\_example}</span><span class="normal"> (Windows: </span><span class="argument">{\tt config\_example\_win}</span><span class="normal">) from the </span><span class="keyword">\stxxl</span>
<span class="normal">installation directory, and adapt it to your configuration.</span>

<span class="comment">% The sources of the billing program as well as input log generation</span>
<span class="comment">% program are available from \ldots.</span>


<span class="comment">% running times</span>

<span class="keyword">\chapter</span><span class="argument">{Design of \stxxl}</span>

<span class="keyword">\stxxl</span><span class="normal"> is a layered library. There are three layers (see</span>
<span class="normal">Fig.</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{stxxlstructure}</span><span class="normal">). The lowest layer, </span>
<span class="keyword">\emph</span><span class="argument">{Asynchronous I/O primitives layer}</span><span class="normal"> hides the details of how I/Os</span>
<span class="normal">are done. In particular, the layer provides abstraction for</span>
<span class="keyword">\emph</span><span class="argument">{asynchronous}</span><span class="normal"> read and write operations on a </span><span class="keyword">\emph</span><span class="argument">{file}</span><span class="normal">. The</span>
<span class="normal">completion status of I/O operations is  </span>
<span class="normal">is facilitated by </span><span class="keyword">\emph</span><span class="argument">{I/O request}</span><span class="normal"> objects returned by</span>
<span class="normal">read and write file operations. </span>
<span class="normal">The layer has several implementations of file access for Linux. The</span>
<span class="normal">fastest one is based on </span><span class="argument">{\tt read}</span><span class="normal"> and </span><span class="argument">{\tt write}</span><span class="normal"> system calls which</span>
<span class="normal">operate directly on user space memory pages</span><span class="keyword">\footnote</span><span class="argument">{{\tt O\_DIRECT}</span>
<span class="argument">option when opening a file.}</span><span class="normal">.</span>
<span class="normal">To support asynchrony the current</span>
<span class="normal">Linux implementation of the layer uses standard </span><span class="argument">{\tt pthread}</span><span class="normal"> library.</span>
<span class="normal">Porting </span><span class="keyword">\stxxl</span><span class="normal"> library to a different platform (for example</span>
<span class="normal">Windows) involves only reimplementing the Asynchronous I/O primitives</span>
<span class="normal">layer using native file access methods and/or native</span>
<span class="normal">multithreading mechanisms</span><span class="keyword">\footnote</span><span class="argument">{Porting \stxxl to Windows platform</span>
<span class="argument">is not finished yet.}</span><span class="normal">.</span>

<span class="keyword">\begin</span><span class="argument">{figure}</span><span class="optionalargument">[hb]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\includegraphics</span><span class="optionalargument">[width=8cm]</span><span class="argument">{layer_diagram}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\vspace</span><span class="symbol">*</span><span class="argument">{-0.3cm}</span>
<span class="keyword">\caption</span><span class="argument">{\label{stxxlstructure}The \stxxl library structure}</span>
<span class="keyword">\end</span><span class="argument">{figure}</span>

<span class="normal">The middle layer, </span><span class="keyword">\emph</span><span class="argument">{Block management layer}</span><span class="normal"> provides a programming</span>
<span class="normal">interface simulating the </span><span class="keyword">\emph</span><span class="argument">{parallel}</span><span class="normal"> disk model. The layer provides</span>
<span class="normal">abstraction for a fundamental concept in the external memory algorithm</span>
<span class="normal">design -- block of elements. Block manager implements</span>
<span class="normal">block allocation/deallocation allowing several block-to-disk</span>
<span class="normal">assignment strategies: striping, randomized striping, randomized</span>
<span class="normal">cycling, etc. The block management layer provides implementation</span>
<span class="normal">of </span><span class="keyword">\emph</span><span class="argument">{parallel}</span><span class="normal"> disk buffered writing and optimal prefetching</span>
<span class="keyword">\cite</span><span class="argument">{HutSanVit01b}</span><span class="normal">, and block caching. The implementations are fully</span>
<span class="normal">asynchronous and designed to explicitly support overlapping of I/O</span>
<span class="normal">and computation. </span>

<span class="normal">The top of </span><span class="keyword">\stxxl</span><span class="normal"> consists of two modules (see Fig.</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{stxxlstructure}</span><span class="normal">). </span>
<span class="normal">STL-user layer implements the functionality and interfaces of the STL</span>
<span class="normal">library. The layer provides external memory sorting, external memory</span>
<span class="normal">stack, external memory priority queue, etc. which have</span>
<span class="normal">(almost) the same interfaces (including syntax and semantics) as their</span>
<span class="normal">STL counterparts.</span>

<span class="normal">The </span><span class="keyword">\emph</span><span class="argument">{Streaming layer}</span><span class="normal"> provides efficient support for external</span>
<span class="normal">memory algorithms with mostly </span><span class="keyword">\emph</span><span class="argument">{sequential}</span><span class="normal"> I/O pattern, i.e.</span><span class="symbol">\ </span><span class="normal">scan, sort,</span>
<span class="normal">merge, etc. A user algorithm, implemented using this module can save</span>
<span class="normal">many I/Os</span><span class="keyword">\footnote</span><span class="argument">{The doubling algorithm for external memory suffix</span>
<span class="argument">array construction implemented with this module requires only $1/3$ of</span>
<span class="argument">I/Os which must be performed by an implementation that uses conventional</span>
<span class="argument">data structures and algorithms (from \stxxl STL-user layer, or LEDA-SM,</span>
<span class="argument">or TPIE).}</span><span class="normal">. The win is due to an efficient interface, that couples the</span>
<span class="normal">input   </span>
<span class="normal">and the output of the algorithms-components (scans, sorts,</span>
<span class="normal">etc.). The </span>
<span class="normal">output from an algorithm is directly fed into another algorithm as the</span>
<span class="normal">input, without the need to store it on the disk.</span>


<span class="keyword">\chapter</span><span class="argument">{STL-User Layer}</span>
<span class="keyword">\stxxl</span><span class="normal"> library was designed to ease the access to external memory</span>
<span class="normal">algorithms and data structures for a programmer. We decided to</span>
<span class="normal">equip our implementations of </span><span class="keyword">\emph</span><span class="argument">{out-of-memory}</span><span class="normal"> data structure and</span>
<span class="normal">algorithms with well known generic interfaces of </span><span class="keyword">\emph</span><span class="argument">{internal memory}</span>
<span class="normal">data structures and algorithms from the Standard Template Library.</span>
<span class="normal">Currently we have implementation of the following data structures (in</span>
<span class="normal">STL terminology </span><span class="keyword">\emph</span><span class="argument">{containers}</span><span class="normal">):</span>
<span class="keyword">\texttt</span><span class="fixed">{vector}</span><span class="normal">, </span><span class="keyword">\texttt</span><span class="fixed">{stack}</span><span class="normal">, </span><span class="keyword">\texttt</span><span class="fixed">{priority\_queue}</span><span class="normal">. We</span>
<span class="normal">have implemented a </span><span class="keyword">\emph</span><span class="argument">{parallel}</span><span class="normal"> disk sorter which have syntax of</span>
<span class="normal">STL </span><span class="keyword">\texttt</span><span class="fixed">{sort}</span><span class="normal"> </span><span class="keyword">\cite</span><span class="argument">{DemSan03}</span><span class="normal">. Our </span><span class="keyword">\texttt</span><span class="fixed">{ksort}</span><span class="normal"> is a specialized</span>
<span class="normal">implementation </span>
<span class="normal">of </span><span class="keyword">\texttt</span><span class="fixed">{sort}</span><span class="normal"> which efficiently sorts elements with integer</span>
<span class="normal">keys</span><span class="keyword">\footnote</span><span class="argument">{\texttt{ksort} is not STL compatible, it extends the</span>
<span class="argument">syntax of STL.}</span><span class="normal">. </span><span class="keyword">\stxxl</span><span class="normal"> currently provides several implementations of</span>
<span class="normal">scanning algorithms (</span><span class="keyword">\texttt</span><span class="fixed">{generate}</span><span class="normal">, </span><span class="keyword">\texttt</span><span class="fixed">{for\_each}</span><span class="normal">,</span>
<span class="keyword">\texttt</span><span class="fixed">{find}</span><span class="normal">) optimized for external memory. However, it is possible</span>
<span class="normal">(with some constant factor degradation in the performance) to apply</span>
<span class="normal">internal memory scanning algorithms from STL to </span><span class="keyword">\stxxl</span><span class="normal"> </span>
<span class="normal">containers, since </span><span class="keyword">\stxxl</span><span class="normal"> containers have iterator based interface.</span>

<span class="keyword">\stxxl</span><span class="normal"> has a restriction that the data types stored in the containers</span>
<span class="normal">can not have pointers or references to other elements of external memory</span>
<span class="normal">containers. The reason is that those pointers/references get</span>
<span class="normal">invalidated when the blocks containing the elements they point/refer to are</span>
<span class="normal">written on the disks.</span>


<span class="keyword">\newcommand</span><span class="argument">{\xvector}{\texttt{stxxl::vector}}</span>

<span class="keyword">\section</span><span class="argument">{Vector}</span>
<span class="normal">External memory vector (array)</span>
<span class="keyword">\xvector</span><span class="symbol">\ </span><span class="normal">is a data structure </span>
<span class="normal">that supports random access to elements. The semantics of the basic</span>
<span class="normal">methods of </span><span class="keyword">\xvector</span><span class="symbol">\ </span><span class="normal">is kept to compatible with STL</span>
<span class="keyword">\texttt</span><span class="fixed">{std::vector}</span><span class="normal">. Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{rtvector}</span><span class="normal"> shows the internal work and</span>
<span class="normal">the I/O worst case complexity of the </span><span class="keyword">\xvector</span><span class="normal">.</span>

<span class="keyword">\begin</span><span class="argument">{table}</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Running times of the basic operations of \xvector}</span>
<span class="keyword">\label</span><span class="argument">{rtvector}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|l|c|c|}</span>
<span class="keyword">\hline</span>
<span class="normal">                    </span><span class="symbol">&amp;</span><span class="normal"> int. work </span><span class="symbol">&amp;</span><span class="normal"> I/O (worst case) </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="normal">random access       </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1}$</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1}$</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">insertion at the end</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1}$</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1}$</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">removal at the end  </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1}$</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1}$</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>

<span class="keyword">\subsection</span><span class="argument">{The Architecture of \xvector}</span>
<span class="normal">The </span><span class="keyword">\xvector</span><span class="symbol">\ </span><span class="normal">is organized as a collection of blocks residing on the</span>
<span class="normal">external storage media (parallel disks). Access to the external blocks</span>
<span class="normal">is organized through the fully associative </span><span class="keyword">\emph</span><span class="argument">{cache}</span><span class="normal"> which consist of some</span>
<span class="normal">fixed amount of in-memory pages</span><span class="keyword">\footnote</span><span class="argument">{The page is a collection of</span>
<span class="argument">consecutive blocks. The number of blocks in the page is</span>
<span class="argument">constant.}</span><span class="normal">. The schema of </span>
<span class="keyword">\xvector</span><span class="symbol">\ </span><span class="normal">is depicted </span>
<span class="normal">in the Fig.</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{xvectorschema}</span><span class="normal">. When accessing an element the</span>
<span class="normal">implementation of </span><span class="keyword">\xvector</span><span class="symbol">\ </span><span class="normal">access methods (</span><span class="keyword">\texttt</span><span class="fixed">{[$\cdot$]}</span><span class="symbol">~</span><span class="normal">operator,</span>
<span class="keyword">\texttt</span><span class="fixed">{push\_back}</span><span class="normal">, etc.) first checks</span>
<span class="normal">whether the page to which the requested element belongs is in the</span>
<span class="normal">vector's cache. If it is the case the reference to the</span>
<span class="normal">element in the cache is returned. Otherwise the page is brought into the</span>
<span class="normal">cache</span><span class="keyword">\footnote</span><span class="argument">{If the page of the element has not been touched so </span>
<span class="argument">far, this step is skipped. To keep an eye on such situations there is a</span>
<span class="argument">special flag </span>
<span class="argument">for each page.}</span><span class="normal">. If there was no free space in the cache, then some</span>
<span class="normal">page is to be written out. Vector maintains a </span><span class="keyword">\emph</span><span class="argument">{pager}</span><span class="normal"> object, that</span>
<span class="normal">tells which page to kick out. </span><span class="keyword">\stxxl</span><span class="normal"> provides LRU and random paging</span>
<span class="normal">strategies. The most efficient and default one is LRU. For each page</span>
<span class="normal">vector maintains the </span><span class="keyword">\emph</span><span class="argument">{dirty}</span><span class="normal"> flag, which is set when</span>
<span class="keyword">\emph</span><span class="argument">{non-constant}</span><span class="normal"> reference to one of the page's elements was</span>
<span class="normal">returned. The dirty flag </span>
<span class="normal">is cleared each time when the page is read into the cache. The purpose of the</span>
<span class="normal">flag is to track whether any element of the page is modified and</span>
<span class="normal">therefore the page needs to</span>
<span class="normal">be written to the disk(s) when it has to be evicted from the</span>
<span class="normal">cache. </span>

<span class="keyword">\begin</span><span class="argument">{figure}</span><span class="optionalargument">[hb]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\includegraphics</span><span class="optionalargument">[width=11cm]</span><span class="argument">{vector}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\vspace</span><span class="symbol">*</span><span class="argument">{-0.3cm}</span>
<span class="keyword">\caption</span><span class="argument">{\label{xvectorschema} The schema of \xvector\ that consists</span>
<span class="argument">of ten external memory pages and has a cache with the capacity of four</span>
<span class="argument">pages. The </span>
<span class="argument">first cache page is mapped to external page 1, the second page</span>
<span class="argument">is mapped to external page 8, and the fourth cache page is</span>
<span class="argument">mapped to page 5. The third page is not assigned to any external</span>
<span class="argument">memory page. }</span>
<span class="keyword">\end</span><span class="argument">{figure}</span>

<span class="normal">In the worst case scenario when vector elements are</span>
<span class="normal">read/written in the random order each access takes </span><span class="math">$2 \times</span>
<span class="math">blocks\_per\_page$</span><span class="normal"> I/Os. The factor </span><span class="keyword">\emph</span><span class="argument">{two}</span><span class="normal"> shows up here because one has</span>
<span class="normal">to write the replaced from cache page and read the required</span>
<span class="normal">one). However the scanning of the array costs about </span><span class="math">$n/B$</span><span class="normal"> I/Os using</span>
<span class="normal">constant vector iterators or const reference to the</span>
<span class="normal">vector</span><span class="keyword">\footnote</span><span class="argument">{$n$ is the number of elements to read or write.}</span>
<span class="normal">(read-only </span>
<span class="normal">access). Using non-const vector access methods leads to </span><span class="math">$2 \times n/B$</span>
<span class="normal">I/Os because every page becomes dirty when returning a non const</span>
<span class="normal">reference. </span>
<span class="normal">If one needs only to sequentially write elements to the vector in</span>
<span class="math">$n/B$</span><span class="normal"> I/Os the </span>
<span class="normal">currently fastest method is </span><span class="keyword">\texttt</span><span class="fixed">{stxxl::generate}</span><span class="normal"> (see section</span>
<span class="keyword">\ref</span><span class="argument">{stxxl::generate}</span><span class="normal">). Sequential writing to an untouched before </span>
<span class="normal">vector</span><span class="keyword">\footnote</span><span class="argument">{For example writing in the vector that has been</span>
<span class="argument">created using </span>
<span class="argument">\texttt{vector(size\_type n)} constructor.}</span><span class="normal"> or alone </span>
<span class="normal">adding elements at the end of the vector</span><span class="keyword">\footnote</span><span class="argument">{Using \texttt{void</span>
<span class="argument">push\_back(const T\&amp;)} method.}</span><span class="normal"> leads also to </span><span class="math">$n/B$</span><span class="normal"> I/Os.  </span>

<span class="argument">{\bf Example of use}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">stxxl::vector&lt;int&gt; V;</span>
<span class="normal">V.push_back(3);</span>
<span class="normal">assert(V.size() == 1 </span><span class="symbol">&amp;&amp;</span><span class="normal"> V.capacity() &gt;= 1 </span><span class="symbol">&amp;&amp;</span><span class="normal"> V</span><span class="optionalargument">[0]</span><span class="normal"> == 3);</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="keyword">\newcommand</span><span class="argument">{\xvectorg}{\texttt{stxxl::VECTOR\_GENERATOR}}</span>

<span class="keyword">\subsection</span><span class="argument">{\xvectorg}</span>


<span class="normal">Besides the type of the elements </span><span class="keyword">\xvector</span><span class="symbol">\ </span><span class="normal">has many other template parameters</span>
<span class="normal">(block size, number of blocks per page, pager class, etc.). To make</span>
<span class="normal">the configuration of the vector type easier </span><span class="keyword">\stxxl</span>
<span class="normal">provides special type generator template meta programs for its</span>
<span class="normal">containers.  </span>

<span class="normal">The program</span>
<span class="normal">for </span><span class="keyword">\xvector</span><span class="symbol">\ </span><span class="normal">is called </span><span class="keyword">\xvectorg</span><span class="normal">.</span>

<span class="argument">{\bf Example of use}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">typedef stxxl::VECTOR_GENERATOR&lt;int&gt;::result vector_type;</span>
<span class="normal">vector_type V;</span>
<span class="normal">V.push_back(3);</span>
<span class="normal">assert(V.size() == 1 </span><span class="symbol">&amp;&amp;</span><span class="normal"> V.capacity() &gt;= 1 </span><span class="symbol">&amp;&amp;</span><span class="normal"> V</span><span class="optionalargument">[0]</span><span class="normal"> == 3);</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Template parameters of \xvectorg\ from left to right.}</span>
<span class="keyword">\label</span><span class="argument">{vectorparam}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|l|p{3.5cm}|c|c|}</span>
<span class="keyword">\hline</span>
<span class="normal">parameter</span><span class="symbol">&amp;</span><span class="normal"> description  </span><span class="symbol">&amp;</span><span class="normal"> default value </span><span class="symbol">&amp;</span><span class="normal"> recommended value </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="normal">Tp</span><span class="symbol">\_</span><span class="normal">       </span><span class="symbol">&amp;</span><span class="normal"> element type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">PgSz</span><span class="symbol">\_</span><span class="normal">     </span><span class="symbol">&amp;</span><span class="normal"> number of blocks in a </span>
<span class="normal">page</span>
<span class="symbol">&amp;</span><span class="normal"> 4 </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\geq D$</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">Pages</span><span class="symbol">\_</span><span class="normal">    </span><span class="symbol">&amp;</span><span class="normal"> number of pages in the cache </span><span class="symbol">&amp;</span><span class="normal"> 8 </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\geq 2$</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">BlkSize</span><span class="symbol">\_</span><span class="normal">  </span><span class="symbol">&amp;</span><span class="normal"> block size </span><span class="math">$B$</span><span class="normal"> in bytes </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$2\times 1024\times 1024$</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> larger</span>
<span class="normal">is better</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">AllocStr</span><span class="symbol">\_</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> parallel disk assignment strategy </span>
<span class="normal">(Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{allocstr}</span><span class="normal">)</span>
<span class="symbol">&amp;</span><span class="normal"> RC </span><span class="symbol">&amp;</span><span class="normal"> RC </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">Pager</span><span class="symbol">\_</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> paging strategy </span>
<span class="normal">(Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{pagingstr}</span><span class="normal">)</span>
<span class="symbol">&amp;</span><span class="normal"> lru </span><span class="symbol">&amp;</span><span class="normal"> lru </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>


<span class="comment">%%\texttt{stxxl::VECTOR\_GENERATOR&lt; Tp,\\ PgSz,\\ Pages,\\ BlkSize,\\</span>
<span class="comment">%%AllocStr,\\ Pager &gt;} </span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Supported parallel disk assignment strategies.}</span>
<span class="keyword">\label</span><span class="argument">{allocstr}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|l|c|}</span>
<span class="keyword">\hline</span>
<span class="normal">strategy </span><span class="symbol">&amp;</span><span class="normal"> identifier  </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="normal">striping </span><span class="symbol">&amp;</span><span class="normal"> striping </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">simple randomized </span><span class="symbol">&amp;</span><span class="normal"> SR</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">fully randomized </span><span class="symbol">&amp;</span><span class="normal"> FR</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">randomized cycling </span><span class="symbol">&amp;</span><span class="normal"> RC </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Supported paging strategies.}</span>
<span class="keyword">\label</span><span class="argument">{pagingstr}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|l|c|}</span>
<span class="keyword">\hline</span>
<span class="normal">strategy </span><span class="symbol">&amp;</span><span class="normal"> identifier  </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="normal">random </span><span class="symbol">&amp;</span><span class="normal"> random </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">least recently used </span><span class="symbol">&amp;</span><span class="normal"> lru</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>

<span class="normal">Notes:</span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> All blocks of a page are read and written from/to</span>
<span class="normal">disks together. Therefore to increase the I/O bandwidth, it is</span>
<span class="normal">recommended to set the PgSz</span><span class="symbol">\_</span><span class="normal"> parameter to multiple of </span><span class="math">$D$</span><span class="normal">.</span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>

<span class="normal">Since there are defaults for the last five</span>
<span class="normal">of the parameters, it is not necessary to specify them all.</span>
<span class="argument">{\bf Examples:}</span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{VECTOR\_GENERATOR&lt;double&gt;::result}</span><span class="normal"> -- external vector of</span>
<span class="argument">{\bf double}</span><span class="normal">'s with four blocks per page, the cache with eight pages, 2</span><span class="symbol">~</span><span class="normal">MiB</span>
<span class="normal">blocks, Random  Allocation and lru cache replacement strategy </span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{VECTOR\_GENERATOR&lt;double,8&gt;::result}</span><span class="normal"> -- external vector</span>
<span class="normal">of </span><span class="argument">{\bf double}</span><span class="normal">'s , with </span><span class="argument">{\bf eight}</span><span class="normal"> blocks per page, the cache with eight pages, 2</span><span class="symbol">~</span><span class="normal">MiB</span>
<span class="normal">blocks, Random  Allocation and lru cache replacement strategy </span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{VECTOR\_GENERATOR&lt;double,8,2,524288,SR&gt;::result}</span><span class="normal"> --</span>
<span class="normal">external vector of </span><span class="argument">{\bf double}</span><span class="normal">'s, with </span><span class="argument">{\bf eight}</span><span class="normal"> blocks per page, the cache</span>
<span class="normal">with </span><span class="argument">{\bf two}</span><span class="normal"> pages, </span><span class="argument">{\bf 512~KiB}</span><span class="normal"> </span>
<span class="normal">blocks, </span><span class="argument">{\bf Simple Randomized}</span><span class="normal"> allocation and lru cache replacement strategy </span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>

<span class="keyword">\subsection</span><span class="argument">{Internal Memory Consumption of \xvector}</span>
<span class="normal">The cache of </span><span class="keyword">\xvector</span><span class="symbol">\ </span><span class="normal">largely dominates in its internal memory</span>
<span class="normal">consumption. Other members consume very small fraction of </span><span class="keyword">\xvector</span><span class="normal"> s</span>
<span class="normal">memory even when the vector size is large. Therefore, the internal</span>
<span class="normal">memory consumption of </span><span class="keyword">\xvector</span><span class="symbol">\ </span><span class="normal">can be estimated as</span>
<span class="math">$BlkSize\_ \times Pages\_ \times PgSz\_$</span><span class="normal"> bytes.</span>



<span class="keyword">\subsection</span><span class="argument">{Members of \xvector}</span>
<span class="normal">See Tables </span><span class="keyword">\ref</span><span class="argument">{vectormembers1}</span><span class="normal"> and  </span><span class="keyword">\ref</span><span class="argument">{vectormembers2}</span><span class="normal">.</span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Members of \xvector. Part 1.}</span>
<span class="keyword">\label</span><span class="argument">{vectormembers1}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|p{6cm}|p{5cm}|}</span>
<span class="keyword">\hline</span>
<span class="normal">member </span><span class="symbol">&amp;</span><span class="normal"> description  </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{value\_type}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">  The type of object, Tp</span><span class="symbol">\_</span><span class="normal">, stored in the vector. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{pointer}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Pointer to Tp</span><span class="symbol">\_</span><span class="normal">. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{reference}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Reference to Tp</span><span class="symbol">\_</span><span class="normal">. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{const\_reference}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Const reference to Tp</span><span class="symbol">\_</span><span class="normal">. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{size\_type}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> An unsigned 64-bit</span><span class="keyword">\footnote</span><span class="argument">{\texttt{off\_t}</span>
<span class="argument">type. It has the length 64 bits if \ldots}</span><span class="normal"> integral type. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{iterator}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Iterator used to iterate through a vector. See</span>
<span class="normal">notes a,b. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{const\_iterator}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Const iterator used to iterate through a</span>
<span class="normal">vector. See notes a,b. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{block\_type}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> type of the block used in disk-memory </span>
<span class="normal">transfers </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{iterator begin()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns an iterator pointing to the</span>
<span class="normal">beginning of the vector. See notes a,b. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{iterator end()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns an iterator pointing to the end of</span>
<span class="normal">the vector. See notes a,b.</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{const\_iterator begin() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns a const</span><span class="symbol">\_</span><span class="normal">iterator</span>
<span class="normal">pointing to the beginning of the vector. See notes a,b.</span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{const\_iterator end() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns a const</span><span class="symbol">\_</span><span class="normal">iterator</span>
<span class="normal">pointing to the end of the vector. See notes a,b. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{size\_type size() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns the size of the vector. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{size\_type capacity() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Number of elements for which</span>
<span class="keyword">\emph</span><span class="argument">{external}</span><span class="normal"> memory has been allocated. </span><span class="keyword">\texttt</span><span class="fixed">{capacity()}</span><span class="normal"> is always</span>
<span class="normal">greater than or equal to </span><span class="keyword">\texttt</span><span class="fixed">{size()}</span><span class="normal">. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{bool empty() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> true if the vector's size is 0.</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{reference operator[](size\_type n)}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns (the reference to)</span>
<span class="normal">the n'th element. See note c.</span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{const\_reference operator[](size\_type n) const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns</span>
<span class="normal">(the const reference to)</span>
<span class="normal">the n'th element. See note c.</span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Members of \xvector. Part 2.}</span>
<span class="keyword">\label</span><span class="argument">{vectormembers2}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|p{6cm}|p{5cm}|}</span>
<span class="keyword">\hline</span>
<span class="normal">member </span><span class="symbol">&amp;</span><span class="normal"> description  </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{vector()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Creates an empty vector. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{vector(size\_type n)}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Creates a vector with n elements. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{vector(const vector\&amp;)}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Not yet implemented </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{\textasciitilde vector()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> The destructor. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{void reserve(size\_type n)}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> If n is less than or equal to</span>
<span class="keyword">\texttt</span><span class="fixed">{capacity()}</span><span class="normal">, this call has no effect. Otherwise, it is a request for</span>
<span class="normal">allocation of additional </span><span class="keyword">\emph</span><span class="argument">{external}</span><span class="normal"> memory. If the request is successful, then</span>
<span class="keyword">\texttt</span><span class="fixed">{capacity()}</span><span class="normal"> is greater than or equal to n; otherwise,</span>
<span class="keyword">\texttt</span><span class="fixed">{capacity()}</span><span class="normal"> is </span>
<span class="normal">unchanged. In either case, </span><span class="keyword">\texttt</span><span class="fixed">{size()}</span><span class="normal"> is unchanged. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{reference front()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns (the reference to) the first</span>
<span class="normal">element. See note c.</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{const\_reference front() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns (the const reference to)</span>
<span class="normal">the first element. See note c.</span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{reference back()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns (the reference to) the last</span>
<span class="normal">element. See note c.</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{const\_reference back() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns (the const reference to)</span>
<span class="normal">the last element. See note c.</span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{void push\_back(const T\&amp;)}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Inserts a new element at the</span>
<span class="normal">end. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{void pop\_back()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Removes the last element. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{void clear()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Erases all of the elements and deallocates all</span>
<span class="normal">external memory that vector occupied.</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{void flush()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Flushes the cache pages to the external</span>
<span class="normal">memory. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{vector (file * from)}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Create the vector from the</span>
<span class="normal">file. The construction causes no I/O.</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>


<span class="normal">Notes:</span>
<span class="keyword">\begin</span><span class="argument">{enumerate}</span>
<span class="keyword">\item</span><span class="normal"> In opposite to STL, </span><span class="keyword">\xvector</span><span class="normal"> 's iterators do not get invalidated</span>
<span class="normal">when the vector is resized or reallocated.</span>
<span class="keyword">\item</span><span class="normal"> Dereferencing a non-const iterator makes the page of the element</span>
<span class="normal">to which the iterator points to </span><span class="keyword">\emph</span><span class="argument">{dirty}</span><span class="normal">. This causes the page to</span>
<span class="normal">be written back to the disks(s) when the page is to be kicked off from</span>
<span class="normal">the cache (additional write I/Os). If you do not want this behavior,</span>
<span class="normal">use const iterators instead. Example:</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">vector_type V;</span>

<span class="normal">// ... fill the vector here</span>

<span class="normal">vector_type::iterator iter = V.begin();</span>

<span class="normal">// ... advance the iterator</span>
<span class="normal">a = </span><span class="symbol">*</span><span class="normal">iter; // causes write I/Os,</span>
<span class="normal">           // although </span><span class="symbol">*</span><span class="normal">iter is not changed</span>
<span class="normal">vector_type::const_iterator citer = V.begin();</span>
<span class="normal">// ... advance the iterator</span>
<span class="normal">a = </span><span class="symbol">*</span><span class="normal">citer; // read-only access, causes no write I/Os</span>
<span class="symbol">*</span><span class="normal">citer = b; // does not compile, citer is const</span>

<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="keyword">\item</span><span class="normal"> Non const </span><span class="keyword">\texttt</span><span class="fixed">{[$\cdot$]}</span><span class="normal"> operator makes the page of the</span>
<span class="normal">element </span><span class="keyword">\emph</span><span class="argument">{dirty}</span><span class="normal">. This causes the page to</span>
<span class="normal">be written back to the disks(s) when the page is to be kicked off from</span>
<span class="normal">the cache (additional write I/Os). If you do not want this behavior,</span>
<span class="normal">use const </span><span class="keyword">\texttt</span><span class="fixed">{[$\cdot$]}</span><span class="normal"> operator. For that you need to access the</span>
<span class="normal">vector via a const reference to it. Example:</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">vector_type V;</span>

<span class="normal">// ... fill the vector here</span>

<span class="normal">a = V</span><span class="optionalargument">[index]</span><span class="normal">; // causes write I/Os, </span>
<span class="normal">              // although V</span><span class="optionalargument">[index]</span><span class="normal"> is not changed</span>

<span class="normal">const vector_type </span><span class="symbol">&amp;</span><span class="normal"> CV = V; // const reference to V</span>
<span class="normal">a = CV</span><span class="optionalargument">[index]</span><span class="normal">; // read-only access, can cause no write I/Os</span>
<span class="normal">CV</span><span class="optionalargument">[index]</span><span class="normal"> = b; // does not compile, CV is const</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="normal">This issue also concerns </span><span class="keyword">\texttt</span><span class="fixed">{front()}</span><span class="normal"> and </span><span class="keyword">\texttt</span><span class="fixed">{back()}</span><span class="normal"> methods.</span>
<span class="keyword">\end</span><span class="argument">{enumerate}</span>

<span class="keyword">\newcommand</span><span class="argument">{\xstack}{\texttt{stxxl::stack}}</span>

<span class="keyword">\section</span><span class="argument">{Stacks}</span>
<span class="keyword">\label</span><span class="argument">{stacksection}</span>
<span class="normal">Stacks provide only restricted subset of</span>
<span class="normal">sequence operations: insertion, removal, and inspection of the element</span>
<span class="normal">at the top of the stack. Stacks are a </span><span class="string">"last in first out"</span><span class="normal"> (LIFO) data</span>
<span class="normal">structures: the element at the top of a stack is the one that was most</span>
<span class="normal">recently added. Stacks does not allow iteration through its</span>
<span class="normal">elements. </span>

<span class="normal">The </span><span class="keyword">\emph</span><span class="argument">{I/O efficient}</span><span class="normal"> stack is perhaps the simplest external memory</span>
<span class="normal">data structure. The basic variant of EM stack keeps the top </span><span class="math">$k$</span>
<span class="normal">elements in the main memory buffer, where </span><span class="math">$k \leq 2B$</span><span class="normal">. If the buffers</span>
<span class="normal">get empty on a removal call, one block is brought from the disk to the</span>
<span class="normal">buffers. Therefore at least </span><span class="math">$B$</span><span class="normal"> removals are required to make one I/O</span>
<span class="normal">reading a block. Insertions cause no I/Os until the internal buffers</span>
<span class="normal">get full. In this case to make space the first </span><span class="math">$B$</span><span class="normal"> elements are</span>
<span class="normal">written to the disk. Thus a block write happens only after at least</span>
<span class="math">$B$</span><span class="normal"> insertions. If we choose the unit of disk</span>
<span class="normal">transfer to be a multiple of </span><span class="math">$DB$</span><span class="normal"> (we denote it as a </span><span class="keyword">\emph</span><span class="argument">{page}</span><span class="normal">), set the</span>
<span class="normal">stack buffer size to </span><span class="math">$2D$</span><span class="normal"> pages, and evenly assign the blocks of a</span>
<span class="normal">page to disks we obtain the running times shown in</span>
<span class="normal">Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{rtstack}</span><span class="normal">. </span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Amortized running times of the basic operations of \xstack}</span>
<span class="keyword">\label</span><span class="argument">{rtstack}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|l|c|c|}</span>
<span class="keyword">\hline</span>
<span class="normal">                    </span><span class="symbol">&amp;</span><span class="normal"> int. work </span><span class="symbol">&amp;</span><span class="normal"> I/O (amortized)</span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="normal">insertion at the end</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1}$</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1/DB}$</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">removal at the end  </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1}$</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1/DB}$</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>

<span class="keyword">\stxxl</span><span class="normal"> has several implementations of the external memory stack. Each </span>
<span class="normal">implementation is specialized for a certain access pattern:</span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> The </span><span class="argument">{\bf Normal }</span><span class="normal"> stack (</span><span class="keyword">\texttt</span><span class="fixed">{stxxl::normal\_stack}</span><span class="normal">) is a general</span>
<span class="normal">purpose implementation which is the best if the access pattern</span>
<span class="normal">to the stack is an irregular mix of push'es and pop's, i.e.</span><span class="symbol">\ </span><span class="normal">the stack</span>
<span class="normal">grows and shrinks without a certain rule.</span>
<span class="keyword">\item</span><span class="normal"> The </span><span class="argument">{\bf Grow-Shrink}</span><span class="normal"> stack is a stack that is optimized for an</span>
<span class="normal">access pattern where the insertions are (almost) not intermixed with</span>
<span class="normal">the removals, and/or vice versa, the removals are (almost) not</span>
<span class="normal">intermixed with the insertions. In other words the stack first grows</span>
<span class="normal">to its maximal size, then it shrinks, then it might again grow, then</span>
<span class="normal">shrink, and so forth, i.e.</span><span class="symbol">\ </span><span class="normal">the pattern is</span>
<span class="math">$(push^{i_j}pop^{r_j})^k$</span><span class="normal">, where </span><span class="math">$k \in N$</span><span class="normal">, </span><span class="math">$1\leq j\leq k$</span><span class="normal">, and</span>
<span class="math">$i_j$</span><span class="normal">, </span><span class="math">$r_j$</span><span class="normal"> are </span><span class="keyword">\emph</span><span class="argument">{large}</span><span class="normal">. </span>
<span class="keyword">\item</span><span class="normal"> The </span><span class="argument">{\bf Grow-Shrink2}</span><span class="normal"> stack is a </span><span class="string">``grow-shrink''</span><span class="normal"> stack that</span>
<span class="normal">allows the use of common prefetch and write buffer pools. The pools</span>
<span class="normal">are shared between several </span><span class="string">``grow-shrink''</span><span class="normal"> stacks.</span>
<span class="keyword">\item</span><span class="normal"> The </span><span class="argument">{\bf Migrating}</span><span class="normal"> stack is a stack that migrates from</span>
<span class="normal">internal memory to external when its size exceeds a certain</span>
<span class="normal">threshold. </span>
<span class="comment">% todo: describe the optimization in its section later</span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>

<span class="keyword">\newcommand</span><span class="argument">{\xnormalstack}{\texttt{stxxl::normal\_stack}}</span>
<span class="keyword">\subsection</span><span class="argument">{\xnormalstack}</span>
<span class="normal">The </span><span class="keyword">\xnormalstack</span><span class="normal"> is a general purpose implementation of the external</span>
<span class="normal">memory stack. The stack has two pages, the size of the page in blocks</span>
<span class="normal">is a configuration constant and can be given as a template</span>
<span class="normal">parameter. The implementation of the methods follows the description</span>
<span class="normal">given in Section</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{stacksection}</span><span class="normal">.</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Internal Memory Consumption of \xnormalstack}</span>
<span class="normal">The cache of </span><span class="keyword">\xnormalstack</span><span class="symbol">\ </span><span class="normal">largely dominates in its internal memory</span>
<span class="normal">consumption. Other members consume very small fraction of</span>
<span class="keyword">\xnormalstack</span><span class="normal"> s </span>
<span class="normal">memory even when the stack size is large. Therefore, the internal</span>
<span class="normal">memory consumption of </span><span class="keyword">\xnormalstack</span><span class="symbol">\ </span><span class="normal">can be estimated as</span>
<span class="math">$2 \times BlkSize\_ \times PgSz\_$</span><span class="normal"> bytes, where </span><span class="math">$BlkSize\_$</span><span class="normal"> is the</span>
<span class="normal">block size and </span><span class="math">$PgSz\_$</span><span class="normal"> is the page size in blocks (see</span>
<span class="normal">Section</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{stackgensection}</span><span class="normal">). </span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Members of \xnormalstack}</span>
<span class="normal">See Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{normalstackmembers}</span><span class="normal">.</span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Members of \xnormalstack.}</span>
<span class="keyword">\label</span><span class="argument">{normalstackmembers}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|p{6cm}|p{5cm}|}</span>
<span class="keyword">\hline</span>
<span class="normal">member </span><span class="symbol">&amp;</span><span class="normal"> description  </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{value\_type}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">  The type of object, Tp</span><span class="symbol">\_</span><span class="normal">, stored in the vector. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{size\_type}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> An unsigned 64-bit</span><span class="keyword">\footnote</span><span class="argument">{\texttt{off\_t}</span>
<span class="argument">type. It has the length 64 bits if \ldots}</span><span class="normal"> integral type. </span><span class="symbol">\\</span><span class="normal">  </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{block\_type}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> type of the block used in disk-memory </span>
<span class="normal">transfers </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{bool empty() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">  Returns true if the stack contains no</span>
<span class="normal">elements, and false  otherwise. </span><span class="keyword">\texttt</span><span class="fixed">{S.empty()}</span><span class="normal"> is equivalent to </span><span class="keyword">\texttt</span><span class="fixed">{S.size() ==</span>
<span class="normal">0}. </span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{size\_type size() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns the number of elements</span>
<span class="normal">contained in the stack. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{value\_type\&amp; top()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns a mutable reference to the</span>
<span class="normal">element at the top of the stack. Precondition: </span><span class="keyword">\texttt</span><span class="fixed">{empty()}</span><span class="normal"> is</span>
<span class="normal">false. </span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{const value\_type\&amp; top() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns a const reference</span>
<span class="normal">to the element at the top of the stack. Precondition: </span><span class="keyword">\texttt</span><span class="fixed">{empty()}</span><span class="normal"> is</span>
<span class="normal">false.</span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{void push(const value\_type\&amp; x)}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Inserts x at the top of</span>
<span class="normal">the stack. Postconditions: </span><span class="keyword">\texttt</span><span class="fixed">{size()}</span><span class="normal"> will be incremented by 1,</span>
<span class="normal">and </span><span class="keyword">\texttt</span><span class="fixed">{top()}</span><span class="normal"> will be equal to x. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{void pop()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Removes the element at the top of the stack.</span>
<span class="normal">Precondition: </span><span class="keyword">\texttt</span><span class="fixed">{empty()}</span><span class="normal"> is false. Postcondition: size() will be</span>
<span class="normal">decremented by 1. </span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{normal\_stack()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> he default constructor. Creates an empty</span>
<span class="normal">stack.</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{template &lt;class stack\_type&gt;</span>
<span class="normal">normal</span><span class="symbol">\_</span><span class="normal">stack(const stack</span><span class="symbol">\_</span><span class="normal">type </span><span class="symbol">\&amp;</span><span class="normal"> stack</span><span class="symbol">\_</span><span class="normal">)} </span><span class="symbol">&amp;</span><span class="normal"> The copy</span>
<span class="normal">constructor. Accepts any </span><span class="keyword">\emph</span><span class="argument">{stack concept}</span><span class="normal"> data type.</span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{\textasciitilde normal\_stack()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> The destructor.</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>

<span class="normal">The running times of the push/pop</span>
<span class="normal">stack operations are given in Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{rtstack}</span><span class="normal">. Other operations</span>
<span class="normal">except copy construction perform constant internal work and no I/Os.</span>

<span class="keyword">\newcommand</span><span class="argument">{\xgsstack}{\texttt{stxxl::grow\_shrink\_stack}}</span>
<span class="keyword">\subsection</span><span class="argument">{\xgsstack}</span>
<span class="normal">The </span><span class="keyword">\xgsstack</span><span class="symbol">\ </span><span class="normal">stack specialization is optimized for an</span>
<span class="normal">access pattern where the insertions are (almost) not intermixed with</span>
<span class="normal">the removals, and/or vice versa, the removals are (almost) not</span>
<span class="normal">intermixed with the insertions. In other words the stack first grows</span>
<span class="normal">to its maximal size, then it shrinks, then it might again grow, then</span>
<span class="normal">shrink, and so forth, i.e.</span><span class="symbol">\ </span><span class="normal">the pattern is</span>
<span class="math">$(push^{i_j}pop^{r_j})^k$</span><span class="normal">, where </span><span class="math">$k \in N$</span><span class="normal">, </span><span class="math">$1\leq j\leq k$</span><span class="normal">, and</span>
<span class="math">$i_j$</span><span class="normal">, </span><span class="math">$r_j$</span><span class="normal"> are </span><span class="keyword">\emph</span><span class="argument">{large}</span><span class="normal">. </span>
<span class="normal">The implementation efficiently exploits the knowledge of the access</span>
<span class="normal">pattern that allows </span><span class="keyword">\emph</span><span class="argument">{prefetching}</span><span class="normal"> the blocks beforehand while the stack</span>
<span class="normal">shrinks and </span><span class="keyword">\emph</span><span class="argument">{buffered writing}</span><span class="normal"> while the stack grows. Therefore</span>
<span class="normal">the </span><span class="keyword">\emph</span><span class="argument">{overlapping}</span><span class="normal"> of I/O and computation is possible.</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Internal Memory Consumption of \xgsstack}</span>
<span class="normal">The cache of </span><span class="keyword">\xgsstack</span><span class="symbol">\ </span><span class="normal">largely dominates in its internal memory</span>
<span class="normal">consumption. Other members consume very small fraction of</span>
<span class="keyword">\xgsstack</span><span class="normal"> 's </span>
<span class="normal">memory even when the stack size is large. Therefore, the internal</span>
<span class="normal">memory consumption of </span><span class="keyword">\xgsstack</span><span class="symbol">\ </span><span class="normal">can be estimated as</span>
<span class="math">$2 \times BlkSize\_ \times PgSz\_$</span><span class="normal"> bytes, where </span><span class="math">$BlkSize\_$</span><span class="normal"> is the</span>
<span class="normal">block size and </span><span class="math">$PgSz\_$</span><span class="normal"> is the page size in blocks (see</span>
<span class="normal">Section</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{stackgensection}</span><span class="normal">). </span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Members of \xgsstack}</span>
<span class="normal">The </span><span class="keyword">\xgsstack</span><span class="normal"> has the same set of members as the </span><span class="keyword">\xnormalstack</span><span class="symbol">\ </span><span class="normal"> (see</span>
<span class="normal">Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{normalstackmembers}</span><span class="normal">). The running times of </span><span class="keyword">\xgsstack</span><span class="symbol">\ </span><span class="normal">are the</span>
<span class="normal">same as </span><span class="keyword">\xnormalstack</span><span class="symbol">\ </span><span class="normal">except that when the stack switches from</span>
<span class="normal">growing to shrinking (or from shrinking to growing) </span><span class="math">$PgSz\_$</span><span class="normal"> I/Os can</span>
<span class="normal">be spent additionally in the worst case.</span><span class="keyword">\footnote</span><span class="argument">{This is for the single</span>
<span class="argument">disk setting, if the page is perfectly striped over parallel disk the</span>
<span class="argument">number of I/Os is $PgSz\_/D$.}</span>

<span class="keyword">\newcommand</span><span class="argument">{\xgsstacktwo}{\texttt{stxxl::grow\_shrink\_stack2}}</span>
<span class="keyword">\subsection</span><span class="argument">{\xgsstacktwo}</span>
<span class="normal">The </span><span class="keyword">\xgsstacktwo</span><span class="symbol">\ </span><span class="normal">is optimized for the same kind of access pattern as</span>
<span class="keyword">\xgsstack</span><span class="normal">. The difference is that each instance of </span><span class="keyword">\xgsstack</span><span class="symbol">\ </span><span class="normal">uses</span>
<span class="normal">an own internal buffer to overlap I/Os and computation, but</span>
<span class="keyword">\xgsstacktwo</span><span class="symbol">\ </span><span class="normal">is able to share the buffers from the pool used by</span>
<span class="normal">several stacks. </span>

<span class="comment">% mention the documentation of prefetch\_pool and write\_pool.</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Internal Memory Consumption of \xgsstacktwo}</span>
<span class="normal">Not counting the memory consumption of the shared blocks from the</span>
<span class="normal">pools, the stack alone consumes about </span><span class="math">$BlkSize\_$</span><span class="normal"> bytes.</span><span class="keyword">\footnote</span><span class="argument">{It has</span>
<span class="argument">the cache that consists of only a single block.}</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Members of \xgsstacktwo}</span>
<span class="normal">The </span><span class="keyword">\xgsstacktwo</span><span class="symbol">\ </span><span class="normal">has almost the same set of members as the</span>
<span class="keyword">\xnormalstack</span><span class="normal">\</span>
<span class="normal">(Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{normalstackmembers}</span><span class="normal">), except that it does not have the</span>
<span class="normal">default constructor. The </span><span class="keyword">\xgsstacktwo</span><span class="symbol">\ </span><span class="normal">requires</span>
<span class="normal">prefetch and write pool objects (see Sections</span>
<span class="keyword">\ref</span><span class="argument">{prefetchpoolsection}</span><span class="normal"> and </span><span class="keyword">\ref</span><span class="argument">{writepoolsection}</span><span class="normal"> for the</span>
<span class="normal">documentation for the pool classes) to be specified in the creation</span>
<span class="normal">time. </span>
<span class="normal">The new members are listed in Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{gsstacktwomembers}</span><span class="normal">.</span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{New members of \xgsstacktwo.}</span>
<span class="keyword">\label</span><span class="argument">{gsstacktwomembers}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|p{6cm}|p{5cm}|}</span>
<span class="keyword">\hline</span>
<span class="normal">member </span><span class="symbol">&amp;</span><span class="normal"> description  </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{grow\_shrink\_stack2 (prefetch\_pool&lt; block\_type &gt; \&amp;</span>
<span class="normal">p</span><span class="symbol">\_</span><span class="normal">pool</span><span class="symbol">\_</span><span class="normal">, write</span><span class="symbol">\_</span><span class="normal">pool&lt; block</span><span class="symbol">\_</span><span class="normal">type &gt; </span><span class="symbol">\&amp;</span><span class="normal">w</span><span class="symbol">\_</span><span class="normal">pool</span><span class="symbol">\_</span><span class="normal">, unsigned</span>
<span class="normal">prefetch</span><span class="symbol">\_</span><span class="normal">aggressiveness=0)} </span><span class="symbol">&amp;</span><span class="normal">  Constructs stack, that will use</span>
<span class="keyword">\texttt</span><span class="fixed">{p\_pool\_}</span><span class="normal"> for prefetching and </span><span class="keyword">\texttt</span><span class="fixed">{w\_pool\_}</span><span class="normal"> for buffered</span>
<span class="normal">writing. </span><span class="keyword">\texttt</span><span class="fixed">{prefetch\_aggressiveness}</span><span class="normal"> parameter tells how many</span>
<span class="normal">blocks from the prefetch pool the stack is allowed to use.</span><span class="symbol">\\</span><span class="normal">  </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{void set\_prefetch\_aggr (unsigned new\_p)}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Sets level of</span>
<span class="normal">prefetch aggressiveness (number of blocks from the prefetch pool used</span>
<span class="normal">for prefetching). </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{unsigned get\_prefetch\_aggr () const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns the number of</span>
<span class="normal">blocks used for prefetching. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>


<span class="keyword">\newcommand</span><span class="argument">{\xmstack}{\texttt{stxxl::migrating\_stack}}</span>
<span class="keyword">\subsection</span><span class="argument">{\xmstack}</span>
<span class="normal">The </span><span class="keyword">\xmstack</span><span class="symbol">\ </span><span class="normal">is a stack that migrates from internal memory to</span>
<span class="normal">external when its size exceeds a certain threshold (template</span>
<span class="normal">parameter). The implementation</span>
<span class="normal">of internal and external memory stacks can be arbitrary and given as a</span>
<span class="normal">template parameters.</span>


<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Internal Memory Consumption of \xmstack}</span>
<span class="normal">The </span><span class="keyword">\xmstack</span><span class="symbol">\ </span><span class="normal">memory consumption depends on the memory consumption of</span>
<span class="normal">the stack implementations given as template parameters. The the</span>
<span class="normal">current state is internal (external), the </span><span class="keyword">\xmstack</span><span class="symbol">\ </span><span class="normal">consumes almost</span>
<span class="normal">exactly the same space as internal (external) memory stack</span>
<span class="normal">implementation.</span><span class="keyword">\footnote</span><span class="argument">{The \xmstack\ needs only few pointers to</span>
<span class="argument">maintain the switching from internal to external memory</span>
<span class="argument">implementations.}</span><span class="normal">  </span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Members of \xmstack}</span>
<span class="normal">The </span><span class="keyword">\xmstack</span><span class="symbol">\ </span><span class="normal">extends the member set of </span><span class="keyword">\xnormalstack</span><span class="normal">\</span>
<span class="normal">(Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{normalstackmembers}</span><span class="normal">). The new members are listed in</span>
<span class="normal">Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{migratingstackmembers}</span><span class="normal">. </span>
<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{New members of \xmstack.}</span>
<span class="keyword">\label</span><span class="argument">{migratingstackmembers}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|p{6cm}|p{5cm}|}</span>
<span class="keyword">\hline</span>
<span class="normal">member </span><span class="symbol">&amp;</span><span class="normal"> description  </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{bool    internal () const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns true if the current</span>
<span class="normal">implementation is internal, otherwise false. </span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{bool    external () const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns true if the current</span>
<span class="normal">implementation is external, otherwise false. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>

<span class="keyword">\newcommand</span><span class="argument">{\xstackg}{\texttt{stxxl::STACK\_GENERATOR}}</span>

<span class="keyword">\subsection</span><span class="argument">{\xstackg}</span>
<span class="keyword">\label</span><span class="argument">{stackgensection}</span>

<span class="normal">To provide an easy way to choose and configure the </span><span class="keyword">\xstack</span><span class="normal">\</span>
<span class="normal">implementations </span><span class="keyword">\stxxl</span><span class="normal"> offers a template meta program called</span>
<span class="keyword">\xstackg</span><span class="normal">. See Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{stackparam}</span><span class="normal">.</span>

<span class="argument">{\bf Example:}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">typedef stxxl::STACK_GENERATOR&lt;int&gt;::result stack_type;</span>

<span class="normal">int main()</span>
<span class="normal">{</span>
<span class="normal">  stack_type S;</span>
<span class="normal">  S.push(8);</span>
<span class="normal">  S.push(7);</span>
<span class="normal">  S.push(4);</span>
<span class="normal">  assert(S.size() == 3);</span>

<span class="normal">  assert(S.top() == 4);</span>
<span class="normal">  S.pop();</span>

<span class="normal">  assert(S.top() == 7);</span>
<span class="normal">  S.pop();</span>

<span class="normal">  assert(S.top() == 8);</span>
<span class="normal">  S.pop();</span>

<span class="normal">  assert(S.empty());</span>
<span class="normal">}</span>

<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Template parameters of \xstackg\ from left to right.}</span>
<span class="keyword">\label</span><span class="argument">{stackparam}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|l|p{4.5cm}|c|c|}</span>
<span class="keyword">\hline</span>
<span class="normal">parameter</span><span class="symbol">&amp;</span><span class="normal"> description  </span><span class="symbol">&amp;</span><span class="normal"> default value </span><span class="symbol">&amp;</span><span class="normal"> recommended value </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="normal">ValTp       </span><span class="symbol">&amp;</span><span class="normal"> element type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">Externality </span><span class="symbol">&amp;</span><span class="normal"> tells whether the vector is internal, external, or</span>
<span class="normal">migrating (Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{externality}</span><span class="normal">) </span><span class="symbol">&amp;</span><span class="normal"> external </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">Behavior </span><span class="symbol">&amp;</span><span class="normal"> chooses </span><span class="keyword">\emph</span><span class="argument">{external}</span><span class="normal"> implementation</span>
<span class="normal">(Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{behaviour}</span><span class="normal">)</span><span class="symbol">&amp;</span><span class="normal"> normal </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="normal">BlocksPerPage </span><span class="symbol">&amp;</span><span class="normal"> defines how many blocks has one page of internal cache</span>
<span class="normal">of an </span><span class="keyword">\emph</span><span class="argument">{external}</span><span class="normal"> implementation </span><span class="symbol">&amp;</span><span class="normal"> 4 </span><span class="symbol">&amp;</span><span class="normal">  </span><span class="math">$\geq D$</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">BlkSz </span><span class="symbol">&amp;</span><span class="normal"> external block size in bytes </span><span class="symbol">&amp;</span><span class="normal">  </span><span class="math">$2\times 1024\times 1024$</span><span class="normal"> </span><span class="symbol">&amp;</span>
<span class="normal">larger is better</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">IntStackTp </span><span class="symbol">&amp;</span><span class="normal"> type of internal stack (used for the migrating stack) </span><span class="symbol">&amp;</span><span class="normal">  </span>
<span class="keyword">\texttt</span><span class="fixed">{std::stack&lt;ValTp&gt;}</span><span class="normal"> </span><span class="symbol">&amp;\\</span>
<span class="keyword">\hline</span>
<span class="normal">MigrCritSize </span><span class="symbol">&amp;</span><span class="normal"> threshold value for number of elements when</span>
<span class="keyword">\texttt</span><span class="fixed">{migrating\_stack}</span><span class="normal"> migrates to the external memory </span><span class="symbol">&amp;</span><span class="normal"> </span>
<span class="math">$2\times BlocksPerPage\times BlkSz$</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">AllocStr </span><span class="symbol">&amp;</span><span class="normal">  parallel disk assignment strategy </span>
<span class="normal">(Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{allocstr}</span><span class="normal">) </span><span class="symbol">&amp;</span><span class="normal"> RC </span><span class="symbol">&amp;</span><span class="normal"> RC </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">SzTp </span><span class="symbol">&amp;</span><span class="normal"> size type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{off\_t}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{off\_t}</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>


<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{The Externality parameter.}</span>
<span class="keyword">\label</span><span class="argument">{externality}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|l|p{7cm}|}</span>
<span class="keyword">\hline</span>
<span class="normal">identifier </span><span class="symbol">&amp;</span><span class="normal"> comment </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="normal">internal </span><span class="symbol">&amp;</span><span class="normal"> chooses IntStackTp implementation</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">external </span><span class="symbol">&amp;</span><span class="normal"> external container, implementation is chosen according to</span>
<span class="normal">the Behavior parameter</span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="normal">migrating </span><span class="symbol">&amp;</span><span class="normal"> migrates from internal implementation given by IntStackTp</span>
<span class="normal">parameter to external implementation given by Behavior parameter when</span>
<span class="normal">size exceeds MigrCritSize </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{The Behavior parameter.}</span>
<span class="keyword">\label</span><span class="argument">{behaviour}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|l|p{7cm}|}</span>
<span class="keyword">\hline</span>
<span class="normal">identifier </span><span class="symbol">&amp;</span><span class="normal"> comment </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="normal">normal </span><span class="symbol">&amp;</span><span class="normal"> conservative version, implemented in </span><span class="keyword">\xnormalstack</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">grow</span><span class="symbol">\_</span><span class="normal">shrink </span><span class="symbol">&amp;</span><span class="normal"> chooses </span><span class="keyword">\xgsstack</span><span class="normal"> </span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="normal">grow</span><span class="symbol">\_</span><span class="normal">shrink2 </span><span class="symbol">&amp;</span><span class="normal"> chooses </span><span class="keyword">\xgsstacktwo</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>


<span class="argument">{\bf Example for \xgsstacktwo\ :}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>

<span class="normal">typedef STACK_GENERATOR&lt;int,external,grow_shrink2&gt;::result stack_type;</span>
<span class="normal">typedef stack_type::block_type block_type;</span>

<span class="normal">stxxl::prefetch_pool p_pool(10); // 10 read buffers</span>
<span class="normal">stxxl::write_pool w_pool(6);     // 6 write buffers</span>
<span class="normal">stack_type S(p_pool,w_pool,0);   // no read buffers used </span>

<span class="normal">for(long long i=0;i &lt; max_value;++i)</span>
<span class="normal">     S.push(i);</span>
<span class="normal"> </span>
<span class="normal">S.set_prefetch_aggressiveness(5); </span>
<span class="normal">/</span><span class="symbol">*</span><span class="normal"> give a hint that we are going to</span>
<span class="normal">   shrink the stack from now on,</span>
<span class="normal">   always prefetch 5 buffers</span>
<span class="normal">   beforehand </span><span class="symbol">*</span><span class="normal">/</span>

<span class="normal">for(long long i=0; i&lt; max_value;++i)</span>
<span class="normal">        S.pop();</span>

<span class="normal">S.set_prefetch_aggressiveness(0);</span>
<span class="normal">// stop prefetching </span>

<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="keyword">\section</span><span class="argument">{Priority Queue}</span>
<span class="normal">A priority queue is a data structure that provides a restricted subset of</span>
<span class="normal">container functionality: it provides insertion of elements, and</span>
<span class="normal">inspection and removal of the top element. It is guaranteed that the</span>
<span class="normal">top element is the largest element in the priority queue, where the</span>
<span class="normal">function object </span><span class="keyword">\texttt</span><span class="fixed">{Cmp\_}</span><span class="normal"> is used for comparisons.</span>
<span class="normal">Priority queue does not allow iteration through its elements. </span>

<span class="keyword">\newcommand</span><span class="argument">{\xpqueue}{\texttt{stxxl::priority\_queue}}</span>

<span class="keyword">\stxxl</span><span class="normal"> priority queue is an external memory implementation of</span>
<span class="keyword">\cite</span><span class="argument">{San00b}</span><span class="normal">. The difference to the original design is that the</span>
<span class="normal">last merge groups keep their sorted sequences in the external memory.</span>
<span class="normal">The running times of </span><span class="keyword">\xpqueue</span><span class="symbol">\ </span><span class="normal">data structure is given in</span>
<span class="normal">Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{rtpqueue}</span><span class="normal">. The theoretic guarantees on I/O performance are</span>
<span class="normal">given only for a single disk setting, however the queue also performs</span>
<span class="normal">well in practice for multi-disk configuration.</span>



<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Amortized running times of the basic operations of \xpqueue{}</span>
<span class="argument">in terms of $I =$ the number of performed operations.}</span>
<span class="keyword">\label</span><span class="argument">{rtpqueue}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|l|c|c|}</span>
<span class="keyword">\hline</span>
<span class="normal">                    </span><span class="symbol">&amp;</span><span class="normal"> int. work </span><span class="symbol">&amp;</span><span class="normal"> I/O (amortized)</span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="normal">insertion           </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{\log I}$</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1/B}$</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">deletion  </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{\log I}$</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="math">$\Oh{1/B}$</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>

<span class="keyword">\subsection</span><span class="argument">{Members of \xpqueue}</span>
<span class="normal">See Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{pqueuemembers}</span><span class="normal">.</span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Members of \xpqueue.}</span>
<span class="keyword">\label</span><span class="argument">{pqueuemembers}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|p{6cm}|p{5cm}|}</span>
<span class="keyword">\hline</span>
<span class="normal">member </span><span class="symbol">&amp;</span><span class="normal"> description  </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{value\_type}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">  The type of object, Tp</span><span class="symbol">\_</span><span class="normal">, stored in the vector. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{size\_type}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> An unsigned 64-bit</span><span class="keyword">\footnote</span><span class="argument">{\texttt{off\_t}</span>
<span class="argument">type. It has the length 64 bits if \ldots}</span><span class="normal"> integral type. </span><span class="symbol">\\</span><span class="normal">  </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{block\_type}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> type of the block used in disk-memory </span>
<span class="normal">transfers </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{priority\_queue( prefetch\_pool&lt;block\_type&gt;\&amp; p\_pool\_, </span>
<span class="normal">write</span><span class="symbol">\_</span><span class="normal">pool&lt;block</span><span class="symbol">\_</span><span class="normal">type&gt;</span><span class="symbol">\&amp;</span><span class="normal"> w</span><span class="symbol">\_</span><span class="normal">pool</span><span class="symbol">\_</span><span class="normal">)} </span><span class="symbol">&amp;</span><span class="normal"> Creates an empty priority</span>
<span class="normal">queue. Prefetch pool </span><span class="keyword">\texttt</span><span class="fixed">{p\_pool\_}</span><span class="normal"> and write pools</span>
<span class="keyword">\texttt</span><span class="fixed">{w\_pool\_}</span><span class="normal"> will be used for overlapping of I/O and computation</span>
<span class="normal">during external memory merging (see Sections</span>
<span class="keyword">\ref</span><span class="argument">{prefetchpoolsection}</span><span class="normal"> and </span><span class="keyword">\ref</span><span class="argument">{writepoolsection}</span><span class="normal"> for the</span>
<span class="normal">documentation for the pool classes).</span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{bool empty() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns true if the </span><span class="keyword">\texttt</span><span class="fixed">{priority\_queue}</span>
<span class="normal">contains no elements, and false  otherwise. </span><span class="keyword">\texttt</span><span class="fixed">{S.empty()}</span><span class="normal"> is</span>
<span class="normal">equivalent to </span><span class="keyword">\texttt</span><span class="fixed">{S.size() == 0}</span><span class="normal">. </span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{size\_type size() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns the number of elements</span>
<span class="normal">contained in the </span><span class="keyword">\texttt</span><span class="fixed">{priority\_queue}</span><span class="normal">. </span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{const value\_type\&amp; top() const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns a const reference to</span>
<span class="normal">the element at the top of the </span><span class="keyword">\texttt</span><span class="fixed">{priority\_queue}</span><span class="normal">. The element at</span>
<span class="normal">the top </span>
<span class="normal">is guaranteed to be the largest element in the priority queue, as</span>
<span class="normal">determined by the comparison function </span><span class="keyword">\texttt</span><span class="fixed">{Cmp\_}</span><span class="normal">. That is, for</span>
<span class="normal">every </span>
<span class="normal">other element x in the </span><span class="keyword">\texttt</span><span class="fixed">{priority\_queue}</span><span class="normal">, </span><span class="keyword">\texttt</span><span class="fixed">{Cmp\_(Q.top(), x)}</span><span class="normal"> is</span>
<span class="normal">false. Precondition: </span><span class="keyword">\texttt</span><span class="fixed">{empty()}</span><span class="normal"> is false. </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{void push(const value\_type\&amp; x)}</span><span class="symbol">&amp;</span><span class="normal"> Inserts x into the</span>
<span class="keyword">\texttt</span><span class="fixed">{priority\_queue}</span><span class="normal">. Postcondition: </span><span class="keyword">\texttt</span><span class="fixed">{size()}</span><span class="normal"> will be</span>
<span class="normal">incremented by 1.</span><span class="symbol">\\</span><span class="normal">  </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{void pop()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Removes the element at the top of the</span>
<span class="keyword">\texttt</span><span class="fixed">{priority\_queue}</span><span class="normal">, that is, the largest element in the</span>
<span class="keyword">\texttt</span><span class="fixed">{priority\_queue}</span><span class="normal">. Precondition: </span><span class="keyword">\texttt</span><span class="fixed">{empty()}</span><span class="normal"> is</span>
<span class="normal">false. Postcondition: </span>
<span class="keyword">\texttt</span><span class="fixed">{size()}</span><span class="normal"> will be decremented by 1.  </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{unsigned mem\_cons () const}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> Returns number of bytes</span>
<span class="normal">consumed by the </span><span class="keyword">\texttt</span><span class="fixed">{priority\_queue}</span><span class="normal"> in the internal memory </span>
<span class="normal">not including the pools.</span><span class="symbol">\\</span><span class="normal">  </span>
<span class="keyword">\hline</span>
<span class="keyword">\texttt</span><span class="fixed">{\textasciitilde priority\_queue()}</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> The</span>
<span class="normal">destructor. Deallocates all occupied internal and external memory.</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>


<span class="keyword">\newcommand</span><span class="argument">{\xpqueueg}{\texttt{stxxl::PRIORITY\_QUEUE\_GENERATOR}}</span>

<span class="keyword">\subsection</span><span class="argument">{\xpqueueg}</span>
<span class="normal">Since the </span><span class="keyword">\xpqueue</span><span class="symbol">\ </span><span class="normal">has many setup parameters (internal memory</span>
<span class="normal">buffer sizes, arity of mergers, number of internal and external memory</span>
<span class="normal">merger groups, etc.) which are difficult to guess, </span><span class="keyword">\stxxl</span><span class="symbol">\ </span><span class="normal">provides a</span>
<span class="normal">helper meta template program </span>
<span class="normal">that searches for the optimum settings for user demands. The program</span>
<span class="normal">is called </span><span class="keyword">\xpqueueg</span><span class="normal">. The parameter of the program are given in</span>
<span class="normal">Table</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{pqueueparam}</span><span class="normal">.</span>

<span class="keyword">\begin</span><span class="argument">{table}</span><span class="optionalargument">[h]</span>
<span class="keyword">\begin</span><span class="argument">{center}</span>
<span class="keyword">\caption</span><span class="argument">{Template parameters of \xpqueueg\ from left to right.}</span>
<span class="keyword">\label</span><span class="argument">{pqueueparam}</span>
<span class="keyword">\begin</span><span class="argument">{tabular}{|l|p{4.5cm}|c|c|}</span>
<span class="keyword">\hline</span>
<span class="normal">parameter</span><span class="symbol">&amp;</span><span class="normal"> description  </span><span class="symbol">&amp;</span><span class="normal"> default value </span><span class="symbol">&amp;</span><span class="normal"> recommended value </span><span class="symbol">\\</span>
<span class="keyword">\hline\hline</span>
<span class="normal">Tp</span><span class="symbol">\_</span><span class="normal">       </span><span class="symbol">&amp;</span><span class="normal"> element type </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">Cmp</span><span class="symbol">\_</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> the comparison type used to determine whether one element is</span>
<span class="normal">smaller than another element. See note a.</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="normal">IntM</span><span class="symbol">\_</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> upper limit for internal memory consumption in bytes </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">&amp;</span>
<span class="normal">larges is better</span><span class="symbol">\\</span>
<span class="keyword">\hline</span>
<span class="normal">MaxS</span><span class="symbol">\_</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> upper limit for number of elements contained in the priority</span>
<span class="normal">queue (in units of 1024 items). See note b. </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="symbol">\\</span><span class="normal"> </span>
<span class="keyword">\hline</span>
<span class="normal">Tune</span><span class="symbol">\_</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> a tuning parameter. See note c. </span><span class="symbol">&amp;</span><span class="normal"> 6 </span><span class="symbol">&amp;\\</span>
<span class="keyword">\hline</span>
<span class="keyword">\end</span><span class="argument">{tabular}</span>
<span class="keyword">\end</span><span class="argument">{center}</span>
<span class="keyword">\end</span><span class="argument">{table}</span>

<span class="normal">Notes:</span>
<span class="keyword">\begin</span><span class="argument">{enumerate}</span>
<span class="keyword">\item</span><span class="normal"> If </span><span class="keyword">\texttt</span><span class="fixed">{Cmp\_(x,y)}</span><span class="normal"> is true, then x is smaller than y. The element</span>
<span class="normal">returned by </span><span class="keyword">\texttt</span><span class="fixed">{Q.top()}</span><span class="normal"> is the largest element in the priority queue. That</span>
<span class="normal">is, it has the property that, for every other element x in the</span>
<span class="normal">priority queue, </span><span class="keyword">\texttt</span><span class="fixed">{Cmp\_(Q.top(), x)}</span><span class="normal"> is false. </span><span class="keyword">\texttt</span><span class="fixed">{Cmp\_}</span>
<span class="normal">must also provide </span>
<span class="keyword">\texttt</span><span class="fixed">{min\_value}</span><span class="normal"> method, that returns value of type </span><span class="keyword">\texttt</span><span class="fixed">{Tp\_}</span>
<span class="normal">that is smaller than </span>
<span class="normal">any element of the queue x , i.e.</span><span class="symbol">\ </span><span class="keyword">\texttt</span><span class="fixed">{Cmp\_(Cmp\_.min\_value(),x))}</span>
<span class="normal">is always true. </span>

<span class="normal">Example, a comparison object for priority queue where </span><span class="keyword">\texttt</span><span class="fixed">{top()}</span>
<span class="normal">returns the </span><span class="keyword">\emph</span><span class="argument">{smallest}</span><span class="normal"> contained integer: </span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">struct CmpIntGreater</span>
<span class="normal">{</span>
<span class="normal">  bool operator () (const int </span><span class="symbol">&amp;</span><span class="normal"> a, const int </span><span class="symbol">&amp;</span><span class="normal"> b)</span>
<span class="normal">  </span><span class="argument">{ return a&lt;b; }</span>
<span class="normal">  int min_value() const  </span>
<span class="normal">  </span><span class="argument">{ return (std::numeric_limits&lt;int&gt;::max)(); }</span>
<span class="normal">};</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="normal">Example, a comparison object for priority queue where </span><span class="keyword">\texttt</span><span class="fixed">{top()}</span>
<span class="normal">returns the </span><span class="keyword">\emph</span><span class="argument">{largest}</span><span class="normal"> contained integer: </span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">struct CmpIntLess: public std::less&lt;int&gt;</span>
<span class="normal">{</span>
<span class="normal">   int min_value() const  </span>
<span class="normal">   </span><span class="argument">{ return (std::numeric_limits&lt;int&gt;::min)(); }</span>
<span class="normal">};</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="normal">Note that </span><span class="keyword">\texttt</span><span class="fixed">{Cmp\_}</span><span class="normal"> must define the Strict Weak Ordering.</span>

<span class="keyword">\item</span><span class="normal"> Example: if you are sure that priority queue contains no more</span>
<span class="normal">than one million elements any time, then the right parameter for you is</span>
<span class="math">$(1000000/1024)= 976$</span><span class="normal">.</span>

<span class="keyword">\item</span><span class="normal"> Try to play with the Tune</span><span class="symbol">\_</span><span class="normal"> parameter if the your code does not</span>
<span class="normal">compile (larger than default value 6 might help). The reason that the</span>
<span class="normal">code does not </span>
<span class="normal">compile is that no suitable </span>
<span class="normal">internal parameters were found for given IntM</span><span class="symbol">\_</span><span class="normal"> and MaxS</span><span class="symbol">\_</span><span class="normal">. It might</span>
<span class="normal">also happen that given IntM</span><span class="symbol">\_</span><span class="normal"> is too small for given MaxS</span><span class="symbol">\_</span><span class="normal">, try larger</span>
<span class="normal">values.</span>
<span class="normal"> </span>
<span class="keyword">\texttt</span><span class="fixed">{PRIORITY\_QUEUE\_GENERATOR}</span><span class="normal"> searches for 7 </span>
<span class="normal">configuration parameters of </span><span class="keyword">\xpqueue</span><span class="symbol">\ </span><span class="normal">that both minimize</span>
<span class="normal">internal memory consumption of the priority queue to match IntM</span><span class="symbol">\_</span><span class="normal"> and</span>
<span class="normal">maximize the performance of priority queue operations. Actual memory</span>
<span class="normal">consumption might be slightly larger (use</span>
<span class="keyword">\texttt</span><span class="fixed">{stxxl::priority\_queue::mem\_cons()}</span>
<span class="normal">method to track it), since the search assumes rather optimistic</span>
<span class="normal">schedule of push'es and pop'es for the estimation of the maximum</span>
<span class="normal">memory consumption. To keep actual memory requirements low, increase</span>
<span class="normal">the value of MaxS</span><span class="symbol">\_</span><span class="normal"> parameter. </span>
<span class="keyword">\item</span><span class="normal"> </span>
<span class="normal">For the functioning, a priority queue object requires two pools of blocks</span>
<span class="normal">(See the constructor of </span><span class="keyword">\texttt</span><span class="fixed">{priority\_queue}</span><span class="normal"> ). To construct</span>
<span class="keyword">\stxxl</span><span class="normal"> block pools </span>
<span class="normal">you need the block type that is used by priority queue. Block's size</span>
<span class="normal">and hence it's type is generated by the </span>
<span class="keyword">\texttt</span><span class="fixed">{PRIORITY\_QUEUE\_GENERATOR}</span><span class="normal"> in compile type from IntM</span><span class="symbol">\_</span><span class="normal">, MaxS</span><span class="symbol">\_</span>
<span class="normal">and </span><span class="keyword">\texttt</span><span class="fixed">{sizeof(Tp\_)}</span><span class="normal"> and it can not be given directly by the user</span>
<span class="normal">as a template parameter. The block type can be accessed as</span><span class="symbol">\\</span>
<span class="keyword">\texttt</span><span class="fixed">{PRIORITY\_QUEUE\_GENERATOR&lt;parameters&gt;::result::block\_type}</span><span class="normal">. </span>

<span class="keyword">\end</span><span class="argument">{enumerate}</span>

<span class="argument">{\bf Example:}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">struct Cmp</span>
<span class="normal">{</span>
<span class="normal">  bool operator () (const int </span><span class="symbol">&amp;</span><span class="normal"> a, </span>
<span class="normal">                    const int </span><span class="symbol">&amp;</span><span class="normal"> b) const </span>
<span class="normal">  </span><span class="argument">{ return a&gt;b; }</span>
<span class="normal">  int min_value() const  </span>
<span class="normal">  </span><span class="argument">{ return (std::numeric_limits&lt;int&gt;::max)(); }</span>
<span class="normal">};</span>

<span class="normal">typedef stxxl::PRIORITY_QUEUE_GENERATOR&lt;int,</span>
<span class="normal">                                        Cmp,</span>
<span class="normal">/</span><span class="symbol">*</span><span class="normal"> use 64 MiB on main memory </span><span class="symbol">*</span><span class="normal">/         64</span><span class="symbol">*</span><span class="normal">1024</span><span class="symbol">*</span><span class="normal">1024,</span>
<span class="normal">/</span><span class="symbol">*</span><span class="normal"> 1 billion items at most  </span><span class="symbol">*</span><span class="normal">/          1024</span><span class="symbol">*</span><span class="normal">1024</span>
<span class="normal">                                        &gt;::result pq_type;</span>
<span class="normal">typedef pq_type::block_type block_type;</span>


<span class="normal">int main() {</span>
<span class="normal">  // use 10 block read and write pools </span>
<span class="normal">  // for enable overlapping of I/O and</span>
<span class="normal">  // computation</span>
<span class="normal">  stxxl::prefetch_pool&lt;block_type&gt; p_pool(10);</span>
<span class="normal">  stxxl::write_pool&lt;block_type&gt;    w_pool(10);</span>

<span class="normal">  pq_type Q(p_pool,w_pool);</span>
<span class="normal">  Q.push(1);</span>
<span class="normal">  Q.push(4);</span>
<span class="normal">  Q.push(2);</span>
<span class="normal">  Q.push(8);</span>
<span class="normal">  Q.push(5);</span>
<span class="normal">  Q.push(7);</span>
<span class="normal">  </span>
<span class="normal">  assert(Q.size() == 6);</span>

<span class="normal">  assert(Q.top() == 8);</span>
<span class="normal">  Q.pop();</span>

<span class="normal">  assert(Q.top() == 7);</span>
<span class="normal">  Q.pop();</span>

<span class="normal">  assert(Q.top() == 5);</span>
<span class="normal">  Q.pop();</span>

<span class="normal">  assert(Q.top() == 4);</span>
<span class="normal">  Q.pop();</span>

<span class="normal">  assert(Q.top() == 2);</span>
<span class="normal">  Q.pop();</span>

<span class="normal">  assert(Q.top() == 1);</span>
<span class="normal">  Q.pop();</span>

<span class="normal">  assert(Q.empty());</span>
<span class="normal">}</span>


<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="keyword">\subsection</span><span class="argument">{Internal Memory Consumption of \xpqueue}</span>
<span class="normal">Internal memory consumption of </span><span class="keyword">\xpqueue</span><span class="symbol">\ </span><span class="normal">is bounded by the IntM</span><span class="symbol">\_</span>
<span class="normal">parameter in most situations.</span>

<span class="keyword">\newcommand</span><span class="argument">{\xsort}{{\texttt{stxxl::sort}}}</span>
<span class="keyword">\newcommand</span><span class="argument">{\xksort}{{\texttt{stxxl::ksort}}}</span>
<span class="keyword">\newcommand</span><span class="argument">{\stdsort}{{\texttt{std::sort}}}</span>



<span class="keyword">\section</span><span class="argument">{\stxxl Algorithms}</span>
<span class="normal">Iterators of </span><span class="keyword">\xvector</span><span class="symbol">\ </span><span class="normal">are STL</span>
<span class="normal">compatible. </span><span class="keyword">\texttt</span><span class="fixed">{stxxl::vector::iterator}</span><span class="normal"> is a model of Random</span>
<span class="normal">Access Iterator concept from STL. Therefore it is possible to use the</span>
<span class="keyword">\xvector</span><span class="symbol">\ </span><span class="normal">iterator ranges with STL algorithms. However such use is not</span>
<span class="normal">I/O efficient if an algorithm accesses the sequence in a random order.</span>
<span class="normal">For such kind of algorithms </span><span class="keyword">\stxxl</span><span class="normal"> provides I/O efficient</span>
<span class="normal">implementations described in this chapter</span>
<span class="normal">(Sections</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{sortsection}</span><span class="normal">--</span><span class="keyword">\ref</span><span class="argument">{ksortsection}</span><span class="normal">). </span>
<span class="normal">If an algorithm does only a scan (or a constant number of scans) of</span>
<span class="normal">a sequence (or sequences) the implementation that calls STL algorithm</span>
<span class="normal">is nevertheless I/O efficient. However one can save constant factors</span>
<span class="normal">in I/O volume </span>
<span class="normal">and internal work if the the access pattern is known (read-only or</span>
<span class="normal">write-only scan for example). This knowledge is used in </span><span class="keyword">\stxxl</span>
<span class="normal">specialized implementations of STL algorithms</span>
<span class="normal">(Section</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{otheralgs}</span><span class="normal">).</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Example: STL Algorithms Running on \stxxl containers}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">typedef stxxl::VECTOR_GENERATOR&lt;int&gt;::result vector_type;</span>

<span class="normal">// Replace every number in an array with its negative.</span>
<span class="normal">const int N = 1000000000;</span>
<span class="normal">vector_type A(N);</span>
<span class="normal">std::iota(A.begin(), A.end(), 1);</span>
<span class="normal">std::transform(A, A+N, A, negate&lt;double&gt;());</span>

<span class="normal">// Calculate the sum of two vectors, </span>
<span class="normal">// storing the result in a third vector.</span>

<span class="normal">const int N = 1000000000;</span>
<span class="normal">vector_type V1(N);</span>
<span class="normal">vector_type V2(N);</span>
<span class="normal">vector_type V3(N);</span>

<span class="normal">std::iota(V1.begin(), V1.end(), 1);</span>
<span class="normal">std::fill(V2.begin(), V2.end(), 75);</span>

<span class="normal">assert(V2.size() &gt;= V1.size() </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span>
<span class="normal">       V3.size() &gt;= V1.size());</span>
<span class="normal">std::transform(V1.begin(), </span>
<span class="normal">               V1.end(), </span>
<span class="normal">               V2.begin(), </span>
<span class="normal">               V3.begin(),</span>
<span class="normal">               plus&lt;int&gt;());</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="keyword">\section</span><span class="argument">{Sorting}</span>
<span class="keyword">\label</span><span class="argument">{sortsection}</span>
<span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">is an external memory equivalent to STL </span><span class="keyword">\stdsort</span><span class="normal">.</span>
<span class="normal">The design and implementation of the algorithm is described in detail</span>
<span class="normal">in </span><span class="keyword">\cite</span><span class="argument">{DemSan03}</span><span class="normal">. </span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Prototype}</span>

<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">template &lt; typename ExtIterator_, </span>
<span class="normal">           typename StrictWeakOrdering_ </span>
<span class="normal">         &gt;</span>
<span class="normal">void sort ( ExtIterator_        first,</span>
<span class="normal">            ExtIterator_        last,</span>
<span class="normal">            StrictWeakOrdering_ cmp,</span>
<span class="normal">            unsigned            M</span>
<span class="normal">          )</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Description}</span>

<span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">sorts the elements in [first, last) into ascending order,</span>
<span class="normal">meaning </span>
<span class="normal">that if </span><span class="keyword">\texttt</span><span class="fixed">{i}</span><span class="normal"> and </span><span class="keyword">\texttt</span><span class="fixed">{j}</span><span class="normal"> are any two valid iterators in</span>
<span class="normal">[first, last) such that </span>
<span class="keyword">\texttt</span><span class="fixed">{i}</span><span class="normal"> precedes </span><span class="keyword">\texttt</span><span class="fixed">{j}</span><span class="normal">, then </span><span class="keyword">\texttt</span><span class="fixed">{*j}</span><span class="normal"> is not less than</span>
<span class="keyword">\texttt</span><span class="fixed">{*i}</span><span class="normal">. Note: as </span><span class="keyword">\stdsort</span><span class="normal">, </span>
<span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">is not guaranteed to be stable. That is, suppose that</span>
<span class="keyword">\texttt</span><span class="fixed">{*i}</span><span class="normal"> and </span><span class="keyword">\texttt</span><span class="fixed">{*j}</span><span class="normal"> are </span>
<span class="normal">equivalent: neither one is less than the other. It is not guaranteed</span>
<span class="normal">that the relative order of these two elements will be preserved by</span>
<span class="keyword">\xsort</span><span class="normal">. </span>

<span class="normal">The order is defined by the </span><span class="keyword">\texttt</span><span class="fixed">{cmp}</span><span class="normal"> parameter. The sorter's</span>
<span class="normal">internal memory consumption is bounded by </span><span class="keyword">\texttt</span><span class="fixed">{M}</span><span class="normal"> bytes.</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Requirements on Types}</span>

<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator\_}</span><span class="normal"> is a model of External Random Access</span>
<span class="normal">Iterator</span><span class="keyword">\footnote</span><span class="argument">{In \stxxl currently only \xvector\ provides</span>
<span class="argument">iterators that are models of External Random Access Iterator.}</span><span class="normal">. </span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator\_}</span><span class="normal"> is mutable.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{StrictWeakOrdering\_}</span><span class="normal"> is a model of Strict Weak Ordering</span>
<span class="normal">and must provide min and max values for the elements in the input:</span>
<span class="normal"> </span><span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="normal"> </span><span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{max\_value}</span><span class="normal"> method that returns an object that is</span>
<span class="normal">   </span><span class="keyword">\emph</span><span class="argument">{strictly greater}</span><span class="normal"> than all other objects of user type according</span>
<span class="normal">    to the given ordering. </span>
<span class="normal"> </span><span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{min\_value}</span><span class="normal"> method that returns an object that</span>
<span class="normal">    is </span><span class="keyword">\emph</span><span class="argument">{strictly less}</span><span class="normal"> than all other objects of user type according</span>
<span class="normal">    to the given ordering.</span>
<span class="normal"> </span><span class="keyword">\end</span><span class="argument">{itemize}</span>
<span class="normal"> </span><span class="argument">{\bf Example:}</span><span class="normal"> </span>
<span class="normal">  a comparison object for ordering integer elements in the ascending</span>
<span class="normal">  order</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">struct CmpIntLess: public std::less&lt;int&gt;</span>
<span class="normal">{</span>
<span class="normal">   static int min_value() const  </span>
<span class="normal">   </span><span class="argument">{ return (std::numeric_limits&lt;int&gt;::min)(); }</span>
<span class="normal">   static int max_value() const  </span>
<span class="normal">   </span><span class="argument">{ return (std::numeric_limits&lt;int&gt;::max)(); }</span>
<span class="normal">};</span>
<span class="normal"> </span><span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="normal"> </span><span class="argument">{\bf Example:}</span><span class="normal"> </span>
<span class="normal">  a comparison object for ordering integer elements in the descending</span>
<span class="normal">  order</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">struct CmpIntGreater: public std::greater&lt;int&gt;</span>
<span class="normal">{</span>
<span class="normal">   int min_value() const  </span>
<span class="normal">   </span><span class="argument">{ return (std::numeric_limits&lt;int&gt;::max)(); }</span>
<span class="normal">   int max_value() const  </span>
<span class="normal">   </span><span class="argument">{ return (std::numeric_limits&lt;int&gt;::min)(); }</span>
<span class="normal">};</span>
<span class="normal"> </span><span class="keyword">\end</span><span class="argument">{lstlisting}</span>


<span class="normal"> Note, that according to the </span><span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">requirements </span><span class="keyword">\texttt</span><span class="fixed">{min\_value}</span>
<span class="normal">and </span><span class="keyword">\texttt</span><span class="fixed">{max\_value}</span><span class="normal"> </span><span class="argument">{\bf can not}</span><span class="normal"> be present in the input</span>
<span class="normal">sequence.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator\_}</span><span class="normal">'s value type is convertible to</span>
<span class="keyword">\texttt</span><span class="fixed">{StrictWeakOrdering\_}</span><span class="normal">'s argument type.</span>

<span class="keyword">\end</span><span class="argument">{itemize}</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Preconditions}</span>
<span class="keyword">\label</span><span class="argument">{sortpreconditions}</span>
<span class="normal">[first, last) is a valid range.</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Complexity}</span>
<span class="keyword">\label</span><span class="argument">{sortcomplexity}</span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> Internal work: </span><span class="math">$\Oh{N \log N}$</span><span class="normal">, where </span><span class="symbol">\\</span><span class="math">$N = (last -</span>
<span class="math">first)\cdot$</span><span class="symbol">~</span><span class="keyword">\texttt</span><span class="fixed">{sizeof(ExtIterator\_::value\_type)}</span><span class="normal">.</span>
<span class="keyword">\item</span><span class="normal"> I/O complexity: </span><span class="math">$(2N/DB)(1 + \lceil {\log}_{M/B}(2N/M) \rceil)$</span><span class="normal"> I/Os</span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>

<span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">chooses the block size (parameter </span><span class="math">$B$</span><span class="normal">) equal to the block size</span>
<span class="normal">of the container, the last and first iterators pointing to</span>
<span class="normal">(e.g.</span><span class="symbol">\ </span><span class="keyword">\xvector</span><span class="normal">'s block size).</span>

<span class="normal">The second term in the I/O complexity accounts for the merge phases of</span>
<span class="normal">the external memory sorting algorithm </span><span class="keyword">\cite</span><span class="argument">{DemSan03}</span><span class="normal">. Avoiding</span>
<span class="normal">multiple merge phases  </span>
<span class="normal">speeds up the sorting. In practice one should choose the block size</span>
<span class="math">$B$</span><span class="normal"> of the container to be </span>
<span class="normal">sorted such that there is only one merge phase needed: </span><span class="math">$\lceil</span>
<span class="math">{\log}_{M/B}(2N/M) \rceil) = 1$</span><span class="normal">. This is </span>
<span class="normal">possible for </span><span class="math">$M &gt; DB$</span><span class="normal"> and </span><span class="math">$N &lt; M^2/2DB$</span><span class="normal">. But still this restriction</span>
<span class="normal">gives a freedom to choose a variety of blocks sizes. The study</span>
<span class="keyword">\cite</span><span class="argument">{DemSan03}</span><span class="normal"> has shown that optimal </span><span class="math">$B$</span><span class="normal"> for sorting lies in the</span>
<span class="normal">range </span><span class="math">$[M^2/(4N),3M^2/(8N)]$</span><span class="normal">. With such choice of the parameters the</span>
<span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">always performs </span><span class="math">$4N/DB$</span><span class="normal"> I/Os.</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Internal Memory Consumption}</span>
<span class="keyword">\label</span><span class="argument">{sortimem}</span>
<span class="normal">The </span><span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">consumes slightly more than </span><span class="keyword">\emph</span><span class="argument">{M}</span><span class="normal"> bytes of internal</span>
<span class="normal">memory. </span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{External Memory Consumption}</span>
<span class="keyword">\label</span><span class="argument">{sortemem}</span>
<span class="normal">The </span><span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">is not in-place. It requires about </span><span class="math">$N$</span><span class="normal"> bytes of external</span>
<span class="normal">memory to store the sorted runs during the sorting process</span>
<span class="keyword">\cite</span><span class="argument">{DemSan03}</span><span class="normal">. After the sorting this memory is freed.</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Example}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">struct MyCmp: public std::less&lt;int&gt; // ascending</span>
<span class="argument">{                                   // order</span>
<span class="argument">   static int min_value() const  </span>
<span class="argument">   { return (std::numeric_limits&lt;int&gt;::min)(); }</span>
<span class="argument">   static int max_value() const  </span>
<span class="argument">   { return (std::numeric_limits&lt;int&gt;::max)(); }</span>
<span class="argument">}</span><span class="normal">;</span>
<span class="normal">typedef stxxl::VECTOR_GENERATOR&lt;int&gt;::result vec_type;</span>

<span class="normal">vec_type V;</span>
<span class="normal">// ... fill here the vector with some values</span>

<span class="normal">/</span><span class="symbol">*</span>
<span class="normal">   Sort in ascending order</span>
<span class="normal">   use 512 MiB of main memory</span>
<span class="symbol">*</span><span class="normal">/</span>
<span class="normal">stxxl::sort(V.begin(),V.end(),MyCmp(),512</span><span class="symbol">*</span><span class="normal">1024</span><span class="symbol">*</span><span class="normal">1024);</span>
<span class="normal">// sorted</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="keyword">\section</span><span class="argument">{Sorted Order Checking}</span>
<span class="keyword">\stxxl</span><span class="normal"> gives an ability to automatically check the order in the output</span>
<span class="normal">of </span><span class="keyword">\stxxl</span><span class="normal"> </span><span class="keyword">\footnote</span><span class="argument">{This checker checks the \xsort, \xksort\</span>
<span class="argument">(Section~\ref{ksortsection}), and </span>
<span class="argument">the pipelined sorter from Section~\ref{pipesorting}.}</span>
<span class="normal">sorters and intermediate results of sorting (the order and a meta</span>
<span class="normal">information in the sorted runs). The check is switched on if the</span>
<span class="normal">source codes and the library are compiled with the option</span>
<span class="keyword">\texttt</span><span class="fixed">{-DSTXXL\_CHECK\_ORDER\_IN\_SORTS}</span><span class="normal"> and the option</span>
<span class="keyword">\texttt</span><span class="fixed">{-DNDEBUG}</span><span class="normal"> is not used. For details see the</span>
<span class="keyword">\texttt</span><span class="fixed">{compiler.make}</span><span class="normal"> file in the </span><span class="keyword">\stxxl</span><span class="normal"> tar ball. Note, that the</span>
<span class="normal">checking routines require more internal work as well as additional </span><span class="math">$N/DB$</span>
<span class="normal">I/Os to read the sorted runs. Therefore for the final non-debug</span>
<span class="normal">version of a user application on should switch this option off.</span>

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="keyword">\section</span><span class="argument">{Sorting Using Integer Keys}</span>
<span class="keyword">\label</span><span class="argument">{ksortsection}</span>
<span class="keyword">\xksort</span><span class="symbol">\ </span><span class="normal">is a specialization of external memory sorting optimized for</span>
<span class="normal">records having integer keys.</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Prototype}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">template &lt; typename ExtIterator_&gt;</span>
<span class="normal">void ksort ( ExtIterator_ first,</span>
<span class="normal">             ExtIterator_ last,</span>
<span class="normal">             unsigned     M</span>
<span class="normal">           )</span>

<span class="normal">template &lt; typename ExtIterator_, typename KeyExtractor_&gt;</span>
<span class="normal">void ksort ( ExtIterator_  first,</span>
<span class="normal">             ExtIterator_  last,</span>
<span class="normal">             KeyExtractor_ keyobj,</span>
<span class="normal">             unsigned      M</span>
<span class="normal">           )  </span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Description}</span>
<span class="keyword">\xksort</span><span class="symbol">\ </span><span class="normal">sorts the elements in [first, last) into ascending order,</span>
<span class="normal">meaning </span>
<span class="normal">that if </span><span class="keyword">\texttt</span><span class="fixed">{i}</span><span class="normal"> and </span><span class="keyword">\texttt</span><span class="fixed">{j}</span><span class="normal"> are any two valid iterators in</span>
<span class="normal">[first, last) such that </span>
<span class="keyword">\texttt</span><span class="fixed">{i}</span><span class="normal"> precedes </span><span class="keyword">\texttt</span><span class="fixed">{j}</span><span class="normal">, then </span><span class="keyword">\texttt</span><span class="fixed">{*j}</span><span class="normal"> is not less than</span>
<span class="keyword">\texttt</span><span class="fixed">{*i}</span><span class="normal">. Note: as </span><span class="keyword">\stdsort</span><span class="normal"> and </span><span class="keyword">\xsort</span><span class="normal">, </span>
<span class="keyword">\xksort</span><span class="symbol">\ </span><span class="normal">is not guaranteed to be stable. That is, suppose that</span>
<span class="keyword">\texttt</span><span class="fixed">{*i}</span><span class="normal"> and </span><span class="keyword">\texttt</span><span class="fixed">{*j}</span><span class="normal"> are </span>
<span class="normal">equivalent: neither one is less than the other. It is not guaranteed</span>
<span class="normal">that the relative order of these two elements will be preserved by</span>
<span class="keyword">\xksort</span><span class="normal">. </span>

<span class="normal">The two versions of </span><span class="keyword">\xksort</span><span class="symbol">\ </span><span class="normal">differ in how they define whether one</span>
<span class="normal">element is less than another. The first version assumes that </span>
<span class="normal">the elements have </span><span class="keyword">\texttt</span><span class="fixed">{key()}</span><span class="normal"> member function that returns an</span>
<span class="normal">integral key (32 or 64 bit), as well as the minimum and the maximum</span>
<span class="normal">element values. The second version compares objects extracting the</span>
<span class="normal">keys using </span><span class="keyword">\texttt</span><span class="fixed">{keyobj}</span><span class="normal"> object, that is in turn provides min and</span>
<span class="normal">max element values.</span>

<span class="normal">The sorter's internal memory consumption is bounded by </span><span class="keyword">\texttt</span><span class="fixed">{M}</span>
<span class="normal">bytes. </span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Requirements on Types}</span>

<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator\_}</span><span class="normal"> is a model of External Random Access</span>
<span class="normal">Iterator</span><span class="keyword">\footnote</span><span class="argument">{In \stxxl currently only \xvector\ provides</span>
<span class="argument">iterators that are models of External Random Access Iterator.}</span><span class="normal">. </span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator\_}</span><span class="normal"> is mutable.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{KeyExtractor\_}</span><span class="normal"> must implement </span><span class="keyword">\texttt</span><span class="fixed">{operator ()}</span><span class="normal"> that</span>
<span class="normal">extracts the key of an element and provide min and max values for the</span>
<span class="normal">elements in the input: </span>
<span class="normal"> </span><span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="normal"> </span><span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{key\_type}</span><span class="normal"> typedef for the type of the keys.</span>
<span class="normal"> </span><span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{max\_value}</span><span class="normal"> method that returns an object that is</span>
<span class="normal">   </span><span class="keyword">\emph</span><span class="argument">{strictly greater}</span><span class="normal"> than all other keys of the elements in the</span>
<span class="normal">   input.  </span>
<span class="normal"> </span><span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{min\_value}</span><span class="normal"> method that returns an object that</span>
<span class="normal">    is </span><span class="keyword">\emph</span><span class="argument">{strictly less}</span><span class="normal"> than all other keys of the elements in the</span>
<span class="normal">    input.</span>
<span class="normal"> </span><span class="keyword">\end</span><span class="argument">{itemize}</span>
<span class="normal"> </span><span class="argument">{\bf Example:}</span><span class="normal"> </span>
<span class="normal">  a key extractor object for ordering elements having 64 bit integer keys:</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">struct MyType</span>
<span class="normal">{</span>
<span class="normal">   typedef unsigned long long key_type;</span>
<span class="normal">   key_type _key;</span>
<span class="normal">   char _data</span><span class="optionalargument">[32]</span><span class="normal">;</span>
<span class="normal">   MyType() </span><span class="argument">{}</span>
<span class="normal">   MyType(key_type __key):_key(__key) </span><span class="argument">{}</span>
<span class="normal">};</span>
<span class="normal">struct GetKey</span>
<span class="normal">{</span>
<span class="normal">   typedef MyType::key_type key_type;</span>
<span class="normal">   key_type operator() (const MyType </span><span class="symbol">&amp;</span><span class="normal"> obj)</span>
<span class="normal">   </span><span class="argument">{ return obj._key; }</span>
<span class="normal">   MyType min_value() const </span>
<span class="normal">   </span><span class="argument">{ return MyType(</span>
<span class="argument">        (std::numeric_limits&lt;key_type&gt;::min)()); }</span>
<span class="normal">   MyType max_value() const </span>
<span class="normal">   </span><span class="argument">{ return MyType(</span>
<span class="argument">        (std::numeric_limits&lt;key_type&gt;::max)()); }</span>
<span class="normal">};</span>
<span class="normal"> </span><span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="normal"> Note, that according to the </span><span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">requirements </span><span class="keyword">\texttt</span><span class="fixed">{min\_value}</span>
<span class="normal">and </span><span class="keyword">\texttt</span><span class="fixed">{max\_value}</span><span class="normal"> </span><span class="argument">{\bf can not}</span><span class="normal"> be present in the input</span>
<span class="normal">sequence.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator\_}</span><span class="normal">'s value type is convertible to</span>
<span class="keyword">\texttt</span><span class="fixed">{KeyExtractor\_}</span><span class="normal">'s argument type.</span>

<span class="keyword">\item</span><span class="normal">  </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator\_}</span><span class="normal">'s value type has a typedef</span>
<span class="keyword">\texttt</span><span class="fixed">{key\_type}</span><span class="normal">. </span>

<span class="keyword">\item</span><span class="normal"> For the first version of </span><span class="keyword">\xksort</span><span class="symbol">\ </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator\_}</span><span class="normal">'s value</span>
<span class="normal">type  must have the </span><span class="keyword">\texttt</span><span class="fixed">{key()}</span><span class="normal"> function that returns the key value</span>
<span class="normal">of the element, and the </span><span class="keyword">\texttt</span><span class="fixed">{min\_value()}</span><span class="normal"> and </span><span class="keyword">\texttt</span><span class="fixed">{max\_value()}</span>
<span class="normal">member functions that return minimum and maximum element values</span>
<span class="normal">respectively. Example:</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">struct MyType</span>
<span class="normal">{</span>
<span class="normal">   typedef unsigned long long key_type;</span>
<span class="normal">   key_type _key;</span>
<span class="normal">   char _data</span><span class="optionalargument">[32]</span><span class="normal">;</span>
<span class="normal">   MyType() </span><span class="argument">{}</span>
<span class="normal">   MyType(key_type __key):_key(__key) </span><span class="argument">{}</span>
<span class="normal">   key_type key() </span><span class="argument">{ return _key; }</span>
<span class="normal">   MyType min_value() const </span>
<span class="normal">   </span><span class="argument">{ return MyType(</span>
<span class="argument">        (std::numeric_limits&lt;key_type&gt;::min)()); }</span>
<span class="normal">   MyType max_value() const </span>
<span class="normal">   </span><span class="argument">{ return MyType(</span>
<span class="argument">        (std::numeric_limits&lt;key_type&gt;::max)()); }</span>
<span class="normal">};</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="keyword">\end</span><span class="argument">{itemize}</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Preconditions}</span>
<span class="normal">The same as for </span><span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">(section</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{sortpreconditions}</span><span class="normal">).</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Complexity}</span>
<span class="normal">The same as for </span><span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">(Section</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{sortcomplexity}</span><span class="normal">).</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Internal Memory Consumption}</span>
<span class="normal">The same as for </span><span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">(Section</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{sortimem}</span><span class="normal">)</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{External Memory Consumption}</span>
<span class="normal">The same as for </span><span class="keyword">\xsort</span><span class="symbol">\ </span><span class="normal">(Section</span><span class="symbol">~</span><span class="keyword">\ref</span><span class="argument">{sortemem}</span><span class="normal">).</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Example}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">struct MyType</span>
<span class="normal">{</span>
<span class="normal">   typedef unsigned long long key_type;</span>
<span class="normal">   key_type _key;</span>
<span class="normal">   char _data</span><span class="optionalargument">[32]</span><span class="normal">;</span>
<span class="normal">   MyType() </span><span class="argument">{}</span>
<span class="normal">   MyType(key_type __key):_key(__key) </span><span class="argument">{}</span>
<span class="normal">   key_type key() </span><span class="argument">{ return obj._key; }</span>
<span class="normal">   static MyType min_value() const </span>
<span class="normal">   </span><span class="argument">{ return MyType(</span>
<span class="argument">        (std::numeric_limits&lt;key_type&gt;::min)()); }</span>
<span class="normal">   static MyType max_value() const </span>
<span class="normal">   </span><span class="argument">{ return MyType(</span>
<span class="argument">        (std::numeric_limits&lt;key_type&gt;::max)()); }</span>
<span class="normal">};</span>

<span class="normal">typedef stxxl::VECTOR_GENERATOR&lt;MyType&gt;::result vec_type;</span>

<span class="normal">vec_type V;</span>
<span class="normal">// ... fill here the vector with some values</span>

<span class="normal">/</span><span class="symbol">*</span>
<span class="normal">   Sort in ascending order</span>
<span class="normal">   use 512 MiB of main memory</span>
<span class="symbol">*</span><span class="normal">/</span>
<span class="normal">stxxl::ksort(V.begin(),V.end(),512</span><span class="symbol">*</span><span class="normal">1024</span><span class="symbol">*</span><span class="normal">1024);</span>
<span class="normal">// sorted</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>


<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="keyword">\section</span><span class="argument">{Other \stxxl Algorithms}</span>
<span class="keyword">\label</span><span class="argument">{otheralgs}</span>

<span class="keyword">\stxxl</span><span class="normal"> offers several specializations of STL algorithms for </span><span class="keyword">\xvector</span><span class="symbol">\ </span>
<span class="normal">iterators. The algorithms while accessing the elements bypass the</span>
<span class="normal">vector's cache and access the vector's blocks directly. Another</span>
<span class="normal">improvement is that algorithms from this chapter are able to overlap</span>
<span class="normal">I/O and computation. With standard STL algorithms the overlapping is</span>
<span class="normal">not possible. </span>
<span class="normal">This measures save constant factors both in I/O volume and internal</span>
<span class="normal">work. </span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5</span>
<span class="keyword">\subsection</span><span class="argument">{\texttt{stxxl::generate}}</span>
<span class="keyword">\label</span><span class="argument">{stxxl::generate}</span>
<span class="normal">The semantics of the algorithm is equivalent to the STL</span>
<span class="keyword">\texttt</span><span class="fixed">{std::generate}</span><span class="normal">. </span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Prototype}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">template&lt;typename ExtIterator, typename Generator&gt;</span>
<span class="normal">void generate ( ExtIterator first,</span>
<span class="normal">                ExtIterator last,</span>
<span class="normal">                Generator gen,</span>
<span class="normal">                int nbuffers</span>
<span class="normal">              ) </span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Description}</span>
<span class="normal">Generate assigns the result of invoking </span><span class="keyword">\texttt</span><span class="fixed">{gen}</span><span class="normal">, a function</span>
<span class="normal">object that </span>
<span class="normal">takes no arguments, to each element in the range [first, last). To</span>
<span class="normal">overlap I/O and computation </span><span class="keyword">\texttt</span><span class="fixed">{nbuffers}</span><span class="normal"> are used (a value at</span>
<span class="normal">least </span><span class="math">$D$</span><span class="normal"> is recommended). The size of</span>
<span class="normal">the buffers is derived from the container that is pointed by the</span>
<span class="normal">iterators. </span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Requirements on types}</span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator}</span><span class="normal"> is a model of External Random Access</span>
<span class="normal">Iterator.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator}</span><span class="normal"> is mutable.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{Generator}</span><span class="normal"> is a model of STL Generator.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{Generator}</span><span class="normal">'s result type is convertible to</span>
<span class="keyword">\texttt</span><span class="fixed">{ExtIterator}</span><span class="normal">'s </span>
<span class="normal">value type.</span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Preconditions}</span>
<span class="normal">[first, last) is a valid range.</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Complexity}</span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> Internal work is linear.</span>
<span class="keyword">\item</span><span class="normal"> External work: close to </span><span class="math">$N/DB$</span><span class="normal"> I/Os (write-only).</span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Example}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">// Fill a vector with random numbers, using the </span>
<span class="normal">// standard C library function rand.</span>
<span class="normal">typedef stxxl::VECTOR_GENERATOR&lt;int&gt;::result vector_type;</span>
<span class="normal">vector_type V(some_size);</span>
<span class="normal">// use 20 buffer blocks</span>
<span class="normal">stxxl::generate(V.begin(), V.end(), rand, 20);</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5</span>
<span class="keyword">\newcommand</span><span class="argument">{\xforeach}{{\texttt{stxxl::for\_each}}}</span>
<span class="keyword">\subsection</span><span class="argument">{\xforeach}</span>
<span class="normal">The semantics of the algorithm is equivalent to the STL</span>
<span class="keyword">\texttt</span><span class="fixed">{std::for\_each}</span><span class="normal">. </span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Prototype}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">template&lt;typename ExtIterator, typename UnaryFunction&gt;</span>
<span class="normal">UnaryFunction for_each ( ExtIterator   first,</span>
<span class="normal">                         ExtIterator   last,</span>
<span class="normal">                         UnaryFunction f,</span>
<span class="normal">                         int nbuffers</span>
<span class="normal">                       )        </span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Description}</span>
<span class="keyword">\xforeach</span><span class="symbol">\ </span><span class="normal">applies the function object </span><span class="keyword">\texttt</span><span class="fixed">{f}</span><span class="normal"> to each element in the range</span>
<span class="normal">[first, last); </span><span class="keyword">\texttt</span><span class="fixed">{f}</span><span class="normal">'s return value, if any, is</span>
<span class="normal">ignored. Applications are </span>
<span class="normal">performed in forward order, i.e.</span><span class="symbol">\ </span><span class="normal">from first to last. </span><span class="keyword">\xforeach</span><span class="symbol">\ </span><span class="normal">returns</span>
<span class="normal">the function object after it has been applied to each element. </span>
<span class="normal"> To</span>
<span class="normal">overlap I/O and computation </span><span class="keyword">\texttt</span><span class="fixed">{nbuffers}</span><span class="normal"> are used (a value at</span>
<span class="normal">least </span><span class="math">$D$</span><span class="normal"> is recommended). The size of</span>
<span class="normal">the buffers is derived from the container that is pointed by the</span>
<span class="normal">iterators. </span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Requirements on types}</span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator}</span><span class="normal"> is a model of External Random Access</span>
<span class="normal">Iterator.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{UnaryFunction}</span><span class="normal"> is a model of STL Unary Function.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{UnaryFunction}</span><span class="normal"> does not apply any non-constant</span>
<span class="normal">operations through its argument.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator}</span><span class="normal">'s value type is convertible to</span>
<span class="keyword">\texttt</span><span class="fixed">{UnaryFunction}</span><span class="normal">'s argument type.</span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Preconditions}</span>
<span class="normal">[first, last) is a valid range.</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Complexity}</span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> Internal work is linear.</span>
<span class="keyword">\item</span><span class="normal"> External work: close to </span><span class="math">$N/DB$</span><span class="normal"> I/Os (read-only).</span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Example}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">template&lt;class T&gt; struct print : </span>
<span class="normal">     public unary_function&lt;T, void&gt;</span>
<span class="normal">{</span>
<span class="normal">  print(ostream</span><span class="symbol">&amp;</span><span class="normal"> out) : os(out), count(0) </span><span class="argument">{}</span>
<span class="normal">  void operator() (T x) </span><span class="argument">{ os &lt;&lt; x &lt;&lt; ' '; ++count; }</span>
<span class="normal">  ostream</span><span class="symbol">&amp;</span><span class="normal"> os;</span>
<span class="normal">  int count;</span>
<span class="normal">};</span>
<span class="normal">typedef stxxl::VECTOR_GENERATOR&lt;int&gt;::result vector_type;</span>
<span class="normal">int main()</span>
<span class="normal">{</span>
<span class="normal">  vector_type A(N);</span>
<span class="normal">  // fill A with some values</span>
<span class="normal">  // ...  </span>

<span class="normal">  print&lt;int&gt; P = stxxl::for_each(A.begin(), A.end(), </span>
<span class="normal">                          print&lt;int&gt;(cout));</span>
<span class="normal">  cout &lt;&lt; endl &lt;&lt; P.count &lt;&lt; </span><span class="string">" objects printed."</span><span class="normal"> &lt;&lt; endl;</span>
<span class="normal">}</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="keyword">\newcommand</span><span class="argument">{\xforeachm}{{\texttt{stxxl::for\_each\_m}}}</span>
<span class="keyword">\subsection</span><span class="argument">{\xforeachm}</span>
<span class="keyword">\xforeachm</span><span class="symbol">\ </span><span class="normal">is a </span><span class="keyword">\emph</span><span class="argument">{mutating}</span><span class="normal"> version of </span><span class="keyword">\xforeach</span><span class="normal">, i.e.</span><span class="symbol">\ </span>
<span class="normal">the restriction that Unary Function f can not apply any non-constant</span>
<span class="normal">operations through its argument does not exist.</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Prototype}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">template&lt;typename ExtIterator, typename UnaryFunction&gt;</span>
<span class="normal">UnaryFunction for_each ( ExtIterator   first,</span>
<span class="normal">                         ExtIterator   last,</span>
<span class="normal">                         UnaryFunction f,</span>
<span class="normal">                         int nbuffers</span>
<span class="normal">                       )        </span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Description}</span>
<span class="keyword">\xforeach</span><span class="symbol">\ </span><span class="normal">applies the function object </span><span class="keyword">\texttt</span><span class="fixed">{f}</span><span class="normal"> to each element in the range</span>
<span class="normal">[first, last); </span><span class="keyword">\texttt</span><span class="fixed">{f}</span><span class="normal">'s return value, if any, is</span>
<span class="normal">ignored. Applications are </span>
<span class="normal">performed in forward order, i.e.</span><span class="symbol">\ </span><span class="normal">from first to last. </span><span class="keyword">\xforeach</span><span class="symbol">\ </span><span class="normal">returns</span>
<span class="normal">the function object after it has been applied to each element. </span>
<span class="normal"> To</span>
<span class="normal">overlap I/O and computation </span><span class="keyword">\texttt</span><span class="fixed">{nbuffers}</span><span class="normal"> are used (a value at</span>
<span class="normal">least </span><span class="math">$2D$</span><span class="normal"> is recommended). The size of</span>
<span class="normal">the buffers is derived from the container that is pointed by the</span>
<span class="normal">iterators. </span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Requirements on types}</span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator}</span><span class="normal"> is a model of External Random Access</span>
<span class="normal">Iterator.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{UnaryFunction}</span><span class="normal"> is a model of STL Unary Function.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator}</span><span class="normal">'s value type is convertible to</span>
<span class="keyword">\texttt</span><span class="fixed">{UnaryFunction}</span><span class="normal">'s argument type.</span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Preconditions}</span>
<span class="normal">[first, last) is a valid range.</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Complexity}</span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> Internal work is linear.</span>
<span class="keyword">\item</span><span class="normal"> External work: close to </span><span class="math">$2N/DB$</span><span class="normal"> I/Os (read and write).</span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Example}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">struct AddX</span>
<span class="normal">{</span>
<span class="normal">  int x;</span>
<span class="normal">  AddX(int x_): x(x_) </span><span class="argument">{}</span>
<span class="normal">  void operator() (int </span><span class="symbol">&amp;</span><span class="normal"> val)</span>
<span class="normal">  </span><span class="argument">{ val += x; }</span>
<span class="normal">};</span>

<span class="normal">typedef stxxl::VECTOR_GENERATOR&lt;int&gt;::result vector_type;</span>
<span class="normal">int main()</span>
<span class="normal">{</span>
<span class="normal">  vector_type A(N);</span>
<span class="normal">  // fill A with some values</span>
<span class="normal">  // ...  </span>

<span class="normal">  // Add 5 to each value in the vector</span>
<span class="normal">  stxxl::for_each(A.begin(), A.end(), AddX(5));</span>
<span class="normal">}</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5</span>
<span class="keyword">\subsection</span><span class="argument">{\texttt{stxxl::find}}</span>
<span class="keyword">\label</span><span class="argument">{stxxl::find}</span>
<span class="normal">The semantics of the algorithm is equivalent to the STL</span>
<span class="keyword">\texttt</span><span class="fixed">{std::find}</span><span class="normal">.</span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Prototype}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">template&lt; typename ExtIterator, </span>
<span class="normal">          typename EqualityComparable&gt;</span>
<span class="normal">ExtIterator find ( ExtIterator                first,</span>
<span class="normal">                   ExtIterator                last,</span>
<span class="normal">                   const EqualityComparable </span><span class="symbol">&amp;</span><span class="normal"> value,</span>
<span class="normal">                   int                        nbuffers</span>
<span class="normal">                 )  </span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Description}</span>
<span class="normal">Returns the first iterator </span><span class="keyword">\texttt</span><span class="fixed">{i}</span><span class="normal"> in the range [first, last) such</span>
<span class="normal">that </span><span class="keyword">\texttt</span><span class="fixed">{*i == value}</span><span class="normal">. Returns last if no such iterator exists.  </span>
<span class="normal">To</span>
<span class="normal">overlap I/O and computation </span><span class="keyword">\texttt</span><span class="fixed">{nbuffers}</span><span class="normal"> are used (a value at</span>
<span class="normal">least </span><span class="math">$D$</span><span class="normal"> is recommended). The size of</span>
<span class="normal">the buffers is derived from the container that is pointed by the</span>
<span class="normal">iterators. </span>

<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Requirements on types}</span>
<span class="keyword">\begin</span><span class="argument">{enumerate}</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{EqualityComparable}</span><span class="normal"> is a model of STL EqualityComparable</span>
<span class="normal">concept.</span>
<span class="keyword">\item</span><span class="normal"> </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator}</span><span class="normal"> is a model of External Random Access</span>
<span class="normal">Iterator. </span>
<span class="keyword">\item</span><span class="normal"> Equality is defined between objects  of type</span>
<span class="keyword">\texttt</span><span class="fixed">{EqualityComparable}</span><span class="normal"> and objects of </span><span class="keyword">\texttt</span><span class="fixed">{ExtIterator}</span><span class="normal">'s</span>
<span class="normal">value type.</span>
<span class="keyword">\end</span><span class="argument">{enumerate}</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Preconditions}</span>
<span class="normal">[first, last) is a valid range.</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Complexity}</span>
<span class="keyword">\begin</span><span class="argument">{itemize}</span>
<span class="keyword">\item</span><span class="normal"> Internal work is linear.</span>
<span class="keyword">\item</span><span class="normal"> External work: close to </span><span class="math">$N/DB$</span><span class="normal"> I/Os (read-only).</span>
<span class="keyword">\end</span><span class="argument">{itemize}</span>
<span class="keyword">\subsection</span><span class="symbol">*</span><span class="argument">{Example}</span>
<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>
<span class="normal">typedef stxxl::VECTOR_GENERATOR&lt;int&gt;::result vector_type;</span>

<span class="normal">vector_type V;</span>
<span class="normal">// fill the vector</span>


<span class="normal">// find 7 in V</span>
<span class="normal">vector_type::iterator result = find(V.begin(), V.end(), 7);</span>
<span class="normal">if(result != V.end())</span>
<span class="normal"> std::cout &lt;&lt; </span><span class="string">``Found at position ''</span><span class="normal">&lt;&lt; </span>
<span class="normal">      (result - V.begin()) &lt;&lt; std::endl;</span>
<span class="normal">else</span>
<span class="normal"> std::cout &lt;&lt; </span><span class="string">``Not found''</span><span class="normal"> &lt;&lt; std::endl;</span>
<span class="keyword">\end</span><span class="argument">{lstlisting}</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="keyword">\chapter</span><span class="argument">{Pipelined/Stream Interfaces}</span>


<span class="comment">%data flow graph, file, sorting, streaming nodes\\</span>
<span class="comment">%compare with TPIE AMI\_scan</span>


<span class="keyword">\section</span><span class="argument">{Preliminaries}</span>
<span class="keyword">\section</span><span class="argument">{Node Interface}</span>
<span class="keyword">\section</span><span class="argument">{Scheduling}</span>
<span class="keyword">\section</span><span class="argument">{File Nodes -- {\tt streamify} and {\tt materialize}}</span>
<span class="keyword">\section</span><span class="argument">{Streaming Nodes}</span>
<span class="keyword">\section</span><span class="argument">{Sorting Nodes}</span>
<span class="keyword">\label</span><span class="argument">{pipesorting}</span>
<span class="keyword">\subsection</span><span class="argument">{Runs Creator -- {\tt stxxl::stream::runs\_creator}}</span>
<span class="keyword">\subsection</span><span class="argument">{Specializations of {\tt stxxl::stream::runs\_creator}}</span>
<span class="keyword">\subsection</span><span class="argument">{Runs Merger --  {\tt stxxl::stream::runs\_merger}}</span>
<span class="keyword">\subsection</span><span class="argument">{A Combination: {\tt stxxl::stream::sort}}</span>

<span class="keyword">\section</span><span class="argument">{A Pipelined Version of the Billing Application}</span>

<span class="keyword">\begin</span><span class="argument">{lstlisting}</span>

<span class="keyword">\end</span><span class="argument">{lstlisting}</span>

<span class="keyword">\chapter</span><span class="argument">{Internals}</span>
<span class="keyword">\section</span><span class="argument">{Block Management Layer}</span>

<span class="keyword">\subsection</span><span class="argument">{\texttt{stxxl::prefetch\_pool}}</span>
<span class="keyword">\label</span><span class="argument">{prefetchpoolsection}</span>
<span class="keyword">\subsection</span><span class="argument">{\texttt{stxxl::write\_pool}}</span>
<span class="keyword">\label</span><span class="argument">{writepoolsection}</span>

<span class="keyword">\section</span><span class="argument">{I/O Primitives Layer}</span>
<span class="keyword">\section</span><span class="argument">{Utilities}</span>


<span class="keyword">\chapter</span><span class="argument">{Miscellaneous}</span>
<span class="keyword">\section</span><span class="argument">{\stxxl Compile Flags}</span>

<span class="keyword">\bibliographystyle</span><span class="argument">{plain}</span><span class="normal"> </span><span class="keyword">\bibliography</span><span class="argument">{tutorial}</span>

<span class="keyword">\end</span><span class="argument">{document}</span>
</tt></pre></div><footer><div style="text-align: right; padding: 8pt; font-size: 13px"><a href="/xmlfeed/weblog-rss20.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABQAAAADwCexKkxAAAAWUlEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMCt0ZdTU/F/7/+1HEkydFpoKVPn+93sUlUujQvP/7UcRTAuNDJ2a//s/imDqtKVZofm/1qGYSZk7sfodGwAAiobBJtffoNAAAAAASUVORK5CYII=" alt="RSS 2.0 Weblog Feed" width="80" height="15"/></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAAaklEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMDV16rTQ/H/7V//69+//v/3/9oMEI6cuAwr+fv/+/b5d///v//0eJBgWOhMo+Gs9UPAdXDBy6lSYyn9wQZCZS0GCYDPXQcykzJ1Y/Y4NAABKvL80wyoMPgAAAABJRU5ErkJggg==" alt="Atom 1.0 Weblog Feed" width="80" height="15"/></a> <a href="http://validator.w3.org/check?uri=referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABKklEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6qIGzIRiKZs9GFoEaMRuZhhrYqqJXy8uZYauRxC/VHew7e3YTPAxnI5swG6JxNrKBNjB1EFmIgV0+HA6C8pqqzhXG7BbJJROQIwViMYQ7G2oDQQNn57JyG7kxiCfObrBmS5+BHMuYLkTzMnYDm5WY4lOZZRPKZocxes+aPbuwCFsYohiICLvZsKBAMrDTQ7K/StveU8icTzrOL8JdLpOyWJ49u8Bx9ozw8DY7UYW03hhdxZAOSg2c3jN79rSJs1vSKmfOnpFXNJmynELlvExlAADnaZpLFGEC2wAAAABJRU5ErkJggg==" alt="Valid XHTML 1.1" width="80" height="15"/></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABEUlEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6mIEQCsIjwhKoga0qerW8nBm2Gkn8Ut3BvrNnN8HCcDYM2cBIogzs8uFwEJTXVHWuMGa3SC6ZgIgUqCEwdxJr4OxcVm4jNwbxxNkN1mzpM2ajGIjsPGK9PLtZiSk+lVk2oWx2GKP3rNmzC4tQwpDoIIQb2Okh2V+lbe8pZM4nHecX4S6XSVksz55d4Dh7Rnh4m52oQlpvjK5iSAelBk7vmT172sTZLWmVM2fPyCuaTFlOoXJepjIAANlljDGY/l5pAAAAAElFTkSuQmCC" alt="Valid CSS (2.1)" width="80" height="15"/></a><br/>Copyright 2005-2020 <a href="/about/">Timo Bingmann</a> - <a href="/about/impressum.html">Impressum</a></div></footer></body></html>