<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=iso-8859-1" http-equiv="content-type" /><title>/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/src/external/esais.h - panthema.net</title><link rel="stylesheet" type="text/css" href="/css/base.css" /><link rel="stylesheet" type="text/css" href="/css/fonts.css" /><link rel="alternate" type="application/rss+xml" title="panthema.net Weblog Feed RSS 2.0" href="http://panthema.net/xmlfeed/weblog-rss20.xml" /><link rel="alternate" type="application/atom+xml" title="panthema.net Weblog Feed Atom 1.0" href="http://panthema.net/xmlfeed/weblog-atom10.xml" /><script type="text/javascript" src="/js/base.js"></script><script type="text/javascript">/* <!-- */makeIEHover = function() {var lis = document.getElementById('ptnav').getElementsByTagName('li');for (var i = 0; i < lis.length; i++) {lis[i].onmouseover = function() {this.className += ' sfhover';};lis[i].onmouseout = function() {this.className = this.className.replace(new RegExp(' sfhover\b'), '');};}};if (window.attachEvent) window.attachEvent('onload', makeIEHover);/* --> */</script></head><body style="background-image: url(/img/bgfractal4.jpg)"><div class="pttopbar"><div style="float: right"><ul id="ptnav"><li class="top"><a class="ni" href="/"><i class="icon-book"></i> Weblog</a><ul style="margin-left: -6px; margin-top: 4px" class="nx"><li><a href="/2015/">2015</a></li><li><a href="/2014/">2014</a></li><li><a href="/2013/">2013</a></li><li><a href="/2012/">2012</a></li><li><a href="/2011/">2011</a></li><li><a href="/2010/">2010</a></li><li><a href="/2009/">2009</a></li><li><a href="/2008/">2008</a></li><li><a href="/2007/">2007</a></li><li><a href="/2006/">2006</a></li><li class="nt"><a href="/2005/">2005</a></li><li class="ns"><a href="/xmlfeed/weblog-rss20.xml">RSS Feed</a></li><li class="nt"><a href="/xmlfeed/weblog-atom10.xml">XML Atom</a></li><li class="ns"><a href="/search.html">Search</a></li></ul></li><li class="top"><a class="ni" href="/tags/"><i class="icon-tags"></i> Tags</a><div style="width: 14em; margin-left: -9em; margin-top: 4px"><a style="font-size: 10pt" href="/tags/algebra.html">algebra</a> <a style="font-size: 16pt" href="/tags/c++.html">c++</a> <a style="font-size: 12pt" href="/tags/code-example.html">code-example</a> <a style="font-size: 14pt" href="/tags/code-snippet.html">code-snippet</a> <a style="font-size: 11pt" href="/tags/coding_tricks.html">coding tricks</a> <a style="font-size: 10pt" href="/tags/compsci.html">compsci</a> <a style="font-size: 10pt" href="/tags/compsci_study_thesis.html">compsci study thesis</a> <a style="font-size: 9pt" href="/tags/crypto-speedtest.html">crypto-speedtest</a> <a style="font-size: 10pt" href="/tags/cryptography.html">cryptography</a> <a style="font-size: 9pt" href="/tags/cryptote.html">cryptote</a> <a style="font-size: 12pt" href="/tags/flex-bison-cpp-example.html">flex-bison-cpp-example</a> <a style="font-size: 15pt" href="/tags/frontpage.html">frontpage</a> <a style="font-size: 14pt" href="/tags/fun.html">fun</a> <a style="font-size: 10pt" href="/tags/graphviz.html">graphviz</a> <a style="font-size: 9pt" href="http://www.hmtg.de">hartmetall</a> <a style="font-size: 9pt" href="/tags/helppc.html">helppc</a> <a style="font-size: 9pt" href="/tags/hifi_selbstbau.html">hifi selbstbau</a> <a style="font-size: 10pt" href="/tags/latex.html">latex</a> <a style="font-size: 10pt" href="/tags/librivox.html">librivox</a> <a style="font-size: 10pt" href="/tags/linux.html">linux</a> <a style="font-size: 9pt" href="/tags/massive-sorting.html">massive-sorting</a> <a style="font-size: 10pt" href="/tags/maths.html">maths</a> <a style="font-size: 9pt" href="/tags/music.html">music</a> <a style="font-size: 10pt" href="/tags/netfundamentals.html">netfundamentals</a> <a style="font-size: 11pt" href="/tags/ns-3.html">ns-3</a> <a style="font-size: 10pt" href="/tags/parallel-string-sorting.html">parallel-string-sorting</a> <a style="font-size: 9pt" href="/tags/qtsqlview.html">qtsqlview</a> <a style="font-size: 12pt" href="/tags/research.html">research</a> <a style="font-size: 11pt" href="/tags/sdios06.html">sdios06</a> <a style="font-size: 9pt" href="/tags/sdlfractal.html">sdlfractal</a> <a style="font-size: 13pt" href="/tags/sorting.html">sorting</a> <a style="font-size: 10pt" href="/tags/stringology.html">stringology</a> <a style="font-size: 16pt" href="/tags/stx-btree.html">stx-btree</a> <a style="font-size: 9pt" href="/tags/stx-exparser.html">stx-exparser</a> <a style="font-size: 13pt" href="/tags/stxxl.html">stxxl</a> <a style="font-size: 16pt" href="/tags/talk.html">talk</a> <a style="font-size: 10pt" href="/tags/tutorium.html">tutorium</a> <a style="font-size: 16pt" href="/tags/university.html">university</a> <a style="font-size: 13pt" href="/tags/utilities.html">utilities</a> <a style="font-size: 10pt" href="/tags/vncrec.html">vncrec</a> <a style="font-size: 9pt" href="/tags/webdesign.html">webdesign</a> </div></li><li class="top"> <a class="ni" href="#"><i class="icon-cubes"></i> Projects</a> <ul style="margin-left: -8em; margin-top: 4px;" class="nx"> <li><a href="/2009/cryptote/">CryptoTE</a></li> <li><a href="/2009/digup/">digup</a></li> <li><a href="/2013/disk-filltest/">disk-filltest</a></li> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP</a></li> <li><a href="/2007/flex-bison-cpp-example/">Flex Bison C++ Example</a></li> <li><a href="/2013/malloc_count/">malloc_count</a></li> <li><a href="/2013/parallel-string-sorting/">parallel-string-sorting</a></li> <li><a href="/2013/pmbw/">Parallel Memory Bandwidth</a></li> <li><a href="/2014/sqlplot-tools/">SqlPlotTools</a></li> <li><a href="/2013/sound-of-sorting/">The Sound of Sorting</a></li> <li><a href="/2007/stx-btree/">STX B+ Tree</a></li> <li><a href="/2010/stx-cbtreedb/">STX Constant BTreeDB</a></li> <li><a href="/2010/stx-execpipe/">STX ExecPipe</a></li> <li><a href="/2007/stx-exparser/">STX Expression Parser</a></li> <li><a href="/tags/stxxl.html">STXXL 1.4</a></li> <li class="nt"><a href="/2014/vncrec-rgb/">VNCrec RGB 0.4</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="#"><i class="icon-graduation-cap"></i> Research</a> <ul style="margin-left: -16em; margin-top: 4px" class="nx"> <li><a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">eSAIS-LCP - External Memory Suffix Sorting</a></li> <li><a href="/2013/parallel-string-sorting/">Parallel String Sorting</a></li> <li><a href="/tags/massive-sorting.html">Practical Massively Parallel Sorting</a></li> <li><a href="/tags/stxxl.html">STXXL - External Memory Algorithms</a></li> <li class="ns"><a href="/search.html">Search</a></li> </ul></li><li class="top"> <a class="ni" href="/about/"><i class="icon-info-circled"></i> About</a> <ul style="margin-left: -6em; margin-top: 4px" class="nx"> <li><a href="/about/">Timo Bingmann</a></li> <li><a href="/about/impressum.html">Impressum</a></li> </ul></li><li class="top"> <a class="ni" href="/subscribe.html"><i class="icon-rss-squared"></i> Subscribe</a></li></ul></div><div style="padding: 6px"><a href="/">panthema</a>  / <a href="/2012/">2012</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/">1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/">eSAIS-DC3-LCP-0.5.2</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/src/">src</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/src/external/">external</a> / <a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/src/external/esais.h.html">esais.h</a> (<a href="/2012/1119-eSAIS-Inducing-Suffix-and-LCP-Arrays-in-External-Memory/eSAIS-DC3-LCP-0.5.2/src/external/esais.h">Download File</a>)</div></div><div class="ptfullwidth"><pre class="codesnippet" style="font-family: monospace"><tt><span class="comment">// -*- mode: c++; mode: rebox; fill-column: 110; rebox-min-fill-column: 110 -*-</span>

<span class="comment">/******************************************************************************</span>
<span class="comment"> * src/external/esais.h</span>
<span class="comment"> *</span>
<span class="comment"> * eSAIS main algorithm</span>
<span class="comment"> *</span>
<span class="comment"> * Based on Bingmann, T., Fischer, J., Osipov, V. (2013).</span>
<span class="comment"> * Inducing suffix and LCP arrays in external memory. ALENEX'13.</span>
<span class="comment"> *</span>
<span class="comment"> ******************************************************************************</span>
<span class="comment"> * Copyright (C) 2012-2013 Timo Bingmann </span><span class="url">&lt;tb@panthema.net&gt;</span>
<span class="comment"> *</span>
<span class="comment"> * This program is free software: you can redistribute it and/or modify it</span>
<span class="comment"> * under the terms of the GNU General Public License as published by the Free</span>
<span class="comment"> * Software Foundation, either version 3 of the License, or (at your option)</span>
<span class="comment"> * any later version.</span>
<span class="comment"> *</span>
<span class="comment"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="comment"> * more details.</span>
<span class="comment"> *</span>
<span class="comment"> * You should have received a copy of the GNU General Public License along with</span>
<span class="comment"> * this program.  If not, see </span><span class="url">&lt;http://www.gnu.org/licenses/&gt;</span><span class="comment">.</span>
<span class="comment"> *****************************************************************************/</span>

<span class="keyword">namespace</span><span class="normal"> esais</span>
<span class="cbracket">{</span>
<span class="comment">/*************************************************************************************************************</span>
<span class="comment"> * Compilation Options                                                                                       *</span>
<span class="comment"> *************************************************************************************************************/</span>

<span class="comment">// run self-verifying parts of the code, very slow!</span>
<span class="preproc">#define</span><span class="normal"> ESAIS_SELF_CHECK        </span><span class="number">0</span>

<span class="comment">// enable LCP calculation</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">ESAIS_LCP_CALC</span><span class="normal">          LCP_CALC</span>

<span class="comment">// enable specific LCP calculation method</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="function">defined</span><span class="symbol">(</span><span class="normal">ESAIS_LCP_CALC_EXT</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">defined</span><span class="symbol">(</span><span class="normal">ESAIS_LCP_CALC_INT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> ESAIS_LCP_CALC_EXT      </span><span class="number">0</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">ESAIS_LCP_CALC_INT</span><span class="normal">      LCP_CALC</span>
<span class="preproc">#endif</span>

<span class="comment">// enable discarding of sequences of unique characters</span>
<span class="preproc">#ifndef</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="preproc">#define</span><span class="normal"> ESAIS_DISCARD_UNIQUES   </span><span class="number">0</span>
<span class="preproc">#endif</span>

<span class="comment">// log PQ fill levels to file</span>
<span class="preproc">#define</span><span class="normal"> ESAIS_LOG_PQFILL        </span><span class="number">0</span>

<span class="comment">// log estimate of wasted space in tuples</span>
<span class="preproc">#ifndef</span><span class="normal"> ESAIS_COUNT_WASTED</span>
<span class="preproc">#define</span><span class="normal"> ESAIS_COUNT_WASTED      </span><span class="number">0</span>
<span class="preproc">#endif</span>

<span class="comment">// *******************************************************************************************************</span>
<span class="comment">// *** Debugging Switches</span>

<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>

<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_substring_split </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_substring_decoder </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_substring_merge </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_lexnamepairs </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_rerank </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_recursive_input </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_recursive_output </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_sstarlcp </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_sstarlcp_merge </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_sstarlcp_result </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_sstarlcp_use </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_induce_input </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_induce_split </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_induce_arrays </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_induceL </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_induceL_lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_induceS </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_induceS_lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_output_write </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> debug_output_merge </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>

<span class="comment">/*************************************************************************************************************</span>
<span class="comment"> * Helper Routines                                                                                           *</span>
<span class="comment"> *************************************************************************************************************/</span>

<span class="comment">// {{{ Debug macros</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LOG_PQFILL</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">     </span><span class="keyword">do</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">while</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="preproc">#else</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">     </span><span class="keyword">do</span><span class="normal"> </span><span class="cbracket">{}</span><span class="normal"> </span><span class="keyword">while</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="preproc">#endif</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_COUNT_WASTED</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">   </span><span class="keyword">do</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> g_wasted_iovolume </span><span class="symbol">+=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">);</span><span class="normal"> </span><span class="cbracket">}</span><span class="normal"> </span><span class="keyword">while</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="preproc">#else</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">   </span><span class="keyword">do</span><span class="normal"> </span><span class="cbracket">{}</span><span class="normal"> </span><span class="keyword">while</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="preproc">#endif</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">      x</span>
<span class="preproc">#else</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span>
<span class="preproc">#endif</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ESAIS_LCP_CALCX_INT</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span><span class="normal">      x</span>
<span class="preproc">#else</span>
<span class="preproc">#define</span><span class="normal"> </span><span class="function">ESAIS_LCP_CALCX_INT</span><span class="symbol">(</span><span class="normal">x</span><span class="symbol">)</span>
<span class="preproc">#endif</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_COUNT_WASTED</span>

<span class="comment">/// count wasted io volumne, hacky global variable</span>
<span class="keyword">static</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal">   g_wasted_iovolume </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_COUNT_WASTED</span>

<span class="comment">/// count maximum size of internal memory RMQ structure, hacky global variable</span>
<span class="keyword">static</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal">   g_mainmemlcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">defined</span><span class="symbol">(</span><span class="normal">ESAIS_LCP_CALC_INT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> ESAIS_LCP_CALC_INT      </span><span class="number">0</span>
<span class="preproc">#endif</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">defined</span><span class="symbol">(</span><span class="normal">ESAIS_LCP_CALC_EXT</span><span class="symbol">)</span>
<span class="preproc">#define</span><span class="normal"> ESAIS_LCP_CALC_EXT      </span><span class="number">0</span>
<span class="preproc">#endif</span>

<span class="comment">// }}} Debug macros</span>

<span class="comment">// {{{ Variable stream writing with varints</span>

<span class="comment">//! \brief put some type as bytes at the end of a stream</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Stream</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Type</span><span class="symbol">&gt;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> Stream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">stream_put</span><span class="symbol">(</span><span class="normal">Stream</span><span class="symbol">&amp;</span><span class="normal"> s</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> Type</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="cbracket">{</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">%</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Stream</span><span class="symbol">::</span><span class="normal">block_type</span><span class="symbol">::</span><span class="normal">type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> Stream</span><span class="symbol">::</span><span class="normal">block_type</span><span class="symbol">::</span><span class="normal">size </span><span class="symbol">);</span>

<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> j </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> j </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">Type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Stream</span><span class="symbol">::</span><span class="normal">block_type</span><span class="symbol">::</span><span class="normal">type</span><span class="symbol">);</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">j</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        s </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">((</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Stream</span><span class="symbol">::</span><span class="normal">block_type</span><span class="symbol">::</span><span class="normal">type</span><span class="symbol">*)&amp;</span><span class="normal">t</span><span class="symbol">)[</span><span class="normal">j</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> s</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">//! \brief get some type as bytes from the end of a stream</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Stream</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Type</span><span class="symbol">&gt;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> Stream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">stream_get</span><span class="symbol">(</span><span class="normal">Stream</span><span class="symbol">&amp;</span><span class="normal"> s</span><span class="symbol">,</span><span class="normal"> Type</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="cbracket">{</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">%</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Stream</span><span class="symbol">::</span><span class="normal">block_type</span><span class="symbol">::</span><span class="normal">type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> Stream</span><span class="symbol">::</span><span class="normal">block_type</span><span class="symbol">::</span><span class="normal">size </span><span class="symbol">);</span>

<span class="normal">    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> j </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> j </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">Type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Stream</span><span class="symbol">::</span><span class="normal">block_type</span><span class="symbol">::</span><span class="normal">type</span><span class="symbol">);</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">j</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        s </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">((</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Stream</span><span class="symbol">::</span><span class="normal">block_type</span><span class="symbol">::</span><span class="normal">type</span><span class="symbol">*)&amp;</span><span class="normal">t</span><span class="symbol">)[</span><span class="normal">j</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> s</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">//! \brief return number of bytes needed to encode a varint of given value</span>
<span class="keyword">static</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">sizeof_varint</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> x</span><span class="symbol">)</span>
<span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">128</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">3</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">x </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">4</span><span class="symbol">;</span>
<span class="normal">    </span><span class="function">abort</span><span class="symbol">();</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">//! \brief encode a varint and append it to a stream</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Stream</span><span class="symbol">&gt;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> Stream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">stream_put_varint</span><span class="symbol">(</span><span class="normal">Stream</span><span class="symbol">&amp;</span><span class="normal"> s</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> v</span><span class="symbol">)</span>
<span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">v </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">128</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        s </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">v </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">v </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        s </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">v </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span><span class="normal"> </span><span class="number">0x80</span><span class="symbol">);</span>
<span class="normal">        s </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">v </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">7</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">v </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        s </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">v </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span><span class="normal"> </span><span class="number">0x80</span><span class="symbol">);</span>
<span class="normal">        s </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">v </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">7</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span><span class="normal"> </span><span class="number">0x80</span><span class="symbol">);</span>
<span class="normal">        s </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">v </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">14</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">v </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">*</span><span class="number">128</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        s </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">v </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span><span class="normal"> </span><span class="number">0x80</span><span class="symbol">);</span>
<span class="normal">        s </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">v </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">7</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span><span class="normal"> </span><span class="number">0x80</span><span class="symbol">);</span>
<span class="normal">        s </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">v </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">14</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">|</span><span class="normal"> </span><span class="number">0x80</span><span class="symbol">);</span>
<span class="normal">        s </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">v </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">21</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">abort</span><span class="symbol">();</span><span class="normal"> </span><span class="comment">// enlarge allowed range if ever needed.</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> s</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">//! \brief decode a varint from end of stream</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Stream</span><span class="symbol">&gt;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> Stream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">stream_get_varint</span><span class="symbol">(</span><span class="normal">Stream</span><span class="symbol">&amp;</span><span class="normal"> s</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">&amp;</span><span class="normal"> v</span><span class="symbol">)</span>
<span class="cbracket">{</span>
<span class="normal">    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="normal"> in</span><span class="symbol">;</span>
<span class="normal">    s </span><span class="symbol">&gt;&gt;</span><span class="normal"> in</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">in </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x80</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        v </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">in </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">);</span>

<span class="normal">        s </span><span class="symbol">&gt;&gt;</span><span class="normal"> in</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">in </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x80</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            v </span><span class="symbol">|=</span><span class="normal"> </span><span class="symbol">((</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">)</span><span class="normal">in </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">7</span><span class="symbol">;</span>

<span class="normal">            s </span><span class="symbol">&gt;&gt;</span><span class="normal"> in</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">in </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x80</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                v </span><span class="symbol">|=</span><span class="normal"> </span><span class="symbol">((</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">)</span><span class="normal">in </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">14</span><span class="symbol">;</span>

<span class="normal">                s </span><span class="symbol">&gt;&gt;</span><span class="normal"> in</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">in </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x80</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">abort</span><span class="symbol">();</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    v </span><span class="symbol">|=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">)</span><span class="normal">in </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">21</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                v </span><span class="symbol">|=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">)</span><span class="normal">in </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">14</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            v </span><span class="symbol">|=</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">)</span><span class="normal">in </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="number">7</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">        v </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">in </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0x7F</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> s</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">//! \brief decode a varint from end of stream</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Stream</span><span class="symbol">&gt;</span>
<span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> Stream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">stream_get_varint</span><span class="symbol">(</span><span class="normal">Stream</span><span class="symbol">&amp;</span><span class="normal"> s</span><span class="symbol">,</span><span class="normal"> uint40</span><span class="symbol">&amp;</span><span class="normal"> v</span><span class="symbol">)</span>
<span class="cbracket">{</span>
<span class="normal">    </span><span class="comment">// expand this proc to decode larger varints if ever needed.</span>
<span class="normal">    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> x</span><span class="symbol">;</span>
<span class="normal">    </span><span class="function">stream_get_varint</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">,</span><span class="normal">x</span><span class="symbol">);</span>
<span class="normal">    v </span><span class="symbol">=</span><span class="normal"> x</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">return</span><span class="normal"> s</span><span class="symbol">;</span>
<span class="cbracket">}</span>

<span class="comment">// }}} Variable stream writing with varints</span>

<span class="comment">// {{{ STXXL Extensions</span>

<span class="comment">/**</span>
<span class="comment"> * Creates a stream object that reads from a stxxl::vector from back to front. This class is also an adapter</span>
<span class="comment"> * for the first call to the algorithm; it matches the interface of recursive calls.</span>
<span class="comment"> */</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">class</span><span class="normal"> </span><span class="classname">InputIterator</span><span class="symbol">&gt;</span>
<span class="keyword">class</span><span class="normal"> </span><span class="classname">my_buf_istream_vector_reverse</span>
<span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">InputIterator</span><span class="symbol">::</span><span class="usertype">block_type</span><span class="normal">                   block_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">InputIterator</span><span class="symbol">::</span><span class="usertype">bids_container_iterator</span><span class="normal">      bid_iterator_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">InputIterator</span><span class="symbol">::</span><span class="usertype">bids_container_type</span><span class="normal">          bids_container_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">block_prefetcher&lt;block_type, bid_iterator_type&gt;</span><span class="normal"> prefetcher_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">my_buf_istream_vector_reverse&lt;InputIterator&gt;</span><span class="normal">        Self</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">iterator_traits</span><span class="symbol">&lt;</span><span class="normal">InputIterator</span><span class="symbol">&gt;::</span><span class="usertype">value_type</span><span class="normal"> value_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal">         reference</span><span class="symbol">;</span>

<span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">    </span><span class="comment">/// beginning and end iterators within the vector</span>
<span class="normal">    </span><span class="usertype">InputIterator</span><span class="normal">               begin_</span><span class="symbol">,</span><span class="normal"> current_</span><span class="symbol">,</span><span class="normal"> end_</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// blocks prefetcher</span>
<span class="normal">    prefetcher_type</span><span class="symbol">*</span><span class="normal">            prefetcher_</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// reversed copy of bids from begin to end</span>
<span class="normal">    </span><span class="usertype">bids_container_type</span><span class="normal">         bids_</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// current element and block</span>
<span class="normal">    stxxl</span><span class="symbol">::</span><span class="usertype">int_type</span><span class="normal">             current_elem_</span><span class="symbol">;</span>
<span class="normal">    block_type</span><span class="symbol">*</span><span class="normal">                 current_blk_</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// prefetch sequence calculated</span>
<span class="normal">    stxxl</span><span class="symbol">::</span><span class="normal">int_type</span><span class="symbol">*</span><span class="normal">            prefetch_seq_</span><span class="symbol">;</span>

<span class="normal">    stxxl</span><span class="symbol">::</span><span class="usertype">int_type</span><span class="normal">             nbuffers_</span><span class="symbol">;</span>

<span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">    </span><span class="function">my_buf_istream_vector_reverse</span><span class="symbol">(</span><span class="usertype">InputIterator</span><span class="normal"> begin</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">InputIterator</span><span class="normal"> end</span><span class="symbol">,</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">unsigned_type</span><span class="normal"> nbuffers </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">begin_</span><span class="symbol">(</span><span class="normal">begin</span><span class="symbol">),</span><span class="normal"> </span><span class="function">end_</span><span class="symbol">(</span><span class="normal">end</span><span class="symbol">),</span><span class="normal"> </span><span class="function">bids_</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        begin</span><span class="symbol">.</span><span class="function">flush</span><span class="symbol">();</span><span class="normal">     </span><span class="comment">// flush container</span>

<span class="normal">        </span><span class="comment">// check if end is inside a block or pointer to a non-existing one.</span>
<span class="normal">        </span><span class="usertype">bid_iterator_type</span><span class="normal"> end_iter </span><span class="symbol">=</span><span class="normal"> end</span><span class="symbol">.</span><span class="function">bid</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">end</span><span class="symbol">.</span><span class="function">block_offset</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">end_iter </span><span class="symbol">-</span><span class="normal"> begin</span><span class="symbol">.</span><span class="function">bid</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// copy list of bids in reverse</span>
<span class="normal">            bids_</span><span class="symbol">.</span><span class="function">resize</span><span class="symbol">(</span><span class="normal"> end_iter </span><span class="symbol">-</span><span class="normal"> begin</span><span class="symbol">.</span><span class="function">bid</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="function">reverse_copy</span><span class="symbol">(</span><span class="normal"> begin</span><span class="symbol">.</span><span class="function">bid</span><span class="symbol">(),</span><span class="normal"> end_iter</span><span class="symbol">,</span><span class="normal"> bids_</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// calculate prefetch sequence</span>
<span class="normal">            </span><span class="keyword">const</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">unsigned_type</span><span class="normal"> ndisks </span><span class="symbol">=</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="normal">config</span><span class="symbol">::</span><span class="function">get_instance</span><span class="symbol">()-&gt;</span><span class="function">disks_number</span><span class="symbol">();</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">nbuffers </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> nbuffers </span><span class="symbol">=</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> ndisks</span><span class="symbol">;</span>

<span class="normal">            prefetch_seq_ </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="normal">int_type</span><span class="symbol">[</span><span class="normal">bids_</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()];</span>

<span class="normal">            nbuffers_ </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">max</span><span class="symbol">(</span><span class="number">2</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> ndisks</span><span class="symbol">,</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="function">unsigned_type</span><span class="symbol">(</span><span class="normal">nbuffers </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">));</span>
<span class="normal">            stxxl</span><span class="symbol">::</span><span class="function">compute_prefetch_schedule</span><span class="symbol">(</span><span class="normal">bids_</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> bids_</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> prefetch_seq_</span><span class="symbol">,</span><span class="normal"> nbuffers_</span><span class="symbol">,</span><span class="normal"> ndisks</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// create stream prefetcher</span>
<span class="normal">            prefetcher_ </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">prefetcher_type</span><span class="symbol">(</span><span class="normal">bids_</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> bids_</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> prefetch_seq_</span><span class="symbol">,</span><span class="normal"> nbuffers_</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// fetch block: last in sequence</span>
<span class="normal">            current_blk_ </span><span class="symbol">=</span><span class="normal"> prefetcher_</span><span class="symbol">-&gt;</span><span class="function">pull_block</span><span class="symbol">();</span>
<span class="normal">            current_elem_ </span><span class="symbol">=</span><span class="normal"> block_type</span><span class="symbol">::</span><span class="normal">size</span><span class="symbol">;</span>

<span class="normal">            </span><span class="comment">// skip to beginning of reverse sequence.</span>
<span class="normal">            stxxl</span><span class="symbol">::</span><span class="usertype">int_type</span><span class="normal"> cur </span><span class="symbol">=</span><span class="normal"> end</span><span class="symbol">.</span><span class="function">block_offset</span><span class="symbol">();</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">cur </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> cur </span><span class="symbol">=</span><span class="normal"> block_type</span><span class="symbol">::</span><span class="normal">size</span><span class="symbol">;</span>

<span class="normal">            </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> current_elem_ </span><span class="symbol">!=</span><span class="normal"> cur </span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">operator</span><span class="symbol">--();</span>

<span class="normal">            </span><span class="keyword">operator</span><span class="symbol">--();</span><span class="normal">       </span><span class="comment">// move one position before end</span>

<span class="normal">            current_ </span><span class="symbol">=</span><span class="normal"> end</span><span class="symbol">;</span><span class="normal">     </span><span class="comment">// reset iteration range</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Frees used internal objects</span>
<span class="normal">    </span><span class="keyword">virtual</span><span class="normal"> </span><span class="symbol">~</span><span class="function">my_buf_istream_vector_reverse</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">delete</span><span class="normal"> prefetcher_</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">delete</span><span class="symbol">[]</span><span class="normal"> prefetch_seq_</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Returns reference to the current record in the stream</span>
<span class="normal">    </span><span class="comment">//! \return reference to the current record in the stream</span>
<span class="normal">    </span><span class="usertype">reference</span><span class="normal"> </span><span class="function">current</span><span class="symbol">()</span><span class="normal">     </span><span class="comment">/* const */</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> current_blk_</span><span class="symbol">-&gt;</span><span class="normal">elem</span><span class="symbol">[</span><span class="normal">current_elem_</span><span class="symbol">];</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Returns reference to the current record in the stream</span>
<span class="normal">    </span><span class="comment">//! \return reference to the current record in the stream</span>
<span class="normal">    </span><span class="usertype">reference</span><span class="normal"> </span><span class="keyword">operator</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">()</span><span class="normal">     </span><span class="comment">/* const */</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> current_blk_</span><span class="symbol">-&gt;</span><span class="normal">elem</span><span class="symbol">[</span><span class="normal">current_elem_</span><span class="symbol">];</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Moves to the next record in the stream</span>
<span class="normal">    </span><span class="comment">//! \return reference to itself after the advance</span>
<span class="normal">    Self </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="normal"> </span><span class="symbol">--</span><span class="normal"> </span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        current_elem_</span><span class="symbol">--;</span>
<span class="normal">        current_</span><span class="symbol">--;</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">current_elem_ </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            current_elem_ </span><span class="symbol">=</span><span class="normal"> block_type</span><span class="symbol">::</span><span class="normal">size</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">            </span><span class="type">bool</span><span class="normal"> ok </span><span class="symbol">=</span><span class="normal"> prefetcher_</span><span class="symbol">-&gt;</span><span class="function">block_consumed</span><span class="symbol">(</span><span class="normal">current_blk_</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">ok </span><span class="symbol">||</span><span class="normal"> </span><span class="function">empty</span><span class="symbol">());</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="function">STXXL_UNUSED</span><span class="symbol">(</span><span class="normal">ok</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Standard stream method</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">current_ </span><span class="symbol">==</span><span class="normal"> begin_</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Return remaining size.</span>
<span class="normal">    </span><span class="usertype">size_t</span><span class="normal"> </span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">current_ </span><span class="symbol">-</span><span class="normal"> begin_</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief Rewind stream</span>
<span class="normal">    Self</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">size_t </span><span class="comment">/* mem */</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">delete</span><span class="normal"> prefetcher_</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// recreate stream prefetcher</span>
<span class="normal">        prefetcher_ </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">prefetcher_type</span><span class="symbol">(</span><span class="normal">bids_</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> bids_</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> prefetch_seq_</span><span class="symbol">,</span><span class="normal"> nbuffers_</span><span class="symbol">);</span>

<span class="normal">        </span><span class="comment">// fetch block: last in sequence</span>
<span class="normal">        current_blk_ </span><span class="symbol">=</span><span class="normal"> prefetcher_</span><span class="symbol">-&gt;</span><span class="function">pull_block</span><span class="symbol">();</span>
<span class="normal">        current_elem_ </span><span class="symbol">=</span><span class="normal"> block_type</span><span class="symbol">::</span><span class="normal">size</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// skip to beginning of reverse sequence.</span>
<span class="normal">        stxxl</span><span class="symbol">::</span><span class="usertype">int_type</span><span class="normal"> cur </span><span class="symbol">=</span><span class="normal"> end_</span><span class="symbol">.</span><span class="function">block_offset</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">cur </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> cur </span><span class="symbol">=</span><span class="normal"> block_type</span><span class="symbol">::</span><span class="normal">size</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> current_elem_ </span><span class="symbol">!=</span><span class="normal"> cur </span><span class="symbol">)</span>
<span class="normal">            </span><span class="keyword">operator</span><span class="symbol">--();</span>

<span class="normal">        </span><span class="keyword">operator</span><span class="symbol">--();</span><span class="normal">       </span><span class="comment">// move one position before end</span>

<span class="normal">        current_ </span><span class="symbol">=</span><span class="normal"> end_</span><span class="symbol">;</span><span class="normal">     </span><span class="comment">// reset iteration range</span>

<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">//! \brief deallocate stream reader. noop.</span>
<span class="normal">    Self</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">finish</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">/*************************************************************************************************************</span>
<span class="comment"> * Sorter for Variable Length Objects                                                                        *</span>
<span class="comment"> *************************************************************************************************************/</span>

<span class="comment">/**</span>
<span class="comment"> * The VarlengthSorter implements non-recursive external memory sorting for variable length objects. The</span>
<span class="comment"> * objects are passed by the caller in form of already-sorted runs of sizes theta(M), which are written to</span>
<span class="comment"> * disk. No aggregation of objects is done in this class. Once all runs are written, the sequences can be</span>
<span class="comment"> * streamed back, merged using a tournament tree and outputted in globally sorted order. Each objects is</span>
<span class="comment"> * serialized when written and deserialized when read using it's enclosed .serialize(stream) and</span>
<span class="comment"> * .deserialize(stream) methods.</span>
<span class="comment"> */</span>
<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">ValueType</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> BlockSize</span><span class="symbol">&gt;</span>
<span class="keyword">class</span><span class="normal"> </span><span class="classname">VarlengthSorter</span>
<span class="cbracket">{</span>
<span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">    </span><span class="comment">// *** Template Arguments</span>

<span class="normal">    </span><span class="comment">/// values serialized.</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">ValueType</span><span class="normal">           value_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// block size of written runs</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">int</span><span class="normal"> block_size </span><span class="symbol">=</span><span class="normal"> BlockSize</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// *** Constructed Types</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">STXXL_DEFAULT_ALLOC_STRATEGY</span><span class="normal"> alloc_strategy_type</span><span class="symbol">;</span>
<span class="normal">    </span><span class="usertype">alloc_strategy_type</span><span class="normal">     m_alloc_strategy</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">BID&lt;block_size&gt;</span><span class="normal">   bid_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">vector&lt;bid_type&gt;</span><span class="normal">   bid_vector_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">bid_vector_type</span><span class="symbol">::</span><span class="usertype">iterator</span><span class="normal">   bid_iterator_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// create typed blocks containing characters</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">typed_block&lt;block_size, unsigned char&gt;</span><span class="normal"> block_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// create byte-oriented buffered output streams</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">buf_ostream&lt;block_type, bid_iterator_type&gt;</span><span class="normal">       buf_ostream_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// create byte-oriented buffered input streams</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">buf_istream&lt;block_type, bid_iterator_type&gt;</span><span class="normal">       buf_istream_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// list of input streams, used when merging runs</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">vector&lt;buf_istream_type*&gt;</span><span class="normal">       buf_istream_vector_type</span><span class="symbol">;</span>

<span class="keyword">protected</span><span class="symbol">:</span>

<span class="normal">    </span><span class="comment">/** Functor for tournament tree which feeds the input streams into the loser tree as required by its</span>
<span class="comment">     * interface. */</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">StreamCompare</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        buf_istream_vector_type</span><span class="symbol">&amp;</span><span class="normal">        m_istream_vector</span><span class="symbol">;</span>

<span class="normal">        std</span><span class="symbol">::</span><span class="usertype">vector&lt;value_type&gt;</span><span class="normal">         m_head</span><span class="symbol">;</span>

<span class="normal">        std</span><span class="symbol">::</span><span class="usertype">vector&lt;bool&gt;</span><span class="normal">               m_exists</span><span class="symbol">;</span>

<span class="normal">        </span><span class="function">StreamCompare</span><span class="symbol">(</span><span class="normal">buf_istream_vector_type</span><span class="symbol">&amp;</span><span class="normal"> istream_vector</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">m_istream_vector</span><span class="symbol">(</span><span class="normal">istream_vector</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">resize</span><span class="symbol">()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            m_head</span><span class="symbol">.</span><span class="function">resize</span><span class="symbol">(</span><span class="normal"> m_istream_vector</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            m_exists</span><span class="symbol">.</span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">            m_exists</span><span class="symbol">.</span><span class="function">resize</span><span class="symbol">(</span><span class="normal"> m_istream_vector</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">(),</span><span class="normal"> </span><span class="keyword">true</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">fetch</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> seq</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            buf_istream_type</span><span class="symbol">&amp;</span><span class="normal"> is </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">m_istream_vector</span><span class="symbol">[</span><span class="normal">seq</span><span class="symbol">];</span>

<span class="normal">            m_exists</span><span class="symbol">[</span><span class="normal">seq</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> m_head</span><span class="symbol">[</span><span class="normal">seq</span><span class="symbol">].</span><span class="function">deserialize</span><span class="symbol">(</span><span class="normal"> is </span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">exists</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> seq</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_exists</span><span class="symbol">[</span><span class="normal">seq</span><span class="symbol">];</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> seqa</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> seqb</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="function">exists</span><span class="symbol">(</span><span class="normal">seqa</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">exists</span><span class="symbol">(</span><span class="normal">seqb</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_head</span><span class="symbol">[</span><span class="normal">seqa</span><span class="symbol">].</span><span class="function">cmp</span><span class="symbol">(</span><span class="normal"> m_head</span><span class="symbol">[</span><span class="normal">seqb</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="keyword">protected</span><span class="symbol">:</span>

<span class="normal">    </span><span class="comment">/// block_manager of stxxl from which to allocate runs</span>
<span class="normal">    stxxl</span><span class="symbol">::</span><span class="normal">block_manager</span><span class="symbol">*</span><span class="normal">               m_bm</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// *** Structures holding references to written runs</span>

<span class="normal">    std</span><span class="symbol">::</span><span class="usertype">vector&lt;bid_vector_type&gt;</span><span class="normal">        m_block_seqs</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// *** Structures when merging runs</span>

<span class="normal">    </span><span class="usertype">buf_istream_vector_type</span><span class="normal">     m_istream_vector</span><span class="symbol">;</span>

<span class="normal">    </span><span class="usertype">StreamCompare</span><span class="normal">               m_streamcmp</span><span class="symbol">;</span>

<span class="normal">    </span><span class="usertype">LoserTree3Way&lt;StreamCompare&gt;</span><span class="normal">    m_losertree</span><span class="symbol">;</span>

<span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">    </span><span class="function">VarlengthSorter</span><span class="symbol">()</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">m_bm</span><span class="symbol">(</span><span class="normal">stxxl</span><span class="symbol">::</span><span class="normal">block_manager</span><span class="symbol">::</span><span class="function">get_instance</span><span class="symbol">()),</span>
<span class="normal">          </span><span class="function">m_streamcmp</span><span class="symbol">(</span><span class="normal">m_istream_vector</span><span class="symbol">),</span>
<span class="normal">          </span><span class="function">m_losertree</span><span class="symbol">(</span><span class="normal">m_streamcmp</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="symbol">~</span><span class="function">VarlengthSorter</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">// write out buffer of sorted objects into one run</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">ConstIterator</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">write</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> totalsize</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">ConstIterator</span><span class="normal"> begin</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">ConstIterator</span><span class="normal"> end</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">bid_vector_type</span><span class="normal"> </span><span class="function">newbids</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">totalsize </span><span class="symbol">+</span><span class="normal"> block_size </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> block_size </span><span class="symbol">);</span>
<span class="normal">        m_bm</span><span class="symbol">-&gt;</span><span class="function">new_blocks</span><span class="symbol">(</span><span class="normal">m_alloc_strategy</span><span class="symbol">,</span><span class="normal"> newbids</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> newbids</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>

<span class="normal">        </span><span class="usertype">buf_ostream_type</span><span class="normal"> </span><span class="function">os</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">newbids</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>

<span class="normal">        </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> begin </span><span class="symbol">!=</span><span class="normal"> end </span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="symbol">(*</span><span class="normal">begin</span><span class="symbol">).</span><span class="function">serialize</span><span class="symbol">(</span><span class="normal">os</span><span class="symbol">);</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">begin</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        os</span><span class="symbol">.</span><span class="function">fill</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">);</span>

<span class="normal">        m_block_seqs</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">newbids</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">// write out buffer of sorted objects into one run</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">ConstIterator</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Serializer</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">write</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> totalsize</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">ConstIterator</span><span class="normal"> begin</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">ConstIterator</span><span class="normal"> end</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Serializer</span><span class="normal"> serializer</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">bid_vector_type</span><span class="normal"> </span><span class="function">newbids</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">totalsize </span><span class="symbol">+</span><span class="normal"> block_size </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> block_size </span><span class="symbol">);</span>
<span class="normal">        m_bm</span><span class="symbol">-&gt;</span><span class="function">new_blocks</span><span class="symbol">(</span><span class="normal">m_alloc_strategy</span><span class="symbol">,</span><span class="normal"> newbids</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> newbids</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>

<span class="normal">        </span><span class="usertype">buf_ostream_type</span><span class="normal"> </span><span class="function">os</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">newbids</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>

<span class="normal">        </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> begin </span><span class="symbol">!=</span><span class="normal"> end </span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">serializer</span><span class="symbol">(</span><span class="normal">os</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">begin</span><span class="symbol">);</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">begin</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        os</span><span class="symbol">.</span><span class="function">fill</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">);</span>

<span class="normal">        m_block_seqs</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">newbids</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// finish input of runs and prepare tournament tree for output</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">sort</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"VarlengthSorter merging "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m_block_seqs</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" sequences."</span><span class="symbol">);</span>

<span class="normal">        m_istream_vector</span><span class="symbol">.</span><span class="function">resize</span><span class="symbol">(</span><span class="normal"> m_block_seqs</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> m_block_seqs</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">//DBG(debug, "  seq" &lt;&lt; i &lt;&lt; " : " &lt;&lt; m_block_seqs[i].size() &lt;&lt; " blocks of size " &lt;&lt; blocksize);</span>

<span class="normal">            m_istream_vector</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">buf_istream_type</span><span class="symbol">(</span><span class="normal"> m_block_seqs</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">].</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> m_block_seqs</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">].</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// create comparator for loser tree</span>

<span class="normal">        m_streamcmp</span><span class="symbol">.</span><span class="function">resize</span><span class="symbol">();</span>

<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> m_istream_vector</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            m_streamcmp</span><span class="symbol">.</span><span class="function">fetch</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        m_losertree</span><span class="symbol">.</span><span class="function">play_initial</span><span class="symbol">(</span><span class="normal"> m_block_seqs</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// Free all resources</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">clear</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> m_block_seqs</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">delete</span><span class="normal"> m_istream_vector</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>

<span class="normal">            m_bm</span><span class="symbol">-&gt;</span><span class="function">delete_blocks</span><span class="symbol">(</span><span class="normal"> m_block_seqs</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">].</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> m_block_seqs</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">].</span><span class="function">end</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        m_istream_vector</span><span class="symbol">.</span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">        m_block_seqs</span><span class="symbol">.</span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// stream interface</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> m_losertree</span><span class="symbol">.</span><span class="function">done</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// stream interface</span>
<span class="normal">    value_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">*()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> m_streamcmp</span><span class="symbol">.</span><span class="normal">m_head</span><span class="symbol">[</span><span class="normal"> m_losertree</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">];</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// stream interface</span>
<span class="normal">    VarlengthSorter</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// get next string in sequence and replay tree</span>
<span class="normal">        m_streamcmp</span><span class="symbol">.</span><span class="function">fetch</span><span class="symbol">(</span><span class="normal"> m_losertree</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">        m_losertree</span><span class="symbol">.</span><span class="function">replay</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// True if the loser tree indicates that this value is equal to the preceding one. This is however only</span>
<span class="normal">    </span><span class="comment">/// semi-definite; due to comparisons in the tree, an equal pair may go unnoticed.</span>
<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">was_equal</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> m_losertree</span><span class="symbol">.</span><span class="function">top_equal</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="comment">// }}}</span>

<span class="comment">/*************************************************************************************************************</span>
<span class="comment"> * Top-Level Algorithm Class                                                                                 *</span>
<span class="comment"> *************************************************************************************************************/</span>

<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">AlphabetType</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">OffsetType</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SizeType</span><span class="symbol">&gt;</span>
<span class="keyword">class</span><span class="normal"> </span><span class="classname">eSAIS</span>
<span class="cbracket">{</span>
<span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">    </span><span class="comment">// *******************************************************************************************************</span>
<span class="normal">    </span><span class="comment">// *** Size parameters</span>

<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> block_size </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">::</span><span class="normal">block_size</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> memsize </span><span class="symbol">=</span><span class="normal"> ram_use</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// *******************************************************************************************************</span>
<span class="normal">    </span><span class="comment">// *** Global typedefs and constants</span>

<span class="normal">    </span><span class="comment">/// type used for character from the string</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">AlphabetType</span><span class="normal">        alphabet_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// type used for offsets and indexes on storage</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">OffsetType</span><span class="normal">          offset_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// type used for offsets and indexes in memory</span>
<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">SizeType</span><span class="normal">            size_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// number of characters stored in a PQ tuple</span>
<span class="preproc">#ifdef</span><span class="normal"> ESAIS_TUPLECHARLIMIT</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal">   D </span><span class="symbol">=</span><span class="normal"> ESAIS_TUPLECHARLIMIT</span><span class="symbol">;</span>
<span class="preproc">#else</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal">   D </span><span class="symbol">=</span><span class="normal"> </span><span class="number">3</span><span class="symbol">;</span>
<span class="preproc">#endif</span>

<span class="normal">    </span><span class="comment">/// type for classes of positions</span>
<span class="normal">    </span><span class="keyword">enum</span><span class="normal"> ctype_type </span><span class="cbracket">{</span><span class="normal"> TYPE_L </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> TYPE_S </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/*********************************************************************************************************</span>
<span class="comment">     * General helpers depending on template parameters                                                      *</span>
<span class="comment">     *********************************************************************************************************/</span>

<span class="normal">    </span><span class="comment">/// helper to print out readable characters</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">string</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> alphabet_type</span><span class="symbol">&amp;</span><span class="normal"> c</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        std</span><span class="symbol">::</span><span class="usertype">ostringstream</span><span class="normal"> oss</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">c </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="function">alphabet_type</span><span class="symbol">(</span><span class="number">128</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="function">isalnum</span><span class="symbol">((</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">c</span><span class="symbol">))</span><span class="normal"> oss </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">'</span><span class="specialchar">\'</span><span class="string">'</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="type">char</span><span class="symbol">)((</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">c</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">'</span><span class="specialchar">\'</span><span class="string">'</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> oss </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">c</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> oss</span><span class="symbol">.</span><span class="function">str</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// helper to format ctype_type values</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> ctype_type</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t </span><span class="symbol">==</span><span class="normal"> TYPE_L</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="string">"L"</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t </span><span class="symbol">==</span><span class="normal"> TYPE_S</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="string">"S"</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="string">"?"</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// helper to format a sequence of characters</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Iterator</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">string</span><span class="normal"> </span><span class="function">strS</span><span class="symbol">(</span><span class="usertype">Iterator</span><span class="normal"> begin</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Iterator</span><span class="normal"> end</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        std</span><span class="symbol">::</span><span class="usertype">ostringstream</span><span class="normal"> oss</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">begin </span><span class="symbol">==</span><span class="normal"> end</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> oss</span><span class="symbol">.</span><span class="function">str</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">begin </span><span class="symbol">!=</span><span class="normal"> end</span><span class="symbol">)</span><span class="normal"> oss </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(*</span><span class="normal">begin</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">Iterator</span><span class="normal"> s </span><span class="symbol">=</span><span class="normal"> begin</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span><span class="normal"> s </span><span class="symbol">!=</span><span class="normal"> end</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">s</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            oss </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(*</span><span class="normal">s</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> oss</span><span class="symbol">.</span><span class="function">str</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// helper to format a sequence of characters and calculate their type if the type of the last character</span>
<span class="normal">    </span><span class="comment">/// is known.</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Iterator</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">string</span><span class="normal"> </span><span class="function">strST</span><span class="symbol">(</span><span class="usertype">Iterator</span><span class="normal"> begin</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Iterator</span><span class="normal"> end</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">ctype_type</span><span class="normal"> lasttype</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        std</span><span class="symbol">::</span><span class="usertype">ostringstream</span><span class="normal"> oss</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">begin </span><span class="symbol">==</span><span class="normal"> end</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> oss</span><span class="symbol">.</span><span class="function">str</span><span class="symbol">();</span>

<span class="normal">        std</span><span class="symbol">::</span><span class="usertype">vector&lt;ctype_type&gt;</span><span class="normal"> </span><span class="function">ctypearray</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">end </span><span class="symbol">-</span><span class="normal"> begin</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">vector</span><span class="symbol">&lt;</span><span class="normal">ctype_type</span><span class="symbol">&gt;::</span><span class="usertype">iterator</span><span class="normal"> cti </span><span class="symbol">=</span><span class="normal"> ctypearray</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">();</span>
<span class="normal">            </span><span class="usertype">Iterator</span><span class="normal"> ai </span><span class="symbol">=</span><span class="normal"> end</span><span class="symbol">;</span>

<span class="normal">            </span><span class="symbol">--</span><span class="normal">cti</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">--</span><span class="normal">ai</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">cti </span><span class="symbol">=</span><span class="normal"> lasttype</span><span class="symbol">;</span>

<span class="normal">            </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> cti </span><span class="symbol">!=</span><span class="normal"> ctypearray</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> ai </span><span class="symbol">!=</span><span class="normal"> begin </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">Iterator</span><span class="normal"> pi </span><span class="symbol">=</span><span class="normal"> ai</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">vector</span><span class="symbol">&lt;</span><span class="normal">ctype_type</span><span class="symbol">&gt;::</span><span class="usertype">iterator</span><span class="normal"> pti </span><span class="symbol">=</span><span class="normal"> cti</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span>

<span class="normal">                </span><span class="symbol">*</span><span class="normal">pti </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">pi </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ai </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">pi </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">ai </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">cti </span><span class="symbol">==</span><span class="normal"> TYPE_S</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> TYPE_S </span><span class="symbol">:</span><span class="normal"> TYPE_L</span><span class="symbol">;</span>

<span class="normal">                ai </span><span class="symbol">=</span><span class="normal"> pi</span><span class="symbol">;</span><span class="normal"> cti </span><span class="symbol">=</span><span class="normal"> pti</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">vector</span><span class="symbol">&lt;</span><span class="normal">ctype_type</span><span class="symbol">&gt;::</span><span class="usertype">iterator</span><span class="normal"> cti </span><span class="symbol">=</span><span class="normal"> ctypearray</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">Iterator</span><span class="normal"> s </span><span class="symbol">=</span><span class="normal"> begin</span><span class="symbol">;</span><span class="normal"> s </span><span class="symbol">!=</span><span class="normal"> end</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">s</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">cti</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s </span><span class="symbol">!=</span><span class="normal"> begin</span><span class="symbol">)</span><span class="normal"> oss </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" "</span><span class="symbol">;</span>
<span class="normal">            oss </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(*</span><span class="normal">s</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">(*</span><span class="normal">cti</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> oss</span><span class="symbol">.</span><span class="function">str</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// helper to format a sequence of characters and calculate their type if all types of the characters are</span>
<span class="normal">    </span><span class="comment">/// known.</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Iterator</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">IteratorCTypes</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">string</span><span class="normal"> </span><span class="function">strST2</span><span class="symbol">(</span><span class="usertype">Iterator</span><span class="normal"> begin</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Iterator</span><span class="normal"> end</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">IteratorCTypes</span><span class="normal"> begin_ctype</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        std</span><span class="symbol">::</span><span class="usertype">ostringstream</span><span class="normal"> oss</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">begin </span><span class="symbol">==</span><span class="normal"> end</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> oss</span><span class="symbol">.</span><span class="function">str</span><span class="symbol">();</span>
<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">Iterator</span><span class="normal"> s </span><span class="symbol">=</span><span class="normal"> begin</span><span class="symbol">;</span><span class="normal"> s </span><span class="symbol">!=</span><span class="normal"> end</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">s</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">begin_ctype</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">s </span><span class="symbol">!=</span><span class="normal"> begin</span><span class="symbol">)</span><span class="normal"> oss </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" "</span><span class="symbol">;</span>
<span class="normal">            oss </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(*</span><span class="normal">s</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">((</span><span class="normal">ctype_type</span><span class="symbol">)*</span><span class="normal">begin_ctype</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> oss</span><span class="symbol">.</span><span class="function">str</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="comment">/// comparator which compares characters and then the type of the last matching one if either string ends</span>
<span class="normal">    </span><span class="comment">/// before the other.</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Iterator</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">lexcompare_type_3way</span><span class="symbol">(</span>
<span class="normal">        </span><span class="usertype">Iterator</span><span class="normal"> beginA</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Iterator</span><span class="normal"> endA</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">ctype_type</span><span class="normal"> lasttypeA</span><span class="symbol">,</span>
<span class="normal">        </span><span class="usertype">Iterator</span><span class="normal"> beginB</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Iterator</span><span class="normal"> endB</span><span class="symbol">,</span><span class="normal"> ctype_type lasttypeB</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> endrepcountA</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> endrepcountB</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> endA </span><span class="symbol">&gt;</span><span class="normal"> beginA </span><span class="symbol">);</span><span class="normal">        </span><span class="comment">// no empty strings</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> endB </span><span class="symbol">&gt;</span><span class="normal"> beginB </span><span class="symbol">);</span>

<span class="normal">        </span><span class="usertype">Iterator</span><span class="normal"> strA </span><span class="symbol">=</span><span class="normal"> beginA</span><span class="symbol">,</span><span class="normal"> strB </span><span class="symbol">=</span><span class="normal"> beginB</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// compare characters until either string is empty</span>
<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(;</span><span class="normal"> strA </span><span class="symbol">!=</span><span class="normal"> endA </span><span class="symbol">&amp;&amp;</span><span class="normal"> strB </span><span class="symbol">!=</span><span class="normal"> endB</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">strA</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">strB</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">strA </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strB</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">strB </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strA</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">//std::cout &lt;&lt; "strings [" &lt;&lt; strST(beginA,endA,lasttypeA) &lt;&lt; "] and [" &lt;&lt; strST(beginB,endB,lasttypeB) &lt;&lt; "] match chars\n" ;</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">strA </span><span class="symbol">==</span><span class="normal"> endA </span><span class="symbol">&amp;&amp;</span><span class="normal"> strB </span><span class="symbol">==</span><span class="normal"> endB</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// both strings end at same time.</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lasttypeA </span><span class="symbol">!=</span><span class="normal"> lasttypeB</span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lasttypeA </span><span class="symbol">-</span><span class="normal"> lasttypeB</span><span class="symbol">);</span><span class="normal">       </span><span class="comment">// different end types</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// same end types: compare repcounts.</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lasttypeA </span><span class="symbol">==</span><span class="normal"> TYPE_L</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">endrepcountA </span><span class="symbol">-</span><span class="normal"> endrepcountB</span><span class="symbol">);</span><span class="normal">   </span><span class="comment">// longer repcounts are lower</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">endrepcountB </span><span class="symbol">-</span><span class="normal"> endrepcountA</span><span class="symbol">);</span><span class="normal">   </span><span class="comment">// longer repcounts are higher</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">// !ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lasttypeA </span><span class="symbol">-</span><span class="normal"> lasttypeB</span><span class="symbol">);</span><span class="normal">       </span><span class="comment">// different end types</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// !ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">strA </span><span class="symbol">==</span><span class="normal"> endA</span><span class="symbol">)</span><span class="normal"> </span><span class="comment">// &amp;&amp; (strB != endB)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// string A done, string B not yet ended, determine type of prev char of B to compare to lasttypeA</span>

<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> strB </span><span class="symbol">&gt;</span><span class="normal"> beginB </span><span class="symbol">);</span>
<span class="normal">            </span><span class="symbol">--</span><span class="normal">strB</span><span class="symbol">;</span>

<span class="normal">            </span><span class="comment">// determine type of *strB</span>
<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> strB</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> endB </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strB </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">strB</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">strB</span><span class="symbol">;</span>

<span class="normal">            </span><span class="usertype">ctype_type</span><span class="normal"> tb </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> strB</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> endB </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> lasttypeB </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strB </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">strB</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> TYPE_S </span><span class="symbol">:</span><span class="normal"> TYPE_L </span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">//std::cout &lt;&lt; "type of *strB = " &lt;&lt; strT(tb) &lt;&lt; "\n";</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lasttypeA </span><span class="symbol">!=</span><span class="normal"> tb</span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lasttypeA </span><span class="symbol">-</span><span class="normal"> tb</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// types are equal, shorter string is smaller</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="comment">// (strA != endA) &amp;&amp; (strB == endB)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// string B done, string A not yet ended, determine type of prev char of A to compare to lasttypeB</span>

<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> strA </span><span class="symbol">&gt;</span><span class="normal"> beginA </span><span class="symbol">);</span>
<span class="normal">            </span><span class="symbol">--</span><span class="normal">strA</span><span class="symbol">;</span>

<span class="normal">            </span><span class="comment">// determine type of *strA</span>
<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> strA</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> endA </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strA </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">strA</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">strA</span><span class="symbol">;</span>

<span class="normal">            </span><span class="usertype">ctype_type</span><span class="normal"> ta </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> strA</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> endA </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> lasttypeA </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strA </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">strA</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> TYPE_S </span><span class="symbol">:</span><span class="normal"> TYPE_L </span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">//std::cout &lt;&lt; "type of *strA = " &lt;&lt; strT(ta) &lt;&lt; "\n";</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ta </span><span class="symbol">!=</span><span class="normal"> lasttypeB</span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ta </span><span class="symbol">-</span><span class="normal"> lasttypeB</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// shorter string is smaller</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">    </span><span class="comment">/// comparator which compares characters and then the type of the last matching one if either string ends</span>
<span class="normal">    </span><span class="comment">/// before the other.</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Iterator</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">lexcompare_type_3way_lcp</span><span class="symbol">(</span><span class="usertype">Iterator</span><span class="normal"> beginA</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Iterator</span><span class="normal"> endA</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">ctype_type</span><span class="normal"> lasttypeA</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> endrepcountA</span><span class="symbol">,</span>
<span class="normal">                                               </span><span class="usertype">Iterator</span><span class="normal"> beginB</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Iterator</span><span class="normal"> endB</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">ctype_type</span><span class="normal"> lasttypeB</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> endrepcountB</span><span class="symbol">,</span>
<span class="normal">                                               offset_type</span><span class="symbol">&amp;</span><span class="normal"> lcp</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> endA </span><span class="symbol">&gt;</span><span class="normal"> beginA </span><span class="symbol">);</span><span class="normal">        </span><span class="comment">// no empty strings</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> endB </span><span class="symbol">&gt;</span><span class="normal"> beginB </span><span class="symbol">);</span>

<span class="normal">        </span><span class="usertype">Iterator</span><span class="normal"> strA </span><span class="symbol">=</span><span class="normal"> beginA</span><span class="symbol">,</span><span class="normal"> strB </span><span class="symbol">=</span><span class="normal"> beginB</span><span class="symbol">;</span>
<span class="normal">        lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// compare characters until either string is empty</span>
<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(;</span><span class="normal"> strA </span><span class="symbol">!=</span><span class="normal"> endA </span><span class="symbol">&amp;&amp;</span><span class="normal"> strB </span><span class="symbol">!=</span><span class="normal"> endB</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">strA</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">strB</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">strA </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strB</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">strB </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strA</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">            </span><span class="symbol">++</span><span class="normal">lcp</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">//std::cout &lt;&lt; "strings [" &lt;&lt; strST(beginA,endA,lasttypeA) &lt;&lt; "] and [" &lt;&lt; strST(beginB,endB,lasttypeB) &lt;&lt; "] match chars\n" ;</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">strA </span><span class="symbol">==</span><span class="normal"> endA </span><span class="symbol">&amp;&amp;</span><span class="normal"> strB </span><span class="symbol">==</span><span class="normal"> endB</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// both strings end at same time.</span>

<span class="normal">            lcp </span><span class="symbol">+=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">endrepcountA</span><span class="symbol">,</span><span class="normal">endrepcountB</span><span class="symbol">);</span><span class="normal"> </span><span class="comment">// last char is equal, add repcount.</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lasttypeA </span><span class="symbol">!=</span><span class="normal"> lasttypeB</span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lasttypeA </span><span class="symbol">-</span><span class="normal"> lasttypeB</span><span class="symbol">);</span><span class="normal">       </span><span class="comment">// different end types</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">endrepcountB </span><span class="symbol">-</span><span class="normal"> endrepcountA</span><span class="symbol">);</span><span class="normal"> </span><span class="comment">// same end types: compare repcounts</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">strA </span><span class="symbol">==</span><span class="normal"> endA</span><span class="symbol">)</span><span class="normal"> </span><span class="comment">// &amp;&amp; (strB != endB)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// string A done, string B not yet ended, must determine type of prev char of B to compare to lasttypeA</span>

<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> strB </span><span class="symbol">&gt;</span><span class="normal"> beginB </span><span class="symbol">);</span>
<span class="normal">            </span><span class="symbol">--</span><span class="normal">strB</span><span class="symbol">;</span>

<span class="normal">            </span><span class="comment">// determine type of *strB and count chars equal to A's last char</span>
<span class="normal">            </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> strB</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> endB </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strB </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">strB</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">strB</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">repcount</span><span class="symbol">;</span>

<span class="normal">            </span><span class="usertype">ctype_type</span><span class="normal"> tb </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> strB</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> endB </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> lasttypeB </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strB </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">strB</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> TYPE_S </span><span class="symbol">:</span><span class="normal"> TYPE_L </span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">strB</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> endB</span><span class="symbol">)</span><span class="normal"> repcount </span><span class="symbol">+=</span><span class="normal"> endrepcountB</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// add endrepcount if at end</span>

<span class="normal">            </span><span class="comment">//std::cout &lt;&lt; "type of *strB = " &lt;&lt; strT(tb) &lt;&lt; "\n";</span>

<span class="normal">            lcp </span><span class="symbol">+=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">repcount</span><span class="symbol">,</span><span class="normal"> endrepcountA</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lasttypeA </span><span class="symbol">!=</span><span class="normal"> tb</span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lasttypeA </span><span class="symbol">-</span><span class="normal"> tb</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// shorter string is smaller</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="comment">// !(strA == endA) &amp;&amp; (strB == endB)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> strA </span><span class="symbol">&gt;</span><span class="normal"> beginA </span><span class="symbol">);</span>
<span class="normal">            </span><span class="symbol">--</span><span class="normal">strA</span><span class="symbol">;</span>

<span class="normal">            </span><span class="comment">// determine type of *strA</span>
<span class="normal">            </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> strA</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> endA </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strA </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">strA</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">strA</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">repcount</span><span class="symbol">;</span>

<span class="normal">            </span><span class="usertype">ctype_type</span><span class="normal"> ta </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> strA</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> endA </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> lasttypeA </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">strA </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">*(</span><span class="normal">strA</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> TYPE_S </span><span class="symbol">:</span><span class="normal"> TYPE_L </span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">strA</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> endA</span><span class="symbol">)</span><span class="normal"> repcount </span><span class="symbol">+=</span><span class="normal"> endrepcountA</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// add endrepcount if at end</span>

<span class="normal">            </span><span class="comment">//std::cout &lt;&lt; "type of *strA = " &lt;&lt; strT(ta) &lt;&lt; "\n";</span>

<span class="normal">            lcp </span><span class="symbol">+=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">repcount</span><span class="symbol">,</span><span class="normal"> endrepcountB</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ta </span><span class="symbol">!=</span><span class="normal"> lasttypeB</span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ta </span><span class="symbol">-</span><span class="normal"> lasttypeB</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// shorter string is smaller</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">test_assert_lexcompare</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">string</span><span class="symbol">&amp;</span><span class="normal"> strA</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">ctype_type</span><span class="normal"> lasttypeA</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> endrepcountA</span><span class="symbol">,</span>
<span class="normal">                                       </span><span class="keyword">const</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">string</span><span class="symbol">&amp;</span><span class="normal"> strB</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">ctype_type</span><span class="normal"> lasttypeB</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> endrepcountB</span><span class="symbol">,</span>
<span class="normal">                                       </span><span class="usertype">offset_type</span><span class="normal"> checklcp</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">offset_type</span><span class="normal"> lcp</span><span class="symbol">;</span>

<span class="normal">        </span><span class="type">int</span><span class="normal"> c1 </span><span class="symbol">=</span><span class="normal"> </span><span class="function">lexcompare_type_3way_lcp</span><span class="symbol">(</span><span class="normal">strA</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> strA</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> lasttypeA</span><span class="symbol">,</span><span class="normal"> endrepcountA</span><span class="symbol">,</span>
<span class="normal">                                          strB</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> strB</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> lasttypeB</span><span class="symbol">,</span><span class="normal"> endrepcountB</span><span class="symbol">,</span><span class="normal"> lcp</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">c1 </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span><span class="normal"> </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">lcp </span><span class="symbol">==</span><span class="normal"> checklcp</span><span class="symbol">);</span>

<span class="normal">        </span><span class="type">int</span><span class="normal"> c2 </span><span class="symbol">=</span><span class="normal"> </span><span class="function">lexcompare_type_3way_lcp</span><span class="symbol">(</span><span class="normal">strB</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> strB</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> lasttypeB</span><span class="symbol">,</span><span class="normal"> endrepcountB</span><span class="symbol">,</span>
<span class="normal">                                          strA</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> strA</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> lasttypeA</span><span class="symbol">,</span><span class="normal"> endrepcountA</span><span class="symbol">,</span><span class="normal"> lcp</span><span class="symbol">);</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">c2 </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span><span class="normal"> </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">lcp </span><span class="symbol">==</span><span class="normal"> checklcp</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">test_lexcompare</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="comment">// (69013,['T'L 'T'L 'G'L 'G'L],L,2) (61227,['T'L 'T'L 'G'S],S,3)</span>
<span class="normal">        </span><span class="function">test_assert_lexcompare</span><span class="symbol">(</span><span class="string">"TTGG"</span><span class="symbol">,</span><span class="normal"> TYPE_L</span><span class="symbol">,</span><span class="normal"> </span><span class="number">2</span><span class="symbol">,</span>
<span class="normal">                               </span><span class="string">"TTG"</span><span class="symbol">,</span><span class="normal">  TYPE_S</span><span class="symbol">,</span><span class="normal"> </span><span class="number">3</span><span class="symbol">,</span><span class="normal"> </span><span class="number">6</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">    </span><span class="comment">/*********************************************************************************************************</span>
<span class="comment">     * Tuple Structures                                                                                      *</span>
<span class="comment">     *********************************************************************************************************/</span>

<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">NameTuple</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">offset_type</span><span class="normal">     index</span><span class="symbol">;</span><span class="normal">          </span><span class="comment">// start index of refered substring</span>
<span class="normal">        </span><span class="usertype">offset_type</span><span class="normal">     name</span><span class="symbol">;</span><span class="normal">           </span><span class="comment">// lexname of substring</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="normal">        </span><span class="type">char</span><span class="normal">            unique</span><span class="symbol">;</span><span class="normal">         </span><span class="comment">// uniqueness flag</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_DISCARD_UNIQUES</span>

<span class="normal">        </span><span class="function">NameTuple</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">        </span><span class="function">NameTuple</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> i</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> n</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">index</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">),</span><span class="normal"> </span><span class="function">name</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">        </span><span class="keyword">static</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">description</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(index,name"</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="normal">                      </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">",unique"</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_DISCARD_UNIQUES</span>
<span class="normal">                      </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">friend</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> NameTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">name</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="normal">                      </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="type">int</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">unique</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_DISCARD_UNIQUES</span>
<span class="normal">                      </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="normal"> </span><span class="function">__attribute__</span><span class="symbol">((</span><span class="normal">packed</span><span class="symbol">));</span>

<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">NameTupleOrder_IndexDesc</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="keyword">const</span><span class="normal"> NameTuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> NameTuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="usertype">NameTuple</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="function">NameTuple</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">(),</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="usertype">NameTuple</span><span class="normal"> </span><span class="function">max_value</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="function">NameTuple</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">(),</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">RankTuple</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">offset_type</span><span class="normal">     index</span><span class="symbol">;</span><span class="normal">          </span><span class="comment">// start index of refered substring</span>
<span class="normal">        </span><span class="usertype">offset_type</span><span class="normal">     name</span><span class="symbol">;</span><span class="normal">           </span><span class="comment">// lexname or rank of substring</span>

<span class="normal">        </span><span class="function">RankTuple</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">        </span><span class="function">RankTuple</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> i</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> r</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">index</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">),</span><span class="normal"> </span><span class="function">name</span><span class="symbol">(</span><span class="normal">r</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">        </span><span class="keyword">static</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">description</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(index,name)"</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">friend</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> RankTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">name </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">RankTupleOrder_IndexDesc</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="keyword">const</span><span class="normal"> RankTuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> RankTuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="usertype">RankTuple</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="function">RankTuple</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">(),</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="usertype">RankTuple</span><span class="normal"> </span><span class="function">max_value</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="function">RankTuple</span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">(),</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">RankTupleOrder_RankAsc</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="keyword">const</span><span class="normal"> RankTuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> RankTuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">name </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">name</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_SELF_CHECK</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">RerankTuple</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">offset_type</span><span class="normal">     index</span><span class="symbol">;</span><span class="normal">          </span><span class="comment">// start index of refered substring</span>
<span class="normal">        </span><span class="usertype">offset_type</span><span class="normal">     name</span><span class="symbol">;</span><span class="normal">           </span><span class="comment">// lexname of substring</span>
<span class="normal">        </span><span class="usertype">offset_type</span><span class="normal">     ISA</span><span class="symbol">;</span><span class="normal">            </span><span class="comment">// rank in recursive string</span>

<span class="normal">        </span><span class="function">RerankTuple</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">        </span><span class="function">RerankTuple</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> i</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> n</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> r</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">index</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">),</span><span class="normal"> </span><span class="function">name</span><span class="symbol">(</span><span class="normal">n</span><span class="symbol">),</span><span class="normal"> </span><span class="function">ISA</span><span class="symbol">(</span><span class="normal">r</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">        </span><span class="keyword">static</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">description</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(index,name,ISA)"</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">friend</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> RerankTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">name </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">ISA </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">RerankTuple_ISA</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="keyword">const</span><span class="normal"> RerankTuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> RerankTuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">ISA </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">ISA</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="usertype">RerankTuple</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="function">RerankTuple</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">,</span><span class="number">0</span><span class="symbol">,</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">());</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="usertype">RerankTuple</span><span class="normal"> </span><span class="function">max_value</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="function">RerankTuple</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">,</span><span class="number">0</span><span class="symbol">,</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">());</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="preproc">#endif</span>

<span class="normal">    </span><span class="comment">/*********************************************************************************************************</span>
<span class="comment">     * Step 1 and 2: Sorting short S*-substrings                                                             *</span>
<span class="comment">     *********************************************************************************************************/</span>

<span class="normal">    </span><span class="comment">// {{{ ShortStringSorter</span>

<span class="normal">    </span><span class="comment">/**</span>
<span class="comment">     * ShortStringSorter splits the input into S*-substrings and creates Substring tuples, which are</span>
<span class="comment">     * serialized and sorted by a VarlengthSorter. The sorted output is then lexicographically named.</span>
<span class="comment">     */</span>
<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">ShortStringSorter</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">        </span><span class="comment">/// Prototype declaration</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">Substring</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Use the VarlengthSorter for Substrings, which are serialized.</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">VarlengthSorter&lt;Substring, block_size&gt;</span><span class="normal">    ssorter_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// The VarlengthSorter</span>
<span class="normal">        </span><span class="usertype">ssorter_type</span><span class="normal">            m_ssorter</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Total input size</span>
<span class="normal">        </span><span class="usertype">size_type</span><span class="normal">               m_inputsize</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Substring classes with trailing type indicator</span>

<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">Substring</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">                 index</span><span class="symbol">;</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">vector&lt;alphabet_type&gt;</span><span class="normal">  str</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">ctype_type</span><span class="normal">                  lasttype</span><span class="symbol">;</span>
<span class="normal">            </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="usertype">offset_type</span><span class="normal"> endrepcount</span><span class="symbol">;)</span>

<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">cmp</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> Substring</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="function">lexcompare_type_3way</span><span class="symbol">(</span><span class="normal">str</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> str</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> lasttype</span><span class="symbol">,</span>
<span class="normal">                                            b</span><span class="symbol">.</span><span class="normal">str</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">str</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">lasttype</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                                            </span><span class="symbol">,</span><span class="normal">endrepcount</span><span class="symbol">,</span><span class="normal">b</span><span class="symbol">.</span><span class="normal">endrepcount</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">                    </span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">cmp</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> Substring</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">,</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> lcp</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="function">lexcompare_type_3way_lcp</span><span class="symbol">(</span><span class="normal">str</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> str</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> lasttype</span><span class="symbol">,</span><span class="normal"> endrepcount</span><span class="symbol">,</span>
<span class="normal">                                                b</span><span class="symbol">.</span><span class="normal">str</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">str</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">lasttype</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">endrepcount</span><span class="symbol">,</span><span class="normal"> lcp</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> Substring</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="function">cmp</span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;=</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> Substring</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="function">cmp</span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">friend</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> Substring</span><span class="symbol">&amp;</span><span class="normal"> s</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> s</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">",["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strST</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">.</span><span class="normal">str</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> s</span><span class="symbol">.</span><span class="normal">str</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> s</span><span class="symbol">.</span><span class="normal">lasttype</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"],"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">(</span><span class="normal">s</span><span class="symbol">.</span><span class="normal">lasttype</span><span class="symbol">)</span>
<span class="normal">                             </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> s</span><span class="symbol">.</span><span class="normal">endrepcount</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">swap</span><span class="symbol">(</span><span class="normal">Substring</span><span class="symbol">&amp;</span><span class="normal"> o</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                std</span><span class="symbol">::</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">index</span><span class="symbol">,</span><span class="normal"> o</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">);</span>
<span class="normal">                std</span><span class="symbol">::</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">str</span><span class="symbol">,</span><span class="normal"> o</span><span class="symbol">.</span><span class="normal">str</span><span class="symbol">);</span>
<span class="normal">                std</span><span class="symbol">::</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">lasttype</span><span class="symbol">,</span><span class="normal"> o</span><span class="symbol">.</span><span class="normal">lasttype</span><span class="symbol">);</span>
<span class="normal">                </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">endrepcount</span><span class="symbol">,</span><span class="normal"> o</span><span class="symbol">.</span><span class="normal">endrepcount</span><span class="symbol">);</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">/// deserialize from byte input stream</span>
<span class="normal">            </span><span class="type">bool</span><span class="normal"> </span><span class="function">deserialize</span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">ssorter_type</span><span class="symbol">::</span><span class="normal">buf_istream_type</span><span class="symbol">&amp;</span><span class="normal"> is</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// read offset_type as index</span>

<span class="normal">                </span><span class="function">stream_get</span><span class="symbol">(</span><span class="normal"> is</span><span class="symbol">,</span><span class="normal"> index </span><span class="symbol">);</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_decoder</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"index = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> index</span><span class="symbol">);</span>

<span class="normal">                </span><span class="comment">// read varint length and lasttype ctype from sequence</span>
<span class="normal">                </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> len</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">stream_get_varint</span><span class="symbol">(</span><span class="normal">is</span><span class="symbol">,</span><span class="normal"> len</span><span class="symbol">);</span>

<span class="normal">                lasttype </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ctype_type</span><span class="symbol">)(</span><span class="normal">len </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">                len </span><span class="symbol">/=</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>

<span class="normal">                </span><span class="comment">// read varint S*-endrepcount</span>
<span class="normal">                </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal"> </span><span class="function">stream_get_varint</span><span class="symbol">(</span><span class="normal">is</span><span class="symbol">,</span><span class="normal">endrepcount</span><span class="symbol">);</span><span class="normal"> </span><span class="symbol">)</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_decoder</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"varint length = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> len </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">", ctype = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">(</span><span class="normal">lasttype</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(&lt;&lt;</span><span class="normal"> </span><span class="string">", endrepcount = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> endrepcount</span><span class="symbol">));</span>

<span class="normal">                </span><span class="comment">// read string</span>

<span class="normal">                str</span><span class="symbol">.</span><span class="function">resize</span><span class="symbol">(</span><span class="normal">len</span><span class="symbol">);</span>

<span class="normal">                </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> len</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">stream_get</span><span class="symbol">(</span><span class="normal"> is</span><span class="symbol">,</span><span class="normal"> str</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug_substring_decoder</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"string = "</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> len</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal"> str</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" "</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> str</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/**</span>
<span class="comment">         * When splitting the input into S*-substring, instead of copying characters we use this pointer</span>
<span class="comment">         * struct to mark offset and length. The Ptrs are sorted and serialized into the VarlengthSorter.</span>
<span class="comment">         */</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SubstringPtr</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">size_type</span><span class="normal">           offset</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">uint16_t</span><span class="normal">            len</span><span class="symbol">;</span><span class="normal">    </span><span class="comment">// no S*-substring is allowed &gt; 64 KiB, otherwise it is split</span>
<span class="normal">            </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="usertype">offset_type</span><span class="normal"> endrepcount</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="function">SubstringPtr</span><span class="symbol">(</span><span class="usertype">size_type</span><span class="normal"> _offset</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">uint16_t</span><span class="normal"> _len</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> _endrepcount</span><span class="symbol">)</span>
<span class="normal">                </span><span class="symbol">:</span><span class="normal"> </span><span class="function">offset</span><span class="symbol">(</span><span class="normal">_offset</span><span class="symbol">),</span><span class="normal"> </span><span class="function">len</span><span class="symbol">(</span><span class="normal">_len</span><span class="symbol">),</span><span class="normal"> </span><span class="function">endrepcount</span><span class="symbol">(</span><span class="normal">_endrepcount</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> len </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="preproc">#else</span>
<span class="normal">            </span><span class="function">SubstringPtr</span><span class="symbol">(</span><span class="usertype">size_type</span><span class="normal"> _offset</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">uint16_t</span><span class="normal"> _len</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;)</span>
<span class="normal">                </span><span class="symbol">:</span><span class="normal"> </span><span class="function">offset</span><span class="symbol">(</span><span class="normal">_offset</span><span class="symbol">),</span><span class="normal"> </span><span class="function">len</span><span class="symbol">(</span><span class="normal">_len</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> len </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="preproc">#endif</span>
<span class="normal">            </span><span class="keyword">friend</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> SubstringPtr</span><span class="symbol">&amp;</span><span class="normal"> s</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> s</span><span class="symbol">.</span><span class="normal">offset </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> s</span><span class="symbol">.</span><span class="normal">len </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="usertype">Substring</span><span class="normal"> </span><span class="function">getSubstring</span><span class="symbol">(</span><span class="usertype">size_type</span><span class="normal"> baseoff</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> alphabet_type</span><span class="symbol">*</span><span class="normal"> str</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> ctype</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">Substring</span><span class="normal"> s</span><span class="symbol">;</span>
<span class="normal">                s</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> baseoff </span><span class="symbol">+</span><span class="normal"> offset</span><span class="symbol">;</span>
<span class="normal">                s</span><span class="symbol">.</span><span class="normal">str</span><span class="symbol">.</span><span class="function">assign</span><span class="symbol">(</span><span class="normal"> str </span><span class="symbol">+</span><span class="normal"> offset</span><span class="symbol">,</span><span class="normal"> str </span><span class="symbol">+</span><span class="normal"> offset </span><span class="symbol">+</span><span class="normal"> len </span><span class="symbol">);</span>
<span class="normal">                s</span><span class="symbol">.</span><span class="normal">lasttype </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ctype_type</span><span class="symbol">)</span><span class="normal">ctype</span><span class="symbol">[</span><span class="normal"> offset </span><span class="symbol">+</span><span class="normal"> len </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">];</span>
<span class="normal">                </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal"> s</span><span class="symbol">.</span><span class="normal">endrepcount </span><span class="symbol">=</span><span class="normal"> endrepcount </span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> s</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/**</span>
<span class="comment">         * Sorting Functional for SubstringPtr objects.</span>
<span class="comment">         */</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SubstringPtrSort</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">const</span><span class="normal"> alphabet_type</span><span class="symbol">*</span><span class="normal">        str</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*</span><span class="normal">        ctype</span><span class="symbol">;</span>

<span class="normal">            </span><span class="function">SubstringPtrSort</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> alphabet_type</span><span class="symbol">*</span><span class="normal"> _str</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> _ctype</span><span class="symbol">)</span>
<span class="normal">                </span><span class="symbol">:</span><span class="normal"> </span><span class="function">str</span><span class="symbol">(</span><span class="normal">_str</span><span class="symbol">),</span><span class="normal"> </span><span class="function">ctype</span><span class="symbol">(</span><span class="normal">_ctype</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// *** Interface for STL sort</span>

<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="keyword">const</span><span class="normal"> SubstringPtr</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> SubstringPtr</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="function">lexcompare_type_3way</span><span class="symbol">(</span><span class="normal">str </span><span class="symbol">+</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">offset</span><span class="symbol">,</span><span class="normal"> str </span><span class="symbol">+</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">offset </span><span class="symbol">+</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">len</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ctype_type</span><span class="symbol">)</span><span class="normal">ctype</span><span class="symbol">[</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">offset </span><span class="symbol">+</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">len</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">],</span>
<span class="normal">                                            str </span><span class="symbol">+</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">offset</span><span class="symbol">,</span><span class="normal"> str </span><span class="symbol">+</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">offset </span><span class="symbol">+</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">len</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ctype_type</span><span class="symbol">)</span><span class="normal">ctype</span><span class="symbol">[</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">offset </span><span class="symbol">+</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">len</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">]</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                                            </span><span class="symbol">,</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">endrepcount</span><span class="symbol">,</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">endrepcount</span>
<span class="preproc">#endif</span>
<span class="normal">                    </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// *** Interface for generic radixsort</span>

<span class="normal">            </span><span class="keyword">typedef</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">short</span><span class="normal"> oracle_type</span><span class="symbol">;</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> </span><span class="function">limit</span><span class="symbol">(</span><span class="normal">size_t </span><span class="comment">/* depth */</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> maxdepth </span><span class="symbol">=</span><span class="normal"> </span><span class="number">16</span><span class="symbol">;</span>

<span class="normal">            </span><span class="usertype">oracle_type</span><span class="normal"> </span><span class="function">index</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> SubstringPtr</span><span class="symbol">&amp;</span><span class="normal"> sp</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> depth</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">depth </span><span class="symbol">==</span><span class="normal"> sp</span><span class="symbol">.</span><span class="normal">len</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="function">oracle_type</span><span class="symbol">(</span><span class="normal">str</span><span class="symbol">[</span><span class="normal">sp</span><span class="symbol">.</span><span class="normal">offset </span><span class="symbol">+</span><span class="normal"> depth</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> ctype</span><span class="symbol">[</span><span class="normal">sp</span><span class="symbol">.</span><span class="normal">offset </span><span class="symbol">+</span><span class="normal"> depth</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">std</span><span class="symbol">::</span><span class="normal">vector</span><span class="symbol">&lt;</span><span class="normal">SubstringPtr</span><span class="symbol">&gt;::</span><span class="usertype">iterator</span><span class="normal"> Iterator</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">subsort_cmpL</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> SubstringPtr</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> SubstringPtr</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// for L-types longer repcounts are ranked lower</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">endrepcount </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">endrepcount</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="function">subsort_cmpS</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> SubstringPtr</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> SubstringPtr</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// for S-types longer repcounts are ranked higher</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">endrepcount </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">endrepcount</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="comment">// thereby the highest repcounts meet at the L/S-seam and correct LCPs are calculated</span>

<span class="normal">            </span><span class="comment">// this is called by radixsort when all items in [begin,end) have same char and type, remains to</span>
<span class="normal">            </span><span class="comment">// compare repcounts</span>
<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">subsort</span><span class="symbol">(</span><span class="usertype">Iterator</span><span class="normal"> begin</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">Iterator</span><span class="normal"> end</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK</span>
<span class="normal">                </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">Iterator</span><span class="normal"> x </span><span class="symbol">=</span><span class="normal"> begin</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span><span class="normal"> x </span><span class="symbol">!=</span><span class="normal"> end</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">x</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// all entries must have save type in the last character</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> ctype</span><span class="symbol">[</span><span class="normal"> begin</span><span class="symbol">-&gt;</span><span class="normal">offset </span><span class="symbol">+</span><span class="normal"> begin</span><span class="symbol">-&gt;</span><span class="normal">len</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> ctype</span><span class="symbol">[</span><span class="normal"> x</span><span class="symbol">-&gt;</span><span class="normal">offset </span><span class="symbol">+</span><span class="normal"> x</span><span class="symbol">-&gt;</span><span class="normal">len</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_SELF_CHECK</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> ctype</span><span class="symbol">[</span><span class="normal"> begin</span><span class="symbol">-&gt;</span><span class="normal">offset </span><span class="symbol">+</span><span class="normal"> begin</span><span class="symbol">-&gt;</span><span class="normal">len</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> TYPE_L </span><span class="symbol">)</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">begin</span><span class="symbol">,</span><span class="normal"> end</span><span class="symbol">,</span><span class="normal"> subsort_cmpL</span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">begin</span><span class="symbol">,</span><span class="normal"> end</span><span class="symbol">,</span><span class="normal"> subsort_cmpS</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="preproc">#else</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">subsort</span><span class="symbol">(</span><span class="normal">Iterator</span><span class="symbol">,</span><span class="normal"> Iterator</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="preproc">#endif</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/*</span>
<span class="comment">         * Serialization functional for serializing SubstringPtr into the VarlengthSorter. The serialization</span>
<span class="comment">         * is then read as a Substring object.</span>
<span class="comment">         */</span><span class="normal"> </span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">SubstringPtrWriter</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> baseoffset</span><span class="symbol">;</span><span class="normal">               </span><span class="comment">// offset of all substrings</span>
<span class="normal">            alphabet_type</span><span class="symbol">*</span><span class="normal"> buffer</span><span class="symbol">;</span><span class="normal">              </span><span class="comment">// the current portion of the input</span>
<span class="normal">            </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="symbol">*</span><span class="normal"> buffer_types</span><span class="symbol">;</span><span class="normal">        </span><span class="comment">// the character types of the current portion</span>

<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">ssorter_type</span><span class="symbol">::</span><span class="normal">buf_ostream_type</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> SubstringPtr</span><span class="symbol">&amp;</span><span class="normal"> sp</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// write offset_type index</span>
<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> index </span><span class="symbol">=</span><span class="normal"> baseoffset </span><span class="symbol">+</span><span class="normal"> sp</span><span class="symbol">.</span><span class="normal">offset</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">stream_put</span><span class="symbol">(</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> index </span><span class="symbol">);</span>

<span class="normal">                </span><span class="comment">// prepare ctype bit of last character</span>
<span class="normal">                </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="normal"> ctype </span><span class="symbol">=</span><span class="normal"> buffer_types</span><span class="symbol">[</span><span class="normal"> sp</span><span class="symbol">.</span><span class="normal">offset </span><span class="symbol">+</span><span class="normal"> sp</span><span class="symbol">.</span><span class="normal">len </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">];</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> ctype </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> ctype </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                </span><span class="comment">// write varint string size: first character contains ctype as second-highest bit</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> sp</span><span class="symbol">.</span><span class="normal">len </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                </span><span class="function">stream_put_varint</span><span class="symbol">(</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> sp</span><span class="symbol">.</span><span class="normal">len </span><span class="symbol">*</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> ctype </span><span class="symbol">);</span>

<span class="normal">                </span><span class="comment">// write varint S*-repcount</span>
<span class="normal">                </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal"> </span><span class="function">stream_put_varint</span><span class="symbol">(</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> sp</span><span class="symbol">.</span><span class="normal">endrepcount </span><span class="symbol">);</span><span class="normal"> </span><span class="symbol">)</span>

<span class="normal">                </span><span class="comment">// write string character-wise</span>
<span class="normal">                </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_type</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> sp</span><span class="symbol">.</span><span class="normal">offset</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> sp</span><span class="symbol">.</span><span class="normal">offset </span><span class="symbol">+</span><span class="normal"> sp</span><span class="symbol">.</span><span class="normal">len</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">stream_put</span><span class="symbol">(</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> buffer</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Left-over from experiments with 8-bit radixsort</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">RadixsortTransform1</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> </span><span class="function">limit</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> depth</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="number">0x100</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">index</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> SubstringPtr</span><span class="symbol">&amp;</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> depth</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> p</span><span class="symbol">.</span><span class="function">radixsort_index</span><span class="symbol">(</span><span class="normal">depth</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Left-over from experiments with 16-bit radixsort</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">RadixsortTransform2</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> </span><span class="function">limit</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> depth</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">depth </span><span class="symbol">%</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="symbol">(</span><span class="number">2</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="number">0x10000</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0x10000</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">index</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> SubstringPtr</span><span class="symbol">&amp;</span><span class="normal"> p</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> depth</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">depth </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> p</span><span class="symbol">.</span><span class="normal">len</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">depth </span><span class="symbol">%</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">p</span><span class="symbol">.</span><span class="normal">str</span><span class="symbol">[</span><span class="normal">depth </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0xFFFF</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> p</span><span class="symbol">.</span><span class="normal">ctypeptr</span><span class="symbol">[</span><span class="normal">depth </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">p</span><span class="symbol">.</span><span class="normal">str</span><span class="symbol">[</span><span class="normal">depth </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="number">16</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal"> </span><span class="number">0xFFFF</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Read input (in reverse) and split into S*- or split substrings.</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">queue&lt; uint16_t, block_size &gt;</span><span class="normal">         SStarSize_type</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">SStarSize_type</span><span class="normal">          SStarSize</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">        </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">InputStreamReverse</span><span class="symbol">&gt;</span>
<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">process_input</span><span class="symbol">(</span><span class="normal">InputStreamReverse</span><span class="symbol">&amp;</span><span class="normal"> inputrev</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> depth</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// *** First scan the input back to front to find all S* positions</span>

<span class="normal">            stxxl</span><span class="symbol">::</span><span class="usertype">queue&lt;offset_type,block_size&gt;</span><span class="normal">     sstar_positions</span><span class="symbol">;</span>

<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                inputrev</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">memsize</span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> spos </span><span class="symbol">=</span><span class="normal"> inputrev</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()-</span><span class="number">1</span><span class="symbol">;</span><span class="normal">   </span><span class="comment">// sentinel is not processed</span>
<span class="normal">                </span><span class="usertype">ctype_type</span><span class="normal"> prev_ctype </span><span class="symbol">=</span><span class="normal"> TYPE_L</span><span class="symbol">;</span><span class="normal">         </span><span class="comment">// last char is always L-type</span>
<span class="normal">                </span><span class="usertype">alphabet_type</span><span class="normal"> prev_char </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"input["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> spos </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"]: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">prev_char</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">(</span><span class="normal">prev_ctype</span><span class="symbol">));</span>

<span class="normal">                </span><span class="symbol">--</span><span class="normal">inputrev</span><span class="symbol">;</span>

<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> spos </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">inputrev</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="usertype">ctype_type</span><span class="normal"> this_ctype </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">inputrev </span><span class="symbol">&lt;</span><span class="normal"> prev_char </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">inputrev </span><span class="symbol">==</span><span class="normal"> prev_char </span><span class="symbol">&amp;&amp;</span><span class="normal"> prev_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_S</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> TYPE_S </span><span class="symbol">:</span><span class="normal"> TYPE_L</span><span class="symbol">;</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"input["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> spos</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"]: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(*</span><span class="normal">inputrev</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">(</span><span class="normal">this_ctype</span><span class="symbol">));</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prev_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_S </span><span class="symbol">&amp;&amp;</span><span class="normal"> this_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_L</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S* at position "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> spos</span><span class="symbol">);</span>

<span class="normal">                        sstar_positions</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">spos</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    prev_ctype </span><span class="symbol">=</span><span class="normal"> this_ctype</span><span class="symbol">;</span>
<span class="normal">                    prev_char </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>

<span class="normal">                    </span><span class="symbol">--</span><span class="normal">spos</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="symbol">--</span><span class="normal">inputrev</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Total S*-indexes in input: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sstar_positions</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                g_statscache </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="string">"S*-indexes"</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> depth </span><span class="symbol">&lt;&lt;</span><span class="normal"> sstar_positions</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// *** Rescan input from back to front and build substring (pointer,size) pairs</span>

<span class="normal">            inputrev</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// value for for block splitting: at most 64kb lengths (so length can be 2 bytes)</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> split_size </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">min</span><span class="symbol">&lt;</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="symbol">&gt;(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">uint16_t</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">(),</span><span class="normal">block_size</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// end pointer of current area</span>
<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> sarea_end </span><span class="symbol">=</span><span class="normal"> m_inputsize </span><span class="symbol">=</span><span class="normal"> inputrev</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span>

<span class="normal">            </span><span class="comment">// for each position of buffer at most one char, 1 ctype and a half-StringPtr are needed.</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">size_type</span><span class="normal"> per_substring_size </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">SubstringPtr</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>

<span class="normal">            </span><span class="comment">// for depth=0 we also need buffers for radixsort: K+1 * bucketsize + n * oracle_type</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">size_type</span><span class="normal"> buffersize </span><span class="symbol">=</span>
<span class="normal">                depth </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span>
<span class="normal">                </span><span class="symbol">?</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">SubstringPtrSort</span><span class="symbol">::</span><span class="normal">maxdepth</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> SubstringPtrSort</span><span class="symbol">::</span><span class="function">limit</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">))</span>
<span class="normal">                    </span><span class="symbol">/</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">per_substring_size </span><span class="symbol">+</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SubstringPtrSort</span><span class="symbol">::</span><span class="normal">oracle_type</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> memsize </span><span class="symbol">*</span><span class="normal"> </span><span class="number">3</span><span class="symbol">/</span><span class="number">4</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> per_substring_size </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Prior to S*-substring buffer allocation"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// temporary buffer for characters part of the current set of substrings</span>
<span class="normal">            </span><span class="usertype">membuffer&lt;alphabet_type&gt;</span><span class="normal"> </span><span class="function">buffer</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">buffersize</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// temporary buffer for types of characters of the current set of substrings</span>
<span class="normal">            </span><span class="usertype">membuffer&lt;unsigned char&gt;</span><span class="normal"> </span><span class="function">buffer_types</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">buffersize</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// pairs of (index,size) to sort split substrings in buffer</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">vector&lt; SubstringPtr &gt;</span><span class="normal"> substrings</span><span class="symbol">;</span>
<span class="normal">            substrings</span><span class="symbol">.</span><span class="function">reserve</span><span class="symbol">(</span><span class="normal"> buffersize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"After buffer allocation"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="usertype">ctype_type</span><span class="normal"> prev_ctype </span><span class="symbol">=</span><span class="normal"> TYPE_L</span><span class="symbol">;</span><span class="normal">     </span><span class="comment">// start with sentinel, but here label it L to skip sentinel S*-substring</span>
<span class="normal">            </span><span class="usertype">alphabet_type</span><span class="normal"> prev_char </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> sarea_pos </span><span class="symbol">=</span><span class="normal"> sarea_end</span><span class="symbol">;</span>

<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> total_substrings </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal">     </span><span class="comment">// total S*-substrings</span>

<span class="normal">            </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> overlap </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal">           </span><span class="comment">// carry-over characters from last portion of input</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> prev_sstar_repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> sarea_end </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstar_positions</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// fetch new input portion of size M</span>

<span class="normal">                </span><span class="usertype">size_type</span><span class="normal"> sarea_begin </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sarea_end </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">buffersize </span><span class="symbol">?</span><span class="normal"> sarea_end </span><span class="symbol">-</span><span class="normal"> buffersize </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">                </span><span class="usertype">size_type</span><span class="normal"> sarea_size </span><span class="symbol">=</span><span class="normal"> sarea_end </span><span class="symbol">-</span><span class="normal"> sarea_begin</span><span class="symbol">;</span>

<span class="normal">                </span><span class="comment">// copy overlap to end of area</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">overlap</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Copy overlap of "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> overlap </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" from beginning to end "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sarea_size</span><span class="symbol">);</span>

<span class="normal">                    std</span><span class="symbol">::</span><span class="function">copy</span><span class="symbol">(</span><span class="normal"> buffer</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> buffer</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> overlap</span><span class="symbol">,</span><span class="normal"> buffer</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> sarea_size </span><span class="symbol">-</span><span class="normal"> overlap </span><span class="symbol">);</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="function">copy</span><span class="symbol">(</span><span class="normal"> buffer_types</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> buffer_types</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> overlap</span><span class="symbol">,</span><span class="normal"> buffer_types</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> sarea_size </span><span class="symbol">-</span><span class="normal"> overlap </span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"working on M range = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sarea_begin </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" to "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sarea_end </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">", overlap "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> overlap</span><span class="symbol">);</span>

<span class="normal">                </span><span class="comment">// length of current string</span>
<span class="normal">                </span><span class="usertype">size_type</span><span class="normal"> currstringlength </span><span class="symbol">=</span><span class="normal"> overlap</span><span class="symbol">;</span>

<span class="normal">                </span><span class="comment">// total bytes that will be written in the end for this buffer</span>
<span class="normal">                </span><span class="usertype">size_type</span><span class="normal"> outputsize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">                substrings</span><span class="symbol">.</span><span class="function">clear</span><span class="symbol">();</span>

<span class="normal">                </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_type</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> sarea_size </span><span class="symbol">-</span><span class="normal"> overlap</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstar_positions</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="symbol">--</span><span class="normal">i</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">--</span><span class="normal">sarea_pos</span><span class="symbol">;</span>

<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> sarea_pos </span><span class="symbol">==</span><span class="normal"> sarea_begin</span><span class="symbol">+</span><span class="normal">i </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="comment">// read next character</span>
<span class="normal">                    buffer</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="symbol">--</span><span class="normal">inputrev</span><span class="symbol">;</span>

<span class="normal">                    currstringlength</span><span class="symbol">++;</span>

<span class="normal">                    </span><span class="usertype">ctype_type</span><span class="normal"> this_ctype </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">buffer</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> prev_char </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">buffer</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> prev_char </span><span class="symbol">&amp;&amp;</span><span class="normal"> prev_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_S</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> TYPE_S </span><span class="symbol">:</span><span class="normal"> TYPE_L</span><span class="symbol">;</span>
<span class="normal">                    buffer_types</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> this_ctype</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                    repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">buffer</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> prev_char</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"next input: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal"> buffer</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" at "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sarea_begin </span><span class="symbol">+</span><span class="normal"> i </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" of ctype "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">(</span><span class="normal">this_ctype</span><span class="symbol">)</span>
<span class="normal">                        </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(&lt;&lt;</span><span class="normal"> </span><span class="string">" with repcount "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> repcount</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and S*-distance: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sarea_pos </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">sstar_positions</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">()));</span>

<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> sarea_pos </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">sstar_positions</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sarea_pos </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">sstar_positions</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">%</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">split_size</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="comment">// S* or block splitting boundary</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="comment">// split at S*-position or block boundary</span>

<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sarea_pos </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">sstar_positions</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">())</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG1</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S*-substr: "</span><span class="symbol">);</span>
<span class="normal">                            sstar_positions</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="keyword">else</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG1</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"block-split: "</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">currstringlength </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="comment">// save for LCP_S* calculation - deduct overlapping (usually S*) position at end,</span>
<span class="normal">                        </span><span class="comment">// except for first tuple where the S* sentinel is only virtual.</span>
<span class="normal">                        SStarSize</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">currstringlength </span><span class="symbol">-</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">total_substrings </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">1</span><span class="symbol">));</span>
<span class="preproc">#endif</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> currstringlength </span><span class="symbol">&lt;=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">uint16_t</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                        substrings</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal"> </span><span class="function">SubstringPtr</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">,</span><span class="normal"> currstringlength</span><span class="symbol">,</span><span class="normal"> prev_sstar_repcount</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                        outputsize </span><span class="symbol">+=</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">offset_type</span><span class="symbol">)</span>
<span class="normal">                            </span><span class="symbol">+</span><span class="normal"> </span><span class="function">sizeof_varint</span><span class="symbol">(</span><span class="normal">currstringlength</span><span class="symbol">*</span><span class="number">2</span><span class="symbol">)</span>
<span class="normal">                            </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(+</span><span class="normal"> </span><span class="function">sizeof_varint</span><span class="symbol">(</span><span class="normal">prev_sstar_repcount</span><span class="symbol">))</span>
<span class="normal">                            </span><span class="symbol">+</span><span class="normal"> currstringlength </span><span class="symbol">*</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">);</span>

<span class="normal">                        </span><span class="symbol">++</span><span class="normal">total_substrings</span><span class="symbol">;</span>

<span class="normal">                        </span><span class="function">DBG2</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span>
<span class="normal">                             i </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" = ["</span><span class="normal">  </span><span class="symbol">&lt;&lt;</span><span class="normal"> sarea_pos </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sarea_pos </span><span class="symbol">+</span><span class="normal"> currstringlength </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") = "</span>
<span class="normal">                             </span><span class="symbol">&lt;&lt;</span><span class="normal"> substrings</span><span class="symbol">.</span><span class="function">back</span><span class="symbol">().</span><span class="function">getSubstring</span><span class="symbol">(</span><span class="normal">sarea_pos</span><span class="symbol">,</span><span class="normal">buffer</span><span class="symbol">.</span><span class="function">data</span><span class="symbol">(),</span><span class="normal">buffer_types</span><span class="symbol">.</span><span class="function">data</span><span class="symbol">())</span>
<span class="normal">                             </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(&lt;&lt;</span><span class="normal"> </span><span class="string">" with sstar_repcount="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prev_sstar_repcount</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">);</span>

<span class="normal">                        currstringlength </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal"> prev_sstar_repcount </span><span class="symbol">=</span><span class="normal"> repcount</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    prev_char </span><span class="symbol">=</span><span class="normal"> buffer</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">];</span>
<span class="normal">                    prev_ctype </span><span class="symbol">=</span><span class="normal"> this_ctype</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> substrings</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;=</span><span class="normal"> buffersize</span><span class="symbol">/</span><span class="number">2</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Remaining: ["</span><span class="normal">  </span><span class="symbol">&lt;&lt;</span><span class="normal"> sarea_begin </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sarea_begin </span><span class="symbol">+</span><span class="normal"> currstringlength </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") = "</span>
<span class="normal">                    </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strS</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">buffer</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">],</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">buffer</span><span class="symbol">[</span><span class="normal">currstringlength</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">));</span>

<span class="normal">                </span><span class="comment">// *** Sort SubstringPtr using radix or quicksort</span>

<span class="normal">                </span><span class="usertype">SubstringPtrSort</span><span class="normal"> </span><span class="function">sorter</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">buffer</span><span class="symbol">.</span><span class="function">data</span><span class="symbol">(),</span><span class="normal"> buffer_types</span><span class="symbol">.</span><span class="function">data</span><span class="symbol">());</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="function">radixsort_transform_oracle</span><span class="symbol">(</span><span class="normal"> substrings</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> substrings</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> sorter </span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="function">sort</span><span class="symbol">(</span><span class="normal"> substrings</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> substrings</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> sorter </span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">ESAIS_SELF_CHECK</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">)</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// !ESAIS_SELF_CHECK</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">Substring</span><span class="normal"> prev </span><span class="symbol">=</span><span class="normal"> substrings</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">].</span><span class="function">getSubstring</span><span class="symbol">(</span><span class="normal">sarea_pos</span><span class="symbol">,</span><span class="normal">buffer</span><span class="symbol">.</span><span class="function">data</span><span class="symbol">(),</span><span class="normal">buffer_types</span><span class="symbol">.</span><span class="function">data</span><span class="symbol">());</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"substr: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prev</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> substrings</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="usertype">Substring</span><span class="normal"> curr </span><span class="symbol">=</span><span class="normal"> substrings</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">].</span><span class="function">getSubstring</span><span class="symbol">(</span><span class="normal">sarea_pos</span><span class="symbol">,</span><span class="normal">buffer</span><span class="symbol">.</span><span class="function">data</span><span class="symbol">(),</span><span class="normal">buffer_types</span><span class="symbol">.</span><span class="function">data</span><span class="symbol">());</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"substr: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> curr</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!(</span><span class="normal">prev </span><span class="symbol">&lt;=</span><span class="normal"> curr</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"WRONG substring order!"</span><span class="symbol">);</span>
<span class="normal">                        prev </span><span class="symbol">=</span><span class="normal"> curr</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="comment">// at least one zero string at the end</span>
<span class="normal">                outputsize </span><span class="symbol">+=</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">offset_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">4</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"outputsize = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> outputsize</span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">SubstringPtrWriter</span><span class="normal"> spw</span><span class="symbol">;</span>
<span class="normal">                spw</span><span class="symbol">.</span><span class="normal">baseoffset </span><span class="symbol">=</span><span class="normal"> sarea_begin</span><span class="symbol">;</span>
<span class="normal">                spw</span><span class="symbol">.</span><span class="normal">buffer </span><span class="symbol">=</span><span class="normal"> buffer</span><span class="symbol">.</span><span class="function">data</span><span class="symbol">();</span>
<span class="normal">                spw</span><span class="symbol">.</span><span class="normal">buffer_types </span><span class="symbol">=</span><span class="normal"> buffer_types</span><span class="symbol">.</span><span class="function">data</span><span class="symbol">();</span>
<span class="normal">                m_ssorter</span><span class="symbol">.</span><span class="function">write</span><span class="symbol">(</span><span class="normal"> outputsize</span><span class="symbol">,</span><span class="normal"> substrings</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> substrings</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> spw </span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Reading new buffer of size M"</span><span class="symbol">);</span>

<span class="normal">                overlap </span><span class="symbol">=</span><span class="normal"> currstringlength</span><span class="symbol">;</span>
<span class="normal">                sarea_end </span><span class="symbol">=</span><span class="normal"> sarea_begin </span><span class="symbol">+</span><span class="normal"> overlap</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">//assert(inputrev.empty());</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">sstar_positions</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">());</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Total number of substrings "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> total_substrings</span><span class="symbol">);</span>

<span class="normal">            inputrev</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">protected</span><span class="symbol">:</span>

<span class="normal">        </span><span class="comment">/// flag whether every name was unique</span>
<span class="normal">        </span><span class="type">bool</span><span class="normal">                    m_was_unique</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// total number of indexed substring positions</span>
<span class="normal">        </span><span class="usertype">size_type</span><span class="normal">               m_totalsize</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// number of substrings that are duplicates</span>
<span class="normal">        </span><span class="usertype">size_type</span><span class="normal">               m_duplicates</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="comment">/// Save LCP_Names, the LCP of two consecutive lexnames, for answering RMQs later. One would expect</span>
<span class="normal">        </span><span class="comment">/// this to be only uint16_t, but due to repcount being included in the LCP, we actually need an</span>
<span class="normal">        </span><span class="comment">/// offset_type.</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">deque2&lt; offset_type, block_size &gt;</span><span class="normal">         lcp_deque_type</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">lcp_deque_type</span><span class="normal">          lexname_lcp_deque</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Read sorted sequences, merge using loser tree and create lexname pairs (index,name)</span>

<span class="normal">        </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">OutputNameTupleStream</span><span class="symbol">&gt;</span>
<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">merge</span><span class="symbol">(</span><span class="normal">OutputNameTupleStream</span><span class="symbol">&amp;</span><span class="normal"> outputnametuples</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            m_ssorter</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">();</span>

<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> name </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            m_was_unique </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">            m_totalsize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            m_duplicates </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m_ssorter</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span><span class="normal"> </span><span class="keyword">return</span><span class="symbol">;</span>

<span class="normal">            </span><span class="comment">// initialize prev variable with first item</span>

<span class="normal">            </span><span class="usertype">Substring</span><span class="normal"> prevstring </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">m_ssorter</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">NameTuple</span><span class="normal"> </span><span class="function">prevtuple</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prevstring</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">,</span><span class="normal"> name</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="normal">            prevtuple</span><span class="symbol">.</span><span class="normal">unique </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">// !ESAIS_DISCARD_UNIQUES</span>
<span class="normal">            </span><span class="type">bool</span><span class="normal"> prevunique </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span><span class="normal">    </span><span class="comment">// for counting duplicates and uniques</span>
<span class="preproc">#endif</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal"> prevlcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            lexname_lcp_deque</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">);</span><span class="normal">     </span><span class="comment">// actually undefined</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            </span><span class="symbol">++</span><span class="normal">m_totalsize</span><span class="symbol">;</span>
<span class="normal">            </span><span class="symbol">++</span><span class="normal">m_ssorter</span><span class="symbol">;</span>

<span class="normal">            </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">m_ssorter</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                Substring</span><span class="symbol">&amp;</span><span class="normal"> topstr </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">m_ssorter</span><span class="symbol">;</span>

<span class="normal">                </span><span class="comment">// check order of strings extracted from sorter</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> prevstring</span><span class="symbol">.</span><span class="function">cmp</span><span class="symbol">(</span><span class="normal">topstr</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                </span><span class="comment">// check if this string is different from last one.</span>
<span class="normal">                </span><span class="type">bool</span><span class="normal"> is_different </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> m_ssorter</span><span class="symbol">.</span><span class="function">was_equal</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// comparison not necessary: prev and this are equal by comparision within loser tree</span>
<span class="normal">                    is_different </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal"> lcp </span><span class="symbol">=</span><span class="normal"> topstr</span><span class="symbol">.</span><span class="normal">str</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> topstr</span><span class="symbol">.</span><span class="normal">endrepcount </span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">ESAIS_LCP_CALC</span>
<span class="normal">                    is_different </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> prevstring</span><span class="symbol">.</span><span class="function">cmp</span><span class="symbol">(</span><span class="normal">topstr</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">);</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">                    is_different </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> prevstring</span><span class="symbol">.</span><span class="function">cmp</span><span class="symbol">(</span><span class="normal">topstr</span><span class="symbol">,</span><span class="normal"> lcp</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">);</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal"> lexname_lcp_deque</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">lcp</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span><span class="normal">       </span><span class="comment">// save lcp in lexname order</span>

<span class="normal">                </span><span class="comment">// select name or update unique flags</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">is_different</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="normal">                    name </span><span class="symbol">=</span><span class="normal"> m_totalsize</span><span class="symbol">;</span><span class="normal">            </span><span class="comment">// select next name</span>
<span class="preproc">#else</span>
<span class="normal">                    name</span><span class="symbol">++;</span>
<span class="preproc">#endif</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    m_was_unique </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span><span class="normal">                       </span><span class="comment">// global unique flag</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="normal">                    m_duplicates</span><span class="symbol">++;</span><span class="normal">                             </span><span class="comment">// this one is a duplicate</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prevtuple</span><span class="symbol">.</span><span class="normal">unique</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">m_duplicates</span><span class="symbol">;</span><span class="normal">       </span><span class="comment">// one unique less.</span>
<span class="normal">                    prevtuple</span><span class="symbol">.</span><span class="normal">unique </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span><span class="normal">                   </span><span class="comment">// mark previous item as duplicate to this one</span>
<span class="preproc">#else</span>
<span class="normal">                    m_duplicates</span><span class="symbol">++;</span><span class="normal">                             </span><span class="comment">// this one is a duplicate</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prevunique</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">m_duplicates</span><span class="symbol">;</span><span class="normal">             </span><span class="comment">// one unique less.</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_DISCARD_UNIQUES</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="comment">// push previous tuple</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevtuple </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - substring = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevstring</span>
<span class="normal">                    </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(&lt;&lt;</span><span class="normal"> </span><span class="string">" with lcp "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevlcp</span><span class="symbol">));</span>
<span class="normal">                outputnametuples</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> prevtuple </span><span class="symbol">);</span>

<span class="normal">                </span><span class="comment">// create next tuple from current string</span>
<span class="normal">                prevtuple </span><span class="symbol">=</span><span class="normal"> </span><span class="function">NameTuple</span><span class="symbol">(</span><span class="normal">topstr</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">,</span><span class="normal"> name</span><span class="symbol">);</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="normal">                prevtuple</span><span class="symbol">.</span><span class="normal">unique </span><span class="symbol">=</span><span class="normal"> is_different</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_DISCARD_UNIQUES</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                prevlcp </span><span class="symbol">=</span><span class="normal"> lcp</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">                </span><span class="comment">// advance</span>
<span class="normal">                m_totalsize</span><span class="symbol">++;</span>
<span class="normal">                prevstring</span><span class="symbol">.</span><span class="function">swap</span><span class="symbol">(</span><span class="normal">topstr</span><span class="symbol">);</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">ESAIS_DISCARD_UNIQUES</span>
<span class="normal">                prevunique </span><span class="symbol">=</span><span class="normal"> is_different</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// !ESAIS_DISCARD_UNIQUES</span>

<span class="normal">                </span><span class="symbol">++</span><span class="normal">m_ssorter</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m_totalsize </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_substring_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevtuple </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - substring = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevstring</span>
<span class="normal">                    </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(&lt;&lt;</span><span class="normal"> </span><span class="string">" with lcp "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevlcp</span><span class="symbol">));</span>
<span class="normal">                outputnametuples</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> prevtuple </span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            m_ssorter</span><span class="symbol">.</span><span class="function">clear</span><span class="symbol">();</span><span class="normal">  </span><span class="comment">// free memory and allocated blocks</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">bool</span><span class="normal"> </span><span class="function">was_unique</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_was_unique</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="usertype">size_type</span><span class="normal"> </span><span class="function">totalsize</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_totalsize</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="usertype">size_type</span><span class="normal"> </span><span class="function">duplicates</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_duplicates</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// }}}</span>

<span class="normal">    </span><span class="comment">// *******************************************************************************************************</span>
<span class="normal">    </span><span class="comment">// *** Step 4: Inducing the SA using a PQ</span>

<span class="normal">    </span><span class="comment">// {{{ Induce Result Structure: Form a Suffix Array using Queue and Stack</span>

<span class="normal">    </span><span class="comment">/* eSAIS's induce step outputs all L-type chars followed by all S-type chars due to the different induce</span>
<span class="comment">      orders. The result object is used to merge these streams of different types back together into a</span>
<span class="comment">      consequtive suffix array. However, since there are no bucket counters as the alphabet can be very large,</span>
<span class="comment">      the two streams L-type and S-types are saved indepdendent from another into a queue and stack,</span>
<span class="comment">      respectively. Also recorded are the number of L-types of the same character, and which character that</span>
<span class="comment">      is. In the output phase, the queue and stack are merged by character yielding the consecutive suffix</span>
<span class="comment">      array. The lcp value is stored along each suffix array index if calculated.</span>
<span class="comment">     */</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">Result</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">        </span><span class="comment">/// represents a "run" of suffix array indexes starting with the same character in the output.</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> std</span><span class="symbol">::</span><span class="usertype">pair&lt;alphabet_type, offset_type&gt;</span><span class="normal">           result_run_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">queue&lt; offset_type, block_size &gt;</span><span class="normal">         Lresult_queue_type</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">queue&lt; result_run_type, block_size &gt;</span><span class="normal">     Lresult_run_queue_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">stxxl</span><span class="symbol">::</span><span class="normal">STACK_GENERATOR</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">,</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="normal">external</span><span class="symbol">,</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="normal">grow_shrink</span><span class="symbol">,</span><span class="normal"> </span><span class="number">4</span><span class="symbol">,</span><span class="normal"> block_size</span><span class="symbol">&gt;::</span><span class="usertype">result</span><span class="normal"> Sresult_stack_type</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">stxxl</span><span class="symbol">::</span><span class="normal">STACK_GENERATOR</span><span class="symbol">&lt;</span><span class="normal">result_run_type</span><span class="symbol">,</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="normal">external</span><span class="symbol">,</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="normal">grow_shrink</span><span class="symbol">,</span><span class="normal"> </span><span class="number">4</span><span class="symbol">,</span><span class="normal"> block_size</span><span class="symbol">&gt;::</span><span class="usertype">result</span><span class="normal"> Sresult_run_stack_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="usertype">Lresult_queue_type</span><span class="normal">              Lqueue</span><span class="symbol">;</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="usertype">Lresult_queue_type</span><span class="normal">              Lqueue_lcp</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="usertype">Lresult_run_queue_type</span><span class="normal">          Lrun_queue</span><span class="symbol">;</span>

<span class="normal">        </span><span class="usertype">Sresult_stack_type</span><span class="normal">              Sstack</span><span class="symbol">;</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="usertype">Sresult_stack_type</span><span class="normal">              Sstack_lcp</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="usertype">Sresult_run_stack_type</span><span class="normal">          Srun_stack</span><span class="symbol">;</span>

<span class="normal">        </span><span class="usertype">ctype_type</span><span class="normal">                      LSstate</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">size_type</span><span class="normal">                       LScounter</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Input into Queue or Stack</span>

<span class="normal">    </span><span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">        </span><span class="comment">// Counter for output number</span>
<span class="normal">        </span><span class="usertype">size_type</span><span class="normal">           output_count</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">alphabet_type</span><span class="normal">       output_char</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">        </span><span class="function">Result</span><span class="symbol">()</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">output_count</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">),</span><span class="normal"> </span><span class="function">output_char</span><span class="symbol">(</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">output_Lentry</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> alphabet_type</span><span class="symbol">&amp;</span><span class="normal"> char0</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> index</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_write</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"L-SAEntry: char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">char0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" index "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> index</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// save index into Lresult queue and if needed the size of the previous sequence</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">output_char </span><span class="symbol">!=</span><span class="normal"> char0</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">output_count </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">                    Lrun_queue</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">result_run_type</span><span class="symbol">(</span><span class="normal">output_char</span><span class="symbol">,</span><span class="normal">output_count</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                output_char </span><span class="symbol">=</span><span class="normal"> char0</span><span class="symbol">;</span>
<span class="normal">                output_count </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            Lqueue</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">index</span><span class="symbol">);</span>
<span class="normal">            output_count</span><span class="symbol">++;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">output_Lentry_lcp</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> lcp</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_write</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"L-LCPEntry: lcp "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> lcp</span><span class="symbol">);</span>
<span class="normal">            Lqueue_lcp</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">lcp</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">finish_Lsequence</span><span class="symbol">()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// no string can contain no L-types</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> output_count </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">            Lrun_queue</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">result_run_type</span><span class="symbol">(</span><span class="normal">output_char</span><span class="symbol">,</span><span class="normal">output_count</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            output_count </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            output_char </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">output_Sentry</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> alphabet_type</span><span class="symbol">&amp;</span><span class="normal"> char0</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> index</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_write</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-SAEntry: char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">char0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" index "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> index</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// save index into Sresult stack and if needed the size of the previous sequence</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">output_char </span><span class="symbol">!=</span><span class="normal"> char0</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">output_count </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">                    Srun_stack</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">result_run_type</span><span class="symbol">(</span><span class="normal">output_char</span><span class="symbol">,</span><span class="normal"> output_count</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                output_char </span><span class="symbol">=</span><span class="normal"> char0</span><span class="symbol">;</span>
<span class="normal">                output_count </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            Sstack</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">index</span><span class="symbol">);</span>
<span class="normal">            output_count</span><span class="symbol">++;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">output_Sentry_lcp</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> lcp</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_write</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-LCPEntry: lcp "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> lcp</span><span class="symbol">);</span>
<span class="normal">            Sstack_lcp</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">lcp</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">finish_Ssequence</span><span class="symbol">()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> output_count </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="comment">// A string can actually contain no S-chars: 'aaaa'</span>
<span class="normal">                Srun_stack</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">result_run_type</span><span class="symbol">(</span><span class="normal">output_char</span><span class="symbol">,</span><span class="normal">output_count</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// initialize output sequence</span>
<span class="normal">            LScounter </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">operator</span><span class="symbol">++();</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Output SA by alternating between Lqueue and Sstack</span>

<span class="normal">        Result</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">LScounter </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal">   </span><span class="comment">// remove current item</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                LScounter</span><span class="symbol">--;</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                </span><span class="symbol">(</span><span class="normal">LSstate </span><span class="symbol">==</span><span class="normal"> TYPE_L</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">Lqueue</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">(),</span><span class="normal"> Lqueue_lcp</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">Sstack</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">(),</span><span class="normal"> Sstack_lcp</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">());</span>
<span class="preproc">#else</span>
<span class="normal">                </span><span class="symbol">(</span><span class="normal">LSstate </span><span class="symbol">==</span><span class="normal"> TYPE_L</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> Lqueue</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> Sstack</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">LScounter </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> Lrun_queue</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> Srun_stack</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> Lqueue</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> Sstack</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> Lqueue_lcp</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> Sstack_lcp</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"very empty"</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="comment">// empty</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> Srun_stack</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Finishing L-sequence of char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">Lrun_queue</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">first</span><span class="symbol">)</span>
<span class="normal">                        </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" of length "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lrun_queue</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">second</span><span class="symbol">);</span>

<span class="normal">                    LScounter </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">Lrun_queue</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">second</span><span class="symbol">;</span>
<span class="normal">                    Lrun_queue</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">                    LSstate </span><span class="symbol">=</span><span class="normal"> TYPE_L</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> Lrun_queue</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Finishing S-sequence of char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">Srun_stack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">first</span><span class="symbol">)</span>
<span class="normal">                        </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" of length "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Srun_stack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">second</span><span class="symbol">);</span>

<span class="normal">                    LScounter </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">Srun_stack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">second</span><span class="symbol">;</span>
<span class="normal">                    Srun_stack</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">                    LSstate </span><span class="symbol">=</span><span class="normal"> TYPE_S</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> Lrun_queue</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">first </span><span class="symbol">&lt;=</span><span class="normal"> Srun_stack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">first </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Switching to L-sequence of char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">Lrun_queue</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">first</span><span class="symbol">)</span>
<span class="normal">                        </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" of length "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lrun_queue</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">second</span><span class="symbol">);</span>

<span class="normal">                    LScounter </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">Lrun_queue</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">().</span><span class="normal">second</span><span class="symbol">;</span>
<span class="normal">                    Lrun_queue</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">                    LSstate </span><span class="symbol">=</span><span class="normal"> TYPE_L</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Switching to S-sequence of char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">Srun_stack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">first</span><span class="symbol">)</span>
<span class="normal">                        </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" of length "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Srun_stack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">second</span><span class="symbol">);</span>

<span class="normal">                    LScounter </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">Srun_stack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">second</span><span class="symbol">;</span>
<span class="normal">                    Srun_stack</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">                    LSstate </span><span class="symbol">=</span><span class="normal"> TYPE_S</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">bool</span><span class="normal"> </span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">Lqueue</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> Sstack</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">());</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal">     value_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">*()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">LScounter </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">LSstate </span><span class="symbol">==</span><span class="normal"> TYPE_L</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"SA: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lqueue</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">());</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> Lqueue</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">();</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"SA: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Sstack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">());</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> Sstack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">();</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">lcp</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">LScounter </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">LSstate </span><span class="symbol">==</span><span class="normal"> TYPE_L</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lqueue_lcp</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">());</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> Lqueue_lcp</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">();</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_output_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Sstack_lcp</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">());</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> Sstack_lcp</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">();</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// }}} Induce Result Structure: Array</span>

<span class="normal">    </span><span class="comment">// {{{ Induce SA using PQ</span>

<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">Induce</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">        </span><span class="comment">// memsize divisors for induce() phase depends on extra LCP information:</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> mempartL </span><span class="symbol">=</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> mempartS </span><span class="symbol">=</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">7</span><span class="symbol">;</span>
<span class="preproc">#else</span>
<span class="normal">        </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> mempartL </span><span class="symbol">=</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">6</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> mempartS </span><span class="symbol">=</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">5</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">        </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal"> </span><span class="function">lcp_unknown</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Tuples and Comparator for the L-PQ and S-PQ</span>

<span class="normal">        </span><span class="comment">/// Continuation tuple -- both L-Array and S-Array contain CTuples</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">CTuple</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         index</span><span class="symbol">;</span><span class="normal">          </span><span class="comment">// i</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         repcount</span><span class="symbol">;</span><span class="normal">       </span><span class="comment">// repetition counter</span>
<span class="normal">            </span><span class="usertype">alphabet_type</span><span class="normal">	chars</span><span class="symbol">[</span><span class="normal">D</span><span class="symbol">];</span><span class="normal">	</span><span class="comment">// T[i,i-1,...,i-D+1]</span>
<span class="normal">            </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="normal">       charfill </span><span class="symbol">:</span><span class="normal"> </span><span class="number">7</span><span class="symbol">;</span>
<span class="normal">            </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="normal">       continued </span><span class="symbol">:</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">description</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(index,chars,continued,repcount)"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">friend</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> CTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">",["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strS</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars </span><span class="symbol">+</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"],"</span>
<span class="normal">                          </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">continued </span><span class="symbol">?</span><span class="normal"> </span><span class="string">'C'</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="string">'_'</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="normal"> </span><span class="function">__attribute__</span><span class="symbol">((</span><span class="normal">packed</span><span class="symbol">));</span>

<span class="normal">        </span><span class="comment">/// Order continuation tuples in L-Array by (chars[0] ASC, repcount ASC, index ASC)</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">CTupleOrder_LArray</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> CTuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> CTuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">repcount</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">repcount</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">CTuple</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">CTuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">CTuple</span><span class="normal"> </span><span class="function">max_value</span><span class="symbol">()</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">CTuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Order continuation tuples in S-Array by (chars[0] DESC, repcount ASC, index ASC)</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">CTupleOrder_SArray</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> CTuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> CTuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">repcount</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">repcount</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">CTuple</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">CTuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">CTuple</span><span class="normal"> </span><span class="function">max_value</span><span class="symbol">()</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">CTuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Tuples of the S*-Array</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">STuple</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         index</span><span class="symbol">;</span><span class="normal">          </span><span class="comment">// i</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         rank</span><span class="symbol">;</span><span class="normal">		</span><span class="comment">// ISA[i+1]</span>
<span class="normal">            </span><span class="usertype">alphabet_type</span><span class="normal">       chars</span><span class="symbol">[</span><span class="normal">D</span><span class="symbol">];</span><span class="normal">       </span><span class="comment">// T[i,i-1,...,i-D+1]</span>
<span class="normal">            </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="normal">       charfill </span><span class="symbol">:</span><span class="normal"> </span><span class="number">7</span><span class="symbol">;</span>
<span class="normal">            </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="normal">       continued </span><span class="symbol">:</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// must look for continuation tuple when charfill=1</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         repcount</span><span class="symbol">;</span><span class="normal">       </span><span class="comment">// repetition count of char[0], the S*-index (zero for first char)</span>
<span class="preproc">#endif</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">description</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(index,chars,rank,continued"</span><span class="normal"> </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(&lt;&lt;</span><span class="normal"> </span><span class="string">",repcount"</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">friend</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> STuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index</span>
<span class="normal">                          </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">",["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strS</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars </span><span class="symbol">+</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"],"</span>
<span class="normal">                          </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">continued </span><span class="symbol">?</span><span class="normal"> </span><span class="string">'C'</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="string">'_'</span><span class="symbol">)</span>
<span class="normal">                          </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">)</span>
<span class="normal">                          </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="cbracket">}</span><span class="normal"> </span><span class="function">__attribute__</span><span class="symbol">((</span><span class="normal">packed</span><span class="symbol">));</span>

<span class="normal">        </span><span class="comment">/// Order seed tuples in S*-Array by (chars[0] ASC, rank ASC, index ASC)</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">STupleOrder_SStarArray</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> STuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> STuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">STuple</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">STuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">STuple</span><span class="normal"> </span><span class="function">max_value</span><span class="symbol">()</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">STuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Tuples of the L-PQ and S-PQ, and of the L*-Array</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">PQTuple</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         index</span><span class="symbol">;</span><span class="normal">          </span><span class="comment">// i</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         rank</span><span class="symbol">;</span><span class="normal">		</span><span class="comment">// ISA[i+1]</span>
<span class="normal">            </span><span class="usertype">alphabet_type</span><span class="normal">	chars</span><span class="symbol">[</span><span class="normal">D</span><span class="symbol">];</span><span class="normal">	</span><span class="comment">// T[i,i-1,...,i-D+1]</span>
<span class="normal">            </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="normal">       charfill </span><span class="symbol">:</span><span class="normal"> </span><span class="number">7</span><span class="symbol">;</span>
<span class="normal">            </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="normal">       continued </span><span class="symbol">:</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// must look for continuation tuple when charfill=1</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         lcp</span><span class="symbol">;</span><span class="normal">            </span><span class="comment">// lcp precalculated or max() if unknown</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_INT</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">PQTuple</span><span class="normal"> </span><span class="function">fromCTuple</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> CTuple</span><span class="symbol">&amp;</span><span class="normal"> ct</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">PQTuple</span><span class="normal"> pt</span><span class="symbol">;</span>
<span class="normal">                pt</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> ct</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">;</span>
<span class="preproc">#ifndef</span><span class="normal"> NDEBUG</span>
<span class="normal">                pt</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">-</span><span class="number">1</span><span class="symbol">;</span>
<span class="preproc">#endif</span>
<span class="normal">                </span><span class="function">memcpy</span><span class="symbol">(</span><span class="normal">pt</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">,</span><span class="normal"> ct</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">,</span><span class="normal"> ct</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">*</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">));</span>
<span class="normal">                pt</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">=</span><span class="normal"> ct</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">;</span>
<span class="normal">                pt</span><span class="symbol">.</span><span class="normal">continued </span><span class="symbol">=</span><span class="normal"> ct</span><span class="symbol">.</span><span class="normal">continued</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> pt</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">PQTuple</span><span class="normal"> </span><span class="function">fromSTuple</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> STuple</span><span class="symbol">&amp;</span><span class="normal"> st</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">PQTuple</span><span class="normal"> pt</span><span class="symbol">;</span>
<span class="normal">                pt</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> st</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">;</span>
<span class="normal">                pt</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> st</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">memcpy</span><span class="symbol">(</span><span class="normal">pt</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">,</span><span class="normal"> st</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">,</span><span class="normal"> st</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">*</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">));</span>
<span class="normal">                pt</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">=</span><span class="normal"> st</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">;</span>
<span class="normal">                pt</span><span class="symbol">.</span><span class="normal">continued </span><span class="symbol">=</span><span class="normal"> st</span><span class="symbol">.</span><span class="normal">continued</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">ESAIS_LCP_CALCX_INT</span><span class="symbol">(</span><span class="normal"> pt</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="function">lcp_unknown</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> pt</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">description</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(index,chars,rank,continued"</span><span class="normal"> </span><span class="function">ESAIS_LCP_CALCX_INT</span><span class="symbol">(&lt;&lt;</span><span class="normal"> </span><span class="string">",lcp"</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">friend</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> PQTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index</span>
<span class="normal">                   </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">",["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strS</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars </span><span class="symbol">+</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"],"</span>
<span class="normal">                   </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span>
<span class="normal">                   </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">continued </span><span class="symbol">?</span><span class="normal"> </span><span class="string">'C'</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="string">'_'</span><span class="symbol">);</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">!=</span><span class="normal"> </span><span class="function">lcp_unknown</span><span class="symbol">())</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">",lcp="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">;</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">",nolcp"</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_INT</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">decrease</span><span class="symbol">()</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> charfill </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                </span><span class="symbol">--</span><span class="normal">index</span><span class="symbol">;</span>
<span class="normal">                </span><span class="symbol">--</span><span class="normal">charfill</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> charfill</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    chars</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> chars</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">];</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="normal"> </span><span class="function">__attribute__</span><span class="symbol">((</span><span class="normal">packed</span><span class="symbol">));</span>

<span class="normal">        </span><span class="comment">/// Order items in L-PQ by (chars[0] DESC, star DESC, rank DESC, index DESC) as PQ picks smallest element</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">PQTupleOrder_LPQ</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> PQTuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> PQTuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="usertype">PQTuple</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">PQTuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Order items in S-PQ by (chars[0] ASC, star DESC, rank DESC, index DESC) as PQ picks smallest element</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">PQTupleOrder_SPQ</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> PQTuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> PQTuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="usertype">PQTuple</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">PQTuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Order items in L*-Array by (chars[0] DESC, rank DESC, index ASC)</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">PQTupleOrder_LStarArray</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> PQTuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> PQTuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">)</span>
<span class="normal">                            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">);</span>

<span class="normal">                        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="usertype">PQTuple</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">PQTuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="usertype">PQTuple</span><span class="normal"> </span><span class="function">max_value</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">PQTuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0x3F</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Tuples in continuation buffers, they are accumulated, sorted and merged with the L/S-Array</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">CBufferTuple</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         index</span><span class="symbol">;</span><span class="normal">          </span><span class="comment">// i</span>
<span class="preproc">#ifndef</span><span class="normal"> NDEBUG</span>
<span class="normal">            </span><span class="usertype">alphabet_type</span><span class="normal">       char0</span><span class="symbol">;</span><span class="normal">          </span><span class="comment">// chars[0] from discontinued tuple</span>
<span class="preproc">#endif</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         rank</span><span class="symbol">;</span><span class="normal">           </span><span class="comment">// rank[i+1]</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         lcp</span><span class="symbol">;</span><span class="normal">            </span><span class="comment">// have lcp precalculated - use max() as sentinel</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_INT</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">CBufferTuple</span><span class="normal"> </span><span class="function">fromPQTuple</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> PQTuple</span><span class="symbol">&amp;</span><span class="normal"> pt</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">CBufferTuple</span><span class="normal"> ct</span><span class="symbol">;</span>
<span class="normal">                ct</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> pt</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">;</span>
<span class="preproc">#ifndef</span><span class="normal"> NDEBUG</span>
<span class="normal">                ct</span><span class="symbol">.</span><span class="normal">char0 </span><span class="symbol">=</span><span class="normal"> pt</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">];</span>
<span class="preproc">#endif</span>
<span class="normal">                ct</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> pt</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">ESAIS_LCP_CALCX_INT</span><span class="symbol">(</span><span class="normal"> ct</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> pt</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> ct</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">description</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(index,rank"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">ESAIS_LCP_CALCX_INT</span><span class="symbol">(</span><span class="string">",lcp"</span><span class="normal"> </span><span class="symbol">&lt;&lt;)</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">friend</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> CBufferTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">ESAIS_LCP_CALCX_INT</span><span class="symbol">(</span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">&lt;&lt;)</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Order continuation buffer tuples in L-MergeBuffer by (index ASC)</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">CBufferTupleOrder_Index</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> CBufferTuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> CBufferTuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">CBufferTuple</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">CBufferTuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">CBufferTuple</span><span class="normal"> </span><span class="function">max_value</span><span class="symbol">()</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">CBufferTuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>
<span class="normal">        </span><span class="comment">/// LCP-Tuples for creating LCP by solving a dynamic RMQ problem. The order of these types is</span>
<span class="normal">        </span><span class="comment">/// important as processing order!</span>
<span class="normal">        </span><span class="keyword">enum</span><span class="normal"> LCPTupleType </span><span class="cbracket">{</span>
<span class="normal">            LCP_LSTAR_MARKER</span><span class="symbol">,</span><span class="normal">                                           </span><span class="comment">// L* marker for target</span>
<span class="normal">            LCP_SETTER</span><span class="symbol">,</span><span class="normal"> LCP_SETTER_OUTPUT</span><span class="symbol">,</span><span class="normal"> LCP_SETTER_OUTPUT_LSTAR</span><span class="symbol">,</span><span class="normal">     </span><span class="comment">// Sets target to v1 and possibly output it</span>
<span class="normal">            LCP_LS_SEAM_QUERY</span><span class="symbol">,</span><span class="normal">                                          </span><span class="comment">// Sets target to L/S-seam repcount  of v2=char</span>
<span class="normal">            LCP_QUERY</span><span class="symbol">,</span><span class="normal"> LCP_QUERY_LSTAR                                  </span><span class="comment">// RMQ(v1,target) -&gt; v2</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// Tuples in LCP priority queue</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">LCPTuple</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">char</span><span class="normal">       type</span><span class="symbol">;</span><span class="normal">           </span><span class="comment">// tuple type</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         target</span><span class="symbol">;</span><span class="normal">         </span><span class="comment">// target, by which tuples are sorted: setter=position, query=right boundary</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         v1</span><span class="symbol">;</span><span class="normal">             </span><span class="comment">// setter=value, query=left boundary, L/S=repcount</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         v2</span><span class="symbol">;</span><span class="normal">		</span><span class="comment">// setter=nothing, query=target, L/S=char</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">description</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(type,target,v1,v2)"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">friend</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">ostream</span><span class="symbol">&amp;</span><span class="normal"> os</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> LCPTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_LSTAR_MARKER</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(lcp["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] is L*)"</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(lcp["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] := "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1 </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER_OUTPUT</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(lcp["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] := "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1 </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" +output)"</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER_OUTPUT_LSTAR</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(lcp["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] := "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1 </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" +output +L*)"</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_QUERY</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(RMQ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1 </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") -&gt; "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v2 </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_QUERY_LSTAR</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(RMQ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1 </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") -&gt; "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v2 </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" +L*)"</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_LS_SEAM_QUERY</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(L/S-seam repcount="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1 </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">", match char="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="function">alphabet_type</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">v2</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" -&gt; "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> os </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"(invalid LCPTuple)"</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="cbracket">}</span><span class="normal"> </span><span class="function">__attribute__</span><span class="symbol">((</span><span class="normal">packed</span><span class="symbol">));</span>

<span class="normal">        </span><span class="comment">/// Order items in LCP PQ by target, which is setter-position or right-bound. Use (target DESC, type</span>
<span class="normal">        </span><span class="comment">/// DESC) as PQ picks smallest element</span>
<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">LCPTupleOrder</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> LCPTuple</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> LCPTuple</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">==</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">target</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">type</span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">&gt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">target</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="usertype">LCPTuple</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">LCPTuple</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> t</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">stxxl</span><span class="symbol">::</span><span class="normal">PRIORITY_QUEUE_GENERATOR</span><span class="symbol">&lt;</span><span class="normal">LCPTuple</span><span class="symbol">,</span><span class="normal"> LCPTupleOrder</span><span class="symbol">,</span><span class="normal"> mempartL</span><span class="symbol">,</span><span class="normal"> max_input_size</span><span class="symbol">/</span><span class="number">1024</span><span class="symbol">&gt;::</span><span class="usertype">result</span><span class="normal"> LCP_Lpq_type</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">stxxl</span><span class="symbol">::</span><span class="normal">PRIORITY_QUEUE_GENERATOR</span><span class="symbol">&lt;</span><span class="normal">LCPTuple</span><span class="symbol">,</span><span class="normal"> LCPTupleOrder</span><span class="symbol">,</span><span class="normal"> mempartS</span><span class="symbol">,</span><span class="normal"> max_input_size</span><span class="symbol">/</span><span class="number">1024</span><span class="symbol">&gt;::</span><span class="usertype">result</span><span class="normal"> LCP_Spq_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">size_t</span><span class="normal"> lcprmq_slabsize </span><span class="symbol">=</span><span class="normal"> mempartL </span><span class="symbol">/</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">offset_type</span><span class="symbol">)*</span><span class="number">2</span><span class="symbol">);</span><span class="normal">       </span><span class="comment">// size inside RMQ_Stack</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_EXT</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** STXXL definitions to create L-PQ and S-PQ shared by the three steps</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">stxxl</span><span class="symbol">::</span><span class="normal">PRIORITY_QUEUE_GENERATOR</span><span class="symbol">&lt;</span><span class="normal">PQTuple</span><span class="symbol">,</span><span class="normal"> PQTupleOrder_LPQ</span><span class="symbol">,</span>
<span class="normal">                                                         mempartL</span><span class="symbol">,</span><span class="normal"> max_input_size</span><span class="symbol">/</span><span class="number">2</span><span class="symbol">/</span><span class="number">1024</span><span class="symbol">&gt;</span><span class="normal"> Lpq_generator_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">stxxl</span><span class="symbol">::</span><span class="normal">PRIORITY_QUEUE_GENERATOR</span><span class="symbol">&lt;</span><span class="normal">PQTuple</span><span class="symbol">,</span><span class="normal"> PQTupleOrder_SPQ</span><span class="symbol">,</span>
<span class="normal">                                                         mempartS</span><span class="symbol">,</span><span class="normal"> max_input_size</span><span class="symbol">/</span><span class="number">2</span><span class="symbol">/</span><span class="number">1024</span><span class="symbol">&gt;</span><span class="normal"> Spq_generator_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Lpq_generator_type</span><span class="symbol">::</span><span class="usertype">result</span><span class="normal"> Lpq_type</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Spq_generator_type</span><span class="symbol">::</span><span class="usertype">result</span><span class="normal"> Spq_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// input size</span>
<span class="normal">        </span><span class="usertype">offset_type</span><span class="normal">     inputsize</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** STXXL typedefs to create L-Array, S-Array, S*-Array and L*-Array</span>

<span class="normal">        </span><span class="comment">// Arrays containing continuation tuples are implemented as a runs_creator, which automatically</span>
<span class="normal">        </span><span class="comment">// pre-sorts blocks before writing them to disk. The runs creator and mergers are encapsuled in the</span>
<span class="normal">        </span><span class="comment">// stxxl::sorter.</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt; CTuple, CTupleOrder_LArray, block_size &gt;</span><span class="normal"> LArray_sorter_type</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt; CTuple, CTupleOrder_SArray, block_size &gt;</span><span class="normal"> SArray_sorter_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt; STuple, STupleOrder_SStarArray, block_size &gt;</span><span class="normal"> SStarArray_sorter_type</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt; PQTuple, PQTupleOrder_LStarArray, block_size &gt;</span><span class="normal"> LStarArray_sorter_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="usertype">LArray_sorter_type</span><span class="normal">        LArray</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">SArray_sorter_type</span><span class="normal">        SArray</span><span class="symbol">;</span>

<span class="normal">        </span><span class="usertype">SStarArray_sorter_type</span><span class="normal">    SStarArray</span><span class="symbol">;</span>
<span class="normal">        LStarArray_sorter_type</span><span class="symbol">*</span><span class="normal">   LStarArray</span><span class="symbol">;</span><span class="normal">   </span><span class="comment">// created in induceL()</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt; CBufferTuple, CBufferTupleOrder_Index, block_size &gt;</span><span class="normal"> CBufferTuple_sorter_type</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt; offset_type, tuples::less&lt;offset_type&gt;, block_size &gt;</span><span class="normal"> SStarLCPSkips_sorter_type</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">SStarLCPSkips_sorter_type</span><span class="normal">       SStarLCPSkips</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">MaxRepcount</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="usertype">alphabet_type</span><span class="normal">       charbkt</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         maxrepcount</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal">         lstar_repcount</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">stxxl</span><span class="symbol">::</span><span class="normal">STACK_GENERATOR</span><span class="symbol">&lt;</span><span class="normal">MaxRepcount</span><span class="symbol">,</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="normal">external</span><span class="symbol">,</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="normal">grow_shrink</span><span class="symbol">,</span><span class="normal"> </span><span class="number">4</span><span class="symbol">,</span><span class="normal"> block_size</span><span class="symbol">&gt;::</span><span class="usertype">result</span><span class="normal"> MaxRepcountStack_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="usertype">MaxRepcountStack_type</span><span class="normal">   MaxRepcountStack</span><span class="symbol">;</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">stxxl</span><span class="symbol">::</span><span class="normal">STACK_GENERATOR</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">,</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="normal">external</span><span class="symbol">,</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="normal">grow_shrink</span><span class="symbol">,</span><span class="normal"> </span><span class="number">4</span><span class="symbol">,</span><span class="normal"> block_size</span><span class="symbol">&gt;::</span><span class="usertype">result</span><span class="normal"> LStarLCPStack_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="usertype">LStarLCPStack_type</span><span class="normal">      LStarLCPStack</span><span class="symbol">;</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_EXT</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LOG_PQFILL</span>
<span class="normal">        </span><span class="usertype">SizeLogger</span><span class="normal">      Lpq_logger</span><span class="symbol">,</span><span class="normal"> Spq_logger</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">SizeLogger</span><span class="normal">      LArray_logger</span><span class="symbol">,</span><span class="normal"> SArray_logger</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">SizeLogger</span><span class="normal">      LStarArray_logger</span><span class="symbol">,</span><span class="normal"> SStarArray_logger</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LOG_PQFILL</span>

<span class="normal">        Result</span><span class="symbol">&amp;</span><span class="normal">                 m_result</span><span class="symbol">;</span>

<span class="normal">        </span><span class="usertype">size_type</span><span class="normal">               m_mergecounter</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">        </span><span class="function">Induce</span><span class="symbol">(</span><span class="normal">Result</span><span class="symbol">*</span><span class="normal"> result</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">LArray</span><span class="symbol">(</span><span class="normal"> </span><span class="function">CTupleOrder_LArray</span><span class="symbol">(),</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">6</span><span class="normal"> </span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">SArray</span><span class="symbol">(</span><span class="normal"> </span><span class="function">CTupleOrder_SArray</span><span class="symbol">(),</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">6</span><span class="normal"> </span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">SStarArray</span><span class="symbol">(</span><span class="normal"> </span><span class="function">STupleOrder_SStarArray</span><span class="symbol">(),</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">6</span><span class="normal"> </span><span class="symbol">),</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">              </span><span class="function">SStarLCPSkips</span><span class="symbol">(</span><span class="normal"> tuples</span><span class="symbol">::</span><span class="normal">less</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;(),</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">128</span><span class="normal"> </span><span class="symbol">),</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LOG_PQFILL</span>
<span class="normal">              </span><span class="function">Lpq_logger</span><span class="symbol">(</span><span class="string">"Lpq.log"</span><span class="symbol">),</span><span class="normal"> </span><span class="function">Spq_logger</span><span class="symbol">(</span><span class="string">"Spq.log"</span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">LArray_logger</span><span class="symbol">(</span><span class="string">"LArray.log"</span><span class="symbol">),</span><span class="normal"> </span><span class="function">SArray_logger</span><span class="symbol">(</span><span class="string">"SArray.log"</span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">LStarArray_logger</span><span class="symbol">(</span><span class="string">"LStarArray.log"</span><span class="symbol">),</span><span class="normal"> </span><span class="function">SStarArray_logger</span><span class="symbol">(</span><span class="string">"SStarArray.log"</span><span class="symbol">),</span>
<span class="preproc">#endif</span>
<span class="normal">              </span><span class="function">m_result</span><span class="symbol">(*</span><span class="normal">result</span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">m_mergecounter</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// {{{ process_input(): create S* and L/S-Arrays</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Read input from back to front: iterating from S* to S* and storing continuation tuples if</span>
<span class="normal">        </span><span class="comment">// *** needed.</span>

<span class="normal">        </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">InputStreamReverse</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SStarRankStream</span><span class="symbol">&gt;</span>
<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">process_input</span><span class="symbol">(</span><span class="normal">InputStreamReverse</span><span class="symbol">&amp;</span><span class="normal"> inputrev</span><span class="symbol">,</span><span class="normal"> SStarRankStream</span><span class="symbol">&amp;</span><span class="normal"> sstarrankstream</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Induce process_input() 1"</span><span class="symbol">);</span>

<span class="normal">            inputrev</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal">inputrev</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">());</span><span class="normal">          </span><span class="comment">// empty input</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">inputrev</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">())</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                std</span><span class="symbol">::</span><span class="normal">cerr </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"eSAIS Error: input size is larger than maximum index number.</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">abort</span><span class="symbol">();</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            inputsize </span><span class="symbol">=</span><span class="normal"> inputrev</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"inputsize = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> inputsize</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// sentinel is always S* and last (real) character is always L-type, so start with a L-PQ-tuple</span>

<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal"> spos </span><span class="symbol">=</span><span class="normal"> inputsize</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">            </span><span class="usertype">ctype_type</span><span class="normal"> pprev_ctype </span><span class="symbol">=</span><span class="normal"> TYPE_L</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// need pre-previous items</span>
<span class="normal">            </span><span class="usertype">alphabet_type</span><span class="normal"> pprev_char </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> pprev_repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="preproc">#endif</span>
<span class="normal">            </span><span class="usertype">ctype_type</span><span class="normal"> prev_ctype </span><span class="symbol">=</span><span class="normal"> TYPE_L</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">alphabet_type</span><span class="normal"> prev_char </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal">     </span><span class="comment">// sentinel character '$', but is a special case and later ignored.</span>
<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> prev_repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Induce process_input() 2"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> spos </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">inputrev</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> prev_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_S </span><span class="symbol">||</span><span class="normal"> spos </span><span class="symbol">==</span><span class="normal"> inputsize </span><span class="symbol">);</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="function">CALC_THIS_CTYPE</span><span class="normal">         </span><span class="symbol">((*</span><span class="normal">inputrev </span><span class="symbol">&lt;</span><span class="normal"> prev_char </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">(*</span><span class="normal">inputrev </span><span class="symbol">==</span><span class="normal"> prev_char </span><span class="symbol">&amp;&amp;</span><span class="normal"> prev_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_S</span><span class="symbol">))</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> TYPE_S </span><span class="symbol">:</span><span class="normal"> TYPE_L</span><span class="symbol">)</span>

<span class="normal">                </span><span class="usertype">ctype_type</span><span class="normal"> this_ctype </span><span class="symbol">=</span><span class="normal"> CALC_THIS_CTYPE</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> this_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_L </span><span class="symbol">||</span><span class="normal"> spos </span><span class="symbol">==</span><span class="normal"> inputsize </span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"input["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> spos</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"]: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(*</span><span class="normal">inputrev</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - type "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">(</span><span class="normal">this_ctype</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - prev_repcount "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prev_repcount</span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">STuple</span><span class="normal">     stuple</span><span class="symbol">;</span>
<span class="normal">                stuple</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> spos</span><span class="symbol">;</span>
<span class="normal">                stuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> prev_char</span><span class="symbol">;</span>
<span class="normal">                stuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>
<span class="normal">                stuple</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">=</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>
<span class="normal">                stuple</span><span class="symbol">.</span><span class="normal">continued </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                stuple</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">=</span><span class="normal"> prev_repcount</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">spos </span><span class="symbol">!=</span><span class="normal"> inputsize</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// Fetch rank by matching index in sorted SStarRankStream.</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Matching rank of S*-position "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> spos </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" in SStarRankStream"</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstarrankstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstarrankstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> sstarrankstream</span><span class="symbol">-&gt;</span><span class="normal">index </span><span class="symbol">&gt;</span><span class="normal"> spos </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Matching S*-position: advancing over forced split "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sstarrankstream</span><span class="symbol">);</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                        SStarLCPSkips</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> sstarrankstream</span><span class="symbol">-&gt;</span><span class="normal">name </span><span class="symbol">);</span><span class="normal">    </span><span class="comment">// save forced split ranks</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">                        </span><span class="symbol">++</span><span class="normal">sstarrankstream</span><span class="symbol">;</span><span class="normal">                              </span><span class="comment">// advance over indexes from forced splits</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstarrankstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> sstarrankstream</span><span class="symbol">-&gt;</span><span class="normal">index </span><span class="symbol">==</span><span class="normal"> spos </span><span class="symbol">);</span><span class="normal">       </span><span class="comment">// S*-indexes must match!</span>

<span class="normal">                    stuple</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> sstarrankstream</span><span class="symbol">-&gt;</span><span class="normal">name</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span><span class="normal">          </span><span class="comment">// names start with 0, but rank 0 is reserved for sentinel</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Found match to S*-position "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> spos </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" with rank "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> stuple</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstarrankstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                        </span><span class="symbol">++</span><span class="normal">sstarrankstream</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="comment">// spos == inputsize (this is the '$' S* position)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    stuple</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="comment">// advance to next character</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">NEXTCHAR</span><span class="normal">        pprev_repcount </span><span class="symbol">=</span><span class="normal"> prev_repcount</span><span class="symbol">;</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prev_char </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev </span><span class="symbol">&amp;&amp;</span><span class="normal"> spos </span><span class="symbol">!=</span><span class="normal"> inputsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">prev_repcount</span><span class="symbol">;</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> prev_repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">                        pprev_ctype </span><span class="symbol">=</span><span class="normal"> prev_ctype</span><span class="symbol">,</span><span class="normal"> pprev_char </span><span class="symbol">=</span><span class="normal"> prev_char</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">                        prev_ctype </span><span class="symbol">=</span><span class="normal"> this_ctype</span><span class="symbol">,</span><span class="normal"> prev_char </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">                        </span><span class="symbol">--</span><span class="normal">spos</span><span class="symbol">;</span>

<span class="preproc">#else</span>

<span class="preproc">#define</span><span class="normal"> </span><span class="usertype">NEXTCHAR</span><span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prev_char </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev </span><span class="symbol">&amp;&amp;</span><span class="normal"> spos </span><span class="symbol">!=</span><span class="normal"> inputsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">prev_repcount</span><span class="symbol">;</span><span class="normal"> </span><span class="keyword">else</span><span class="normal"> prev_repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">                        prev_ctype </span><span class="symbol">=</span><span class="normal"> this_ctype</span><span class="symbol">,</span><span class="normal"> prev_char </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">\</span>
<span class="normal">                        </span><span class="symbol">--</span><span class="normal">spos</span><span class="symbol">;</span>

<span class="preproc">#endif</span>
<span class="normal">                NEXTCHAR</span><span class="symbol">;</span>

<span class="normal">                </span><span class="comment">// prepare for continuation tuples</span>

<span class="normal">                </span><span class="usertype">CTuple</span><span class="normal">          ctuple</span><span class="symbol">;</span>
<span class="normal">                </span><span class="usertype">ctype_type</span><span class="normal">      ctuple_ctype </span><span class="symbol">=</span><span class="normal"> TYPE_L</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// arbitrary due to compiler warnings about uninitialized use</span>
<span class="normal">                ctuple</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">                </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> spos </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">                       </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">--</span><span class="normal">inputrev</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">!((</span><span class="normal">this_ctype </span><span class="symbol">=</span><span class="normal"> CALC_THIS_CTYPE</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> TYPE_L </span><span class="symbol">&amp;&amp;</span><span class="normal"> prev_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">inputrev</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"input["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> spos</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"]: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(*</span><span class="normal">inputrev</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - type "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">(</span><span class="normal">this_ctype</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - prev_repcount "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prev_repcount</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">stuple</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">&lt;</span><span class="normal"> D</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="comment">// append this L-character to STuple</span>
<span class="normal">                        stuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="normal">stuple</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">++]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>

<span class="normal">                        NEXTCHAR</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="comment">// STuple is full. Collect further L/S-characters into continuation tuple.</span>

<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">stuple</span><span class="symbol">.</span><span class="normal">continued</span><span class="symbol">)</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="comment">// starting first L or S continuation tuple</span>
<span class="normal">                            stuple</span><span class="symbol">.</span><span class="normal">continued </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="keyword">else</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="comment">// starting next L or S continuation tuple</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">continued </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>

<span class="normal">                            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ctuple_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_L</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Saving L-CTuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> ctuple</span><span class="symbol">);</span>
<span class="normal">                                LArray</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">ctuple</span><span class="symbol">);</span>
<span class="normal">                                </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">LArray_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> LArray</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                                </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">D </span><span class="symbol">-</span><span class="normal"> ctuple</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">));</span>
<span class="normal">                            </span><span class="cbracket">}</span>
<span class="normal">                            </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Saving S-CTuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> ctuple</span><span class="symbol">);</span>
<span class="normal">                                SArray</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">ctuple</span><span class="symbol">);</span>
<span class="normal">                                </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">SArray_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> SArray</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                                </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">D </span><span class="symbol">-</span><span class="normal"> ctuple</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">));</span>
<span class="normal">                            </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">pprev_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_L</span><span class="symbol">)</span><span class="normal">   </span><span class="comment">// continuation tuple for a L-position</span>
<span class="preproc">#else</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prev_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_L</span><span class="symbol">)</span><span class="normal">   </span><span class="comment">// continuation tuple for a L-position</span>
<span class="preproc">#endif</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"STuple is full: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> stuple </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" will be saved. Starting continuation L-CTuple."</span><span class="symbol">);</span>

<span class="normal">                            ctuple_ctype </span><span class="symbol">=</span><span class="normal"> TYPE_L</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> spos</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">=</span><span class="normal"> pprev_repcount</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> pprev_char</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> prev_char</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">2</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">=</span><span class="normal"> </span><span class="number">3</span><span class="symbol">;</span>
<span class="preproc">#else</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> spos</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">=</span><span class="normal"> prev_repcount</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> prev_char</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">=</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>
<span class="preproc">#endif</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">continued </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>


<span class="normal">                            NEXTCHAR</span><span class="symbol">;</span>

<span class="normal">                            </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> spos </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> ctuple</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">&lt;</span><span class="normal"> D </span><span class="symbol">&amp;&amp;</span>
<span class="normal">                                   </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">--</span><span class="normal">inputrev</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">!((</span><span class="normal">this_ctype </span><span class="symbol">=</span><span class="normal"> CALC_THIS_CTYPE</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> TYPE_L </span><span class="symbol">&amp;&amp;</span><span class="normal"> prev_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                            </span><span class="cbracket">{</span>
<span class="normal">                                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">inputrev</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                                </span><span class="comment">// while this position is not an S*-position, fill up the continuation tuple</span>

<span class="normal">                                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"input["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> spos</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"]: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(*</span><span class="normal">inputrev</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - type "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">(</span><span class="normal">this_ctype</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - prev_repcount "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prev_repcount</span><span class="symbol">);</span>

<span class="normal">                                </span><span class="comment">// append this L/S-character to L-CTuple</span>
<span class="normal">                                ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="normal">ctuple</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">++]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>

<span class="normal">                                NEXTCHAR</span><span class="symbol">;</span>
<span class="normal">                            </span><span class="cbracket">}</span>

<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"L-CTuple is full "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> ctuple</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="keyword">else</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"STuple is full: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> stuple </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" will be saved. Starting continuation S-CTuple."</span><span class="symbol">);</span>

<span class="normal">                            ctuple_ctype </span><span class="symbol">=</span><span class="normal"> TYPE_S</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> spos</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">=</span><span class="normal"> pprev_repcount</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> pprev_char</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> prev_char</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">2</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">=</span><span class="normal"> </span><span class="number">3</span><span class="symbol">;</span>
<span class="preproc">#else</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">=</span><span class="normal"> spos</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">repcount </span><span class="symbol">=</span><span class="normal"> prev_repcount</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> prev_char</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">=</span><span class="normal"> </span><span class="number">2</span><span class="symbol">;</span>
<span class="preproc">#endif</span>
<span class="normal">                            ctuple</span><span class="symbol">.</span><span class="normal">continued </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">                            NEXTCHAR</span><span class="symbol">;</span>

<span class="normal">                            </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> spos </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> ctuple</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">&lt;</span><span class="normal"> D </span><span class="symbol">&amp;&amp;</span>
<span class="normal">                                   </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">--</span><span class="normal">inputrev</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">!((</span><span class="normal">this_ctype </span><span class="symbol">=</span><span class="normal"> CALC_THIS_CTYPE</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> TYPE_L </span><span class="symbol">&amp;&amp;</span><span class="normal"> prev_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                            </span><span class="cbracket">{</span>
<span class="normal">                                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">inputrev</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                                </span><span class="comment">// while this position is not an S*-position, fill up the continuation tuple</span>

<span class="normal">                                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"input["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> spos</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"]: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(*</span><span class="normal">inputrev</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - type "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strT</span><span class="symbol">(</span><span class="normal">this_ctype</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - prev_repcount "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prev_repcount</span><span class="symbol">);</span>

<span class="normal">                                </span><span class="comment">// append this L/S-character to S-CTuple</span>
<span class="normal">                                ctuple</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="normal">ctuple</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">++]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>

<span class="normal">                                NEXTCHAR</span><span class="symbol">;</span>
<span class="normal">                            </span><span class="cbracket">}</span>

<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-CTuple is full "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> ctuple</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>

<span class="normal">                        </span><span class="comment">// immediately break (= end tuple) if this is S*-char before reading another char</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">this_ctype </span><span class="symbol">=</span><span class="normal"> CALC_THIS_CTYPE</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> TYPE_L </span><span class="symbol">&amp;&amp;</span><span class="normal"> prev_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_S</span><span class="symbol">)</span>
<span class="normal">                            </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ctuple</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ctuple_ctype </span><span class="symbol">==</span><span class="normal"> TYPE_L</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Saving L-CTuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> ctuple</span><span class="symbol">);</span>
<span class="normal">                        LArray</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">ctuple</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">LArray_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> LArray</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                        </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">D </span><span class="symbol">-</span><span class="normal"> ctuple</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">));</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Saving S-CTuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> ctuple</span><span class="symbol">);</span>
<span class="normal">                        SArray</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">ctuple</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">SArray_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> SArray</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                        </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">D </span><span class="symbol">-</span><span class="normal"> ctuple</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">));</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_split</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Pushing "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> stuple </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into S*-array, starting new STuple, spos = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> spos</span><span class="symbol">);</span>

<span class="normal">                SStarArray</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">stuple</span><span class="symbol">);</span>
<span class="normal">                </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">SStarArray_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> SStarArray</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">D </span><span class="symbol">-</span><span class="normal"> stuple</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">));</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="preproc">#undef</span><span class="normal"> CALC_THIS_CTYPE</span>

<span class="normal">            </span><span class="comment">//assert( inputrev.empty() );</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> sstarrankstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_induce_arrays</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LArray"</span><span class="symbol">,</span><span class="normal"> LArray</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_induce_arrays</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"SArray"</span><span class="symbol">,</span><span class="normal"> SArray</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_induce_arrays</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"SStarArray"</span><span class="symbol">,</span><span class="normal"> SStarArray</span><span class="symbol">);</span>

<span class="normal">            inputrev</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="normal">            sstarrankstream</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>

<span class="normal">            SArray</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="normal">            LArray</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="normal">            SStarArray</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// }}}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Main Memory LCP calculation structure</span>

<span class="normal">        </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">MainMemLCP</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">private</span><span class="symbol">:</span>

<span class="normal">            </span><span class="usertype">RMQ_Stack&lt;offset_type,offset_type&gt;</span><span class="normal"> rmqstruct</span><span class="symbol">;</span>

<span class="normal">            </span><span class="comment">//typedef std::map&lt;alphabet_type,offset_type&gt; bwtmap_type;</span>
<span class="normal">            </span><span class="comment">//typedef typename bwtmap_type::const_iterator bwtiter_type;</span>

<span class="normal">            </span><span class="keyword">typedef</span><span class="normal"> __gnu_pbds</span><span class="symbol">::</span><span class="usertype">cc_hash_table&lt;alphabet_type,offset_type&gt;</span><span class="normal"> bwtmap_type</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">typedef</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">bwtmap_type</span><span class="symbol">::</span><span class="usertype">const_point_iterator</span><span class="normal"> bwtiter_type</span><span class="symbol">;</span>

<span class="normal">            </span><span class="usertype">bwtmap_type</span><span class="normal">         prevbwt</span><span class="symbol">;</span>

<span class="normal">            </span><span class="usertype">alphabet_type</span><span class="normal">       current_char</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">            </span><span class="function">MainMemLCP</span><span class="symbol">()</span>
<span class="normal">                </span><span class="symbol">:</span><span class="normal"> </span><span class="function">current_char</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="symbol">~</span><span class="function">MainMemLCP</span><span class="symbol">()</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">clear</span><span class="symbol">()</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                g_mainmemlcp </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">max</span><span class="symbol">(</span><span class="normal">g_mainmemlcp</span><span class="symbol">,</span><span class="normal"> rmqstruct</span><span class="symbol">.</span><span class="function">memsize</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> prevbwt</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>

<span class="normal">                rmqstruct</span><span class="symbol">.</span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">                prevbwt</span><span class="symbol">.</span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">prepare_char</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> alphabet_type</span><span class="symbol">&amp;</span><span class="normal"> ch</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">ch </span><span class="symbol">!=</span><span class="normal"> current_char</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">                    current_char </span><span class="symbol">=</span><span class="normal"> ch</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// save the BWT char of the extracted PQTuple or constructed S*/L* seed PQTuple</span>
<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">set_bwtchar</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> PQTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp </span><span class="symbol">||</span><span class="normal"> debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Setting BWT at rank "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" to bwtchar "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]));</span>

<span class="normal">                prevbwt</span><span class="symbol">[</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// save BWT and LCP without query</span>
<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">setL_noQuery</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> PQTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> thislcp</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp</span><span class="symbol">);</span>
<span class="normal">                rmqstruct</span><span class="symbol">.</span><span class="function">set</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">,</span><span class="normal"> thislcp</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// queryL LCP RMQ: find prevbwt position and do RMQ (prevbwt_pos,this]</span>
<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">queryL</span><span class="symbol">(</span><span class="normal">PQTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> thislcp</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Setting L-LCP at rank "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" to lcp "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and find prevbwt "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]));</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp</span><span class="symbol">);</span>
<span class="normal">                rmqstruct</span><span class="symbol">.</span><span class="function">set</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">,</span><span class="normal"> thislcp</span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">bwtiter_type</span><span class="normal"> bwtiter </span><span class="symbol">=</span><span class="normal"> prevbwt</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]);</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bwtiter </span><span class="symbol">==</span><span class="normal"> prevbwt</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// no previous bwt occurance:</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"L-LCP bwtchar "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" has no previous occurance -&gt; tenative lcp = 1"</span><span class="symbol">);</span>
<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG1</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"L-LCP bwtchar "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" has previous occurance: RMQ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> bwtiter</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" to "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">);</span>
<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> rmqstruct</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="normal"> bwtiter</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">DBG3</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">" -&gt; result lcp = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="function">set_bwtchar</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// queryLStar LCP: find RMQ to previous L*</span>
<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">queryL_lstar</span><span class="symbol">(</span><span class="normal">PQTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> thislcp</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> prevlstar</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"L*-LCP: save lcp "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and find minimum to previous L*: RMQ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevlstar</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp</span><span class="symbol">);</span>
<span class="normal">                rmqstruct</span><span class="symbol">.</span><span class="function">set</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">,</span><span class="normal"> thislcp</span><span class="symbol">);</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prevlstar </span><span class="symbol">!=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">())</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> rmqstruct</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="normal">prevlstar</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"RMQ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevlstar</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") -&gt; "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal">  </span><span class="comment">// no previous L* in this bucket</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"RMQ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevlstar</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") -&gt; invalid = 0"</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// save BWT and LCP without query</span>
<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">setS_noQuery</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> PQTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> thislcp</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp</span><span class="symbol">);</span>
<span class="normal">                rmqstruct</span><span class="symbol">.</span><span class="function">set</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> thislcp</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// queryS LCP RMQ for L*s: find prevbwt positions, do RMQ [prevbwt_pos,this) and then set L*-LCP</span>
<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">queryS_lstar</span><span class="symbol">(</span><span class="normal">PQTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">,</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal"> thislcp</span><span class="symbol">)</span><span class="normal">  </span><span class="comment">// no const&amp; here, as thislcp must be copied.</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-LCP query at rank "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" with bwtchar "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" for L*-LCP"</span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">bwtiter_type</span><span class="normal"> bwtiter </span><span class="symbol">=</span><span class="normal"> prevbwt</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]);</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bwtiter </span><span class="symbol">==</span><span class="normal"> prevbwt</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// no previous bwt occurance:</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-LCP bwtchar "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" has no previous occurance -&gt; tenative lcp = 1"</span><span class="symbol">);</span>
<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG1</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-LCP bwtchar "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" has previous occurance: RMQ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> bwtiter</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" to "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">);</span>
<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> rmqstruct</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="normal"> bwtiter</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">DBG3</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">" -&gt; result lcp = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Setting S-LCP at rank "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" to lcp "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" after prevbwt find."</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp</span><span class="symbol">);</span>
<span class="normal">                rmqstruct</span><span class="symbol">.</span><span class="function">set</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">,</span><span class="normal"> thislcp</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">set_bwtchar</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// queryS LCP RMQ without lcp labeling (for first positions in repbucket)</span>
<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">queryS_nolcp</span><span class="symbol">(</span><span class="normal">PQTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Query S-LCP at rank "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" find prevbwt "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]));</span>

<span class="normal">                </span><span class="usertype">bwtiter_type</span><span class="normal"> bwtiter </span><span class="symbol">=</span><span class="normal"> prevbwt</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]);</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bwtiter </span><span class="symbol">==</span><span class="normal"> prevbwt</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// no previous bwt occurance:</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-LCP bwtchar "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" has no previous occurance -&gt; tenative lcp = 1"</span><span class="symbol">);</span>
<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG1</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-LCP bwtchar "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" has previous occurance: RMQ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> bwtiter</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" to "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">);</span>
<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> rmqstruct</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="normal"> bwtiter</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">DBG3</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">" -&gt; result lcp = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="function">set_bwtchar</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// queryS LCP RMQ: first set rank-1's LCP, find prevbwt positions, do RMQ [prevbwt_pos,this)</span>
<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">queryS</span><span class="symbol">(</span><span class="normal">PQTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> thislcp</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Setting S-LCP at rank "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" to lcp "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and find prevbwt "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]));</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp</span><span class="symbol">);</span>
<span class="normal">                rmqstruct</span><span class="symbol">.</span><span class="function">set</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> thislcp</span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">bwtiter_type</span><span class="normal"> bwtiter </span><span class="symbol">=</span><span class="normal"> prevbwt</span><span class="symbol">.</span><span class="function">find</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]);</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">bwtiter </span><span class="symbol">==</span><span class="normal"> prevbwt</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">())</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// no previous bwt occurance:</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-LCP bwtchar "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" has no previous occurance -&gt; tenative lcp = 1"</span><span class="symbol">);</span>
<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG1</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-LCP bwtchar "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" has previous occurance: RMQ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> bwtiter</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" to "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">);</span>
<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> rmqstruct</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="normal"> bwtiter</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">-</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">DBG3</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">" -&gt; result lcp = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="function">set_bwtchar</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// setRepbucketEnd LCP RMQ: set first position of an ending repbucket with repcount or L/S-seam result</span>
<span class="normal">            </span><span class="type">void</span><span class="normal"> </span><span class="function">setRepbucketEnd</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> rank</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> thislcp</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Setting S-LCP repbucket boundary at rank "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" to lcp "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> rank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thislcp</span><span class="symbol">);</span>
<span class="normal">                rmqstruct</span><span class="symbol">.</span><span class="function">set</span><span class="symbol">(</span><span class="normal">rank</span><span class="symbol">,</span><span class="normal"> thislcp</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_INT</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>

<span class="normal">        </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">PQType</span><span class="symbol">&gt;</span>
<span class="normal">        </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">inline</span><span class="normal"> </span><span class="type">void</span><span class="normal"> </span><span class="function">insertSplitRMQ</span><span class="symbol">(</span><span class="type">int</span><span class="normal"> type</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> left</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> right</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> target</span><span class="symbol">,</span><span class="normal"> PQType</span><span class="symbol">&amp;</span><span class="normal"> pq</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">((</span><span class="normal">left </span><span class="symbol">/</span><span class="normal"> lcprmq_slabsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">right </span><span class="symbol">/</span><span class="normal"> lcprmq_slabsize</span><span class="symbol">))</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">//std::cout &lt;&lt; "Insert unsplit RMQ(" &lt;&lt; left &lt;&lt; "," &lt;&lt; right &lt;&lt; ")\n";</span>
<span class="normal">                </span><span class="usertype">LCPTuple</span><span class="normal"> l </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> type</span><span class="symbol">,</span><span class="normal"> right</span><span class="symbol">,</span><span class="normal"> left</span><span class="symbol">,</span><span class="normal"> target </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Query LCP-tuple: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> l</span><span class="symbol">);</span>
<span class="normal">                pq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// calculate lower boundary of next slab after left</span>
<span class="normal">                </span><span class="usertype">size_type</span><span class="normal"> splitpos </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(((</span><span class="normal">size_type</span><span class="symbol">)(</span><span class="normal">left </span><span class="symbol">/</span><span class="normal"> lcprmq_slabsize</span><span class="symbol">)+</span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> lcprmq_slabsize</span><span class="symbol">);</span>

<span class="normal">                </span><span class="comment">//std::cout &lt;&lt; "Insert split RMQ(" &lt;&lt; left &lt;&lt; "," &lt;&lt; right &lt;&lt; ")"</span>
<span class="normal">                </span><span class="comment">//          &lt;&lt; " = RMQ(" &lt;&lt; left &lt;&lt; "," &lt;&lt; splitpos-1 &lt;&lt; ") &amp; RMQ(" &lt;&lt; splitpos &lt;&lt; "," &lt;&lt; right &lt;&lt; ")\n";</span>

<span class="normal">                </span><span class="usertype">LCPTuple</span><span class="normal"> l1 </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> type</span><span class="symbol">,</span><span class="normal"> splitpos</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> left</span><span class="symbol">,</span><span class="normal"> target </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                </span><span class="usertype">LCPTuple</span><span class="normal"> l2 </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> type</span><span class="symbol">,</span><span class="normal"> right</span><span class="symbol">,</span><span class="normal"> splitpos</span><span class="symbol">,</span><span class="normal"> target </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Query LCP-tuples: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> l1 </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> l2</span><span class="symbol">);</span>
<span class="normal">                pq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">l1</span><span class="symbol">),</span><span class="normal"> pq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">l2</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_EXT</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Induce Ls</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">reinsertLTuple</span><span class="symbol">(</span><span class="normal">PQTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">,</span><span class="normal"> Lpq_type</span><span class="symbol">&amp;</span><span class="normal"> Lpq</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&gt;=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// previous position is L-type, decrease and reinsert</span>

<span class="normal">                t</span><span class="symbol">.</span><span class="function">decrease</span><span class="symbol">();</span>
<span class="normal">                Lpq</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"reinserted "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into L-PQ."</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">Lpq_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">D </span><span class="symbol">-</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">));</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span><span class="normal"> </span><span class="comment">// if (t.chars[1] &lt; t.chars[0])</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// previous position is S-type, so this is L*-type</span>

<span class="normal">                LStarArray</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"saved "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into L*-Array."</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">LStarArray_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> LStarArray</span><span class="symbol">-&gt;</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">D </span><span class="symbol">-</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">));</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// induceL() input: S*-Array, L-Array, (S*-LCPs). work: L-PQ, PQ-pool, (LCP-PQ, PQ-pool), MergeBuffer. output: L*-Array.</span>

<span class="normal">        </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SStarLCPStream</span><span class="symbol">&gt;</span>
<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">induceL</span><span class="symbol">(</span><span class="normal">SStarLCPStream</span><span class="symbol">&amp;</span><span class="normal"> sstarlcpstream</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">ESAIS_LCP_CALC</span>
<span class="normal">            stxxl</span><span class="symbol">::</span><span class="function">STXXL_UNUSED</span><span class="symbol">(</span><span class="normal">sstarlcpstream</span><span class="symbol">);</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"=== start induceL() ============================================================"</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"induce initializing"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal"> relRank </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal">                        </span><span class="comment">// rank for Ls (counts only Ls and S*s)</span>

<span class="normal">            </span><span class="comment">// the L-PQ for inducing, allocated on heap due to it containing large buffer fields</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">auto_ptr&lt;Lpq_type&gt;</span><span class="normal"> </span><span class="function">Lpq</span><span class="symbol">(</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Lpq_type</span><span class="symbol">(</span><span class="normal">mempartL </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">,</span><span class="normal"> mempartL </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"L-PQ parameters:"</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" total_memory="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">mem_cons</span><span class="symbol">()</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" delete_buffer_size="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="normal">delete_buffer_size</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" N="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="normal">N</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" IntKMAX="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="normal">IntKMAX</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" num_int_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="normal">num_int_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" num_ext_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="normal">num_ext_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" total_num_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="normal">total_num_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" BlockSize="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="normal">BlockSize</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" ExtKMAX="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="normal">ExtKMAX </span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// create L*-Array</span>
<span class="normal">            LStarArray </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">LStarArray_sorter_type</span><span class="symbol">(</span><span class="function">PQTupleOrder_LStarArray</span><span class="symbol">(),</span><span class="normal"> mempartL</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>
<span class="normal">            </span><span class="comment">// the LCP L-PQ for LCP calculation, allocated on heap due to it containing large buffer fields</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">auto_ptr&lt;LCP_Lpq_type&gt;</span><span class="normal"> </span><span class="function">LCPpq</span><span class="symbol">(</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">LCP_Lpq_type</span><span class="symbol">(</span><span class="normal">mempartL </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">,</span><span class="normal"> mempartL </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP-L-PQ parameters:"</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" total_memory="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">mem_cons</span><span class="symbol">()</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" delete_buffer_size="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">delete_buffer_size</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" N="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">N</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" IntKMAX="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">IntKMAX</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" num_int_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">num_int_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" num_ext_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">num_ext_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" total_num_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">total_num_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" BlockSize="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">BlockSize</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" ExtKMAX="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">ExtKMAX </span><span class="symbol">);</span>
<span class="preproc">#endif</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="comment">// initialize S*-LCP information</span>
<span class="normal">            sstarlcpstream</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">mempartL </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>

<span class="normal">            SStarLCPSkips</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">mempartL </span><span class="symbol">/</span><span class="normal"> </span><span class="number">128</span><span class="symbol">);</span>
<span class="normal">            </span><span class="comment">//DBG_ST_ARRAY(1, "SStarLCPSkips", SStarLCPSkips);</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            </span><span class="comment">// S*-Array input stream which contains the seed tuples</span>
<span class="normal">            SStarArray</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">mempartL</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// L-Array stream running through all continuation tuples in index order</span>
<span class="normal">            LArray</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">mempartL</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// buffer for tuples in need of continuation</span>
<span class="normal">            </span><span class="usertype">CBufferTuple_sorter_type</span><span class="normal">    </span><span class="function">LMergeBuffer</span><span class="symbol">(</span><span class="normal"> </span><span class="function">CBufferTupleOrder_Index</span><span class="symbol">(),</span><span class="normal"> mempartL </span><span class="symbol">);</span>

<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">alphabet_type</span><span class="normal"> prevCharLimit </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> lstar_repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">            </span><span class="usertype">MainMemLCP</span><span class="normal"> mmlcp</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal"> prev_lstar </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="preproc">#endif</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"induce starting"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">Lpq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal">                 </span><span class="comment">// tuples left in PQ</span>
<span class="normal">                   </span><span class="symbol">!</span><span class="normal">SStarArray</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span><span class="normal">            </span><span class="comment">// S*-positions left as seeds</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// *** Seed from new S* positions into PQ if possible.</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                </span><span class="type">bool</span><span class="normal"> firstsstar </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">SStarArray</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">                        </span><span class="symbol">(</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> SStarArray</span><span class="symbol">-&gt;</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">PQTuple</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> PQTuple</span><span class="symbol">::</span><span class="function">fromSTuple</span><span class="symbol">(*</span><span class="normal">SStarArray</span><span class="symbol">);</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                    </span><span class="usertype">offset_type</span><span class="normal"> sstarrepcount </span><span class="symbol">=</span><span class="normal"> SStarArray</span><span class="symbol">-&gt;</span><span class="normal">repcount</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="usertype">alphabet_type</span><span class="normal"> seedchar </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">];</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">                    </span><span class="symbol">++</span><span class="normal">SStarArray</span><span class="symbol">;</span>

<span class="normal">                    </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">SStarArray_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> SStarArray</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Seeding from S*-tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">==</span><span class="normal"> inputsize </span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                    mmlcp</span><span class="symbol">.</span><span class="function">prepare_char</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]);</span>
<span class="preproc">#endif</span>

<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> relRank</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">relRank</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                    </span><span class="usertype">offset_type</span><span class="normal"> t_lcp</span><span class="symbol">;</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">==</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="comment">// first position has sentinel lcp 0</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        t_lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                        firstsstar </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">firstsstar</span><span class="symbol">)</span><span class="normal"> </span><span class="comment">// first S* in a bucket must be compared to preceding L repcount</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prevCharLimit </span><span class="symbol">==</span><span class="normal"> seedchar</span><span class="symbol">)</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"first S* in bucket: current L repcount = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> repcount </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" S*-repcount "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sstarrepcount</span><span class="symbol">);</span>
<span class="normal">                            t_lcp </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">min</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;(</span><span class="normal">repcount</span><span class="symbol">,</span><span class="normal"> sstarrepcount</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"first S* in bucket: no preceding Ls -&gt; 0"</span><span class="symbol">);</span>
<span class="normal">                            t_lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="cbracket">}</span>

<span class="normal">                        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstarlcpstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">SStarLCPSkips</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">                                sstarlcpstream</span><span class="symbol">.</span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">SStarLCPSkips </span><span class="symbol">)</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp_use</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Skipped S*-LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sstarlcpstream</span><span class="symbol">.</span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"]: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sstarlcpstream</span><span class="symbol">);</span>
<span class="normal">                            </span><span class="symbol">++</span><span class="normal">sstarlcpstream</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">SStarLCPSkips</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="cbracket">}</span>

<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstarlcpstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp_use</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S*-LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sstarlcpstream</span><span class="symbol">.</span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"]: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sstarlcpstream </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" unused"</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="symbol">++</span><span class="normal">sstarlcpstream</span><span class="symbol">;</span><span class="normal">       </span><span class="comment">// skip unused S*-lcp</span>

<span class="normal">                        firstsstar </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstarlcpstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                        t_lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sstarlcpstream</span><span class="symbol">;</span>

<span class="normal">                        </span><span class="comment">// if this position is not a real S*-index, but a forced-split, then calculate dumb</span>
<span class="normal">                        </span><span class="comment">// RMQ to the next real S*.</span>
<span class="normal">                        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstarlcpstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">SStarLCPSkips</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">                                sstarlcpstream</span><span class="symbol">.</span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">SStarLCPSkips </span><span class="symbol">)</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp_use</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Skipped S*-LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sstarlcpstream</span><span class="symbol">.</span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"]: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sstarlcpstream </span><span class="symbol">);</span>
<span class="normal">                            </span><span class="symbol">++</span><span class="normal">sstarlcpstream</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">SStarLCPSkips</span><span class="symbol">;</span>

<span class="normal">                            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstarlcpstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                            t_lcp </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">t_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sstarlcpstream</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>

<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp_use</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S*-LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sstarlcpstream</span><span class="symbol">.</span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"]: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sstarlcpstream</span><span class="symbol">);</span>

<span class="normal">                        </span><span class="symbol">++</span><span class="normal">sstarlcpstream</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"seeding S*-LCP from LCP stream: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t_lcp</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>

<span class="normal">                    mmlcp</span><span class="symbol">.</span><span class="function">queryL</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> t_lcp</span><span class="symbol">);</span>

<span class="preproc">#elif</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>

<span class="normal">                    </span><span class="usertype">LCPTuple</span><span class="normal"> l </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> LCP_SETTER</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">,</span><span class="normal"> t_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Setter LCP-tuple: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> l</span><span class="symbol">);</span>
<span class="normal">                    LCPpq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">);</span>
<span class="preproc">#endif</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">                    t</span><span class="symbol">.</span><span class="function">decrease</span><span class="symbol">();</span>

<span class="normal">                    Lpq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">Lpq_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                    </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">D </span><span class="symbol">-</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">));</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"inserted L-tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into L-PQ"</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="comment">// determine current limit char</span>

<span class="normal">                </span><span class="usertype">alphabet_type</span><span class="normal"> charLimit </span><span class="symbol">=</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">];</span>
<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> rankLimit </span><span class="symbol">=</span><span class="normal"> relRank</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">charLimit </span><span class="symbol">!=</span><span class="normal"> prevCharLimit</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    repcount </span><span class="symbol">=</span><span class="normal"> lstar_repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">ESAIS_LCP_CALCX_INT</span><span class="symbol">(</span><span class="normal"> prev_lstar </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="symbol">++</span><span class="normal">repcount</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                mmlcp</span><span class="symbol">.</span><span class="function">prepare_char</span><span class="symbol">(</span><span class="normal">charLimit</span><span class="symbol">);</span>
<span class="preproc">#endif</span>
<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> prevSrcRank </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>

<span class="preproc">#else</span><span class="normal"> </span><span class="comment">// !ESAIS_LCP_CALC</span>

<span class="normal">                repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">charLimit </span><span class="symbol">==</span><span class="normal"> prevCharLimit</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"----------------------------------------------------------------------------------------------------"</span><span class="symbol">);</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Extracting from L-PQ with repcount = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> repcount </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">", charLimit = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">charLimit</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and rankLimit = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> rankLimit</span><span class="symbol">);</span>

<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">Lpq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">                        Lpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> charLimit </span><span class="symbol">&amp;&amp;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">rank </span><span class="symbol">&lt;</span><span class="normal"> rankLimit </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">PQTuple</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">();</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">pop</span><span class="symbol">();</span>

<span class="normal">                    </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">Lpq_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">size</span><span class="symbol">());</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Processing L-tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" given index "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" relRank "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> relRank</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"--&gt; SA "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" is next L-entry (relRank = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> relRank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">);</span>

<span class="normal">                    m_result</span><span class="symbol">.</span><span class="function">output_Lentry</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">],</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal"> srcRank </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">)</span>

<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> relRank</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">relRank</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                    </span><span class="type">bool</span><span class="normal"> isLStar </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prevSrcRank </span><span class="symbol">==</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">())</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"First entry in repbucket -&gt; LCP = repcount = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> repcount</span><span class="symbol">);</span>

<span class="normal">                        </span><span class="usertype">LCPTuple</span><span class="normal"> l </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> LCP_SETTER_OUTPUT </span><span class="symbol">+</span><span class="normal"> isLStar</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">,</span><span class="normal"> repcount</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Setter LCP-tuple: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> l</span><span class="symbol">);</span>
<span class="normal">                        LCPpq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Calculate LCP between prevSrcRank = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevSrcRank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"+1 and "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> srcRank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" relTarget = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">insertSplitRMQ</span><span class="symbol">(</span><span class="normal">LCP_QUERY </span><span class="symbol">+</span><span class="normal"> isLStar</span><span class="symbol">,</span><span class="normal"> prevSrcRank</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> srcRank</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">,</span><span class="normal"> LCPpq</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                    </span><span class="usertype">offset_type</span><span class="normal"> t_lcp </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">;</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prevSrcRank </span><span class="symbol">==</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">())</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"L-LCP: first entry in repbucket -&gt; override LCP = repcount = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> repcount</span><span class="symbol">);</span>
<span class="normal">                        t_lcp </span><span class="symbol">=</span><span class="normal"> repcount</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"--&gt; LCP "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t_lcp</span><span class="symbol">);</span>
<span class="normal">                    m_result</span><span class="symbol">.</span><span class="function">output_Lentry_lcp</span><span class="symbol">(</span><span class="normal"> t_lcp </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="comment">// if not L* -&gt; precalculate LCP of induced L-type</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">isLStar</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                            mmlcp</span><span class="symbol">.</span><span class="function">queryL</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> t_lcp</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                            mmlcp</span><span class="symbol">.</span><span class="function">setL_noQuery</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> t_lcp</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">// for L*s (induced char is S-type) -&gt; calculate LCP to the preceding L*</span>
<span class="normal">                        mmlcp</span><span class="symbol">.</span><span class="function">queryL_lstar</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> t_lcp</span><span class="symbol">,</span><span class="normal"> prev_lstar</span><span class="symbol">);</span>
<span class="normal">                        prev_lstar </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_INT</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">isLStar</span><span class="symbol">)</span><span class="normal"> lstar_repcount </span><span class="symbol">=</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                    prevSrcRank </span><span class="symbol">=</span><span class="normal"> srcRank</span><span class="symbol">;</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">                    </span><span class="comment">// decrease varlength tuple if possible and reinsert</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">ESAIS_LCP_CALC_INT</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">==</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"First position processed and finished, no reinsert."</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">continued</span><span class="symbol">)</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Process: charfill=1, put "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into L-MergeBuffer."</span><span class="symbol">);</span>

<span class="normal">                            </span><span class="symbol">++</span><span class="normal">m_mergecounter</span><span class="symbol">;</span>
<span class="normal">                            LMergeBuffer</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> CBufferTuple</span><span class="symbol">::</span><span class="function">fromPQTuple</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_INT</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">==</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"First position processed and finished, no reinsert."</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">continued</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">==</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">continued</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Process: charfill=2, put "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into L-MergeBuffer."</span><span class="symbol">);</span>

<span class="normal">                        </span><span class="symbol">++</span><span class="normal">m_mergecounter</span><span class="symbol">;</span>
<span class="normal">                        LMergeBuffer</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> CBufferTuple</span><span class="symbol">::</span><span class="function">fromPQTuple</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">reinsertLTuple</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">Lpq</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> LMergeBuffer</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span><span class="normal">      </span><span class="comment">// Some tuples need continuation</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// PQ has advanced as far as possible without merging in tuples that need more characters.</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Must remerge tuples needing more characters."</span><span class="symbol">);</span>

<span class="normal">                    LMergeBuffer</span><span class="symbol">.</span><span class="function">sort_reuse</span><span class="symbol">();</span>

<span class="normal">                    </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LMergeBuffer"</span><span class="symbol">,</span><span class="normal"> LMergeBuffer</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">defined</span><span class="symbol">(</span><span class="normal">NDEBUG</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">// check that all starting chars of the merge buffer are the same</span>

<span class="normal">                        </span><span class="usertype">alphabet_type</span><span class="normal"> mergechar </span><span class="symbol">=</span><span class="normal"> LMergeBuffer</span><span class="symbol">-&gt;</span><span class="normal">char0</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LMergeBuffer</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> LMergeBuffer</span><span class="symbol">-&gt;</span><span class="normal">char0 </span><span class="symbol">==</span><span class="normal"> mergechar </span><span class="symbol">);</span>
<span class="normal">                            </span><span class="symbol">++</span><span class="normal">LMergeBuffer</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        LMergeBuffer</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">();</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span>
<span class="normal">                    </span><span class="comment">// merge array with tuples from L-Array</span>

<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LArray</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LMergeBuffer</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LArray</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> LArray</span><span class="symbol">-&gt;</span><span class="normal">index </span><span class="symbol">==</span><span class="normal"> LMergeBuffer</span><span class="symbol">-&gt;</span><span class="normal">index </span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> LArray</span><span class="symbol">-&gt;</span><span class="normal">repcount </span><span class="symbol">==</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="normal">repcount</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                        </span><span class="comment">// construct new PQ tuple from continuation tuple</span>
<span class="normal">                        </span><span class="usertype">PQTuple</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> PQTuple</span><span class="symbol">::</span><span class="function">fromCTuple</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">LArray </span><span class="symbol">);</span>

<span class="normal">                        t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> LMergeBuffer</span><span class="symbol">-&gt;</span><span class="normal">rank</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                        t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> LMergeBuffer</span><span class="symbol">-&gt;</span><span class="normal">lcp</span><span class="symbol">;</span>
<span class="preproc">#endif</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="comment">// this merged tuples is an L* tuple, so we missed the L*-star flag on the RMQ-tuple</span>

<span class="normal">                            </span><span class="usertype">LCPTuple</span><span class="normal"> l </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> LCP_LSTAR_MARKER</span><span class="symbol">,</span><span class="normal"> LMergeBuffer</span><span class="symbol">-&gt;</span><span class="normal">rank</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Adding LCP-tuple marker tuple for missed L*: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> l</span><span class="symbol">);</span>
<span class="normal">                            LCPpq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">);</span>

<span class="normal">                            lstar_repcount </span><span class="symbol">=</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_EXT</span>

<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Merged L-tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">);</span>

<span class="normal">                        </span><span class="function">reinsertLTuple</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">Lpq</span><span class="symbol">);</span>

<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LArray</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="symbol">++</span><span class="normal">LArray</span><span class="symbol">;</span>
<span class="normal">                            </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">LArray_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> LArray</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                        </span><span class="cbracket">}</span>

<span class="normal">                        </span><span class="symbol">++</span><span class="normal">LMergeBuffer</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    LMergeBuffer</span><span class="symbol">.</span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                </span><span class="comment">// *** Save repcount for L/S-seam calculation</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> charLimit </span><span class="symbol">!=</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"RepcountStack: pushing repcount="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> repcount </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and L*-repcount="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> lstar_repcount </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" for char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">charLimit</span><span class="symbol">));</span>
<span class="normal">                    </span><span class="usertype">MaxRepcount</span><span class="normal"> mr </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> charLimit</span><span class="symbol">,</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> lstar_repcount </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                    MaxRepcountStack</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">mr</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="preproc">#endif</span>

<span class="normal">                prevCharLimit </span><span class="symbol">=</span><span class="normal"> charLimit</span><span class="symbol">;</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">Lpq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"L-PQ.top after break: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Lpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">());</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"induce-only finished"</span><span class="symbol">);</span>

<span class="normal">            SStarArray</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>
<span class="normal">            LArray</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>
<span class="normal">            LMergeBuffer</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>
<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"induce answering RMQs"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"===================================================================================================="</span><span class="symbol">);</span>

<span class="normal">            </span><span class="usertype">RMQ_Stack_Blocked&lt;offset_type,offset_type,lcprmq_slabsize&gt;</span><span class="normal"> rmqstruct</span><span class="symbol">;</span>

<span class="normal">            </span><span class="type">bool</span><span class="normal"> lstarmarker </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal"> lstar_rangemin </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LCPpq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">LCPTuple</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">();</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">pop</span><span class="symbol">();</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">%</span><span class="normal"> </span><span class="number">1000</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">//rmqstruct.print_size();</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Extracted from LCP-PQ: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">);</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_LSTAR_MARKER</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    lstarmarker </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER </span><span class="symbol">||</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER_OUTPUT </span><span class="symbol">||</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER_OUTPUT_LSTAR</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// collect more answers</span>
<span class="normal">                    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LCPpq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">target </span><span class="symbol">==</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">&amp;&amp;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Min-merged with LCP-PQ: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">());</span>
<span class="normal">                        t</span><span class="symbol">.</span><span class="normal">v1 </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">v1</span><span class="symbol">,</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">v1</span><span class="symbol">);</span>
<span class="normal">                        LCPpq</span><span class="symbol">-&gt;</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    rmqstruct</span><span class="symbol">.</span><span class="function">set</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">target</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1</span><span class="symbol">);</span>

<span class="normal">                    lstar_rangemin </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">lstar_rangemin</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1</span><span class="symbol">);</span><span class="normal">    </span><span class="comment">// manual RMQ to last L*</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER_OUTPUT </span><span class="symbol">||</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER_OUTPUT_LSTAR</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        m_result</span><span class="symbol">.</span><span class="function">output_Lentry_lcp</span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1 </span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER_OUTPUT_LSTAR </span><span class="symbol">||</span><span class="normal"> lstarmarker</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="comment">// don't push the value itself, but the RMQ to the previous L*</span>

<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Pushing into L*-LCP Stack: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> lstar_rangemin</span><span class="symbol">);</span>
<span class="normal">                        LStarLCPStack</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">lstar_rangemin</span><span class="symbol">);</span>

<span class="normal">                        lstar_rangemin </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                        lstarmarker </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_QUERY </span><span class="symbol">||</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_QUERY_LSTAR</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">left </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">right </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">target</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> left </span><span class="symbol">&lt;=</span><span class="normal"> right </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> lcp </span><span class="symbol">=</span><span class="normal"> rmqstruct</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">,</span><span class="normal"> right</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>

<span class="normal">                    </span><span class="usertype">LCPTuple</span><span class="normal"> l </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> LCP_SETTER_OUTPUT </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_QUERY_LSTAR </span><span class="symbol">?</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">),</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v2</span><span class="symbol">,</span><span class="normal"> lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Reinserting answer LCP-tuple: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> l</span><span class="symbol">);</span>
<span class="normal">                    LCPpq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(!</span><span class="string">"Unknown RMQ-Tuple"</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            rmqstruct</span><span class="symbol">.</span><span class="function">print_size</span><span class="symbol">();</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_EXT</span>

<span class="normal">            m_result</span><span class="symbol">.</span><span class="function">finish_Lsequence</span><span class="symbol">();</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"induce finished"</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Induce Ss</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">reinsertSTuple</span><span class="symbol">(</span><span class="normal">PQTuple</span><span class="symbol">&amp;</span><span class="normal"> t</span><span class="symbol">,</span><span class="normal"> Spq_type</span><span class="symbol">&amp;</span><span class="normal"> Spq</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// previous position is S-type</span>

<span class="normal">                t</span><span class="symbol">.</span><span class="function">decrease</span><span class="symbol">();</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"reinserted "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into S-PQ."</span><span class="symbol">);</span>

<span class="normal">                Spq</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">                </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">Spq_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">D </span><span class="symbol">-</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">));</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">else</span><span class="normal"> </span><span class="comment">// if (t.chars[1] &gt; t.chars[0])</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// previous position is L-type, so this is S*-type</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(!</span><span class="string">"Impossible reinsertion of L-type as tuples should not contain L-types anymore!"</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"not reinserted, finished."</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// induceS() input: L*-Array, S-Array. work: S-PQ, PQ-pool, (LCP-PQ, PQ-pool), MergeBuffer. output: (only stack+queue).</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">induceS</span><span class="symbol">()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"=== start induceS() ============================================================"</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"induce initializing"</span><span class="symbol">);</span>

<span class="normal">            LStarArray_sorter_type</span><span class="symbol">&amp;</span><span class="normal"> LStarArray </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">-&gt;</span><span class="normal">LStarArray</span><span class="symbol">;</span>

<span class="normal">            </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_induce_arrays</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LStarArray"</span><span class="symbol">,</span><span class="normal"> LStarArray</span><span class="symbol">);</span>

<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal"> relRank </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal">                </span><span class="comment">// rank for Ss (in reverse order, counting only Ss)</span>

<span class="normal">            </span><span class="comment">// the S-PQ for inducing, allocated on heap due to it containing large buffer fields</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">auto_ptr&lt;Spq_type&gt;</span><span class="normal"> </span><span class="function">Spq</span><span class="symbol">(</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">Spq_type</span><span class="symbol">(</span><span class="normal">mempartS </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">,</span><span class="normal"> mempartS </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-PQ parameters:"</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" total_memory="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">mem_cons</span><span class="symbol">()</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" delete_buffer_size="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="normal">delete_buffer_size</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" N="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="normal">N</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" IntKMAX="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="normal">IntKMAX</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" num_int_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="normal">num_int_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" num_ext_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="normal">num_ext_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" total_num_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="normal">total_num_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" BlockSize="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="normal">BlockSize</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" ExtKMAX="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="normal">ExtKMAX </span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// L*-Array input stream which contains the seed tuples</span>
<span class="normal">            LStarArray</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">mempartS</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>
<span class="normal">            </span><span class="comment">// the LCP S-PQ for LCP calculation, allocated on heap due to it containing large buffer fields</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">auto_ptr&lt;LCP_Spq_type&gt;</span><span class="normal"> </span><span class="function">LCPpq</span><span class="symbol">(</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> </span><span class="function">LCP_Spq_type</span><span class="symbol">(</span><span class="normal">mempartS </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">,</span><span class="normal"> mempartS </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"L*-LCPStack size "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LStarLCPStack</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" vs. L*-Array size "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LStarArray</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">((</span><span class="normal">size_type</span><span class="symbol">)</span><span class="normal">LStarLCPStack</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> LStarArray</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP-S-PQ parameters:"</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" total_memory="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">mem_cons</span><span class="symbol">()</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" delete_buffer_size="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">delete_buffer_size</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" N="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">N</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" IntKMAX="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">IntKMAX</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" num_int_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">num_int_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" num_ext_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">num_ext_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" total_num_groups="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">total_num_groups</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" BlockSize="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">BlockSize</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" ExtKMAX="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="normal">ExtKMAX </span><span class="symbol">);</span>
<span class="preproc">#endif</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">            </span><span class="usertype">MainMemLCP</span><span class="normal"> mmlcp</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            </span><span class="comment">// buffer for tuples in need of continuation</span>
<span class="normal">            </span><span class="usertype">CBufferTuple_sorter_type</span><span class="normal">    </span><span class="function">SMergeBuffer</span><span class="symbol">(</span><span class="normal"> </span><span class="function">CBufferTupleOrder_Index</span><span class="symbol">(),</span><span class="normal"> mempartS </span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// iterator of S-Array running through all continuation tuples in index order</span>
<span class="normal">            SArray</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">mempartS</span><span class="symbol">);</span>

<span class="normal">            </span><span class="usertype">size_type</span><span class="normal"> repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">alphabet_type</span><span class="normal"> prevCharLimit </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">alphabet_type</span><span class="symbol">&gt;::</span><span class="function">min</span><span class="symbol">();</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"induce starting"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">Spq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal">                  </span><span class="comment">// tuples left in PQ</span>
<span class="normal">                   </span><span class="symbol">!</span><span class="normal">LStarArray</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span><span class="normal">             </span><span class="comment">// L*-positions left as seeds</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// *** Seed from new L* positions into PQ if possible.</span>

<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LStarArray</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">                        </span><span class="symbol">(</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> LStarArray</span><span class="symbol">-&gt;</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&gt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">PQTuple</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">LStarArray</span><span class="symbol">;</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>
<span class="normal">                    </span><span class="usertype">offset_type</span><span class="normal"> t_lcp </span><span class="symbol">=</span><span class="normal"> LStarLCPStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">();</span><span class="normal"> LStarLCPStack</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_EXT</span>
<span class="normal">                    </span><span class="symbol">++</span><span class="normal">LStarArray</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">LStarArray_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> LStarArray</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Seeding from L*-tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> relRank</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">relRank</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>

<span class="normal">                    mmlcp</span><span class="symbol">.</span><span class="function">prepare_char</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]);</span>
<span class="normal">                    mmlcp</span><span class="symbol">.</span><span class="function">queryS_lstar</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">);</span>

<span class="preproc">#endif</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>

<span class="normal">                    </span><span class="usertype">LCPTuple</span><span class="normal"> l </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> LCP_SETTER</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">,</span><span class="normal"> t_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Setter LCP-tuple: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> l</span><span class="symbol">);</span>
<span class="normal">                    LCPpq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">);</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_EXT</span>

<span class="normal">                    t</span><span class="symbol">.</span><span class="function">decrease</span><span class="symbol">();</span>

<span class="normal">                    Spq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">Spq_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                    </span><span class="function">LOG_WASTED</span><span class="symbol">(</span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">D </span><span class="symbol">-</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">charfill</span><span class="symbol">));</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"inserted S-tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into S-PQ"</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="comment">// determine current limit char</span>

<span class="normal">                </span><span class="usertype">alphabet_type</span><span class="normal"> charLimit </span><span class="symbol">=</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">];</span>
<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> rankLimit </span><span class="symbol">=</span><span class="normal"> relRank</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                mmlcp</span><span class="symbol">.</span><span class="function">prepare_char</span><span class="symbol">(</span><span class="normal">charLimit</span><span class="symbol">);</span>
<span class="preproc">#endif</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> prevSrcRank </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="preproc">#endif</span>

<span class="normal">                repcount </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">charLimit </span><span class="symbol">==</span><span class="normal"> prevCharLimit</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"----------------------------------------------------------------------------------------------------"</span><span class="symbol">);</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Extracting from S-PQ with charLimit = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">charLimit</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and rankLimit = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> rankLimit</span><span class="symbol">);</span>

<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">Spq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span>
<span class="normal">                        Spq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> charLimit </span><span class="symbol">&amp;&amp;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">rank </span><span class="symbol">&lt;</span><span class="normal"> rankLimit</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">PQTuple</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">();</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">pop</span><span class="symbol">();</span>

<span class="normal">                    </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">Spq_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">size</span><span class="symbol">());</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Processing S-tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" given index "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" relRank "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> relRank</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"--&gt; SA "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" is next S-entry (relRank = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> relRank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">);</span>

<span class="normal">                    m_result</span><span class="symbol">.</span><span class="function">output_Sentry</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">],</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal"> srcRank </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">)</span>

<span class="normal">                    t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> relRank</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">relRank</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">prevSrcRank </span><span class="symbol">==</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">())</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="comment">// do nothing for very first entry from this repchar-sequence</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP: delay calculation for first entry of repbucket"</span><span class="symbol">);</span>
<span class="normal">                        mmlcp</span><span class="symbol">.</span><span class="function">queryS_nolcp</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">);</span>
<span class="preproc">#endif</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"--&gt; LCP "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">);</span>
<span class="normal">                        m_result</span><span class="symbol">.</span><span class="function">output_Sentry_lcp</span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">);</span>

<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">&gt;</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                            mmlcp</span><span class="symbol">.</span><span class="function">queryS</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                            mmlcp</span><span class="symbol">.</span><span class="function">setS_noQuery</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">lcp</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>

<span class="preproc">#elif</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Calculate LCP between prevSrcRank = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevSrcRank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> srcRank </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"-1 relTarget = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">insertSplitRMQ</span><span class="symbol">(</span><span class="normal">LCP_QUERY</span><span class="symbol">,</span><span class="normal"> prevSrcRank</span><span class="symbol">,</span><span class="normal"> srcRank</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">rank</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> LCPpq</span><span class="symbol">);</span>
<span class="preproc">#endif</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    prevSrcRank </span><span class="symbol">=</span><span class="normal"> srcRank</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">                    </span><span class="comment">// decrease varlength tuple if possible and reinsert</span>
<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">ESAIS_LCP_CALC_INT</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">==</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"first position finished. no reinsert."</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">continued</span><span class="symbol">)</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"charfill=1, put "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into S-MergeBuffer"</span><span class="symbol">);</span>

<span class="normal">                            </span><span class="symbol">++</span><span class="normal">m_mergecounter</span><span class="symbol">;</span>
<span class="normal">                            SMergeBuffer</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> CBufferTuple</span><span class="symbol">::</span><span class="function">fromPQTuple</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="keyword">else</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"no continuation, finished."</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_INT</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">==</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">==</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"first position finished. no reinsert."</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">continued</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">charfill </span><span class="symbol">==</span><span class="normal"> </span><span class="number">2</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">continued</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"charfill=2, put "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" into S-MergeBuffer"</span><span class="symbol">);</span>

<span class="normal">                        </span><span class="symbol">++</span><span class="normal">m_mergecounter</span><span class="symbol">;</span>
<span class="normal">                        SMergeBuffer</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> CBufferTuple</span><span class="symbol">::</span><span class="function">fromPQTuple</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_EXT</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">reinsertSTuple</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">Spq</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> SMergeBuffer</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span><span class="normal">      </span><span class="comment">// Some tuples need continuation</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// PQ has advanced as far as possible without merging in</span>
<span class="normal">                    </span><span class="comment">// tuples that need more characters.</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Must remerge tuples needing more characters."</span><span class="symbol">);</span>

<span class="normal">                    SMergeBuffer</span><span class="symbol">.</span><span class="function">sort_reuse</span><span class="symbol">();</span>

<span class="normal">                    </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"SMergeBuffer"</span><span class="symbol">,</span><span class="normal"> SMergeBuffer</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">defined</span><span class="symbol">(</span><span class="normal">NDEBUG</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">// check that all starting chars of the merge buffer are the same</span>

<span class="normal">                        </span><span class="usertype">alphabet_type</span><span class="normal"> mergechar </span><span class="symbol">=</span><span class="normal"> SMergeBuffer</span><span class="symbol">-&gt;</span><span class="normal">char0</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">SMergeBuffer</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> SMergeBuffer</span><span class="symbol">-&gt;</span><span class="normal">char0 </span><span class="symbol">==</span><span class="normal"> mergechar </span><span class="symbol">);</span>
<span class="normal">                            </span><span class="symbol">++</span><span class="normal">SMergeBuffer</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        SMergeBuffer</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">();</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span>
<span class="normal">                    </span><span class="comment">// merge array with tuples from S-Array</span>

<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">SArray</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">SMergeBuffer</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">SArray</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> SArray</span><span class="symbol">-&gt;</span><span class="normal">index </span><span class="symbol">==</span><span class="normal"> SMergeBuffer</span><span class="symbol">-&gt;</span><span class="normal">index </span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> SArray</span><span class="symbol">-&gt;</span><span class="normal">repcount </span><span class="symbol">==</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="normal">repcount</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                        </span><span class="comment">// construct new PQ tuple from continuation tuple</span>
<span class="normal">                        </span><span class="usertype">PQTuple</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> PQTuple</span><span class="symbol">::</span><span class="function">fromCTuple</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">SArray </span><span class="symbol">);</span>

<span class="normal">                        t</span><span class="symbol">.</span><span class="normal">rank </span><span class="symbol">=</span><span class="normal"> SMergeBuffer</span><span class="symbol">-&gt;</span><span class="normal">rank</span><span class="symbol">;</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                        t</span><span class="symbol">.</span><span class="normal">lcp </span><span class="symbol">=</span><span class="normal"> SMergeBuffer</span><span class="symbol">-&gt;</span><span class="normal">lcp</span><span class="symbol">;</span>
<span class="preproc">#endif</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Merged S-tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">);</span>

<span class="normal">                        </span><span class="function">reinsertSTuple</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">Spq</span><span class="symbol">);</span>

<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">SArray</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="symbol">++</span><span class="normal">SArray</span><span class="symbol">;</span>
<span class="normal">                            </span><span class="function">LOG_SIZE</span><span class="symbol">(</span><span class="normal">SArray_logger </span><span class="symbol">&lt;&lt;</span><span class="normal"> SArray</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                        </span><span class="cbracket">}</span>

<span class="normal">                        </span><span class="symbol">++</span><span class="normal">SMergeBuffer</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    SMergeBuffer</span><span class="symbol">.</span><span class="function">clear</span><span class="symbol">();</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>
<span class="normal">                </span><span class="comment">// handle LCP for preceding position: either push repetition bucket number or L/S-seam tuples</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">Spq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> charLimit </span><span class="symbol">==</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// next position is still within the same bucket</span>

<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prevSrcRank </span><span class="symbol">!=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">());</span>

<span class="normal">                    </span><span class="usertype">LCPTuple</span><span class="normal"> l </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> LCP_SETTER_OUTPUT</span><span class="symbol">,</span><span class="normal"> relRank</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Pushed repbucket LCP-tuple: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> l </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" with repcount "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">                    LCPpq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// create L/S-seam query tuple</span>
<span class="normal">                    </span><span class="usertype">LCPTuple</span><span class="normal"> l </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> LCP_LS_SEAM_QUERY</span><span class="symbol">,</span><span class="normal"> relRank</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="normal">charLimit</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Pushed seam LCP-tuple: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> l</span><span class="symbol">);</span>
<span class="normal">                    LCPpq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_EXT</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">Spq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> charLimit </span><span class="symbol">==</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">chars</span><span class="symbol">[</span><span class="number">0</span><span class="symbol">])</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// next position is still within the same bucket</span>

<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">prevSrcRank </span><span class="symbol">!=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">());</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"--&gt; LCP "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" (= repcount at repbucket end)"</span><span class="symbol">);</span>
<span class="normal">                    m_result</span><span class="symbol">.</span><span class="function">output_Sentry_lcp</span><span class="symbol">(</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                    mmlcp</span><span class="symbol">.</span><span class="function">setRepbucketEnd</span><span class="symbol">(</span><span class="normal"> relRank</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">offset_type</span><span class="normal"> m </span><span class="symbol">=</span><span class="normal"> repcount</span><span class="symbol">+</span><span class="number">1</span><span class="symbol">;</span><span class="normal"> </span><span class="comment">// base value is the repcount.</span>

<span class="normal">                    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">MaxRepcountStack</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">charbkt </span><span class="symbol">&gt;</span><span class="normal"> charLimit </span><span class="symbol">)</span><span class="normal">   </span><span class="comment">// pop all unneeded characters</span>
<span class="normal">                        MaxRepcountStack</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Top max repcount stack is empty!"</span><span class="symbol">);</span>
<span class="normal">                        m </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">charbkt </span><span class="symbol">!=</span><span class="normal"> charLimit </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Top max repcount stack char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">charbkt</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" != "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> charLimit</span><span class="symbol">);</span>
<span class="normal">                        m </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Top max repcount stack char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">charbkt</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" matches, using max repcount value "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">maxrepcount</span><span class="symbol">);</span>
<span class="normal">                        m </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">maxrepcount</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Stack max repcount for char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">charLimit</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" -&gt; result = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"--&gt; LCP "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" (= L/S-seam output)"</span><span class="symbol">);</span>

<span class="normal">                    m_result</span><span class="symbol">.</span><span class="function">output_Sentry_lcp</span><span class="symbol">(</span><span class="normal"> m </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">MaxRepcountStack</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">charbkt </span><span class="symbol">==</span><span class="normal"> charLimit </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Buckets match, applying minimum from L*-RepcountStack = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">lstar_repcount</span><span class="symbol">);</span>
<span class="normal">                        m </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">lstar_repcount</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        m </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"++&gt; LCP "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" (= L/S-seam L*-RMQ value)"</span><span class="symbol">);</span>
<span class="normal">                    mmlcp</span><span class="symbol">.</span><span class="function">setRepbucketEnd</span><span class="symbol">(</span><span class="normal"> relRank</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">,</span><span class="normal"> m </span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_EXT</span>

<span class="normal">                prevCharLimit </span><span class="symbol">=</span><span class="normal"> charLimit</span><span class="symbol">;</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">Spq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S-PQ.top after break: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> Spq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">());</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">delete</span><span class="normal"> </span><span class="keyword">this</span><span class="symbol">-&gt;</span><span class="normal">LStarArray</span><span class="symbol">;</span>
<span class="normal">            SArray</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>
<span class="normal">            SMergeBuffer</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"induce-only finished"</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>
<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"induce answering RMQs"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"===================================================================================================="</span><span class="symbol">);</span>

<span class="normal">            </span><span class="usertype">RMQ_Stack_Blocked&lt;offset_type,offset_type,lcprmq_slabsize&gt;</span><span class="normal"> rmqstruct</span><span class="symbol">;</span>

<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LCPpq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">LCPTuple</span><span class="normal"> t </span><span class="symbol">=</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">();</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">pop</span><span class="symbol">();</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">%</span><span class="normal"> </span><span class="number">1000</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">//rmqstruct.print_size();</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Extracted from LCP-PQ: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> t</span><span class="symbol">);</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER </span><span class="symbol">||</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER_OUTPUT</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// collect more answers</span>
<span class="normal">                    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LCPpq</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">target </span><span class="symbol">==</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">target </span><span class="symbol">&amp;&amp;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceL_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Min-merged with LCP-PQ: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">());</span>
<span class="normal">                        t</span><span class="symbol">.</span><span class="normal">v1 </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">v1</span><span class="symbol">,</span><span class="normal"> LCPpq</span><span class="symbol">-&gt;</span><span class="function">top</span><span class="symbol">().</span><span class="normal">v1</span><span class="symbol">);</span>
<span class="normal">                        LCPpq</span><span class="symbol">-&gt;</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    rmqstruct</span><span class="symbol">.</span><span class="function">set</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">target</span><span class="symbol">,</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_SETTER_OUTPUT</span><span class="symbol">)</span>
<span class="normal">                        m_result</span><span class="symbol">.</span><span class="function">output_Sentry_lcp</span><span class="symbol">(</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1 </span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_QUERY</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">const</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">left </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">right </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">target</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> left </span><span class="symbol">&lt;=</span><span class="normal"> right </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> lcp </span><span class="symbol">=</span><span class="normal"> rmqstruct</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">,</span><span class="normal">right</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span>

<span class="normal">                    </span><span class="usertype">LCPTuple</span><span class="normal"> l </span><span class="symbol">=</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> LCP_SETTER_OUTPUT </span><span class="symbol">+</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_QUERY_LSTAR </span><span class="symbol">?</span><span class="normal"> </span><span class="number">1</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="number">0</span><span class="symbol">),</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v2</span><span class="symbol">,</span><span class="normal"> lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="number">0</span><span class="normal"> </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Reinserting answer LCP-tuple: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> l</span><span class="symbol">);</span>
<span class="normal">                    LCPpq</span><span class="symbol">-&gt;</span><span class="function">push</span><span class="symbol">(</span><span class="normal">l</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">type </span><span class="symbol">==</span><span class="normal"> LCP_LS_SEAM_QUERY</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">alphabet_type</span><span class="normal"> a2 </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v2</span><span class="symbol">;</span>

<span class="normal">                    </span><span class="usertype">offset_type</span><span class="normal"> m </span><span class="symbol">=</span><span class="normal"> t</span><span class="symbol">.</span><span class="normal">v1</span><span class="symbol">;</span><span class="normal">     </span><span class="comment">// repcount from S-sequence</span>

<span class="normal">                    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">MaxRepcountStack</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">charbkt </span><span class="symbol">&gt;</span><span class="normal"> a2 </span><span class="symbol">)</span>
<span class="normal">                        MaxRepcountStack</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Top max repcount stack is empty!"</span><span class="symbol">);</span>
<span class="normal">                        m </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">charbkt </span><span class="symbol">!=</span><span class="normal"> a2 </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Top max repcount stack char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">charbkt</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" != "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> a2</span><span class="symbol">);</span>
<span class="normal">                        m </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Top max repcount stack char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">charbkt</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" matches, using max repcount value "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">maxrepcount</span><span class="symbol">);</span>
<span class="normal">                        m </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">maxrepcount</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Stack max repcount for char "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">a2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" -&gt; result = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m</span><span class="symbol">);</span>

<span class="normal">                    m_result</span><span class="symbol">.</span><span class="function">output_Sentry_lcp</span><span class="symbol">(</span><span class="normal"> m </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">MaxRepcountStack</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">charbkt </span><span class="symbol">==</span><span class="normal"> a2 </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induceS_lcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Buckets match, applying minimum from L*-RepcountStack = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">lstar_repcount</span><span class="symbol">);</span>
<span class="normal">                        m </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">m</span><span class="symbol">,</span><span class="normal"> MaxRepcountStack</span><span class="symbol">.</span><span class="function">top</span><span class="symbol">().</span><span class="normal">lstar_repcount</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        m </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    rmqstruct</span><span class="symbol">.</span><span class="function">set</span><span class="symbol">(</span><span class="normal">t</span><span class="symbol">.</span><span class="normal">target</span><span class="symbol">,</span><span class="normal"> m</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(!</span><span class="string">"Unknown RMQ-Tuple"</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            rmqstruct</span><span class="symbol">.</span><span class="function">print_size</span><span class="symbol">();</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC_EXT</span>

<span class="normal">            m_result</span><span class="symbol">.</span><span class="function">finish_Ssequence</span><span class="symbol">();</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"induce finished"</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Induce process in three steps</span>

<span class="normal">        </span><span class="comment">/// Process the input stream in reverse together with the correctly ranked S*-positions. The</span>
<span class="normal">        </span><span class="comment">/// SStarRankStream is instanciated with a runs_merger</span><span class="keyword">&lt;NameTuple&gt;</span><span class="comment"> for non-recursion cases and with</span>
<span class="normal">        </span><span class="comment">/// RecursionInduceFilter for recursive calls, which returns NameTuples for each S*-position.</span>
<span class="normal">        </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">InputStreamReverse</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SStarRankStream</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SStarLCPStream</span><span class="symbol">&gt;</span>
<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">process</span><span class="symbol">(</span><span class="normal">InputStreamReverse</span><span class="symbol">&amp;</span><span class="normal"> inputrev</span><span class="symbol">,</span><span class="normal"> SStarRankStream</span><span class="symbol">&amp;</span><span class="normal"> sstarrankstream</span><span class="symbol">,</span><span class="normal"> SStarLCPStream</span><span class="symbol">&amp;</span><span class="normal"> sstarlcpstream</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> depth</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Induce process() started"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">process_input</span><span class="symbol">(</span><span class="normal">inputrev</span><span class="symbol">,</span><span class="normal"> sstarrankstream</span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Induce process() done"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">induceL</span><span class="symbol">(</span><span class="normal">sstarlcpstream</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">induceS</span><span class="symbol">();</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Merge counter: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m_mergecounter</span><span class="symbol">);</span>
<span class="normal">            g_statscache </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="string">"tuplemerges"</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> depth </span><span class="symbol">&lt;&lt;</span><span class="normal"> m_mergecounter</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">// }}}</span>

<span class="normal">    </span><span class="comment">/*********************************************************************************************************</span>
<span class="comment">     * Step 3: Recursion - input filter and output merger                                                    *</span>
<span class="comment">     *********************************************************************************************************/</span>

<span class="normal">    </span><span class="comment">/// This stream class splits up the NameTuple of (index,name) prepared by run_merger into just a sequence</span>
<span class="normal">    </span><span class="comment">/// of (name). This basically adapts the standard stxxl::sorter to the input sequence, which is read</span>
<span class="normal">    </span><span class="comment">/// backwards.</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">st_nametuple_type</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">RecursionInputFilter</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">private</span><span class="symbol">:</span>

<span class="normal">        </span><span class="comment">/// sorter NameTuple (index,name) stream</span>
<span class="normal">        st_nametuple_type</span><span class="symbol">&amp;</span><span class="normal">              m_st_nametuple</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// value type</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal">             value_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">        </span><span class="function">RecursionInputFilter</span><span class="symbol">(</span><span class="normal">st_nametuple_type</span><span class="symbol">&amp;</span><span class="normal"> st_nametuple</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">m_st_nametuple</span><span class="symbol">(</span><span class="normal">st_nametuple</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        RecursionInputFilter</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">rewind</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> mem</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            m_st_nametuple</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        RecursionInputFilter</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">finish</span><span class="symbol">()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            m_st_nametuple</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="usertype">value_type</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">*()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_st_nametuple</span><span class="symbol">-&gt;</span><span class="normal">name</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="usertype">value_type</span><span class="normal"> </span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_st_nametuple</span><span class="symbol">-&gt;</span><span class="normal">index</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        RecursionInputFilter</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">--()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="symbol">++</span><span class="normal">m_st_nametuple</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">bool</span><span class="normal"> </span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_st_nametuple</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="usertype">size_type</span><span class="normal"> </span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_st_nametuple</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">InputPairs</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">InputISA</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">RecursionInduceFilter</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">protected</span><span class="symbol">:</span>

<span class="normal">        InputPairs</span><span class="symbol">&amp;</span><span class="normal">     m_in1</span><span class="symbol">;</span>

<span class="normal">        InputISA</span><span class="symbol">&amp;</span><span class="normal">       m_in2</span><span class="symbol">;</span>

<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">RankTuple</span><span class="normal"> value_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="usertype">RankTuple</span><span class="normal">       m_current</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">        </span><span class="function">RecursionInduceFilter</span><span class="symbol">(</span><span class="normal">InputPairs</span><span class="symbol">&amp;</span><span class="normal"> in1</span><span class="symbol">,</span><span class="normal"> InputISA</span><span class="symbol">&amp;</span><span class="normal"> in2</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">m_in1</span><span class="symbol">(</span><span class="normal">in1</span><span class="symbol">),</span><span class="normal"> </span><span class="function">m_in2</span><span class="symbol">(</span><span class="normal">in2</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            m_current </span><span class="symbol">=</span><span class="normal"> </span><span class="function">RankTuple</span><span class="symbol">(</span><span class="normal">m_in1</span><span class="symbol">.</span><span class="function">curr_index</span><span class="symbol">(),</span><span class="normal"> m_in2</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">bool</span><span class="normal"> </span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m_in1</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> m_in2</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">());</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">finish_clear</span><span class="symbol">()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            m_in2</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span><span class="normal">      </span><span class="comment">// deallocate ISA array</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        RecursionInduceFilter</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="symbol">--</span><span class="normal">m_in1</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">m_in2</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">                m_current </span><span class="symbol">=</span><span class="normal"> </span><span class="function">RankTuple</span><span class="symbol">(</span><span class="normal">m_in1</span><span class="symbol">.</span><span class="function">curr_index</span><span class="symbol">(),</span><span class="normal"> m_in2</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">*()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_current</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">*</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">-&gt;()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">&amp;</span><span class="normal">m_current</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">DequeLCPStream</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="keyword">public</span><span class="normal"> ShortStringSorter</span><span class="symbol">::</span><span class="normal">lcp_deque_type</span><span class="symbol">::</span><span class="normal">stream</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">private</span><span class="symbol">:</span>
<span class="normal">        </span><span class="usertype">offset_type</span><span class="normal">     index</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">        </span><span class="function">DequeLCPStream</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">ShortStringSorter</span><span class="symbol">::</span><span class="normal">lcp_deque_type</span><span class="symbol">&amp;</span><span class="normal"> deque2</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> ShortStringSorter</span><span class="symbol">::</span><span class="normal">lcp_deque_type</span><span class="symbol">::</span><span class="function">stream</span><span class="symbol">(</span><span class="normal">deque2</span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">index</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">sort</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        DequeLCPStream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++()</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="symbol">++</span><span class="normal">index</span><span class="symbol">;</span>
<span class="normal">            ShortStringSorter</span><span class="symbol">::</span><span class="normal">lcp_deque_type</span><span class="symbol">::</span><span class="normal">stream</span><span class="symbol">::</span><span class="keyword">operator</span><span class="symbol">++();</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> index</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/// Dummy LCP stream returning only zeros as needed for the base-case where all lcps are zero.</span>
<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">ZeroLCPStream</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal">     value_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">        </span><span class="usertype">value_type</span><span class="normal">      m_current</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">        </span><span class="function">ZeroLCPStream</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="function">m_current</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">        </span><span class="type">bool</span><span class="normal"> </span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">        ZeroLCPStream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">*()</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> m_current</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">sort</span><span class="symbol">(</span><span class="normal">size_t</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{}</span>

<span class="normal">        </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SorterLCPrangesumAnswer</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SorterRMQresult</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">SStarLCPStream</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal">     value_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">protected</span><span class="symbol">:</span>
<span class="normal">        </span><span class="type">bool</span><span class="normal">            m_empty</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">value_type</span><span class="normal">      m_current</span><span class="symbol">;</span>
<span class="normal">        </span><span class="usertype">offset_type</span><span class="normal">     m_index</span><span class="symbol">;</span>

<span class="normal">        SorterLCPrangesumAnswer</span><span class="symbol">&amp;</span><span class="normal">  LCPrangesumAnswer</span><span class="symbol">;</span>
<span class="normal">        SorterRMQresult</span><span class="symbol">&amp;</span><span class="normal">        RMQresult</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>
<span class="normal">        </span><span class="function">SStarLCPStream</span><span class="symbol">(</span><span class="normal">SorterLCPrangesumAnswer</span><span class="symbol">&amp;</span><span class="normal"> _LCPrangesumAnswer</span><span class="symbol">,</span><span class="normal"> SorterRMQresult</span><span class="symbol">&amp;</span><span class="normal"> _RMQresult</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">m_empty</span><span class="symbol">(</span><span class="keyword">false</span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">m_current</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">m_index</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">),</span><span class="normal">               </span><span class="comment">// first lcp is sentinel zero</span>
<span class="normal">              </span><span class="function">LCPrangesumAnswer</span><span class="symbol">(</span><span class="normal">_LCPrangesumAnswer</span><span class="symbol">),</span>
<span class="normal">              </span><span class="function">RMQresult</span><span class="symbol">(</span><span class="normal">_RMQresult</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">void</span><span class="normal"> </span><span class="function">sort</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> size_t</span><span class="symbol">&amp;</span><span class="normal"> memsize</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            LCPrangesumAnswer</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>
<span class="normal">            RMQresult</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">bool</span><span class="normal"> </span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_empty</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        SStarLCPStream</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">RMQresult</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                m_empty </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            m_index </span><span class="symbol">=</span><span class="normal"> RMQresult</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">;</span>
<span class="normal">            m_current </span><span class="symbol">=</span><span class="normal"> RMQresult</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">;</span>
<span class="normal">            </span><span class="symbol">++</span><span class="normal">RMQresult</span><span class="symbol">;</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Next S*-lcp at position "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m_index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" current minimum "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m_current</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">RMQresult</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> RMQresult</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">==</span><span class="normal"> m_index </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                m_current </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal"> m_current</span><span class="symbol">,</span><span class="normal"> RMQresult</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">);</span>
<span class="normal">                </span><span class="symbol">++</span><span class="normal">RMQresult</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"After another RMQanswer: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m_current</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LCPrangesumAnswer</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> LCPrangesumAnswer</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">==</span><span class="normal"> m_index </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> rangesum1 </span><span class="symbol">=</span><span class="normal"> LCPrangesumAnswer</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">;</span>

<span class="normal">                </span><span class="symbol">++</span><span class="normal">LCPrangesumAnswer</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">LCPrangesumAnswer</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span><span class="normal">   </span><span class="comment">// range sums always come in pairs</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> LCPrangesumAnswer</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">==</span><span class="normal"> m_index </span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> rangesum2 </span><span class="symbol">=</span><span class="normal"> LCPrangesumAnswer</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">;</span>
<span class="normal">                </span><span class="symbol">++</span><span class="normal">LCPrangesumAnswer</span><span class="symbol">;</span>

<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> rangesum </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rangesum1 </span><span class="symbol">&lt;</span><span class="normal"> rangesum2</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">?</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rangesum2 </span><span class="symbol">-</span><span class="normal"> rangesum1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rangesum1 </span><span class="symbol">-</span><span class="normal"> rangesum2</span><span class="symbol">);</span>

<span class="normal">                m_current </span><span class="symbol">+=</span><span class="normal"> rangesum</span><span class="symbol">;</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Added range sum = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> rangesum</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp_merge</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Final S*-lcp = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m_current</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">*()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_current</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_index</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="normal">    </span><span class="comment">/// This stream class splits up the sequences of (index,name) prepared by run_merger into just a sequence</span>
<span class="normal">    </span><span class="comment">/// of (name). Therewhile discarding sequences of unique substrings, leaving only the first unique name.</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">st_nametuple_type</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">class</span><span class="normal"> </span><span class="classname">RecursionInputFilterDiscard</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="keyword">private</span><span class="symbol">:</span>

<span class="normal">        </span><span class="comment">/// sorter NameTuple (index,name) stream</span>
<span class="normal">        st_nametuple_type</span><span class="symbol">&amp;</span><span class="normal">              m_st_nametuple</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// value type</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal">             value_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// the current value of this stream, while the runs_merger is always one step ahead.</span>
<span class="normal">        </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">st_nametuple_type</span><span class="symbol">::</span><span class="usertype">value_type</span><span class="normal">        m_current</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// end of stream, extra flag needed because it does not coincide with runs_merger.empty()</span>
<span class="normal">        </span><span class="type">bool</span><span class="normal">                            m_empty</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">/// total size</span>
<span class="normal">        </span><span class="usertype">size_type</span><span class="normal">                       m_totalsize</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">        </span><span class="function">RecursionInputFilterDiscard</span><span class="symbol">(</span><span class="normal">st_nametuple_type</span><span class="symbol">&amp;</span><span class="normal"> st_nametuple</span><span class="symbol">)</span>
<span class="normal">            </span><span class="symbol">:</span><span class="normal"> </span><span class="function">m_st_nametuple</span><span class="symbol">(</span><span class="normal">st_nametuple</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            m_empty </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">operator</span><span class="symbol">--();</span>

<span class="normal">            m_totalsize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal">    </span><span class="comment">// count number of characters after discarding uniques</span>
<span class="normal">            </span><span class="keyword">while</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="symbol">++</span><span class="normal">m_totalsize</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">operator</span><span class="symbol">--();</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Total size after discarding: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m_totalsize</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - original: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> m_st_nametuple</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - "</span>
<span class="normal">                </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m_totalsize </span><span class="symbol">*</span><span class="normal"> </span><span class="number">100.0</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> m_st_nametuple</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" percent"</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        RecursionInputFilterDiscard</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">rewind</span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> mem</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            m_st_nametuple</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">mem</span><span class="symbol">);</span>
<span class="normal">            m_empty </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">operator</span><span class="symbol">--();</span>

<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        RecursionInputFilterDiscard</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">finish</span><span class="symbol">()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            m_st_nametuple</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="usertype">value_type</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">*()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_current</span><span class="symbol">.</span><span class="normal">name</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="usertype">value_type</span><span class="normal"> </span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_current</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        RecursionInputFilterDiscard</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">--()</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="function">assert</span><span class="symbol">(!</span><span class="normal">m_empty</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m_st_nametuple</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                m_empty </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            m_current </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">m_st_nametuple</span><span class="symbol">;</span>
<span class="normal">            </span><span class="symbol">++</span><span class="normal">m_st_nametuple</span><span class="symbol">;</span>

<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">m_st_nametuple</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> m_current</span><span class="symbol">.</span><span class="normal">unique </span><span class="symbol">&amp;&amp;</span><span class="normal"> m_st_nametuple</span><span class="symbol">-&gt;</span><span class="normal">unique </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                m_current </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">m_st_nametuple</span><span class="symbol">;</span>
<span class="normal">                </span><span class="symbol">++</span><span class="normal">m_st_nametuple</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="type">bool</span><span class="normal"> </span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_empty</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="usertype">size_type</span><span class="normal"> </span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> m_totalsize</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>
<span class="preproc">#endif</span>

<span class="normal">     </span><span class="comment">/// Sorts left RMQ tuples boundaries by (i DIV S, tgt) with S the RMQ slab size</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="type">int</span><span class="normal"> S</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">indexpair_RMQ</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> tuples</span><span class="symbol">::</span><span class="usertype">pair&lt;offset_type,offset_type&gt;</span><span class="normal">      value_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">/</span><span class="normal"> S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">/</span><span class="normal"> S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">second </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">/</span><span class="normal"> S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">/</span><span class="normal"> S</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">value_type</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> value_type</span><span class="symbol">::</span><span class="function">min_value</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">value_type</span><span class="normal"> </span><span class="function">max_value</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> value_type</span><span class="symbol">::</span><span class="function">max_value</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">     </span><span class="comment">/// Sorts right RMQ tuples boundaries by (i DIV S, tgt) with S the RMQ slab size</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">TripleType</span><span class="symbol">,</span><span class="normal"> </span><span class="type">int</span><span class="normal"> S</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="keyword">struct</span><span class="normal"> </span><span class="classname">indextriple_RMQ</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">TripleType</span><span class="normal">      value_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="type">bool</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">()(</span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal"> a</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> value_type</span><span class="symbol">&amp;</span><span class="normal"> b</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">/</span><span class="normal"> S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">/</span><span class="normal"> S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> a</span><span class="symbol">.</span><span class="normal">second </span><span class="symbol">&lt;</span><span class="normal"> b</span><span class="symbol">.</span><span class="normal">second</span><span class="symbol">;</span>
<span class="normal">            </span><span class="keyword">else</span>
<span class="normal">                </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">a</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">/</span><span class="normal"> S</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">b</span><span class="symbol">.</span><span class="normal">first </span><span class="symbol">/</span><span class="normal"> S</span><span class="symbol">);</span>
<span class="normal">        </span><span class="cbracket">}</span>

<span class="normal">        </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">value_type</span><span class="normal"> </span><span class="function">min_value</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> value_type</span><span class="symbol">::</span><span class="function">min_value</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">        </span><span class="keyword">static</span><span class="normal"> </span><span class="usertype">value_type</span><span class="normal"> </span><span class="function">max_value</span><span class="symbol">()</span><span class="normal"> </span><span class="cbracket">{</span><span class="normal"> </span><span class="keyword">return</span><span class="normal"> value_type</span><span class="symbol">::</span><span class="function">max_value</span><span class="symbol">();</span><span class="normal"> </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span><span class="symbol">;</span>

<span class="normal">    </span><span class="comment">/*********************************************************************************************************</span>
<span class="comment">     * eSAIS Main                                                                                            *</span>
<span class="comment">     *********************************************************************************************************/</span>

<span class="normal">    </span><span class="comment">/// instance of inducing process's result which delivers the output stream</span>
<span class="normal">    Result</span><span class="symbol">*</span><span class="normal">             m_result</span><span class="symbol">;</span>

<span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">    </span><span class="function">eSAIS</span><span class="symbol">()</span>
<span class="normal">        </span><span class="symbol">:</span><span class="normal"> </span><span class="function">m_result</span><span class="symbol">(</span><span class="normal">NULL</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">alphabet_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;=</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">offset_type</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="symbol">~</span><span class="function">eSAIS</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">m_result</span><span class="symbol">)</span><span class="normal"> </span><span class="keyword">delete</span><span class="normal"> m_result</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">InputStreamReverse</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="function">run</span><span class="symbol">(</span><span class="normal">InputStreamReverse</span><span class="symbol">&amp;</span><span class="normal"> inputrev</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> depth </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">TimerSeries</span><span class="normal"> timer</span><span class="symbol">;</span>
<span class="normal">        timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"start"</span><span class="symbol">);</span>

<span class="normal">        </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> maxdepth</span><span class="symbol">;</span>

<span class="normal">        </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"run()"</span><span class="symbol">);</span>

<span class="normal">        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"inputsize="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> inputrev</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">", "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span>
<span class="normal">            </span><span class="string">"sizeof(CTuple)="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Induce</span><span class="symbol">::</span><span class="normal">CTuple</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">", "</span>
<span class="normal">            </span><span class="string">"sizeof(PQTuple)="</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">Induce</span><span class="symbol">::</span><span class="normal">PQTuple</span><span class="symbol">));</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Typedefs of sorter for index pairs of (index,rank)</span>

<span class="normal">        </span><span class="comment">// pair of (index,name) created by lexnaming in substring sorter</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> tuples</span><span class="symbol">::</span><span class="usertype">pair&lt;offset_type,offset_type&gt;</span><span class="normal"> indexpair_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// comparator type that will sort by first component: index</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> tuples</span><span class="symbol">::</span><span class="usertype">pair_less1st&lt;indexpair_type&gt;</span><span class="normal"> indexpair_less1st_type</span><span class="symbol">;</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> tuples</span><span class="symbol">::</span><span class="usertype">pair_greater1st&lt;indexpair_type&gt;</span><span class="normal"> indexpair_greater1st_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="usertype">indexpair_greater1st_type</span><span class="normal"> indexpair_greater1st</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// complete sorter for indexpair_type</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt;indexpair_type, indexpair_greater1st_type, block_size&gt;</span><span class="normal"> st_indexpair_byindex_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Read input from back to front, split at S*-positions or block boundaries and feed substrings to</span>
<span class="normal">        </span><span class="comment">// *** sorter</span>

<span class="normal">        </span><span class="usertype">ShortStringSorter</span><span class="normal"> sss</span><span class="symbol">;</span>

<span class="normal">        </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"ShortStringSorter start"</span><span class="symbol">);</span>

<span class="normal">        sss</span><span class="symbol">.</span><span class="function">process_input</span><span class="symbol">(</span><span class="normal"> inputrev</span><span class="symbol">,</span><span class="normal"> depth </span><span class="symbol">);</span>

<span class="normal">        </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"ShortStringSorter process_input() done"</span><span class="symbol">);</span>
<span class="normal">        timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"sssort"</span><span class="symbol">).</span><span class="function">printlast</span><span class="symbol">();</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Get sorted NameTuples (name,index,uniqueflag,length) via merge of sorted sequences and sort</span>
<span class="normal">        </span><span class="comment">// *** output by index</span>

<span class="normal">        </span><span class="comment">// sorter for NameTuples (index,name,uniqueflag,length)</span>
<span class="normal">        </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt;NameTuple, NameTupleOrder_IndexDesc, block_size&gt;</span><span class="normal"> st_nametuple_byindex_type</span><span class="symbol">;</span>

<span class="normal">        </span><span class="usertype">st_nametuple_byindex_type</span><span class="normal">    </span><span class="function">st_nametuple</span><span class="symbol">(</span><span class="function">NameTupleOrder_IndexDesc</span><span class="symbol">(),</span><span class="normal"> memsize</span><span class="symbol">,</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>

<span class="normal">        </span><span class="comment">// run substring merger: merge sorted sequences do lexnaming and push (index,name,...) into runs creator</span>
<span class="normal">        sss</span><span class="symbol">.</span><span class="function">merge</span><span class="symbol">(</span><span class="normal"> st_nametuple </span><span class="symbol">);</span>

<span class="normal">        </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_lexnamepairs</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"NameTuple list"</span><span class="symbol">,</span><span class="normal"> st_nametuple</span><span class="symbol">);</span>

<span class="normal">        </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"ShortStringSorter merge() done"</span><span class="symbol">);</span>
<span class="normal">        timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"ssname"</span><span class="symbol">).</span><span class="function">printlast</span><span class="symbol">();</span>

<span class="normal">        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Substring tuples: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sss</span><span class="symbol">.</span><span class="function">totalsize</span><span class="symbol">()</span>
<span class="normal">            </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" total with "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sss</span><span class="symbol">.</span><span class="function">duplicates</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" duplicates and "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sss</span><span class="symbol">.</span><span class="function">totalsize</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> sss</span><span class="symbol">.</span><span class="function">duplicates</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" uniques,"</span>
<span class="normal">            </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" ratio = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sss</span><span class="symbol">.</span><span class="function">totalsize</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">*</span><span class="normal"> </span><span class="number">1.0</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> sss</span><span class="symbol">.</span><span class="function">duplicates</span><span class="symbol">());</span>

<span class="normal">        g_statscache </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="string">"S*ss-duplicates"</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> depth </span><span class="symbol">&lt;&lt;</span><span class="normal"> sss</span><span class="symbol">.</span><span class="function">duplicates</span><span class="symbol">();</span>
<span class="normal">        g_statscache </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="string">"S*ss-uniques"</span><span class="normal"> </span><span class="symbol">&gt;&gt;</span><span class="normal"> depth </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sss</span><span class="symbol">.</span><span class="function">totalsize</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">-</span><span class="normal"> sss</span><span class="symbol">.</span><span class="function">duplicates</span><span class="symbol">());</span>

<span class="normal">        </span><span class="comment">// ***************************************************************************************************</span>
<span class="normal">        </span><span class="comment">// *** Depending of whether names were unique: go into recursion or use names as ranks.</span>

<span class="normal">        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> sss</span><span class="symbol">.</span><span class="function">was_unique</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// base case with unique names: use (index,rank) directly for PQ-creation</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">" No recursion needed, depth "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> depth </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" *************************************************************"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug_recursive_input </span><span class="symbol">||</span><span class="normal"> debug_induce_input</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// sorter yields (index,rank) order by index DESC.</span>
<span class="normal">                </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_recursive_input </span><span class="symbol">||</span><span class="normal"> debug_induce_input</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Base-case Input for Induce (in reverse)"</span><span class="symbol">,</span><span class="normal"> st_nametuple</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">ShortStringSorter</span><span class="symbol">::</span><span class="normal">lcp_deque_type</span><span class="symbol">::</span><span class="usertype">stream</span><span class="normal"> </span><span class="function">lcpstream</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> sss</span><span class="symbol">.</span><span class="normal">lexname_lcp_deque </span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_recursive_input </span><span class="symbol">||</span><span class="normal"> debug_induce_input</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Base-case LCP Stream for Induce (in SA-order): "</span><span class="symbol">);</span>

<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">lcpstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_recursive_input </span><span class="symbol">||</span><span class="normal"> debug_induce_input</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">lcpstream</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="symbol">++</span><span class="normal">lcpstream</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// sorter yields (index,rank) order by index DESC.</span>
<span class="normal">            st_nametuple</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="usertype">DequeLCPStream</span><span class="normal"> </span><span class="function">lcpstream</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> sss</span><span class="symbol">.</span><span class="normal">lexname_lcp_deque </span><span class="symbol">);</span>
<span class="preproc">#else</span><span class="normal"> </span><span class="comment">// !ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="usertype">ZeroLCPStream</span><span class="normal"> lcpstream</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            m_result </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> Result</span><span class="symbol">;</span>

<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">auto_ptr&lt;Induce&gt;</span><span class="normal"> </span><span class="function">induce</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">new</span><span class="normal"> </span><span class="function">Induce</span><span class="symbol">(</span><span class="normal">m_result</span><span class="symbol">));</span>
<span class="normal">            induce</span><span class="symbol">-&gt;</span><span class="function">process</span><span class="symbol">(</span><span class="normal"> inputrev</span><span class="symbol">,</span><span class="normal"> st_nametuple</span><span class="symbol">,</span><span class="normal"> lcpstream</span><span class="symbol">,</span><span class="normal"> depth </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Induce process() done"</span><span class="symbol">);</span>
<span class="normal">            timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"done"</span><span class="symbol">).</span><span class="function">printall</span><span class="symbol">();</span>

<span class="normal">            </span><span class="comment">// result of induce can be read by caller via stream interface.</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> depth</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="normal">        </span><span class="keyword">else</span><span class="normal"> </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">sss</span><span class="symbol">.</span><span class="function">totalsize</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> sss</span><span class="symbol">.</span><span class="function">duplicates</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&gt;=</span><span class="normal"> </span><span class="number">3</span><span class="symbol">)</span><span class="normal">     </span><span class="comment">// unique discarding</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// ***********************************************************************************************</span>
<span class="normal">            </span><span class="comment">// *** recursion case with duplicate names: create recursion string by removing second component</span>
<span class="normal">            </span><span class="comment">// *** and discarding sequences of unique names</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"*** Entering Recursion with unique discarding, depth "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> depth </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" ************************************************************"</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="preproc">#error</span><span class="normal"> </span><span class="string">"LCP Calculation not implemented with discarding."</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            </span><span class="comment">// recursion filter: extracts sequences of (name) from pairs and indexes in a queue</span>

<span class="normal">            st_nametuple</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">RecursionInputFilterDiscard&lt;st_nametuple_byindex_type&gt;</span><span class="normal"> rec_input_type</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">rec_input_type</span><span class="normal"> </span><span class="function">rec_input</span><span class="symbol">(</span><span class="normal"> st_nametuple </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(</span><span class="normal"> </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">sss</span><span class="symbol">.</span><span class="normal">SStarSize</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> rec_input</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Built recursion filter"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug_recursive_input</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_recursive_input</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Recursive Input (in reverse):"</span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal"> rec_input</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_recursive_input</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">rec_input </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" (idx "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> rec_input</span><span class="symbol">.</span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="symbol">--</span><span class="normal">rec_input</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_recursive_input</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"End"</span><span class="symbol">);</span>

<span class="normal">                rec_input</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// --- run recursion</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Enter recursion"</span><span class="symbol">);</span>
<span class="normal">            timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"recstart"</span><span class="symbol">).</span><span class="function">printlast</span><span class="symbol">();</span>

<span class="normal">            </span><span class="usertype">eSAIS&lt;offset_type, offset_type, size_type&gt;</span><span class="normal"> esais_recurse</span><span class="symbol">;</span>
<span class="normal">            maxdepth </span><span class="symbol">=</span><span class="normal"> esais_recurse</span><span class="symbol">.</span><span class="function">run</span><span class="symbol">(</span><span class="normal"> rec_input</span><span class="symbol">,</span><span class="normal"> depth</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"*** Exiting Recursion, depth "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> depth </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" *************************************************************"</span><span class="symbol">);</span>

<span class="normal">            timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"recdone"</span><span class="symbol">).</span><span class="function">printlast</span><span class="symbol">();</span>
<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Exit recursion"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// --- process recursion result</span>

<span class="normal">            </span><span class="comment">// sorted_runs to contain result SA and build inverse suffix array</span>
<span class="normal">            </span><span class="usertype">st_indexpair_byindex_type</span><span class="normal">   </span><span class="function">st_ISA</span><span class="symbol">(</span><span class="normal">indexpair_greater1st</span><span class="symbol">,</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Created result sorters"</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">vector&lt;offset_type&gt;</span><span class="normal">    recoutput</span><span class="symbol">;</span>
<span class="preproc">#endif</span>

<span class="normal">            </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="usertype">size_type</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">esais_recurse</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">esais_recurse </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_recursive_output</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"recursive SA["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="usertype">esais_recurse</span><span class="normal"> </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(&lt;&lt;</span><span class="normal"> </span><span class="string">" with lcp["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> esais_recurse</span><span class="symbol">.</span><span class="function">lcp</span><span class="symbol">()));</span>

<span class="normal">                st_ISA</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indexpair_type</span><span class="symbol">(*</span><span class="normal">esais_recurse</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK</span>
<span class="normal">                recoutput</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">esais_recurse </span><span class="symbol">);</span>
<span class="preproc">#endif</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            st_ISA</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// read recursive input into memory</span>
<span class="normal">                rec_input</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>
<span class="normal">                std</span><span class="symbol">::</span><span class="usertype">vector&lt;offset_type&gt;</span><span class="normal"> </span><span class="function">recinput</span><span class="symbol">(</span><span class="normal">rec_input</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                </span><span class="keyword">for</span><span class="symbol">(</span><span class="usertype">size_type</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> recinput</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">rec_input</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">--</span><span class="normal">rec_input</span><span class="symbol">)</span>
<span class="normal">                    recinput</span><span class="symbol">[--</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">rec_input</span><span class="symbol">;</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug_recursive_output</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"</span><span class="specialchar">\n</span><span class="string">Resulting suffix array: </span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">;</span>

<span class="normal">                    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> recoutput</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> i </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" : "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> recoutput</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" : "</span><span class="symbol">;</span>

<span class="normal">                        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> j </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> recoutput</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]+</span><span class="normal">j </span><span class="symbol">&lt;</span><span class="normal"> recinput</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> j </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">20</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">j</span><span class="symbol">)</span>
<span class="normal">                            std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">recinput</span><span class="symbol">[</span><span class="normal">recoutput</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]+</span><span class="normal">j</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" "</span><span class="symbol">;</span>

<span class="normal">                        std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" checking Recursion "</span><span class="symbol">).</span><span class="function">flush</span><span class="symbol">();</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> sacheck</span><span class="symbol">::</span><span class="function">check_sa_vectors</span><span class="symbol">(</span><span class="normal">recinput</span><span class="symbol">,</span><span class="normal"> recoutput</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"failed!"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"ok"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_SELF_CHECK</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Iterating over ISA build RerankTuples"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// final sorter yielding (index,rank) by index of all S*-positions, used by Induce</span>
<span class="normal">            stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt;RankTuple, RankTupleOrder_IndexDesc, block_size&gt;</span><span class="normal"> </span><span class="function">st_sstarranks</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RankTupleOrder_IndexDesc</span><span class="symbol">(),</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// *** Merge (i,ISA) from recursion with original recstr (i,name[i]). Those that were discarded</span>
<span class="normal">            </span><span class="comment">// *** are put into the final sorter, others are merged with recISA into a RerankTuple</span>

<span class="normal">            </span><span class="comment">// runs creator for RerankTuple (index,rank,ISA)</span>
<span class="normal">            stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt;RerankTuple, RerankTuple_ISA, block_size&gt;</span><span class="normal"> </span><span class="function">st_reranktuple</span><span class="normal"> </span><span class="symbol">(</span><span class="function">RerankTuple_ISA</span><span class="symbol">(),</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>

<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// runs merger yields (i,ISA[i]) order by index DESC.</span>
<span class="normal">                st_ISA</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>

<span class="normal">                </span><span class="comment">// runs merger yields (index,rank) order by index DESC.</span>
<span class="normal">                st_nametuple</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">NameTuple</span><span class="normal"> current </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">st_nametuple</span><span class="symbol">;</span>
<span class="normal">                </span><span class="symbol">++</span><span class="normal">st_nametuple</span><span class="symbol">;</span>

<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">st_nametuple</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">current</span><span class="symbol">.</span><span class="normal">unique </span><span class="symbol">&amp;&amp;</span><span class="normal"> st_nametuple</span><span class="symbol">-&gt;</span><span class="normal">unique</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="comment">// current was discarded</span>
<span class="normal">                        st_sstarranks</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">RankTuple</span><span class="symbol">(</span><span class="normal">current</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">,</span><span class="normal"> current</span><span class="symbol">.</span><span class="normal">name</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_rerank</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Discarded from recursion: ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> current</span><span class="symbol">.</span><span class="normal">index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> current</span><span class="symbol">.</span><span class="normal">name </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">st_ISA</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                        </span><span class="usertype">RerankTuple</span><span class="normal"> </span><span class="function">rt</span><span class="symbol">(</span><span class="normal">current</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">,</span><span class="normal"> current</span><span class="symbol">.</span><span class="normal">name</span><span class="symbol">,</span><span class="normal"> st_ISA</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">                        st_reranktuple</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">rt</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="symbol">++</span><span class="normal">st_ISA</span><span class="symbol">;</span>

<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_rerank</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Reranking tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> rt</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    current </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">st_nametuple</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="symbol">++</span><span class="normal">st_nametuple</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="comment">// process last tuple</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">st_ISA</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">RerankTuple</span><span class="normal"> </span><span class="function">rt</span><span class="symbol">(</span><span class="normal">current</span><span class="symbol">.</span><span class="normal">index</span><span class="symbol">,</span><span class="normal"> current</span><span class="symbol">.</span><span class="normal">name</span><span class="symbol">,</span><span class="normal"> st_ISA</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">                st_reranktuple</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal">rt</span><span class="symbol">);</span>
<span class="normal">                </span><span class="symbol">++</span><span class="normal">st_ISA</span><span class="symbol">;</span>

<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> st_ISA</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_rerank</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Reranking tuple "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> rt</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            st_nametuple</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>
<span class="normal">            st_ISA</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Reranking Tuples"</span><span class="symbol">);</span>

<span class="normal">            st_reranktuple</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>

<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// *** Iterate over RerankTuples (index,name,ISA) and rerank names into ranks ascending with ISA.</span>

<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> lastrank </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">numeric_limits</span><span class="symbol">&lt;</span><span class="normal">offset_type</span><span class="symbol">&gt;::</span><span class="function">max</span><span class="symbol">();</span>
<span class="normal">                </span><span class="usertype">size_type</span><span class="normal"> rankcounter </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>

<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">st_reranktuple</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_rerank</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Rerank tuple: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">st_reranktuple</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">st_reranktuple</span><span class="symbol">-&gt;</span><span class="normal">name </span><span class="symbol">!=</span><span class="normal"> lastrank</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        lastrank </span><span class="symbol">=</span><span class="normal"> st_reranktuple</span><span class="symbol">-&gt;</span><span class="normal">name</span><span class="symbol">;</span>
<span class="normal">                        rankcounter </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        rankcounter</span><span class="symbol">++;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_rerank</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"--- reranking to "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> lastrank</span><span class="symbol">+</span><span class="normal">rankcounter</span><span class="symbol">);</span>
<span class="normal">                    st_sstarranks</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">RankTuple</span><span class="symbol">(</span><span class="normal">st_reranktuple</span><span class="symbol">-&gt;</span><span class="normal">index</span><span class="symbol">,</span><span class="normal">lastrank</span><span class="symbol">+</span><span class="normal">rankcounter</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="symbol">++</span><span class="normal">st_reranktuple</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            st_reranktuple</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>
<span class="normal">            st_sstarranks</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_rerank</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"SStarRanks"</span><span class="symbol">,</span><span class="normal"> st_sstarranks</span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Induce created"</span><span class="symbol">);</span>
<span class="normal">            timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"rerank"</span><span class="symbol">).</span><span class="function">printlast</span><span class="symbol">();</span>

<span class="normal">            m_result </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> Result</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">ZeroLCPStream</span><span class="normal"> lcpstream</span><span class="symbol">;</span>

<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">auto_ptr&lt;Induce&gt;</span><span class="normal"> </span><span class="function">induce</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">new</span><span class="normal"> </span><span class="function">Induce</span><span class="symbol">(</span><span class="normal">m_result</span><span class="symbol">));</span>
<span class="normal">            induce</span><span class="symbol">-&gt;</span><span class="function">process</span><span class="symbol">(</span><span class="normal"> inputrev</span><span class="symbol">,</span><span class="normal"> st_sstarranks</span><span class="symbol">,</span><span class="normal"> lcpstream</span><span class="symbol">,</span><span class="normal"> depth </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Induce process() done"</span><span class="symbol">);</span>
<span class="normal">            timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"done"</span><span class="symbol">).</span><span class="function">printall</span><span class="symbol">();</span>

<span class="normal">            </span><span class="comment">// result of induce can be read by caller via stream interface.</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> maxdepth</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_DISCARD_UNIQUES</span>
<span class="normal">        </span><span class="keyword">else</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">// ***********************************************************************************************</span>
<span class="normal">            </span><span class="comment">// *** recursion case with duplicate names: create recursion string by removing second component.</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"*** Entering Recursion, depth "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> depth </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" ************************************************************"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// recursion filter: extracts sequences of (name) from pairs and indexes in a queue</span>

<span class="normal">            st_nametuple</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>
<span class="normal">            </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">RecursionInputFilter&lt;st_nametuple_byindex_type&gt;</span><span class="normal"> rec_input_type</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">rec_input_type</span><span class="normal"> </span><span class="function">rec_input</span><span class="symbol">(</span><span class="normal"> st_nametuple </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Built recursion filter"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug_recursive_input</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_recursive_input</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Recursive Input (in reverse):"</span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal"> rec_input</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_recursive_input</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">rec_input </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" (idx "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> rec_input</span><span class="symbol">.</span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="symbol">--</span><span class="normal">rec_input</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_recursive_input</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"End"</span><span class="symbol">);</span>

<span class="normal">                rec_input</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// --- run recursion</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Enter recursion"</span><span class="symbol">);</span>
<span class="normal">            timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"recstart"</span><span class="symbol">).</span><span class="function">printlast</span><span class="symbol">();</span>

<span class="normal">            </span><span class="usertype">eSAIS&lt;offset_type, offset_type, size_type&gt;</span><span class="normal"> esais_recurse</span><span class="symbol">;</span>
<span class="normal">            maxdepth </span><span class="symbol">=</span><span class="normal"> esais_recurse</span><span class="symbol">.</span><span class="function">run</span><span class="symbol">(</span><span class="normal"> rec_input</span><span class="symbol">,</span><span class="normal"> depth</span><span class="symbol">+</span><span class="number">1</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"*** Exiting Recursion, depth "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> depth </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" *************************************************************"</span><span class="symbol">);</span>

<span class="normal">            timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"recdone"</span><span class="symbol">).</span><span class="function">printlast</span><span class="symbol">();</span>
<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Exit recursion"</span><span class="symbol">);</span>

<span class="normal">            std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"g_mainmemlcp: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> g_mainmemlcp </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">;</span>

<span class="normal">            st_nametuple</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>

<span class="normal">            </span><span class="comment">// --- process recursion result</span>

<span class="preproc">#if</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="comment">// sorter to read result SA and build inverse suffix array</span>
<span class="normal">            </span><span class="usertype">st_indexpair_byindex_type</span><span class="normal">   </span><span class="function">st_ISA</span><span class="symbol">(</span><span class="normal">indexpair_greater1st</span><span class="symbol">,</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>
<span class="preproc">#else</span>
<span class="normal">            </span><span class="comment">// sorter to read result SA and build inverse suffix array</span>
<span class="normal">            </span><span class="usertype">st_indexpair_byindex_type</span><span class="normal">   </span><span class="function">st_ISA</span><span class="symbol">(</span><span class="normal">indexpair_greater1st</span><span class="symbol">,</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// sorter to contain the range queries needed for sum term in LCP</span>
<span class="normal">            </span><span class="usertype">st_indexpair_byindex_type</span><span class="normal">   </span><span class="function">st_LCPrangesum</span><span class="symbol">(</span><span class="normal">indexpair_greater1st</span><span class="symbol">,</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// sorter to query the ISA array for specific positions, which are later transformed to RMQ</span>
<span class="normal">            </span><span class="usertype">st_indexpair_byindex_type</span><span class="normal">   </span><span class="function">st_ISAqueryLeft</span><span class="symbol">(</span><span class="normal">indexpair_greater1st</span><span class="symbol">,</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>
<span class="normal">            </span><span class="usertype">st_indexpair_byindex_type</span><span class="normal">   </span><span class="function">st_ISAqueryRight</span><span class="symbol">(</span><span class="normal">indexpair_greater1st</span><span class="symbol">,</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// direct queries into lcp_names for recursive lcp = 0</span>

<span class="normal">            </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">deque2&lt; offset_type, block_size &gt;</span><span class="normal">         LCPdirect_deque_type</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">LCPdirect_deque_type</span><span class="normal">        dq_LCPDirect</span><span class="symbol">;</span>

<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Created result sorters"</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">vector&lt;offset_type&gt;</span><span class="normal">    recoutput</span><span class="symbol">;</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">vector&lt;offset_type&gt;</span><span class="normal">    recoutput_lcp</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_SELF_CHECK</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="usertype">offset_type</span><span class="normal"> prevSA </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="usertype">size_type</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">esais_recurse</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">esais_recurse </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_recursive_output</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"recursive SA["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="usertype">esais_recurse</span><span class="normal"> </span><span class="function">ESAIS_LCP_CALCX</span><span class="symbol">(&lt;&lt;</span><span class="normal"> </span><span class="string">" with lcp["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> esais_recurse</span><span class="symbol">.</span><span class="function">lcp</span><span class="symbol">()));</span>

<span class="normal">                st_ISA</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indexpair_type</span><span class="symbol">(*</span><span class="normal">esais_recurse</span><span class="symbol">,</span><span class="normal"> i</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">i </span><span class="symbol">!=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">esais_recurse</span><span class="symbol">.</span><span class="function">lcp</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">))</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="comment">// add LCP range sum query tuples</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"range sum query pos "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">esais_recurse </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"range sum query pos "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">esais_recurse </span><span class="symbol">+</span><span class="normal"> esais_recurse</span><span class="symbol">.</span><span class="function">lcp</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i</span><span class="symbol">);</span>

<span class="normal">                        st_LCPrangesum</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="function">indexpair_type</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">esais_recurse</span><span class="symbol">,</span><span class="normal"> i </span><span class="symbol">));</span><span class="normal"> </span><span class="comment">// left position</span>
<span class="normal">                        st_LCPrangesum</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="function">indexpair_type</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">esais_recurse </span><span class="symbol">+</span><span class="normal"> esais_recurse</span><span class="symbol">.</span><span class="function">lcp</span><span class="symbol">(),</span><span class="normal"> i </span><span class="symbol">));</span><span class="normal"> </span><span class="comment">// right position</span>

<span class="normal">                        </span><span class="comment">// add ISA query tuples</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"ISA query left "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> prevSA </span><span class="symbol">+</span><span class="normal"> esais_recurse</span><span class="symbol">.</span><span class="function">lcp</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"ISA query right "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">esais_recurse </span><span class="symbol">+</span><span class="normal"> esais_recurse</span><span class="symbol">.</span><span class="function">lcp</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i</span><span class="symbol">);</span>

<span class="normal">                        st_ISAqueryLeft</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="function">indexpair_type</span><span class="symbol">(</span><span class="normal"> prevSA </span><span class="symbol">+</span><span class="normal"> esais_recurse</span><span class="symbol">.</span><span class="function">lcp</span><span class="symbol">(),</span><span class="normal"> i </span><span class="symbol">));</span>
<span class="normal">                        st_ISAqueryRight</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="function">indexpair_type</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">esais_recurse </span><span class="symbol">+</span><span class="normal"> esais_recurse</span><span class="symbol">.</span><span class="function">lcp</span><span class="symbol">(),</span><span class="normal"> i </span><span class="symbol">));</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="keyword">else</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="comment">// don't need to query ISA: direct lookup of adjacent lexname lcps</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP=0 direct query into LCP_Names for target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i</span><span class="symbol">);</span>
<span class="normal">                        dq_LCPDirect</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal">i</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                prevSA </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">esais_recurse</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK</span>
<span class="normal">                recoutput</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">esais_recurse </span><span class="symbol">);</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                recoutput_lcp</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal"> esais_recurse</span><span class="symbol">.</span><span class="function">lcp</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_SELF_CHECK</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            st_ISA</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            st_LCPrangesum</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="normal">            st_ISAqueryLeft</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="normal">            st_ISAqueryRight</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Done reading recursive input"</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="comment">// read recursive input into memory</span>
<span class="normal">                rec_input</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>
<span class="normal">                std</span><span class="symbol">::</span><span class="usertype">vector&lt;offset_type&gt;</span><span class="normal"> </span><span class="function">recinput</span><span class="symbol">(</span><span class="normal">rec_input</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                </span><span class="keyword">for</span><span class="symbol">(</span><span class="usertype">size_type</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> recinput</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">rec_input</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">--</span><span class="normal">rec_input</span><span class="symbol">)</span>
<span class="normal">                    recinput</span><span class="symbol">[--</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">rec_input</span><span class="symbol">;</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug_recursive_output</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"</span><span class="specialchar">\n</span><span class="string">Resulting suffix array: </span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">;</span>

<span class="normal">                    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> recoutput</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> i </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" : "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> recoutput</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" : "</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                        std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> i </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" lcp "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> recoutput_lcp</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" : "</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">                        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> j </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> recoutput</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]+</span><span class="normal">j </span><span class="symbol">&lt;</span><span class="normal"> recinput</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> j </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="number">20</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">j</span><span class="symbol">)</span>
<span class="normal">                            std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">strC</span><span class="symbol">(</span><span class="normal">recinput</span><span class="symbol">[</span><span class="normal">recoutput</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]+</span><span class="normal">j</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" "</span><span class="symbol">;</span>

<span class="normal">                        std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" checking recursive SA "</span><span class="symbol">).</span><span class="function">flush</span><span class="symbol">();</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal"> sacheck</span><span class="symbol">::</span><span class="function">check_sa_vectors</span><span class="symbol">(</span><span class="normal">recinput</span><span class="symbol">,</span><span class="normal"> recoutput</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"failed!"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                    std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"ok"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> std</span><span class="symbol">::</span><span class="normal">endl</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">                </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" checking recursive LCP "</span><span class="symbol">).</span><span class="function">flush</span><span class="symbol">();</span>

<span class="normal">                </span><span class="type">bool</span><span class="normal"> good </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_t</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> recoutput_lcp</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">size_type</span><span class="normal"> lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> j </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">max</span><span class="symbol">(</span><span class="normal">recoutput</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">],</span><span class="normal">recoutput</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> j </span><span class="symbol">&lt;</span><span class="normal"> recinput</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">j</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">recinput</span><span class="symbol">[</span><span class="normal"> recoutput</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> j </span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span><span class="normal"> recinput</span><span class="symbol">[</span><span class="normal"> recoutput</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> j </span><span class="symbol">])</span>
<span class="normal">                            </span><span class="keyword">break</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="symbol">++</span><span class="normal">lcp</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lcp </span><span class="symbol">!=</span><span class="normal"> recoutput_lcp</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">])</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"recursive LCP incorrect: lcp["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> i </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> recoutput_lcp</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" which should be "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> lcp</span><span class="symbol">);</span>
<span class="normal">                        good </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">good </span><span class="symbol">?</span><span class="normal"> </span><span class="string">"good"</span><span class="normal"> </span><span class="symbol">:</span><span class="normal"> </span><span class="string">"failed!"</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_SELF_CHECK</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>

<span class="normal">            </span><span class="comment">// sorter to contain the range query answers needed for sum term in LCP</span>
<span class="normal">            </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt;indexpair_type, indexpair_less1st_type, block_size&gt;</span><span class="normal"> st_LCPrangesumAnswer_type</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">indexpair_less1st_type</span><span class="normal"> indexpair_less1st</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">st_LCPrangesumAnswer_type</span><span class="normal"> </span><span class="function">st_LCPrangesumAnswer</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">indexpair_less1st</span><span class="symbol">,</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>

<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                st_LCPrangesum</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">2</span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">size_type</span><span class="normal"> suffixsum </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal">        </span><span class="comment">// reading sizes backwards, so this is a suffix sum (instead of prefix sum)</span>
<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> index </span><span class="symbol">=</span><span class="normal"> sss</span><span class="symbol">.</span><span class="normal">SStarSize</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span>

<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sss</span><span class="symbol">.</span><span class="normal">SStarSize</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">st_LCPrangesum</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="symbol">--</span><span class="normal">index</span><span class="symbol">;</span>
<span class="normal">                    suffixsum </span><span class="symbol">+=</span><span class="normal"> sss</span><span class="symbol">.</span><span class="normal">SStarSize</span><span class="symbol">.</span><span class="function">front</span><span class="symbol">();</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> index </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" - suffixsum = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> suffixsum</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">st_LCPrangesum</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> st_LCPrangesum</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">==</span><span class="normal"> index </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"answering query pos "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_LCPrangesum</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">", target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_LCPrangesum</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" with "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> suffixsum</span><span class="symbol">);</span>

<span class="normal">                        st_LCPrangesumAnswer</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indexpair_type</span><span class="symbol">(</span><span class="normal">st_LCPrangesum</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">,</span><span class="normal"> suffixsum</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                        </span><span class="symbol">++</span><span class="normal">st_LCPrangesum</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    sss</span><span class="symbol">.</span><span class="normal">SStarSize</span><span class="symbol">.</span><span class="function">pop</span><span class="symbol">();</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                st_LCPrangesum</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>
<span class="normal">                st_LCPrangesumAnswer</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>

<span class="normal">                </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"st_LCPrangesumAnswer"</span><span class="symbol">,</span><span class="normal"> st_LCPrangesumAnswer</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Done LCP range sum query"</span><span class="symbol">);</span>

<span class="normal">            st_ISAqueryLeft</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>
<span class="normal">            st_ISAqueryRight</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>
<span class="normal">            st_ISA</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// *** step 1: answer queries on ISA and regroup RMQs as (target,boundary)</span>

<span class="normal">            stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt;indexpair_type, indexpair_less1st_type, block_size&gt;</span><span class="normal"> </span><span class="function">st_ISAresult</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">indexpair_less1st</span><span class="symbol">,</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">st_ISA</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(!</span><span class="normal">st_ISAqueryLeft</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">||</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">st_ISAqueryRight</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">())</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">st_ISAqueryLeft</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> st_ISAqueryLeft</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">==</span><span class="normal"> st_ISA</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"matching ISA-query pos "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_ISAqueryLeft</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" left boundary to "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_ISA</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" tgt "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_ISAqueryLeft</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">                    st_ISAresult</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indexpair_type</span><span class="symbol">(</span><span class="normal">st_ISAqueryLeft</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">,</span><span class="normal"> st_ISA</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">+</span><span class="normal"> </span><span class="number">1</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                    </span><span class="symbol">++</span><span class="normal">st_ISAqueryLeft</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">st_ISAqueryRight</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> st_ISAqueryRight</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">==</span><span class="normal"> st_ISA</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"matching ISA-query pos "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_ISAqueryRight</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" right boundary to "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_ISA</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" tgt "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_ISAqueryRight</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">);</span>
<span class="normal">                    st_ISAresult</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indexpair_type</span><span class="symbol">(</span><span class="normal">st_ISAqueryRight</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">,</span><span class="normal"> st_ISA</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                    </span><span class="symbol">++</span><span class="normal">st_ISAqueryRight</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                </span><span class="symbol">++</span><span class="normal">st_ISA</span><span class="symbol">;</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            st_ISA</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="normal">            st_ISAqueryLeft</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>
<span class="normal">            st_ISAqueryRight</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Done ISA queries"</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// *** step 2: generate RMQ tuples from the ISA values, depending on the size of the RMQ interval</span>

<span class="normal">            </span><span class="keyword">static</span><span class="normal"> </span><span class="keyword">const</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> slabsize </span><span class="symbol">=</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="normal"> </span><span class="symbol">/</span><span class="normal"> </span><span class="keyword">sizeof</span><span class="symbol">(</span><span class="normal">offset_type</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">typedef</span><span class="normal"> tuples</span><span class="symbol">::</span><span class="usertype">triple&lt;offset_type,offset_type,offset_type&gt;</span><span class="normal"> indextriple_type</span><span class="symbol">;</span>

<span class="normal">            stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt;indexpair_type, indexpair_RMQ&lt;slabsize&gt;, block_size&gt;</span><span class="normal"> </span><span class="function">st_RMQleft</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">indexpair_RMQ</span><span class="symbol">&lt;</span><span class="normal">slabsize</span><span class="symbol">&gt;(),</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">3</span><span class="symbol">);</span>
<span class="normal">            stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt;indextriple_type, indextriple_RMQ&lt;indextriple_type, slabsize&gt;, block_size&gt;</span><span class="normal"> </span><span class="function">st_RMQright</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">indextriple_RMQ</span><span class="symbol">&lt;</span><span class="normal">indextriple_type</span><span class="symbol">,</span><span class="normal"> slabsize</span><span class="symbol">&gt;(),</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">3</span><span class="symbol">);</span>

<span class="normal">            st_ISAresult</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">3</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">st_ISAresult</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> target </span><span class="symbol">=</span><span class="normal"> st_ISAresult</span><span class="symbol">-&gt;</span><span class="normal">first</span><span class="symbol">;</span>
<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> left </span><span class="symbol">=</span><span class="normal"> st_ISAresult</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">;</span>

<span class="normal">                </span><span class="symbol">++</span><span class="normal">st_ISAresult</span><span class="symbol">;</span>
<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> st_ISAresult</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">==</span><span class="normal"> target </span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">offset_type</span><span class="normal"> right </span><span class="symbol">=</span><span class="normal"> st_ISAresult</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">;</span>
<span class="normal">                </span><span class="symbol">++</span><span class="normal">st_ISAresult</span><span class="symbol">;</span>

<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> left </span><span class="symbol">&lt;=</span><span class="normal"> right </span><span class="symbol">);</span>

<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">left </span><span class="symbol">/</span><span class="normal"> slabsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">right </span><span class="symbol">/</span><span class="normal"> slabsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// case 1: query is within the same slab -&gt; create one right tuple</span>

<span class="normal">                    st_RMQright</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indextriple_type</span><span class="symbol">(</span><span class="normal">right</span><span class="symbol">,</span><span class="normal"> left</span><span class="symbol">,</span><span class="normal"> target</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Create one right tuple for enclosed RMQ ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> left </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> right </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") -&gt; target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> target</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">else</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="comment">// case 2: query spans blocks and must be answered using two queries</span>

<span class="normal">                    st_RMQleft</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indexpair_type</span><span class="symbol">(</span><span class="normal">left</span><span class="symbol">,</span><span class="normal"> target</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                    st_RMQright</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indextriple_type</span><span class="symbol">(</span><span class="normal">right</span><span class="symbol">,</span><span class="normal"> left</span><span class="symbol">,</span><span class="normal"> target</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Create two tuples for spanning RMQ ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> left </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> right </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") -&gt; target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> target</span><span class="symbol">);</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            st_ISAresult</span><span class="symbol">.</span><span class="function">finish_clear</span><span class="symbol">();</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Done RMQ queries create"</span><span class="symbol">);</span>

<span class="normal">            st_RMQleft</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>
<span class="normal">            st_RMQright</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"st_RMQleft"</span><span class="symbol">,</span><span class="normal"> st_RMQleft</span><span class="symbol">);</span>
<span class="normal">            </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"st_RMQright"</span><span class="symbol">,</span><span class="normal"> st_RMQright</span><span class="symbol">);</span>

<span class="normal">            </span><span class="comment">// *** step 3: create blocked RMQ structures and answer queries within those blocks</span>

<span class="normal">            </span><span class="comment">// sorter to contain the RMQ results for each position (real RMQ is minimum of matches)</span>
<span class="normal">            </span><span class="keyword">typedef</span><span class="normal"> stxxl</span><span class="symbol">::</span><span class="usertype">sorter&lt;indexpair_type, indexpair_less1st_type, block_size&gt;</span><span class="normal"> st_RMQresult_type</span><span class="symbol">;</span>
<span class="normal">            </span><span class="usertype">st_RMQresult_type</span><span class="normal"> </span><span class="function">st_RMQresult</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">indexpair_less1st</span><span class="symbol">,</span><span class="normal"> memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>

<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">ShortStringSorter</span><span class="symbol">::</span><span class="normal">lcp_deque_type</span><span class="symbol">::</span><span class="usertype">stream</span><span class="normal"> </span><span class="function">lcpstream</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> sss</span><span class="symbol">.</span><span class="normal">lexname_lcp_deque </span><span class="symbol">);</span>

<span class="normal">                </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">LCPdirect_deque_type</span><span class="symbol">::</span><span class="usertype">stream</span><span class="normal"> </span><span class="function">lcpdirect</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> dq_LCPDirect </span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">size_type</span><span class="normal"> start </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                </span><span class="usertype">membuffer&lt;offset_type&gt;</span><span class="normal"> </span><span class="function">buffer</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">slabsize</span><span class="symbol">);</span>

<span class="normal">                </span><span class="usertype">RMQ_Stack&lt;uint32_t, offset_type&gt;</span><span class="normal"> slabrmq</span><span class="symbol">;</span>

<span class="normal">                </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_type</span><span class="normal"> thisslab </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">lcpstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">thisslab</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">size_type</span><span class="normal"> thissize </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> start </span><span class="symbol">/</span><span class="normal"> slabsize </span><span class="symbol">==</span><span class="normal"> thisslab </span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> thissize </span><span class="symbol">&lt;</span><span class="normal"> slabsize </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">lcpstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"buffer["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> thissize </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">lcpstream</span><span class="symbol">);</span>
<span class="normal">                        buffer</span><span class="symbol">[</span><span class="normal">thissize</span><span class="symbol">++]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">lcpstream</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="symbol">++</span><span class="normal">lcpstream</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Prior to building succinct RMQ data structure"</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Building RMQ on range ["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> start </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> start</span><span class="symbol">+</span><span class="normal">thissize </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">")"</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="usertype">RMQ_succinct&lt;offset_type, uint32_t&gt;</span><span class="normal"> </span><span class="function">RMQ</span><span class="symbol">(</span><span class="normal">buffer</span><span class="symbol">.</span><span class="function">data</span><span class="symbol">(),</span><span class="normal"> thissize</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Done building RMQ"</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"After building succinct RMQ data structure"</span><span class="symbol">);</span>

<span class="normal">                    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">st_RMQleft</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">st_RMQleft</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">/</span><span class="normal"> slabsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> thisslab </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="comment">// case 1: left RMQ boundary in this slab, right is beyond the border</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"RMQ left in slab: ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_RMQleft</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">",inf) target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_RMQleft</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">);</span>

<span class="normal">                        </span><span class="usertype">uint32_t</span><span class="normal"> resultpos </span><span class="symbol">=</span><span class="normal"> RMQ</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="normal"> st_RMQleft</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">-</span><span class="normal"> start</span><span class="symbol">,</span><span class="normal"> thissize</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> resultpos </span><span class="symbol">&lt;</span><span class="normal"> thissize </span><span class="symbol">);</span>
<span class="normal">                        </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> buffer</span><span class="symbol">[</span><span class="normal">resultpos</span><span class="symbol">];</span>

<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"RMQ result "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> result</span><span class="symbol">);</span>
<span class="normal">                        st_RMQresult</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indexpair_type</span><span class="symbol">(</span><span class="normal">st_RMQleft</span><span class="symbol">-&gt;</span><span class="normal">second</span><span class="symbol">,</span><span class="normal"> result</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                        </span><span class="symbol">++</span><span class="normal">st_RMQleft</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">st_RMQright</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">/</span><span class="normal"> slabsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> thisslab </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">/</span><span class="normal"> slabsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">==</span><span class="normal"> thisslab </span><span class="symbol">)</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="comment">// case 2: both RMQ boundaries are for this slab and the same target</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"RMQ pair in slab: ("</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">","</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">third</span><span class="symbol">);</span>

<span class="normal">                            </span><span class="usertype">uint32_t</span><span class="normal"> resultpos </span><span class="symbol">=</span><span class="normal"> RMQ</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="normal"> st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">-</span><span class="normal"> start</span><span class="symbol">,</span><span class="normal"> st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">-</span><span class="normal"> start </span><span class="symbol">);</span>
<span class="normal">                            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> resultpos </span><span class="symbol">&lt;</span><span class="normal"> thissize </span><span class="symbol">);</span>
<span class="normal">                            </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> buffer</span><span class="symbol">[</span><span class="normal">resultpos</span><span class="symbol">];</span>

<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"RMQ result: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> result</span><span class="symbol">);</span>
<span class="normal">                            st_RMQresult</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indexpair_type</span><span class="symbol">(</span><span class="normal">st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">third</span><span class="symbol">,</span><span class="normal"> result</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                            </span><span class="symbol">++</span><span class="normal">st_RMQright</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                        </span><span class="keyword">else</span>
<span class="normal">                        </span><span class="cbracket">{</span>
<span class="normal">                            </span><span class="comment">// case 3: right RMQ boundary in this slab, left is beyond the border</span>
<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"RMQ right in slab: (-inf,"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">") target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">third</span><span class="symbol">);</span>

<span class="normal">                            </span><span class="usertype">uint32_t</span><span class="normal"> resultpos </span><span class="symbol">=</span><span class="normal"> RMQ</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="normal"> </span><span class="number">0</span><span class="symbol">,</span><span class="normal"> st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">first </span><span class="symbol">-</span><span class="normal"> start </span><span class="symbol">);</span>
<span class="normal">                            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> resultpos </span><span class="symbol">&lt;</span><span class="normal"> thissize </span><span class="symbol">);</span>
<span class="normal">                            </span><span class="usertype">offset_type</span><span class="normal"> result </span><span class="symbol">=</span><span class="normal"> buffer</span><span class="symbol">[</span><span class="normal">resultpos</span><span class="symbol">];</span>

<span class="normal">                            </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">/</span><span class="normal"> slabsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> thisslab </span><span class="symbol">);</span>
<span class="normal">                            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">/</span><span class="normal"> slabsize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="normal"> thisslab</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                                </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> min2 </span><span class="symbol">=</span><span class="normal"> slabrmq</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">second </span><span class="symbol">/</span><span class="normal"> slabsize</span><span class="symbol">)+</span><span class="number">1</span><span class="symbol">,</span><span class="normal">  thisslab</span><span class="symbol">-</span><span class="number">1</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">                                result </span><span class="symbol">=</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">min</span><span class="symbol">(</span><span class="normal">result</span><span class="symbol">,</span><span class="normal"> min2</span><span class="symbol">);</span>
<span class="normal">                            </span><span class="cbracket">}</span>

<span class="normal">                            </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"RMQ result: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> result</span><span class="symbol">);</span>
<span class="normal">                            st_RMQresult</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indexpair_type</span><span class="symbol">(</span><span class="normal">st_RMQright</span><span class="symbol">-&gt;</span><span class="normal">third</span><span class="symbol">,</span><span class="normal"> result</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                            </span><span class="symbol">++</span><span class="normal">st_RMQright</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="cbracket">}</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="comment">// Copy LCP_Names directly into RMQresult for all positions with LCP_Recursive = 0</span>
<span class="normal">                    </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">lcpdirect</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&amp;&amp;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">lcpdirect </span><span class="symbol">&lt;</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="normal">start </span><span class="symbol">+</span><span class="normal"> thissize</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Direct LCP_Names copy value "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> buffer</span><span class="symbol">[*</span><span class="normal">lcpdirect </span><span class="symbol">-</span><span class="normal"> start</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" for target "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">lcpdirect</span><span class="symbol">);</span>

<span class="normal">                        st_RMQresult</span><span class="symbol">.</span><span class="function">push</span><span class="symbol">(</span><span class="normal"> </span><span class="function">indexpair_type</span><span class="symbol">(*</span><span class="normal">lcpdirect</span><span class="symbol">,</span><span class="normal"> buffer</span><span class="symbol">[*</span><span class="normal">lcpdirect </span><span class="symbol">-</span><span class="normal"> start</span><span class="symbol">])</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">                        </span><span class="symbol">++</span><span class="normal">lcpdirect</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="comment">// Add global minimum to in-memory stack-structure</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="usertype">uint32_t</span><span class="normal"> gminpos </span><span class="symbol">=</span><span class="normal"> RMQ</span><span class="symbol">.</span><span class="function">query</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">,</span><span class="normal">thissize</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">);</span>
<span class="normal">                        </span><span class="usertype">offset_type</span><span class="normal"> gmin </span><span class="symbol">=</span><span class="normal"> buffer</span><span class="symbol">[</span><span class="normal">gminpos</span><span class="symbol">];</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Saving slab global minimum "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> gmin</span><span class="symbol">);</span>
<span class="normal">                        slabrmq</span><span class="symbol">.</span><span class="function">set</span><span class="symbol">(</span><span class="normal"> thisslab</span><span class="symbol">,</span><span class="normal"> gmin </span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    start </span><span class="symbol">+=</span><span class="normal"> thissize</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="function">DBG_ST_ARRAY</span><span class="symbol">(</span><span class="normal">debug_sstarlcp</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"st_RMQresult"</span><span class="symbol">,</span><span class="normal"> st_RMQresult</span><span class="symbol">);</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug_sstarlcp_result</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                </span><span class="usertype">SStarLCPStream&lt;st_LCPrangesumAnswer_type,st_RMQresult_type&gt;</span><span class="normal"> </span><span class="function">sstarlcpstream</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">st_LCPrangesumAnswer</span><span class="symbol">,</span><span class="normal"> st_RMQresult</span><span class="symbol">);</span>
<span class="normal">                sstarlcpstream</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>

<span class="normal">                </span><span class="keyword">while</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">sstarlcpstream</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_sstarlcp_result</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"S*-LCP["</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sstarlcpstream</span><span class="symbol">.</span><span class="function">curr_index</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"] = "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sstarlcpstream</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="symbol">++</span><span class="normal">sstarlcpstream</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>

<span class="normal">                st_LCPrangesumAnswer</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK</span>
<span class="normal">            </span><span class="cbracket">{</span><span class="normal"> </span><span class="comment">// check S*-LCPs by reading S*-index list and calculating LCP naively</span>

<span class="normal">                </span><span class="symbol">(</span><span class="normal">std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" checking S*-LCPs "</span><span class="symbol">).</span><span class="function">flush</span><span class="symbol">();</span>

<span class="normal">                </span><span class="comment">// read this reclevel's input into memory</span>
<span class="normal">                inputrev</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>
<span class="normal">                std</span><span class="symbol">::</span><span class="usertype">vector&lt;alphabet_type&gt;</span><span class="normal"> </span><span class="function">input</span><span class="symbol">(</span><span class="normal">inputrev</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">());</span>
<span class="normal">                </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_type</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> input</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">inputrev</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">--</span><span class="normal">inputrev</span><span class="symbol">)</span>
<span class="normal">                    input</span><span class="symbol">[--</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">inputrev</span><span class="symbol">;</span>

<span class="normal">                </span><span class="comment">// read induce input to find ordered S*-indexes</span>
<span class="normal">                std</span><span class="symbol">::</span><span class="usertype">vector&lt;RankTuple&gt;</span><span class="normal"> sstars</span><span class="symbol">;</span>

<span class="normal">                st_ISA</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">();</span><span class="normal"> rec_input</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>
<span class="normal">                </span><span class="usertype">RecursionInduceFilter&lt;rec_input_type, st_indexpair_byindex_type&gt;</span><span class="normal"> </span><span class="function">induceinput</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rec_input</span><span class="symbol">,</span><span class="normal"> st_ISA</span><span class="symbol">);</span>

<span class="normal">                </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">induceinput</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">induceinput </span><span class="symbol">)</span>
<span class="normal">                    sstars</span><span class="symbol">.</span><span class="function">push_back</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">induceinput </span><span class="symbol">);</span>

<span class="normal">                std</span><span class="symbol">::</span><span class="function">sort</span><span class="symbol">(</span><span class="normal"> sstars</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> sstars</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">(),</span><span class="normal"> </span><span class="function">RankTupleOrder_RankAsc</span><span class="symbol">());</span><span class="normal"> </span><span class="comment">// sort by rank</span>

<span class="normal">                </span><span class="comment">// naively calculate lcp between S*-indexes in rank order</span>

<span class="normal">                </span><span class="usertype">SStarLCPStream&lt;st_LCPrangesumAnswer_type,st_RMQresult_type&gt;</span><span class="normal"> </span><span class="function">sstarlcpstream</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">st_LCPrangesumAnswer</span><span class="symbol">,</span><span class="normal"> st_RMQresult</span><span class="symbol">);</span>
<span class="normal">                sstarlcpstream</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">assert</span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sstarlcpstream </span><span class="symbol">==</span><span class="normal"> </span><span class="function">offset_type</span><span class="symbol">(</span><span class="number">0</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">);</span><span class="normal"> </span><span class="comment">// first is zero</span>
<span class="normal">                </span><span class="symbol">++</span><span class="normal">sstarlcpstream</span><span class="symbol">;</span>

<span class="normal">                </span><span class="type">bool</span><span class="normal"> good </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">true</span><span class="symbol">;</span>
<span class="normal">                </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">1</span><span class="symbol">;</span><span class="normal"> i </span><span class="symbol">&lt;</span><span class="normal"> sstars</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">                </span><span class="cbracket">{</span>
<span class="normal">                    </span><span class="usertype">size_type</span><span class="normal"> lcp </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> j </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> std</span><span class="symbol">::</span><span class="function">max</span><span class="symbol">(</span><span class="normal">sstars</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">].</span><span class="normal">index</span><span class="symbol">,</span><span class="normal">sstars</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">].</span><span class="normal">index</span><span class="symbol">)</span><span class="normal"> </span><span class="symbol">+</span><span class="normal"> j </span><span class="symbol">&lt;</span><span class="normal"> input</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">j</span><span class="symbol">)</span>
<span class="normal">                    </span><span class="cbracket">{</span>
<span class="normal">                        </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">input</span><span class="symbol">[</span><span class="normal"> sstars</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">].</span><span class="normal">index </span><span class="symbol">+</span><span class="normal"> j </span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">!=</span>
<span class="normal">                            input</span><span class="symbol">[</span><span class="normal"> sstars</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">].</span><span class="normal">index </span><span class="symbol">+</span><span class="normal"> j </span><span class="symbol">])</span>
<span class="normal">                            </span><span class="keyword">break</span><span class="symbol">;</span>

<span class="normal">                        </span><span class="symbol">++</span><span class="normal">lcp</span><span class="symbol">;</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lcp </span><span class="symbol">!=</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sstarlcpstream</span><span class="symbol">)</span><span class="normal"> </span><span class="cbracket">{</span>
<span class="normal">                        good </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">false</span><span class="symbol">;</span>
<span class="normal">                        </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"LCP of S*s "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sstars</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">-</span><span class="number">1</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" and "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> sstars</span><span class="symbol">[</span><span class="normal">i</span><span class="symbol">]</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" incorrectly calculated "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">sstarlcpstream </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">" correct is "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> lcp</span><span class="symbol">);</span>
<span class="normal">                    </span><span class="cbracket">}</span>

<span class="normal">                    </span><span class="symbol">++</span><span class="normal">sstarlcpstream</span><span class="symbol">;</span>
<span class="normal">                </span><span class="cbracket">}</span>
<span class="normal">                </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">good</span><span class="symbol">)</span><span class="normal"> </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"good"</span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">else</span><span class="normal"> </span><span class="function">assert</span><span class="symbol">(!</span><span class="string">"bad"</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_SELF_CHECK</span>

<span class="normal">            st_RMQresult</span><span class="symbol">.</span><span class="function">finish</span><span class="symbol">();</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Done with S*-LCP calculation"</span><span class="symbol">);</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            </span><span class="keyword">if</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">debug_induce_input</span><span class="symbol">)</span>
<span class="normal">            </span><span class="cbracket">{</span>
<span class="normal">                st_ISA</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">();</span>

<span class="normal">                rec_input</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">4</span><span class="symbol">);</span>
<span class="normal">                </span><span class="usertype">RecursionInduceFilter&lt;rec_input_type, st_indexpair_byindex_type&gt;</span><span class="normal"> </span><span class="function">induceinput</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rec_input</span><span class="symbol">,</span><span class="normal"> st_ISA</span><span class="symbol">);</span>

<span class="normal">                </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_input</span><span class="symbol">,</span><span class="normal"> </span><span class="string">"Input for Induce:"</span><span class="symbol">);</span>
<span class="normal">                </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="normal"> </span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">!</span><span class="normal">induceinput</span><span class="symbol">.</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">induceinput </span><span class="symbol">)</span>
<span class="normal">                    </span><span class="function">DBG</span><span class="symbol">(</span><span class="normal">debug_induce_input</span><span class="symbol">,</span><span class="normal"> </span><span class="symbol">*</span><span class="normal">induceinput</span><span class="symbol">);</span>
<span class="normal">            </span><span class="cbracket">}</span>

<span class="normal">            </span><span class="comment">// Induce::process_input() memory: inputrev (1/8) + induceinput (2*1/8) + rec_input(1/8) + 3 output arrays (1/6 each)</span>
<span class="normal">            st_nametuple</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>
<span class="normal">            st_ISA</span><span class="symbol">.</span><span class="function">sort</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>

<span class="normal">            rec_input</span><span class="symbol">.</span><span class="function">rewind</span><span class="symbol">(</span><span class="normal">memsize </span><span class="symbol">/</span><span class="normal"> </span><span class="number">8</span><span class="symbol">);</span>
<span class="normal">            </span><span class="usertype">RecursionInduceFilter&lt;rec_input_type, st_indexpair_byindex_type&gt;</span><span class="normal"> </span><span class="function">induceinput</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">rec_input</span><span class="symbol">,</span><span class="normal"> st_ISA</span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Induce created"</span><span class="symbol">);</span>
<span class="normal">            timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"isadone"</span><span class="symbol">).</span><span class="function">printlast</span><span class="symbol">();</span>

<span class="normal">            m_result </span><span class="symbol">=</span><span class="normal"> </span><span class="keyword">new</span><span class="normal"> Result</span><span class="symbol">;</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">            </span><span class="usertype">SStarLCPStream&lt;st_LCPrangesumAnswer_type,st_RMQresult_type&gt;</span><span class="normal"> </span><span class="function">lcpstream</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">st_LCPrangesumAnswer</span><span class="symbol">,</span><span class="normal"> st_RMQresult</span><span class="symbol">);</span>
<span class="preproc">#else</span>
<span class="normal">            </span><span class="usertype">ZeroLCPStream</span><span class="normal"> lcpstream</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">            std</span><span class="symbol">::</span><span class="usertype">auto_ptr&lt;Induce&gt;</span><span class="normal"> </span><span class="function">induce</span><span class="normal"> </span><span class="symbol">(</span><span class="keyword">new</span><span class="normal"> </span><span class="function">Induce</span><span class="symbol">(</span><span class="normal">m_result</span><span class="symbol">));</span>
<span class="normal">            induce</span><span class="symbol">-&gt;</span><span class="function">process</span><span class="symbol">(</span><span class="normal"> inputrev</span><span class="symbol">,</span><span class="normal"> induceinput</span><span class="symbol">,</span><span class="normal"> lcpstream</span><span class="symbol">,</span><span class="normal"> depth </span><span class="symbol">);</span>

<span class="normal">            </span><span class="function">DBGMEM</span><span class="symbol">(</span><span class="string">"Induce process() done"</span><span class="symbol">);</span>
<span class="normal">            timer</span><span class="symbol">.</span><span class="function">record</span><span class="symbol">(</span><span class="string">"done"</span><span class="symbol">).</span><span class="function">printall</span><span class="symbol">();</span>

<span class="normal">            </span><span class="comment">// result of induce can be read by caller via stream interface.</span>
<span class="normal">            </span><span class="keyword">return</span><span class="normal"> maxdepth</span><span class="symbol">;</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">StringContainer</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SuffixArrayContainer</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">run_vector</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> StringContainer</span><span class="symbol">&amp;</span><span class="normal"> string</span><span class="symbol">,</span><span class="normal"> SuffixArrayContainer</span><span class="symbol">&amp;</span><span class="normal"> suffixarray</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">my_buf_istream_vector_reverse&lt;typename StringContainer::const_iterator&gt;</span><span class="normal"> </span><span class="function">vectstream</span><span class="symbol">(</span><span class="normal">string</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> string</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>

<span class="normal">        </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> maxdepth </span><span class="symbol">=</span><span class="normal"> </span><span class="function">run</span><span class="symbol">(</span><span class="normal">vectstream</span><span class="symbol">);</span>
<span class="normal">        g_statscache </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="string">"maxdepth"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> maxdepth</span><span class="symbol">;</span>

<span class="normal">        suffixarray</span><span class="symbol">.</span><span class="function">resize</span><span class="symbol">(</span><span class="normal"> string</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">        stxxl</span><span class="symbol">::</span><span class="normal">stream</span><span class="symbol">::</span><span class="function">materialize</span><span class="symbol">(*</span><span class="keyword">this</span><span class="symbol">,</span><span class="normal"> suffixarray</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> suffixarray</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">StringContainer</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SuffixArrayContainer</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">LCPArrayContainer</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">run_vector_lcp</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> StringContainer</span><span class="symbol">&amp;</span><span class="normal"> string</span><span class="symbol">,</span><span class="normal"> SuffixArrayContainer</span><span class="symbol">&amp;</span><span class="normal"> suffixarray</span><span class="symbol">,</span><span class="normal"> LCPArrayContainer</span><span class="symbol">&amp;</span><span class="normal"> lcparray</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">my_buf_istream_vector_reverse&lt;typename StringContainer::const_iterator&gt;</span><span class="normal"> </span><span class="function">vectstream</span><span class="symbol">(</span><span class="normal">string</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> string</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>

<span class="normal">        </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> maxdepth </span><span class="symbol">=</span><span class="normal"> </span><span class="function">run</span><span class="symbol">(</span><span class="normal">vectstream</span><span class="symbol">);</span>
<span class="normal">        g_statscache </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="string">"maxdepth"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> maxdepth</span><span class="symbol">;</span>

<span class="normal">        suffixarray</span><span class="symbol">.</span><span class="function">resize</span><span class="symbol">(</span><span class="normal"> string</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>
<span class="normal">        lcparray</span><span class="symbol">.</span><span class="function">resize</span><span class="symbol">(</span><span class="normal"> string</span><span class="symbol">.</span><span class="function">size</span><span class="symbol">()</span><span class="normal"> </span><span class="symbol">);</span>

<span class="normal">        stxxl</span><span class="symbol">::</span><span class="usertype">vector_bufwriter&lt;SuffixArrayContainer&gt;</span><span class="normal"> </span><span class="function">sa_writer</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">suffixarray</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> suffixarray</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>
<span class="normal">        stxxl</span><span class="symbol">::</span><span class="usertype">vector_bufwriter&lt;LCPArrayContainer&gt;</span><span class="normal"> </span><span class="function">lcp_writer</span><span class="normal"> </span><span class="symbol">(</span><span class="normal">lcparray</span><span class="symbol">.</span><span class="function">begin</span><span class="symbol">(),</span><span class="normal"> lcparray</span><span class="symbol">.</span><span class="function">end</span><span class="symbol">());</span>

<span class="normal">        </span><span class="keyword">for</span><span class="normal"> </span><span class="symbol">(</span><span class="usertype">size_type</span><span class="normal"> i </span><span class="symbol">=</span><span class="normal"> </span><span class="number">0</span><span class="symbol">;</span><span class="normal"> </span><span class="symbol">!</span><span class="function">empty</span><span class="symbol">();</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++(),</span><span class="normal"> </span><span class="symbol">++</span><span class="normal">i</span><span class="symbol">)</span>
<span class="normal">        </span><span class="cbracket">{</span>
<span class="normal">            </span><span class="comment">//std::cout &lt;&lt; "SA[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; operator*() &lt;&lt; " - LCP[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; lcp() &lt;&lt; "\n";</span>
<span class="normal">            sa_writer </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">*();</span>
<span class="normal">            lcp_writer </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="function">lcp</span><span class="symbol">();</span>
<span class="normal">        </span><span class="cbracket">}</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">    </span><span class="comment">/*********************************************************************************************************</span>
<span class="comment">     * Stream Interface of eSAIS class                                                                       *</span>
<span class="comment">     *********************************************************************************************************/</span>

<span class="keyword">public</span><span class="symbol">:</span>

<span class="normal">    </span><span class="keyword">typedef</span><span class="normal"> </span><span class="usertype">offset_type</span><span class="normal">         value_type</span><span class="symbol">;</span>

<span class="normal">    </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">*()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">m_result</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*(*</span><span class="normal">m_result</span><span class="symbol">);</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">    </span><span class="keyword">const</span><span class="normal"> offset_type</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="function">lcp</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">m_result</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> m_result</span><span class="symbol">-&gt;</span><span class="function">lcp</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>

<span class="normal">    </span><span class="type">bool</span><span class="normal"> </span><span class="function">empty</span><span class="symbol">()</span><span class="normal"> </span><span class="keyword">const</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">m_result</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> m_result</span><span class="symbol">-&gt;</span><span class="function">empty</span><span class="symbol">();</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    eSAIS</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="keyword">operator</span><span class="symbol">++()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="function">assert</span><span class="symbol">(</span><span class="normal">m_result</span><span class="symbol">);</span>
<span class="normal">        </span><span class="symbol">++(*</span><span class="normal">m_result</span><span class="symbol">);</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="symbol">*</span><span class="keyword">this</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="cbracket">}</span><span class="symbol">;</span>


<span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">StringContainer</span><span class="symbol">,</span><span class="normal"> </span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">SuffixArrayContainer</span><span class="symbol">&gt;</span>
<span class="keyword">struct</span><span class="normal"> </span><span class="classname">SACA</span>
<span class="cbracket">{</span>
<span class="normal">    std</span><span class="symbol">::</span><span class="usertype">string</span><span class="normal"> </span><span class="function">name</span><span class="symbol">()</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC_EXT</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="string">"eSAISlcpext"</span><span class="symbol">;</span>
<span class="preproc">#elif</span><span class="normal"> ESAIS_LCP_CALC_INT</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="string">"eSAISlcpint"</span><span class="symbol">;</span>
<span class="preproc">#elif</span><span class="normal"> ESAIS_DISCARD_UNIQUES</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="string">"eSAISdisc"</span><span class="symbol">;</span>
<span class="preproc">#else</span>
<span class="normal">        </span><span class="keyword">return</span><span class="normal"> </span><span class="string">"eSAIS"</span><span class="symbol">;</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_DISCARD_UNIQUES</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">prepare</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> StringContainer</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="comment">/* string */</span><span class="symbol">,</span><span class="normal"> SuffixArrayContainer</span><span class="symbol">&amp;</span><span class="normal"> </span><span class="comment">/* suffixarray */</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="comment">/* K */</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">run</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> StringContainer</span><span class="symbol">&amp;</span><span class="normal"> string</span><span class="symbol">,</span><span class="normal"> SuffixArrayContainer</span><span class="symbol">&amp;</span><span class="normal"> suffixarray</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="comment">/* K */</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">eSAIS&lt;typename StringContainer::value_type, typename SuffixArrayContainer::value_type, uint64_t&gt;</span><span class="normal"> algo</span><span class="symbol">;</span>

<span class="normal">        g_statscache </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="string">"tuplecharlimit"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="type">int</span><span class="symbol">(</span><span class="normal">algo</span><span class="symbol">.</span><span class="normal">D</span><span class="symbol">);</span>

<span class="normal">        algo</span><span class="symbol">.</span><span class="function">run_vector</span><span class="symbol">(</span><span class="normal">string</span><span class="symbol">,</span><span class="normal"> suffixarray</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_COUNT_WASTED</span>
<span class="normal">        g_statscache </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="string">"wasted_iovolume"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> g_wasted_iovolume</span><span class="symbol">;</span>
<span class="preproc">#endif</span>
<span class="normal">    </span><span class="cbracket">}</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_LCP_CALC</span>
<span class="normal">    </span><span class="keyword">template</span><span class="normal"> </span><span class="symbol">&lt;</span><span class="keyword">typename</span><span class="normal"> </span><span class="classname">LCPArrayContainer</span><span class="symbol">&gt;</span>
<span class="normal">    </span><span class="type">void</span><span class="normal"> </span><span class="function">run_lcp</span><span class="symbol">(</span><span class="keyword">const</span><span class="normal"> StringContainer</span><span class="symbol">&amp;</span><span class="normal"> string</span><span class="symbol">,</span><span class="normal"> SuffixArrayContainer</span><span class="symbol">&amp;</span><span class="normal"> suffixarray</span><span class="symbol">,</span><span class="normal"> LCPArrayContainer</span><span class="symbol">&amp;</span><span class="normal"> lcparray</span><span class="symbol">,</span><span class="normal"> </span><span class="type">unsigned</span><span class="normal"> </span><span class="type">int</span><span class="normal"> </span><span class="comment">/* K */</span><span class="symbol">)</span>
<span class="normal">    </span><span class="cbracket">{</span>
<span class="normal">        </span><span class="usertype">eSAIS&lt;typename StringContainer::value_type, typename SuffixArrayContainer::value_type, uint64_t&gt;</span><span class="normal"> algo</span><span class="symbol">;</span>

<span class="normal">        g_statscache </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="string">"tuplecharlimit"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="type">int</span><span class="symbol">(</span><span class="normal">algo</span><span class="symbol">.</span><span class="normal">D</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_SELF_CHECK</span>
<span class="normal">        algo</span><span class="symbol">.</span><span class="function">test_lexcompare</span><span class="symbol">();</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_SELF_CHECK</span>

<span class="normal">        algo</span><span class="symbol">.</span><span class="function">run_vector_lcp</span><span class="symbol">(</span><span class="normal">string</span><span class="symbol">,</span><span class="normal"> suffixarray</span><span class="symbol">,</span><span class="normal"> lcparray</span><span class="symbol">);</span>

<span class="preproc">#if</span><span class="normal"> ESAIS_COUNT_WASTED</span>
<span class="normal">        g_statscache </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="string">"wasted_iovolume"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> g_wasted_iovolume</span><span class="symbol">;</span>
<span class="preproc">#endif</span>
<span class="normal">        g_statscache </span><span class="symbol">&gt;&gt;</span><span class="normal"> </span><span class="string">"mainmemlcp"</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> g_mainmemlcp</span><span class="symbol">;</span>
<span class="normal">        std</span><span class="symbol">::</span><span class="normal">cout </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"g_mainmemlcp: "</span><span class="normal"> </span><span class="symbol">&lt;&lt;</span><span class="normal"> g_mainmemlcp </span><span class="symbol">&lt;&lt;</span><span class="normal"> </span><span class="string">"</span><span class="specialchar">\n</span><span class="string">"</span><span class="symbol">;</span>
<span class="normal">    </span><span class="cbracket">}</span>
<span class="preproc">#endif</span><span class="normal"> </span><span class="comment">// ESAIS_LCP_CALC</span>
<span class="cbracket">}</span><span class="symbol">;</span>

<span class="cbracket">}</span><span class="normal"> </span><span class="comment">// namespace esais</span>
</tt></pre></div><div style="text-align: right; padding: 8pt; font-size: 12px"><a href="/xmlfeed/weblog-rss20.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABQAAAADwCexKkxAAAAWUlEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMCt0ZdTU/F/7/+1HEkydFpoKVPn+93sUlUujQvP/7UcRTAuNDJ2a//s/imDqtKVZofm/1qGYSZk7sfodGwAAiobBJtffoNAAAAAASUVORK5CYII=" alt="RSS 2.0 Weblog Feed" width="80" height="15"/></a> <a href="/xmlfeed/weblog-atom10.xml"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPAgMAAAAOp6AcAAAADFBMVEVmZmb/ZgD///+JjnlbTUWmAAAAaklEQVQYlWNgwAa0VmGAFQyqoSCQ/x8J/CBFMDV16rTQ/H/7V//69+//v/3/9oMEI6cuAwr+fv/+/b5d///v//0eJBgWOhMo+Gs9UPAdXDBy6lSYyn9wQZCZS0GCYDPXQcykzJ1Y/Y4NAABKvL80wyoMPgAAAABJRU5ErkJggg==" alt="Atom 1.0 Weblog Feed" width="80" height="15"/></a> <a href="http://validator.w3.org/check?uri=referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABKklEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6qIGzIRiKZs9GFoEaMRuZhhrYqqJXy8uZYauRxC/VHew7e3YTPAxnI5swG6JxNrKBNjB1EFmIgV0+HA6C8pqqzhXG7BbJJROQIwViMYQ7G2oDQQNn57JyG7kxiCfObrBmS5+BHMuYLkTzMnYDm5WY4lOZZRPKZocxes+aPbuwCFsYohiICLvZsKBAMrDTQ7K/StveU8icTzrOL8JdLpOyWJ49u8Bx9ozw8DY7UYW03hhdxZAOSg2c3jN79rSJs1vSKmfOnpFXNJmynELlvExlAADnaZpLFGEC2wAAAABJRU5ErkJggg==" alt="Valid XHTML 1.1" width="80" height="15"/></a> <a href="http://jigsaw.w3.org/css-validator/check/referer"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAB1FBMVEUHQIgIRY0MN4QNRYoSRYsXUpIYVJQeUpUhWpgjUJMjWpgmU5QnXJkuYZ0uYpwwV5YyZJ4zaKM3ZaA5aaI6aqM6a6E8ZqA8Z6BAbaRBbqdCbaVHd61KSkpKcaZQUFBUf69UgbBVVVVXfq9Yg7NZhbJZh7RagrNeXVxeh7RfjLdgYGBiiLZmZmZnZ2doirhpkbt0m8F3m8B3ncJ5lb55ocR+ocSDgX+Do8eEpMqGhoaHp8iIpMeJjnmJpseKqMeOqsqPsdCQrcyVlZWVsM2Zs9CZtNCfu9ahoaGhuNShudSivNSjtMWjvNSmpqWnpqSrw9qvxNqyxdmyxdyzsK6zs7Ozx9y0xt21yN22tra4y+K80eK/v7/AwMDExMTEy9DH2ejK2+jM2ujN3uvP0dLR0NDR3uvS3uvS3+zU4u3V1dXY2dnY4u7Y4+3b5e/d3d3d5u/d5/De3t7f39/h4uLj4uHj6/Ll7PXm7fTn7/Xo7/Tp7/bq7Ozr6unr8ffw8PDw9vvx9fny+P7z8/Pz9vnz9vv3+fv4+vz5+vz6+vr6+/36/P36///7+/77/Pz7/f37/f78/Pz8/f38/f79/f39/f79/f/9/v79///+/v7+/v////3///+tYR2LAAABEUlEQVQ4y2PQoTJg0JlNVYDPQBsyAMTAqaFes8tdsmdPCtA3MDStr3GKKK6myMAprgJ9pcpWs/MlRExYJBvNZLR0sigycHYOV1S7mtjsQJ4gf+HIFPXoWMs6mIEQCsIjwhKoga0qerW8nBm2Gkn8Ut3BvrNnN8HCcDYM2cBIogzs8uFwEJTXVHWuMGa3SC6ZgIgUqCEwdxJr4OxcVm4jNwbxxNkN1mzpM2ajGIjsPGK9PLtZiSk+lVk2oWx2GKP3rNmzC4tQwpDoIIQb2Okh2V+lbe8pZM4nHecX4S6XSVksz55d4Dh7Rnh4m52oQlpvjK5iSAelBk7vmT172sTZLWmVM2fPyCuaTFlOoXJepjIAANlljDGY/l5pAAAAAElFTkSuQmCC" alt="Valid CSS (2.1)" width="80" height="15"/></a><br/>Copyright 2005-2015 <a href="/about/">Timo Bingmann</a> - <a href="/about/impressum.html">Impressum</a></div><script type="text/javascript">var _paq = _paq || []; _paq.push(["trackPageView"]); _paq.push(["enableLinkTracking"]);(function() {var u=(("https:" == document.location.protocol) ? "https" : "http") + "://panthema.net/wik-331/"; _paq.push(["setTrackerUrl", u+"js/"]); _paq.push(["setSiteId", "2"]);var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";g.defer=true; g.async=true; g.src=u+"js/"; s.parentNode.insertBefore(g,s);})();</script><noscript><p><img src="http://panthema.net/wik-331/js/?idsite=2&amp;rec=1" style="border:0" alt="" /></p></noscript></body></html>