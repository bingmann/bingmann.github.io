<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Stxxl: doxymain.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stxxl
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">doxymain.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="doxymain_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*! \mainpage Documentation for STXXL library</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> *  \image html layer_diagram.png</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * &lt;br&gt;&lt;br&gt;</span>
<a name="l00006"></a>00006 <span class="comment"> * The core of \c S&lt;small&gt;TXXL&lt;/small&gt; is an implementation of the C++</span>
<a name="l00007"></a>00007 <span class="comment"> * standard template library STL for external memory (out-of-core)</span>
<a name="l00008"></a>00008 <span class="comment"> * computations, i.e., \c S&lt;small&gt;TXXL&lt;/small&gt; implements containers and algorithms</span>
<a name="l00009"></a>00009 <span class="comment"> * that can process huge volumes of data that only fit on</span>
<a name="l00010"></a>00010 <span class="comment"> * disks. While the compatibility to the STL supports</span>
<a name="l00011"></a>00011 <span class="comment"> * ease of use and compatibility with existing applications,</span>
<a name="l00012"></a>00012 <span class="comment"> * another design priority is high performance.</span>
<a name="l00013"></a>00013 <span class="comment"> * Here is a selection of \c S&lt;small&gt;TXXL&lt;/small&gt; performance features:</span>
<a name="l00014"></a>00014 <span class="comment"> * - transparent support of multiple disks</span>
<a name="l00015"></a>00015 <span class="comment"> * - variable block lengths</span>
<a name="l00016"></a>00016 <span class="comment"> * - overlapping of I/O and computation</span>
<a name="l00017"></a>00017 <span class="comment"> * - prevention of OS file buffering overhead</span>
<a name="l00018"></a>00018 <span class="comment"> * - algorithm pipelining</span>
<a name="l00019"></a>00019 <span class="comment"> * - utilization of multiple processor cores for internal computation</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> *</span>
<a name="l00022"></a>00022 <span class="comment"> * \section platforms Supported Operating Systems</span>
<a name="l00023"></a>00023 <span class="comment"> * - Linux (kernel &gt;= 2.4.18)</span>
<a name="l00024"></a>00024 <span class="comment"> * - Mac OS X</span>
<a name="l00025"></a>00025 <span class="comment"> * - FreeBSD</span>
<a name="l00026"></a>00026 <span class="comment"> * - other POSIX compatible systems should work, but have not been tested</span>
<a name="l00027"></a>00027 <span class="comment"> * - Windows 2000/XP/Vista/7</span>
<a name="l00028"></a>00028 <span class="comment"> *</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * \section compilers Supported Compilers</span>
<a name="l00031"></a>00031 <span class="comment"> *</span>
<a name="l00032"></a>00032 <span class="comment"> * The following compilers have been tested in different</span>
<a name="l00033"></a>00033 <span class="comment"> * \c S&lt;small&gt;TXXL&lt;/small&gt; configurations.</span>
<a name="l00034"></a>00034 <span class="comment"> * Other compilers might work, too, but we don&#39;t have the resources</span>
<a name="l00035"></a>00035 <span class="comment"> * (systems, compilers or time) to test them.</span>
<a name="l00036"></a>00036 <span class="comment"> * Feedback is welcome.</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> * The compilers marked with &#39;*&#39; are the developer&#39;s favorite choices</span>
<a name="l00039"></a>00039 <span class="comment"> * and are most thoroughly tested.</span>
<a name="l00040"></a>00040 <span class="comment"> *</span>
<a name="l00041"></a>00041 <span class="comment"> * \verbatim</span>
<a name="l00042"></a>00042 <span class="comment">                |         parallel            parallel</span>
<a name="l00043"></a>00043 <span class="comment">                |  stxxl   stxxl     stxxl     stxxl</span>
<a name="l00044"></a>00044 <span class="comment">  compiler      |                   + boost   + boost</span>
<a name="l00045"></a>00045 <span class="comment">----------------+----------------------------------------</span>
<a name="l00046"></a>00046 <span class="comment">  GCC 4.6 c++0x |    x     PMODE       x       PMODE </span>
<a name="l00047"></a>00047 <span class="comment">  GCC 4.6       |    x     PMODE       x       PMODE </span>
<a name="l00048"></a>00048 <span class="comment">  GCC 4.5 c++0x |    x     PMODE       x       PMODE </span>
<a name="l00049"></a>00049 <span class="comment">  GCC 4.5       |    x     PMODE       x       PMODE </span>
<a name="l00050"></a>00050 <span class="comment">* GCC 4.4 c++0x |    x     PMODE       x       PMODE </span>
<a name="l00051"></a>00051 <span class="comment">  GCC 4.4       |    x     PMODE       x       PMODE </span>
<a name="l00052"></a>00052 <span class="comment">  GCC 4.3 c++0x |    x     PMODE²      x       PMODE²</span>
<a name="l00053"></a>00053 <span class="comment">  GCC 4.3       |    x     PMODE²      x       PMODE²</span>
<a name="l00054"></a>00054 <span class="comment">  GCC 4.2       |    x     MCSTL       x       MCSTL</span>
<a name="l00055"></a>00055 <span class="comment">  GCC 4.1       |    x       -         x         -</span>
<a name="l00056"></a>00056 <span class="comment">  GCC 4.0       |    x       -         x         -</span>
<a name="l00057"></a>00057 <span class="comment">  GCC 3.4       |    x       -         x         -</span>
<a name="l00058"></a>00058 <span class="comment">  GCC 3.3       |    o       -         o         -</span>
<a name="l00059"></a>00059 <span class="comment">  GCC 2.95      |    -       -         -         -</span>
<a name="l00060"></a>00060 <span class="comment">  ICPC 12.0.191 |    x¹    PMODE¹²     x¹      PMODE¹²</span>
<a name="l00061"></a>00061 <span class="comment">  ICPC 12.0.191 |    x¹    MCSTL¹      x¹      MCSTL¹</span>
<a name="l00062"></a>00062 <span class="comment">* ICPC 11.1.075 |    x¹    MCSTL¹      x¹      MCSTL¹</span>
<a name="l00063"></a>00063 <span class="comment">  ICPC 11.0.084 |    x¹    MCSTL¹      x¹      MCSTL¹</span>
<a name="l00064"></a>00064 <span class="comment">  ICPC 10.1.026 |    x¹    MCSTL¹      x¹      MCSTL¹</span>
<a name="l00065"></a>00065 <span class="comment">  ICPC 10.0.026 |    x¹    MCSTL¹      x¹      MCSTL¹</span>
<a name="l00066"></a>00066 <span class="comment">  ICPC 9.1.053  |    x¹      -         x¹        -</span>
<a name="l00067"></a>00067 <span class="comment">  ICPC 9.0.032  |    x¹      -         x¹        -</span>
<a name="l00068"></a>00068 <span class="comment">  clang++ 2.9   |    x       -         x         -</span>
<a name="l00069"></a>00069 <span class="comment">  MSVC 2010 10.0|    -       -         x         -</span>
<a name="l00070"></a>00070 <span class="comment">* MSVC 2008 9.0 |    -       -         x         -</span>
<a name="l00071"></a>00071 <span class="comment">  MSVC 2005 8.0 |    -       -         x         -</span>
<a name="l00072"></a>00072 <span class="comment"></span>
<a name="l00073"></a>00073 <span class="comment"> x   = full support</span>
<a name="l00074"></a>00074 <span class="comment"> o   = partial support</span>
<a name="l00075"></a>00075 <span class="comment"> -   = unsupported</span>
<a name="l00076"></a>00076 <span class="comment"> ?   = untested</span>
<a name="l00077"></a>00077 <span class="comment"> PMODE = supports parallelization using libstdc++ parallel mode</span>
<a name="l00078"></a>00078 <span class="comment"> MCSTL = supports parallelization using the MCSTL library (superseded by</span>
<a name="l00079"></a>00079 <span class="comment">       PMODE, introduced in gcc 4.3)</span>
<a name="l00080"></a>00080 <span class="comment"> ¹   = you may have to add a -gcc-name=&lt;gcc-x.y&gt; option if the system default</span>
<a name="l00081"></a>00081 <span class="comment">       gcc does not come in the correct version:</span>
<a name="l00082"></a>00082 <span class="comment">       icpc 9.0: use with gcc 3.x</span>
<a name="l00083"></a>00083 <span class="comment">       icpc 9.1: use with gcc before 4.2</span>
<a name="l00084"></a>00084 <span class="comment">       icpc 10.x, 11.x, 12.0 with mcstl support: use with gcc 4.2</span>
<a name="l00085"></a>00085 <span class="comment">       icpc 12.0 with pmode support: use with gcc 4.3</span>
<a name="l00086"></a>00086 <span class="comment"> ²   = gcc 4.3 only provides partial support for the libstdc++ parallel mode,</span>
<a name="l00087"></a>00087 <span class="comment">       full support requires gcc 4.4 or later</span>
<a name="l00088"></a>00088 <span class="comment">\endverbatim</span>
<a name="l00089"></a>00089 <span class="comment"> *</span>
<a name="l00090"></a>00090 <span class="comment"> *</span>
<a name="l00091"></a>00091 <span class="comment"> * \section boost Supported BOOST versions</span>
<a name="l00092"></a>00092 <span class="comment"> *</span>
<a name="l00093"></a>00093 <span class="comment"> * The &lt;a href=&quot;http://www.boost.org&quot;&gt;Boost&lt;/a&gt; libraries are required on</span>
<a name="l00094"></a>00094 <span class="comment"> * Windows platforms using MSVC compiler and optional on other platforms.</span>
<a name="l00095"></a>00095 <span class="comment"> *</span>
<a name="l00096"></a>00096 <span class="comment"> * \c S&lt;small&gt;TXXL&lt;/small&gt; has been tested with Boost 1.40.0, 1.42.0 and 1.46.1.</span>
<a name="l00097"></a>00097 <span class="comment"> * Other versions may work, too, but older versions will not get support.</span>
<a name="l00098"></a>00098 <span class="comment"> *</span>
<a name="l00099"></a>00099 <span class="comment"> *</span>
<a name="l00100"></a>00100 <span class="comment"> * \section installation Instructions on installation, usage, configuration</span>
<a name="l00101"></a>00101 <span class="comment"> *</span>
<a name="l00102"></a>00102 <span class="comment"> * - \link installation_linux_gcc Installation, usage, configuration (Linux/Unix &amp;ndash; g++/icpc/clang++) \endlink</span>
<a name="l00103"></a>00103 <span class="comment"> * - \link installation_msvc Installation, usage, configuration (Windows &amp;ndash; Microsoft Visual C++) \endlink</span>
<a name="l00104"></a>00104 <span class="comment"> *</span>
<a name="l00105"></a>00105 <span class="comment"> * - \link install-svn Installing from subversion \endlink</span>
<a name="l00106"></a>00106 <span class="comment"> *</span>
<a name="l00107"></a>00107 <span class="comment"> *</span>
<a name="l00108"></a>00108 <span class="comment"> * \section questions Questions</span>
<a name="l00109"></a>00109 <span class="comment"> *</span>
<a name="l00110"></a>00110 <span class="comment"> * - Questions concerning use and development of the \c S&lt;small&gt;TXXL&lt;/small&gt;</span>
<a name="l00111"></a>00111 <span class="comment"> * library should be posted to the</span>
<a name="l00112"></a>00112 <span class="comment"> * &lt;b&gt;&lt;a href=&quot;http://sourceforge.net/projects/stxxl/forums&quot;&gt;FORUMS&lt;/a&gt;&lt;/b&gt;.</span>
<a name="l00113"></a>00113 <span class="comment"> * Please search the forum before posting,</span>
<a name="l00114"></a>00114 <span class="comment"> * your question may have been answered before.</span>
<a name="l00115"></a>00115 <span class="comment"> *</span>
<a name="l00116"></a>00116 <span class="comment"> * \section bugreports Bug Reports</span>
<a name="l00117"></a>00117 <span class="comment"> *</span>
<a name="l00118"></a>00118 <span class="comment"> * - Bugs should be reported in the </span>
<a name="l00119"></a>00119 <span class="comment"> *   &lt;b&gt;&lt;a href=&quot;https://stxxl.ae.cs.uni-frankfurt.de/bugs/&quot;&gt;Bugzilla Bug Tracker&lt;/a&gt;&lt;/b&gt;</span>
<a name="l00120"></a>00120 <span class="comment"> *</span>
<a name="l00121"></a>00121 <span class="comment"> * - \link FAQ FAQ - Frequently Asked Questions \endlink</span>
<a name="l00122"></a>00122 <span class="comment"> *</span>
<a name="l00123"></a>00123 <span class="comment"> *</span>
<a name="l00124"></a>00124 <span class="comment"> * \section license License</span>
<a name="l00125"></a>00125 <span class="comment"> *</span>
<a name="l00126"></a>00126 <span class="comment"> * \c S&lt;small&gt;TXXL&lt;/small&gt; is distributed under the Boost Software License, Version 1.0.&lt;br&gt;</span>
<a name="l00127"></a>00127 <span class="comment"> * You can find a copy of the license in the accompanying file \c LICENSE_1_0.txt or online at</span>
<a name="l00128"></a>00128 <span class="comment"> * &lt;a href=&quot;http://www.boost.org/LICENSE_1_0.txt&quot;&gt;http://www.boost.org/LICENSE_1_0.txt&lt;/a&gt;.</span>
<a name="l00129"></a>00129 <span class="comment"> */</span>
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="comment"></span>
<a name="l00132"></a>00132 <span class="comment">/*!</span>
<a name="l00133"></a>00133 <span class="comment"> * \page FAQ FAQ - Frequently Asked Questions</span>
<a name="l00134"></a>00134 <span class="comment"> *</span>
<a name="l00135"></a>00135 <span class="comment"> * \section FAQ-latest Latest version of this FAQ</span>
<a name="l00136"></a>00136 <span class="comment"> * The most recent version of this FAQ can always be found</span>
<a name="l00137"></a>00137 <span class="comment"> * &lt;a href=&quot;http://algo2.iti.kit.edu/stxxl/trunk/FAQ.html&quot;&gt;here&lt;/a&gt;.</span>
<a name="l00138"></a>00138 <span class="comment"> *</span>
<a name="l00139"></a>00139 <span class="comment"> *</span>
<a name="l00140"></a>00140 <span class="comment"> * \section q1 References to Elements in External Memory Data Structures</span>
<a name="l00141"></a>00141 <span class="comment"> *</span>
<a name="l00142"></a>00142 <span class="comment"> * You should not pass or store references to elements in an external memory</span>
<a name="l00143"></a>00143 <span class="comment"> * data structure. When the reference is used, the block that contains the</span>
<a name="l00144"></a>00144 <span class="comment"> * element may be no longer in internal memory.&lt;br&gt;</span>
<a name="l00145"></a>00145 <span class="comment"> * Use/pass an iterator (reference) instead.&lt;br&gt;</span>
<a name="l00146"></a>00146 <span class="comment"> * For an \c stxxl::vector with \c n pages and LRU replacement strategy, it</span>
<a name="l00147"></a>00147 <span class="comment"> * can be guaranteed that the last \c n references</span>
<a name="l00148"></a>00148 <span class="comment"> * obtained using \c stxxl::vector::operator[] or dereferencing</span>
<a name="l00149"></a>00149 <span class="comment"> * an iterator are valid.</span>
<a name="l00150"></a>00150 <span class="comment"> * However, if \c n is 1, even a single innocent-looking line like</span>
<a name="l00151"></a>00151 <span class="comment"> * \verbatim std::cout &lt;&lt; v[0] &lt;&lt; &quot; &quot; &lt;&lt; v[1000000] &lt;&lt; std::endl; \endverbatim can lead to</span>
<a name="l00152"></a>00152 <span class="comment"> * inconsistent results.</span>
<a name="l00153"></a>00153 <span class="comment"> * &lt;br&gt;</span>
<a name="l00154"></a>00154 <span class="comment"> *</span>
<a name="l00155"></a>00155 <span class="comment"> *</span>
<a name="l00156"></a>00156 <span class="comment"> * \section q2 Parameterizing STXXL Containers</span>
<a name="l00157"></a>00157 <span class="comment"> *</span>
<a name="l00158"></a>00158 <span class="comment"> * STXXL container types like stxxl::vector can be parameterized only with a value type that is a</span>
<a name="l00159"></a>00159 <span class="comment"> * &lt;a href=&quot;http://en.wikipedia.org/wiki/Plain_old_data_structures&quot;&gt;POD&lt;/a&gt;</span>
<a name="l00160"></a>00160 <span class="comment"> * (i. e. no virtual functions, no user-defined copy assignment/destructor, etc.)</span>
<a name="l00161"></a>00161 <span class="comment"> * and does not contain references (including pointers) to internal memory.</span>
<a name="l00162"></a>00162 <span class="comment"> * Usually, &quot;complex&quot; data types do not satisfy this requirements.</span>
<a name="l00163"></a>00163 <span class="comment"> *</span>
<a name="l00164"></a>00164 <span class="comment"> * This is why stxxl::vector&lt;std::vector&lt;T&gt; &gt; and stxxl::vector&lt;stxxl::vector&lt;T&gt; &gt; are invalid.</span>
<a name="l00165"></a>00165 <span class="comment"> * If appropriate, use std::vector&lt;stxxl::vector&lt;T&gt; &gt;, or emulate a two-dimensional array by</span>
<a name="l00166"></a>00166 <span class="comment"> * doing index calculation.</span>
<a name="l00167"></a>00167 <span class="comment"> *</span>
<a name="l00168"></a>00168 <span class="comment"> *</span>
<a name="l00169"></a>00169 <span class="comment"> * \section q3 Thread-Safety</span>
<a name="l00170"></a>00170 <span class="comment"> *</span>
<a name="l00171"></a>00171 <span class="comment"> * The I/O and block management layers are thread-safe (since release 1.1.1).</span>
<a name="l00172"></a>00172 <span class="comment"> * The user layer data structures are not thread-safe.&lt;br&gt;</span>
<a name="l00173"></a>00173 <span class="comment"> * I.e. you may access &lt;b&gt;different&lt;/b&gt; \c S&lt;small&gt;TXXL&lt;/small&gt; data structures from concurrent threads without problems,</span>
<a name="l00174"></a>00174 <span class="comment"> * but you should not share a data structure between threads (without implementing proper locking yourself).&lt;br&gt;</span>
<a name="l00175"></a>00175 <span class="comment"> * This is a design choice, having the data structures thread-safe would mean a significant performance loss.</span>
<a name="l00176"></a>00176 <span class="comment"> *</span>
<a name="l00177"></a>00177 <span class="comment"> *</span>
<a name="l00178"></a>00178 <span class="comment"> * \section q4 I have configured several disks to use with STXXL. Why does STXXL fail complaining about the lack of space? According to my calclulations, the space on the disks should be sufficient.</span>
<a name="l00179"></a>00179 <span class="comment"> *</span>
<a name="l00180"></a>00180 <span class="comment"> * This may happen if the disks have different size. With the default parameters \c S&lt;small&gt;TXXL&lt;/small&gt; containers use randomized block-to-disk allocation strategies</span>
<a name="l00181"></a>00181 <span class="comment"> * that distribute data evenly between the disks but ignore the availability of free space on them. </span>
<a name="l00182"></a>00182 <span class="comment"> *</span>
<a name="l00183"></a>00183 <span class="comment"> *</span>
<a name="l00184"></a>00184 <span class="comment"> * \section q5 STXXL in a Microsoft CLR Library</span>
<a name="l00185"></a>00185 <span class="comment"> *</span>
<a name="l00186"></a>00186 <span class="comment"> * From STXXL user Christian, posted in the &lt;a href=&quot;https://sourceforge.net/projects/stxxl/forums/forum/446474/topic/3407329&quot;&gt;forum&lt;/a&gt;:</span>
<a name="l00187"></a>00187 <span class="comment"> *</span>
<a name="l00188"></a>00188 <span class="comment"> * Precondition: I use STXXL in a Microsoft CLR Library (a special DLL). That means that managed code and native code (e.g. STXXL) have to co-exist in your library.</span>
<a name="l00189"></a>00189 <span class="comment"> *</span>
<a name="l00190"></a>00190 <span class="comment"> * Symptom: Application crashes at process exit, when the DLL is unloaded.</span>
<a name="l00191"></a>00191 <span class="comment"> *</span>
<a name="l00192"></a>00192 <span class="comment"> * Cause: STXXL&#39;s singleton classes use the \c atexit() function to destruct themselves at process exit. The exit handling will cause the process to crash at exit (still unclear if it&#39;s a bug or a feature of the MS runtime).</span>
<a name="l00193"></a>00193 <span class="comment"> *</span>
<a name="l00194"></a>00194 <span class="comment"> * Solution:</span>
<a name="l00195"></a>00195 <span class="comment"> *</span>
<a name="l00196"></a>00196 <span class="comment"> * 1.) Compiled STXXL static library with \c STXXL_NON_DEFAULT_EXIT_HANDLER defined.</span>
<a name="l00197"></a>00197 <span class="comment"> *</span>
<a name="l00198"></a>00198 <span class="comment"> * 2.) For cleanup, \c stxxl::run_exit_handlers() has now to be called manually. To get this done automatically:</span>
<a name="l00199"></a>00199 <span class="comment"> *</span>
<a name="l00200"></a>00200 <span class="comment"> * Defined a CLI singleton class &quot;Controller&quot;:</span>
<a name="l00201"></a>00201 <span class="comment"> *</span>
<a name="l00202"></a>00202 <span class="comment"> * \verbatim</span>
<a name="l00203"></a>00203 <span class="comment">public ref class Controller {</span>
<a name="l00204"></a>00204 <span class="comment">private: </span>
<a name="l00205"></a>00205 <span class="comment">    static Controller^ instance = gcnew Controller;</span>
<a name="l00206"></a>00206 <span class="comment">    Controller();</span>
<a name="l00207"></a>00207 <span class="comment">};</span>
<a name="l00208"></a>00208 <span class="comment">\endverbatim</span>
<a name="l00209"></a>00209 <span class="comment"> *</span>
<a name="l00210"></a>00210 <span class="comment"> *     Registered my own cleanup function in Controller&#39;s constructor which will manage to call \c stxxl::run_exit_handlers():</span>
<a name="l00211"></a>00211 <span class="comment"> *</span>
<a name="l00212"></a>00212 <span class="comment"> * \verbatim</span>
<a name="l00213"></a>00213 <span class="comment">#pragma managed(push, off)</span>
<a name="l00214"></a>00214 <span class="comment">static int myexitfn()</span>
<a name="l00215"></a>00215 <span class="comment">{</span>
<a name="l00216"></a>00216 <span class="comment">    stxxl::run_exit_handlers();</span>
<a name="l00217"></a>00217 <span class="comment">    return 0;</span>
<a name="l00218"></a>00218 <span class="comment">}</span>
<a name="l00219"></a>00219 <span class="comment">#pragma managed(pop)</span>
<a name="l00220"></a>00220 <span class="comment"></span>
<a name="l00221"></a>00221 <span class="comment">Controller::Controller()</span>
<a name="l00222"></a>00222 <span class="comment">{</span>
<a name="l00223"></a>00223 <span class="comment">    onexit(myexitfn);</span>
<a name="l00224"></a>00224 <span class="comment">}</span>
<a name="l00225"></a>00225 <span class="comment">\endverbatim</span>
<a name="l00226"></a>00226 <span class="comment"> *</span>
<a name="l00227"></a>00227 <span class="comment"> *</span>
<a name="l00228"></a>00228 <span class="comment"> * \section q6 How can I credit STXXL, and thus foster its development?</span>
<a name="l00229"></a>00229 <span class="comment"> *</span>
<a name="l00230"></a>00230 <span class="comment"> * - For all users:</span>
<a name="l00231"></a>00231 <span class="comment"> *   - Sign up at Ohloh and add yourself as an STXXL user / rate STXXL: http://www.ohloh.net/p/stxxl</span>
<a name="l00232"></a>00232 <span class="comment"> *   - Rate STXXL at heise Software-Verzeichnis (German): http://www.heise.de/software/download/stxxl/76072</span>
<a name="l00233"></a>00233 <span class="comment"> *   - Rate STXXL at SourceForge: https://sourceforge.net/projects/stxxl/</span>
<a name="l00234"></a>00234 <span class="comment"> *</span>
<a name="l00235"></a>00235 <span class="comment"> * - For scientific work:  Cite the papers mentioned here: http://stxxl.sourceforge.net/</span>
<a name="l00236"></a>00236 <span class="comment"> *</span>
<a name="l00237"></a>00237 <span class="comment"> * - For industrial users:  Tell us the name of your company, so we can use it as a reference.</span>
<a name="l00238"></a>00238 <span class="comment"> *</span>
<a name="l00239"></a>00239 <span class="comment"> */</span>
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="comment"></span>
<a name="l00242"></a>00242 <span class="comment">/*!</span>
<a name="l00243"></a>00243 <span class="comment"> * \page install Instructions on Installation, usage, configuration</span>
<a name="l00244"></a>00244 <span class="comment"> * - \link installation_linux_gcc Installation, usage, configuration (Linux/Unix &amp;ndash; g++/icpc/clang++) \endlink</span>
<a name="l00245"></a>00245 <span class="comment"> * - \link installation_msvc Installation, usage, configuration (Windows &amp;ndash; Microsoft Visual C++) \endlink</span>
<a name="l00246"></a>00246 <span class="comment"> *</span>
<a name="l00247"></a>00247 <span class="comment"> * - \link install-svn Installing from subversion \endlink</span>
<a name="l00248"></a>00248 <span class="comment"> */</span>
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 <span class="comment"></span>
<a name="l00251"></a>00251 <span class="comment">/*!</span>
<a name="l00252"></a>00252 <span class="comment"> * \page installation_linux_gcc Installation, usage, configuration (Linux/Unix &amp;ndash; g++/icpc/clang++)</span>
<a name="l00253"></a>00253 <span class="comment"> *</span>
<a name="l00254"></a>00254 <span class="comment"> * \section download_linux_gcc Download and Extraction</span>
<a name="l00255"></a>00255 <span class="comment"> *</span>
<a name="l00256"></a>00256 <span class="comment"> * - Download the latest gzipped tarball from</span>
<a name="l00257"></a>00257 <span class="comment"> *   &lt;a href=&quot;http://sourceforge.net/projects/stxxl/files/stxxl/&quot;&gt;SourceForge&lt;/a&gt;</span>
<a name="l00258"></a>00258 <span class="comment"> * - Unpack in some directory executing: \c tar \c zfxv \c stxxl-x.y.z.tgz</span>
<a name="l00259"></a>00259 <span class="comment"> * - Change to \c stxxl directory: \c cd \c stxxl-x.y.z</span>
<a name="l00260"></a>00260 <span class="comment"> *</span>
<a name="l00261"></a>00261 <span class="comment"> * \section library_compilation_linux_gcc Library Compilation</span>
<a name="l00262"></a>00262 <span class="comment"> *</span>
<a name="l00263"></a>00263 <span class="comment"> * - Run: \verbatim make config_gnu \endverbatim to create a template \c make.settings.local file.</span>
<a name="l00264"></a>00264 <span class="comment"> *   Note: this will produce some warnings and abort with an error, which is intended.</span>
<a name="l00265"></a>00265 <span class="comment"> * - (optionally) change the \c make.settings.local file according to your system configuration:</span>
<a name="l00266"></a>00266 <span class="comment"> *   - (optionally) set the \c STXXL_ROOT variable to \c S&lt;small&gt;TXXL&lt;/small&gt; root directory</span>
<a name="l00267"></a>00267 <span class="comment"> *     ( \c directory_where_you_unpacked_the_tar_ball/stxxl-x.y.z )</span>
<a name="l00268"></a>00268 <span class="comment"> *   - if you want \c S&lt;small&gt;TXXL&lt;/small&gt; to use &lt;a href=&quot;http://www.boost.org&quot;&gt;Boost&lt;/a&gt; libraries</span>
<a name="l00269"></a>00269 <span class="comment"> *     (you should have the Boost libraries already installed)</span>
<a name="l00270"></a>00270 <span class="comment"> *     - change the \c USE_BOOST variable to \c yes</span>
<a name="l00271"></a>00271 <span class="comment"> *     - change the \c BOOST_ROOT variable to the Boost root path, unless Boost is installed in system default search paths.</span>
<a name="l00272"></a>00272 <span class="comment"> *   - if you want \c S&lt;small&gt;TXXL&lt;/small&gt; to use the &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/libstdc++/manual/parallel_mode.html&quot;&gt;libstdc++ parallel mode&lt;/a&gt;</span>
<a name="l00273"></a>00273 <span class="comment"> *     - use GCC version 4.3 or later</span>
<a name="l00274"></a>00274 <span class="comment"> *     - use the targets \c library_g++_pmode and \c tests_g++_pmode instead of the ones listed below</span>
<a name="l00275"></a>00275 <span class="comment"> *   - if you want \c S&lt;small&gt;TXXL&lt;/small&gt; to use the &lt;a href=&quot;http://algo2.iti.kit.edu/singler/mcstl/&quot;&gt;MCSTL&lt;/a&gt;</span>
<a name="l00276"></a>00276 <span class="comment"> *     library (you should have the MCSTL library already installed)</span>
<a name="l00277"></a>00277 <span class="comment"> *     - change the \c MCSTL_ROOT variable to the MCSTL root path</span>
<a name="l00278"></a>00278 <span class="comment"> *     - use the targets \c library_g++_mcstl and \c tests_g++_mcstl instead of the ones listed below</span>
<a name="l00279"></a>00279 <span class="comment"> *   - (optionally) set the \c OPT variable to \c -O3 or other g++ optimization level you like (default: \c -O3 )</span>
<a name="l00280"></a>00280 <span class="comment"> *   - (optionally) set the \c DEBUG variable to \c -g or other g++ debugging option</span>
<a name="l00281"></a>00281 <span class="comment"> *     if you want to produce a debug version of the Stxxl library or Stxxl examples (default: not set)</span>
<a name="l00282"></a>00282 <span class="comment"> *   - for more variables to tune take a look at \c make.settings.gnu ,</span>
<a name="l00283"></a>00283 <span class="comment"> *     they are usually overridden by settings in \c make.settings.local,</span>
<a name="l00284"></a>00284 <span class="comment"> *     using \c CPPFLAGS and \c LDFLAGS, for example, you can add arbitrary compiler and linker options</span>
<a name="l00285"></a>00285 <span class="comment"> * - Run: \verbatim make library_g++ \endverbatim</span>
<a name="l00286"></a>00286 <span class="comment"> * - Run: \verbatim make tests_g++ \endverbatim (optional, if you want to compile and run some test programs)</span>
<a name="l00287"></a>00287 <span class="comment"> *</span>
<a name="l00288"></a>00288 <span class="comment"> *</span>
<a name="l00289"></a>00289 <span class="comment"> * \section build_apps Building an Application</span>
<a name="l00290"></a>00290 <span class="comment"> *</span>
<a name="l00291"></a>00291 <span class="comment"> * After compiling the library, some Makefile variables are written to</span>
<a name="l00292"></a>00292 <span class="comment"> * \c stxxl.mk (\c pmstxxl.mk if you have built with parallel mode, \c mcstxxl.mk if you have built with MCSTL) in your</span>
<a name="l00293"></a>00293 <span class="comment"> * \c STXXL_ROOT directory. This file should be included from your</span>
<a name="l00294"></a>00294 <span class="comment"> * application&#39;s Makefile.</span>
<a name="l00295"></a>00295 <span class="comment"> *</span>
<a name="l00296"></a>00296 <span class="comment"> * The following variables can be used:</span>
<a name="l00297"></a>00297 <span class="comment"> * - \c STXXL_CXX - the compiler used to build the \c S&lt;small&gt;TXXL&lt;/small&gt;</span>
<a name="l00298"></a>00298 <span class="comment"> *      library, it&#39;s recommended to use the same to build your applications</span>
<a name="l00299"></a>00299 <span class="comment"> * - \c STXXL_CPPFLAGS - add these flags to the compile commands</span>
<a name="l00300"></a>00300 <span class="comment"> * - \c STXXL_LDLIBS - add these libraries to the link commands</span>
<a name="l00301"></a>00301 <span class="comment"> *</span>
<a name="l00302"></a>00302 <span class="comment"> * An example Makefile for an application using \c S&lt;small&gt;TXXL&lt;/small&gt;:</span>
<a name="l00303"></a>00303 <span class="comment"> * \verbatim</span>
<a name="l00304"></a>00304 <span class="comment">STXXL_ROOT      ?= .../stxxl</span>
<a name="l00305"></a>00305 <span class="comment">STXXL_CONFIG    ?= stxxl.mk</span>
<a name="l00306"></a>00306 <span class="comment">include $(STXXL_ROOT)/$(STXXL_CONFIG)</span>
<a name="l00307"></a>00307 <span class="comment"></span>
<a name="l00308"></a>00308 <span class="comment"># use the variables from stxxl.mk</span>
<a name="l00309"></a>00309 <span class="comment">CXX              = $(STXXL_CXX)</span>
<a name="l00310"></a>00310 <span class="comment">CPPFLAGS        += $(STXXL_CPPFLAGS)</span>
<a name="l00311"></a>00311 <span class="comment">LDLIBS          += $(STXXL_LDLIBS)</span>
<a name="l00312"></a>00312 <span class="comment"></span>
<a name="l00313"></a>00313 <span class="comment"># add your own optimization, warning, debug, ... flags</span>
<a name="l00314"></a>00314 <span class="comment"># (these are *not* set in stxxl.mk)</span>
<a name="l00315"></a>00315 <span class="comment">CPPFLAGS        += -O3 -Wall -g -DFOO=BAR</span>
<a name="l00316"></a>00316 <span class="comment"></span>
<a name="l00317"></a>00317 <span class="comment"># build your application</span>
<a name="l00318"></a>00318 <span class="comment"># (my_example.o is generated from my_example.cpp automatically)</span>
<a name="l00319"></a>00319 <span class="comment">my_example.bin: my_example.o</span>
<a name="l00320"></a>00320 <span class="comment">        $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) my_example.o -o $@ $(LDLIBS)</span>
<a name="l00321"></a>00321 <span class="comment">\endverbatim</span>
<a name="l00322"></a>00322 <span class="comment"> *</span>
<a name="l00323"></a>00323 <span class="comment"> * \section parallel Enabling parallel execution</span>
<a name="l00324"></a>00324 <span class="comment"> *</span>
<a name="l00325"></a>00325 <span class="comment"> * To enable (shared-memory-)parallel execution of internal computation (in fact, sorting and merging, and random shuffling),</span>
<a name="l00326"></a>00326 <span class="comment"> * you have several options depending on the \ref compilers &quot;compiler version&quot; used:</span>
<a name="l00327"></a>00327 <span class="comment"> * - Enable the g++ parallel mode specifically for STXXL,</span>
<a name="l00328"></a>00328 <span class="comment"> *   by defining \c STXXL_PARALLEL_MODE_EXPLICIT and enabling OpenMP (\c -DSTXXL_PARALLEL_MODE_EXPLICIT \c -fopenmp)</span>
<a name="l00329"></a>00329 <span class="comment"> *   during compilation and linkage of your program.</span>
<a name="l00330"></a>00330 <span class="comment"> *   Compiling the library binary with this flag enabled is not really necessary,</span>
<a name="l00331"></a>00331 <span class="comment"> *   since the most time-consuming operations are called by the generic routines and thus contained in the header files.</span>
<a name="l00332"></a>00332 <span class="comment"> * - Enable the g++ parallel mode for your program globally,</span>
<a name="l00333"></a>00333 <span class="comment"> *   by defining \c _GLIBCXX_PARALLEL and enabling OpenMP (\c -D_GLIBCXX_PARALLEL \c -fopenmp).</span>
<a name="l00334"></a>00334 <span class="comment"> *   This has the implication that STL algorithms in your program will also be executed in parallel,</span>
<a name="l00335"></a>00335 <span class="comment"> *   which may have undesired side effects.</span>
<a name="l00336"></a>00336 <span class="comment"> *   These options are automatically used when you built STXXL using the \c *_pmode target,</span>
<a name="l00337"></a>00337 <span class="comment"> *   and your Makefile includes \c pmstxxl.mk.</span>
<a name="l00338"></a>00338 <span class="comment"> * - Enable MCSTL in your program by setting the include path appropriately.</span>
<a name="l00339"></a>00339 <span class="comment"> *   This implies that STL algorithms in your program will also be executed in parallel,</span>
<a name="l00340"></a>00340 <span class="comment"> *   which may have undesired side effects.</span>
<a name="l00341"></a>00341 <span class="comment"> *   These options are automatically used when you built STXXL using the \c *_mcstl target,</span>
<a name="l00342"></a>00342 <span class="comment"> *   and your Makefile includes \c mcstxxl.mk.</span>
<a name="l00343"></a>00343 <span class="comment"> *</span>
<a name="l00344"></a>00344 <span class="comment"> * We recommend to try the first option at first.</span>
<a name="l00345"></a>00345 <span class="comment"> *</span>
<a name="l00346"></a>00346 <span class="comment"> * The number of threads to be used can be set by the environment variable OMP_NUM_THREADS or</span>
<a name="l00347"></a>00347 <span class="comment"> * by calling omp_set_num_threads.</span>
<a name="l00348"></a>00348 <span class="comment"> * Detailed tuning can be achieved as described</span>
<a name="l00349"></a>00349 <span class="comment"> * &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt03ch18s04.html#parallel_mode.design.tuning&quot;&gt;here&lt;/a&gt;.</span>
<a name="l00350"></a>00350 <span class="comment"> *</span>
<a name="l00351"></a>00351 <span class="comment"> *</span>
<a name="l00352"></a>00352 <span class="comment"> * \section space Disk space</span>
<a name="l00353"></a>00353 <span class="comment"> *</span>
<a name="l00354"></a>00354 <span class="comment"> * Before you try to run one of the \c S&lt;small&gt;TXXL&lt;/small&gt; examples</span>
<a name="l00355"></a>00355 <span class="comment"> * (or your own \c S&lt;small&gt;TXXL&lt;/small&gt; program) you must configure the disk</span>
<a name="l00356"></a>00356 <span class="comment"> * space that will be used as external memory for the library.</span>
<a name="l00357"></a>00357 <span class="comment"> *</span>
<a name="l00358"></a>00358 <span class="comment"> * To get best performance with \c S&lt;small&gt;TXXL&lt;/small&gt; you should assign separate disks to it.</span>
<a name="l00359"></a>00359 <span class="comment"> * These disks should be used by the library only.</span>
<a name="l00360"></a>00360 <span class="comment"> * Since \c S&lt;small&gt;TXXL&lt;/small&gt; is developed to exploit disk parallelism, the performance of your</span>
<a name="l00361"></a>00361 <span class="comment"> * external memory application will increase if you use more than one disk.</span>
<a name="l00362"></a>00362 <span class="comment"> * But from how many disks your application can benefit depends on how &quot;I/O bound&quot; it is.</span>
<a name="l00363"></a>00363 <span class="comment"> * With modern disk bandwidths</span>
<a name="l00364"></a>00364 <span class="comment"> * of about 50-75 MiB/s most of applications are I/O bound for one disk. This means that if you add another disk</span>
<a name="l00365"></a>00365 <span class="comment"> * the running time will be halved. Adding more disks might also increase performance significantly.</span>
<a name="l00366"></a>00366 <span class="comment"> *</span>
<a name="l00367"></a>00367 <span class="comment"> *</span>
<a name="l00368"></a>00368 <span class="comment"> * \section filesystem Recommended file system</span>
<a name="l00369"></a>00369 <span class="comment"> *</span>
<a name="l00370"></a>00370 <span class="comment"> * The library benefits from direct transfers from user memory to disk, which saves superfluous copies.</span>
<a name="l00371"></a>00371 <span class="comment"> * We recommend to use the</span>
<a name="l00372"></a>00372 <span class="comment"> * \c &lt;a href=&quot;http://xfs.org&quot;&gt;XFS&lt;/a&gt; file system,</span>
<a name="l00373"></a>00373 <span class="comment"> * which gives good read and write performance for large files.</span>
<a name="l00374"></a>00374 <span class="comment"> * Note that file creation speed of \c XFS is a bit slower,</span>
<a name="l00375"></a>00375 <span class="comment"> * so that disk files should be precreated for optimal performance.</span>
<a name="l00376"></a>00376 <span class="comment"> *</span>
<a name="l00377"></a>00377 <span class="comment"> * If the filesystems only use is to store one large \c S&lt;small&gt;TXXL&lt;/small&gt; disk file,</span>
<a name="l00378"></a>00378 <span class="comment"> * we also recommend to add the following options to the \c mkfs.xfs command to gain maximum performance:</span>
<a name="l00379"></a>00379 <span class="comment"> * \verbatim -d agcount=1 -l size=512b \endverbatim</span>
<a name="l00380"></a>00380 <span class="comment"> *</span>
<a name="l00381"></a>00381 <span class="comment"> * The following filesystems have been reported not to support direct I/O: \c tmpfs , \c glusterfs .</span>
<a name="l00382"></a>00382 <span class="comment"> * Since direct I/O is enabled by default, you may recompile \c S&lt;small&gt;TXXL&lt;/small&gt;</span>
<a name="l00383"></a>00383 <span class="comment"> * with \c STXXL_DIRECT_IO_OFF defined to access files on these file systems.</span>
<a name="l00384"></a>00384 <span class="comment"> *</span>
<a name="l00385"></a>00385 <span class="comment"> *</span>
<a name="l00386"></a>00386 <span class="comment"> * \section configuration Disk configuration file</span>
<a name="l00387"></a>00387 <span class="comment"> *</span>
<a name="l00388"></a>00388 <span class="comment"> * You must define the disk configuration for an</span>
<a name="l00389"></a>00389 <span class="comment"> * \c S&lt;small&gt;TXXL&lt;/small&gt; program in a file named \c &#39;.stxxl&#39; that must reside</span>
<a name="l00390"></a>00390 <span class="comment"> * in the same directory where you execute the program.</span>
<a name="l00391"></a>00391 <span class="comment"> * You can change the default file name for the configuration</span>
<a name="l00392"></a>00392 <span class="comment"> * file by setting the environment variable \c STXXLCFG .</span>
<a name="l00393"></a>00393 <span class="comment"> *</span>
<a name="l00394"></a>00394 <span class="comment"> * Each line of the configuration file describes a disk.</span>
<a name="l00395"></a>00395 <span class="comment"> * A disk description uses the following format:&lt;br&gt;</span>
<a name="l00396"></a>00396 <span class="comment"> * \c disk=full_disk_filename,capacity,access_method</span>
<a name="l00397"></a>00397 <span class="comment"> *</span>
<a name="l00398"></a>00398 <span class="comment"> * Description of the parameters:</span>
<a name="l00399"></a>00399 <span class="comment"> * - \c full_disk_filename : full disk filename. In order to access disks S&lt;small&gt;TXXL&lt;/small&gt; uses file</span>
<a name="l00400"></a>00400 <span class="comment"> *   access methods. Each disk is represented as a file. If you have a disk that is mounted in Unix</span>
<a name="l00401"></a>00401 <span class="comment"> *   to the path /mnt/disk0/, then the correct value for the \c full_disk_filename would be</span>
<a name="l00402"></a>00402 <span class="comment"> *   \c /mnt/disk0/some_file_name ,</span>
<a name="l00403"></a>00403 <span class="comment"> * - \c capacity : maximum capacity of the disk in megabytes</span>
<a name="l00404"></a>00404 <span class="comment"> *   (0 means autogrow, file will be deleted afterwards)</span>
<a name="l00405"></a>00405 <span class="comment"> * - \c access_method : \c S&lt;small&gt;TXXL&lt;/small&gt; has a number of different</span>
<a name="l00406"></a>00406 <span class="comment"> *   file access implementations for POSIX systems, choose one of them:</span>
<a name="l00407"></a>00407 <span class="comment"> *   - \c syscall : use \c read and \c write system calls which perform disk transfers directly</span>
<a name="l00408"></a>00408 <span class="comment"> *     on user memory pages without superfluous copying (currently the fastest method)</span>
<a name="l00409"></a>00409 <span class="comment"> *   - \c mmap : \c use \c mmap and \c munmap system calls</span>
<a name="l00410"></a>00410 <span class="comment"> *   - \c boostfd : access the file using a Boost file descriptor</span>
<a name="l00411"></a>00411 <span class="comment"> *   - \c fileperblock_syscall, \c fileperblock_mmap, \c fileperblock_boostfd :</span>
<a name="l00412"></a>00412 <span class="comment"> *     same as above, but take a single file per block, using full_disk_filename as file name prefix.</span>
<a name="l00413"></a>00413 <span class="comment"> *     Usually provide worse performance than the standard variants,</span>
<a name="l00414"></a>00414 <span class="comment"> *     but release freed blocks to the file system immediately.</span>
<a name="l00415"></a>00415 <span class="comment"> *   - \c simdisk : simulates timings of the IBM IC35L080AVVA07 disk, full_disk_filename must point</span>
<a name="l00416"></a>00416 <span class="comment"> *     to a file on a RAM disk partition with sufficient space</span>
<a name="l00417"></a>00417 <span class="comment"> *   - \c memory : keeps all data in RAM, for quicker testing</span>
<a name="l00418"></a>00418 <span class="comment"> *   - \c wbtl : library-based write-combining (good for writing small blocks onto SSDs),</span>
<a name="l00419"></a>00419 <span class="comment"> *     based on \c syscall</span>
<a name="l00420"></a>00420 <span class="comment"> *</span>
<a name="l00421"></a>00421 <span class="comment"> * See also the example configuration file \c &#39;config_example&#39; included in the tarball.</span>
<a name="l00422"></a>00422 <span class="comment"> *</span>
<a name="l00423"></a>00423 <span class="comment"> *</span>
<a name="l00424"></a>00424 <span class="comment"> * \section logfiles Log files</span>
<a name="l00425"></a>00425 <span class="comment"> *</span>
<a name="l00426"></a>00426 <span class="comment"> * \c S&lt;small&gt;TXXL&lt;/small&gt; produces two kinds of log files, a message and an error log.</span>
<a name="l00427"></a>00427 <span class="comment"> * By setting the environment variables \c STXXLLOGFILE and \c STXXLERRLOGFILE, you can configure</span>
<a name="l00428"></a>00428 <span class="comment"> * the location of these files.</span>
<a name="l00429"></a>00429 <span class="comment"> * The default values are \c stxxl.log and \c stxxl.errlog, respectively.</span>
<a name="l00430"></a>00430 <span class="comment"> *</span>
<a name="l00431"></a>00431 <span class="comment"> *</span>
<a name="l00432"></a>00432 <span class="comment"> * \section excreation Precreating external memory files</span>
<a name="l00433"></a>00433 <span class="comment"> *</span>
<a name="l00434"></a>00434 <span class="comment"> * In order to get the maximum performance one should precreate disk files described in the configuration file,</span>
<a name="l00435"></a>00435 <span class="comment"> * before running \c S&lt;small&gt;TXXL&lt;/small&gt; applications.</span>
<a name="l00436"></a>00436 <span class="comment"> *</span>
<a name="l00437"></a>00437 <span class="comment"> * The precreation utility is included in the set of \c S&lt;small&gt;TXXL&lt;/small&gt;</span>
<a name="l00438"></a>00438 <span class="comment"> * utilities ( \c utils/createdisks.bin ). Run this utility</span>
<a name="l00439"></a>00439 <span class="comment"> * for each disk you have defined in the disk configuration file:</span>
<a name="l00440"></a>00440 <span class="comment"> * \verbatim utils/createdisks.bin capacity full_disk_filename... \endverbatim</span>
<a name="l00441"></a>00441 <span class="comment"> *</span>
<a name="l00442"></a>00442 <span class="comment"> * */</span>
<a name="l00443"></a>00443 
<a name="l00444"></a>00444 <span class="comment"></span>
<a name="l00445"></a>00445 <span class="comment">/*!</span>
<a name="l00446"></a>00446 <span class="comment"> * \page installation_msvc Installation, usage, configuration (Windows &amp;ndash; Microsoft Visual C++)</span>
<a name="l00447"></a>00447 <span class="comment"> *</span>
<a name="l00448"></a>00448 <span class="comment"> * \section download_msvc Download and Extraction</span>
<a name="l00449"></a>00449 <span class="comment"> *</span>
<a name="l00450"></a>00450 <span class="comment"> * - Install the &lt;a href=&quot;http://www.boost.org&quot;&gt;Boost&lt;/a&gt; libraries (required).</span>
<a name="l00451"></a>00451 <span class="comment"> * - Download the latest \c Stxxl zip file from</span>
<a name="l00452"></a>00452 <span class="comment"> *   &lt;a href=&quot;http://sourceforge.net/projects/stxxl/files/stxxl/&quot;&gt;SourceForge&lt;/a&gt;</span>
<a name="l00453"></a>00453 <span class="comment"> * - Unpack the zip file in some directory (e.&amp;nbsp;g. \c &#39;C:\\&#39; )</span>
<a name="l00454"></a>00454 <span class="comment"> * - Change to \c stxxl base directory: \c cd \c stxxl-x.y.z</span>
<a name="l00455"></a>00455 <span class="comment"> *</span>
<a name="l00456"></a>00456 <span class="comment"> * \section library_compilation_msvc Library Compilation</span>
<a name="l00457"></a>00457 <span class="comment"> *</span>
<a name="l00458"></a>00458 <span class="comment"> * - Create \c make.settings.local in the base directory according to your system configuration:</span>
<a name="l00459"></a>00459 <span class="comment"> *   - set \c BOOST_ROOT variable according to the Boost root path, e.&amp;nbsp;g.</span>
<a name="l00460"></a>00460 <span class="comment"> *     BOOST_ROOT = &quot;C:\Program Files (x86)\boost\boost_1_40_0&quot;#</span>
<a name="l00461"></a>00461 <span class="comment"> *   - (optionally) set \c STXXL_ROOT variable to \c S&lt;small&gt;TXXL&lt;/small&gt; root directory</span>
<a name="l00462"></a>00462 <span class="comment"> *   - (optionally) set \c OPT variable to \c /O2 or any other VC++ optimization level you like,</span>
<a name="l00463"></a>00463 <span class="comment"> *   add -D_SECURE_SCL=0 to switch off iterator checking, which improves performance</span>
<a name="l00464"></a>00464 <span class="comment"> *   - (optionally) set \c DEBUG_COMPILER=/MDd /Zi and DEBUG_LINKER=/DEBUG enable debugging</span>
<a name="l00465"></a>00465 <span class="comment"> * - Open the \c stxxl.vcproj file (VS Solution Object) in Visual Studio.</span>
<a name="l00466"></a>00466 <span class="comment"> *   The file is located in the \c STXXL_ROOT directory</span>
<a name="l00467"></a>00467 <span class="comment"> *   Press F7 to build the library.</span>
<a name="l00468"></a>00468 <span class="comment"> *   The library file (libstxxl.lib) should appear in \c STXXL_ROOT\\lib directory</span>
<a name="l00469"></a>00469 <span class="comment"> *   Or build the library and the S&lt;small&gt;TXXL&lt;/small&gt; test programs by pressing Ctrl-Alt-F7</span>
<a name="l00470"></a>00470 <span class="comment"> *   (or choosing from &#39;Build&#39; drop-down menu Rebuild Solution)</span>
<a name="l00471"></a>00471 <span class="comment"> * - (alternatively) Compile the library by executing \c nmake \c library_msvc</span>
<a name="l00472"></a>00472 <span class="comment"> *   and the tests by executing \c nmake \c tests_msvc,</span>
<a name="l00473"></a>00473 <span class="comment"> *   with all the appropriate environment set (e.&amp;nbsp;g. by using the VS Command Shell)</span>
<a name="l00474"></a>00474 <span class="comment"> *</span>
<a name="l00475"></a>00475 <span class="comment"> *</span>
<a name="l00476"></a>00476 <span class="comment"> * \section build_apps Building an application</span>
<a name="l00477"></a>00477 <span class="comment"> *</span>
<a name="l00478"></a>00478 <span class="comment"> * Programs using Stxxl can be compiled using options from \c compiler.options</span>
<a name="l00479"></a>00479 <span class="comment"> * file (in the \c STXXL_ROOT directory). The linking options for the VC++</span>
<a name="l00480"></a>00480 <span class="comment"> * linker you can find in \c linker.options file. In order to accomplish this</span>
<a name="l00481"></a>00481 <span class="comment"> * do the following:</span>
<a name="l00482"></a>00482 <span class="comment"> * - Open project property pages (menu Project-&gt;Properties)</span>
<a name="l00483"></a>00483 <span class="comment"> * - Choose C/C++-&gt;Command Line page.</span>
<a name="l00484"></a>00484 <span class="comment"> * - In the &#39;Additional Options&#39; field insert the contents of the \c compiler.options file.</span>
<a name="l00485"></a>00485 <span class="comment"> * Make sure that the Runtime libraries/debug options (/MDd or /MD or /MT or /MTd) of</span>
<a name="l00486"></a>00486 <span class="comment"> * the \c Stxxl library (see above) do not conflict with the options of your project.</span>
<a name="l00487"></a>00487 <span class="comment"> * Use the same options in the \c Stxxl and your project.</span>
<a name="l00488"></a>00488 <span class="comment"> * - Choose Linker-&gt;Command Line page.</span>
<a name="l00489"></a>00489 <span class="comment"> * - In the &#39;Additional Options&#39; field insert the contents of the \c linker.options file.</span>
<a name="l00490"></a>00490 <span class="comment"> *</span>
<a name="l00491"></a>00491 <span class="comment"> * &lt;br&gt;</span>
<a name="l00492"></a>00492 <span class="comment"> * If you use make files you can</span>
<a name="l00493"></a>00493 <span class="comment"> * include the \c make.settings file in your make files and use \c STXXL_COMPILER_OPTIONS and</span>
<a name="l00494"></a>00494 <span class="comment"> * \c STXXL_LINKER_OPTIONS variables, defined therein.</span>
<a name="l00495"></a>00495 <span class="comment"> *</span>
<a name="l00496"></a>00496 <span class="comment"> * For example: &lt;br&gt;</span>
<a name="l00497"></a>00497 <span class="comment"> * \verbatim cl -c my_example.cpp $(STXXL_COMPILER_OPTIONS) \endverbatim &lt;br&gt;</span>
<a name="l00498"></a>00498 <span class="comment"> * \verbatim link my_example.obj /out:my_example.exe $(STXXL_LINKER_OPTIONS) \endverbatim</span>
<a name="l00499"></a>00499 <span class="comment"> *</span>
<a name="l00500"></a>00500 <span class="comment"> * &lt;br&gt;</span>
<a name="l00501"></a>00501 <span class="comment"> * The \c STXXL_ROOT\\test\\WinGUI directory contains an example MFC GUI project</span>
<a name="l00502"></a>00502 <span class="comment"> * that uses \c Stxxl. In order to compile it open the WinGUI.vcproj file in</span>
<a name="l00503"></a>00503 <span class="comment"> * Visual Studio .NET. Change if needed the Compiler and Linker Options of the project</span>
<a name="l00504"></a>00504 <span class="comment"> * (see above).</span>
<a name="l00505"></a>00505 <span class="comment"> *</span>
<a name="l00506"></a>00506 <span class="comment"> * Before you try to run one of the \c S&lt;small&gt;TXXL&lt;/small&gt; examples</span>
<a name="l00507"></a>00507 <span class="comment"> * (or your own \c S&lt;small&gt;TXXL&lt;/small&gt; program) you must configure the disk</span>
<a name="l00508"></a>00508 <span class="comment"> * space that will be used as external memory for the library. For instructions how to do that,</span>
<a name="l00509"></a>00509 <span class="comment"> * see the next section.</span>
<a name="l00510"></a>00510 <span class="comment"> *</span>
<a name="l00511"></a>00511 <span class="comment"> *</span>
<a name="l00512"></a>00512 <span class="comment"> * \section space Disk space</span>
<a name="l00513"></a>00513 <span class="comment"> *</span>
<a name="l00514"></a>00514 <span class="comment"> * To get best performance with \c S&lt;small&gt;TXXL&lt;/small&gt; you should assign separate disks to it.</span>
<a name="l00515"></a>00515 <span class="comment"> * These disks should be used by the library only.</span>
<a name="l00516"></a>00516 <span class="comment"> * Since \c S&lt;small&gt;TXXL&lt;/small&gt; is developed to exploit disk parallelism, the performance of your</span>
<a name="l00517"></a>00517 <span class="comment"> * external memory application will increase if you use more than one disk.</span>
<a name="l00518"></a>00518 <span class="comment"> * But from how many disks your application can benefit depends on how &quot;I/O bound&quot; it is.</span>
<a name="l00519"></a>00519 <span class="comment"> * With modern disk bandwidths</span>
<a name="l00520"></a>00520 <span class="comment"> * of about 50-75 MiB/s most of applications are I/O bound for one disk. This means that if you add another disk</span>
<a name="l00521"></a>00521 <span class="comment"> * the running time will be halved. Adding more disks might also increase performance significantly.</span>
<a name="l00522"></a>00522 <span class="comment"> *</span>
<a name="l00523"></a>00523 <span class="comment"> *</span>
<a name="l00524"></a>00524 <span class="comment"> * \section configuration Disk configuration file</span>
<a name="l00525"></a>00525 <span class="comment"> *</span>
<a name="l00526"></a>00526 <span class="comment"> * You must define the disk configuration for an</span>
<a name="l00527"></a>00527 <span class="comment"> * \c S&lt;small&gt;TXXL&lt;/small&gt; program in a file named \c &#39;.stxxl&#39; that must reside</span>
<a name="l00528"></a>00528 <span class="comment"> * in the same directory where you execute the program.</span>
<a name="l00529"></a>00529 <span class="comment"> * You can change the default file name for the configuration</span>
<a name="l00530"></a>00530 <span class="comment"> * file by setting the environment variable \c STXXLCFG .</span>
<a name="l00531"></a>00531 <span class="comment"> *</span>
<a name="l00532"></a>00532 <span class="comment"> * Each line of the configuration file describes a disk.</span>
<a name="l00533"></a>00533 <span class="comment"> * A disk description uses the following format:&lt;br&gt;</span>
<a name="l00534"></a>00534 <span class="comment"> * \c disk=full_disk_filename,capacity,access_method</span>
<a name="l00535"></a>00535 <span class="comment"> *</span>
<a name="l00536"></a>00536 <span class="comment"> * Description of the parameters:</span>
<a name="l00537"></a>00537 <span class="comment"> * - \c full_disk_filename : full disk filename. In order to access disks S&lt;small&gt;TXXL&lt;/small&gt; uses file</span>
<a name="l00538"></a>00538 <span class="comment"> *   access methods. Each disk is represented as a file. If you have a disk called \c e:</span>
<a name="l00539"></a>00539 <span class="comment"> *   then the correct value for the \c full_disk_filename would be</span>
<a name="l00540"></a>00540 <span class="comment"> *   \c e:\\some_file_name ,</span>
<a name="l00541"></a>00541 <span class="comment"> * - \c capacity : maximum capacity of the disk in megabytes</span>
<a name="l00542"></a>00542 <span class="comment"> * - \c access_method : \c S&lt;small&gt;TXXL&lt;/small&gt; has a number of different</span>
<a name="l00543"></a>00543 <span class="comment"> *   file access implementations for WINDOWS, choose one of them:</span>
<a name="l00544"></a>00544 <span class="comment"> *   - \c syscall : use \c read and \c write POSIX system calls (slow)</span>
<a name="l00545"></a>00545 <span class="comment"> *   - \c wincall: performs disks transfers using \c ReadFile and \c WriteFile WinAPI calls</span>
<a name="l00546"></a>00546 <span class="comment"> *     This method supports direct I/O that avoids superfluous copying of data pages</span>
<a name="l00547"></a>00547 <span class="comment"> *     in the Windows kernel. This is the best (and default) method in Stxxl for Windows.</span>
<a name="l00548"></a>00548 <span class="comment"> *   - \c boostfd : access the file using a Boost file descriptor</span>
<a name="l00549"></a>00549 <span class="comment"> *   - \c fileperblock_syscall, \c fileperblock_wincall, \c fileperblock_boostfd :</span>
<a name="l00550"></a>00550 <span class="comment"> *     same as above, but take a single file per block, using full_disk_filename as file name prefix.</span>
<a name="l00551"></a>00551 <span class="comment"> *     Usually provide worse performance than the standard variants,</span>
<a name="l00552"></a>00552 <span class="comment"> *     but release freed blocks to the file system immediately.</span>
<a name="l00553"></a>00553 <span class="comment"> *   - \c memory : keeps all data in RAM, for quicker testing</span>
<a name="l00554"></a>00554 <span class="comment"> *   - \c wbtl : library-based write-combining (good for writing small blocks onto SSDs),</span>
<a name="l00555"></a>00555 <span class="comment"> *     based on \c syscall</span>
<a name="l00556"></a>00556 <span class="comment"> *</span>
<a name="l00557"></a>00557 <span class="comment"> * See also the example configuration file \c &#39;config_example_win&#39; included in the archive.</span>
<a name="l00558"></a>00558 <span class="comment"> *</span>
<a name="l00559"></a>00559 <span class="comment"> *</span>
<a name="l00560"></a>00560 <span class="comment"> * \section excreation Precreating external memory files</span>
<a name="l00561"></a>00561 <span class="comment"> *</span>
<a name="l00562"></a>00562 <span class="comment"> * In order to get the maximum performance one should precreate disk files described in the configuration file,</span>
<a name="l00563"></a>00563 <span class="comment"> * before running \c S&lt;small&gt;TXXL&lt;/small&gt; applications.</span>
<a name="l00564"></a>00564 <span class="comment"> *</span>
<a name="l00565"></a>00565 <span class="comment"> * The precreation utility is included in the set of \c S&lt;small&gt;TXXL&lt;/small&gt;</span>
<a name="l00566"></a>00566 <span class="comment"> * utilities ( \c utils\\createdisks.exe ). Run this utility</span>
<a name="l00567"></a>00567 <span class="comment"> * for each disk you have defined in the disk configuration file:</span>
<a name="l00568"></a>00568 <span class="comment"> * \verbatim utils\createdisks.exe capacity full_disk_filename... \endverbatim</span>
<a name="l00569"></a>00569 <span class="comment"> *</span>
<a name="l00570"></a>00570 <span class="comment"> * */</span>
<a name="l00571"></a>00571 <span class="comment"></span>
<a name="l00572"></a>00572 <span class="comment">/*!</span>
<a name="l00573"></a>00573 <span class="comment"> * \page install-svn Installing from subversion</span>
<a name="l00574"></a>00574 <span class="comment"> *</span>
<a name="l00575"></a>00575 <span class="comment"> * \section checkout Retrieving the source from subversion</span>
<a name="l00576"></a>00576 <span class="comment"> *</span>
<a name="l00577"></a>00577 <span class="comment"> * The \c S&lt;small&gt;TXXL&lt;/small&gt; source code is available in a subversion repository on sourceforge.net.&lt;br&gt;</span>
<a name="l00578"></a>00578 <span class="comment"> * To learn more about subversion and (command line and graphical) subversion clients</span>
<a name="l00579"></a>00579 <span class="comment"> * visit &lt;a href=&quot;http://subversion.tigris.org/&quot;&gt;http://subversion.tigris.org/&lt;/a&gt;.</span>
<a name="l00580"></a>00580 <span class="comment"> *</span>
<a name="l00581"></a>00581 <span class="comment"> * The main development line (in subversion called the &quot;trunk&quot;) is located at</span>
<a name="l00582"></a>00582 <span class="comment"> * \c https://stxxl.svn.sourceforge.net/svnroot/stxxl/trunk</span>
<a name="l00583"></a>00583 <span class="comment"> * &lt;br&gt;Alternatively you might use a branch where a new feature is being developed.</span>
<a name="l00584"></a>00584 <span class="comment"> * Branches have URLs like</span>
<a name="l00585"></a>00585 <span class="comment"> * \c https://stxxl.svn.sourceforge.net/svnroot/stxxl/branches/foobar</span>
<a name="l00586"></a>00586 <span class="comment"> *</span>
<a name="l00587"></a>00587 <span class="comment"> * For the following example let us assume you want to download the latest trunk version</span>
<a name="l00588"></a>00588 <span class="comment"> * using the command line client and store it in a directory called \c stxxl-trunk</span>
<a name="l00589"></a>00589 <span class="comment"> * (which should not exist, yet).</span>
<a name="l00590"></a>00590 <span class="comment"> * Otherwise replace URL and path to your needs.</span>
<a name="l00591"></a>00591 <span class="comment"> *</span>
<a name="l00592"></a>00592 <span class="comment"> * Run: \verbatim svn checkout https://stxxl.svn.sourceforge.net/svnroot/stxxl/trunk stxxl-trunk \endverbatim</span>
<a name="l00593"></a>00593 <span class="comment"> * Change to stxxl directory: \verbatim cd stxxl-trunk \endverbatim</span>
<a name="l00594"></a>00594 <span class="comment"> *</span>
<a name="l00595"></a>00595 <span class="comment"> * \section svn_continue_installation Continue as Usual</span>
<a name="l00596"></a>00596 <span class="comment"> *</span>
<a name="l00597"></a>00597 <span class="comment"> * Now follow the regular installation and usage instructions,</span>
<a name="l00598"></a>00598 <span class="comment"> * starting from &quot;Library Compilation&quot;:</span>
<a name="l00599"></a>00599 <span class="comment"> * - \ref library_compilation_linux_gcc &quot;Linux/Unix &amp;ndash; g++/icpc/clang++&quot;</span>
<a name="l00600"></a>00600 <span class="comment"> * - \ref library_compilation_msvc &quot;Windows &amp;ndash; Microsoft Visual C++&quot;</span>
<a name="l00601"></a>00601 <span class="comment"> *</span>
<a name="l00602"></a>00602 <span class="comment"> * \section update Updating an existing subversion checkout</span>
<a name="l00603"></a>00603 <span class="comment"> *</span>
<a name="l00604"></a>00604 <span class="comment"> * Once you have checked out the source code you can easily update it to the latest version later on.</span>
<a name="l00605"></a>00605 <span class="comment"> *</span>
<a name="l00606"></a>00606 <span class="comment"> * In the S&lt;small&gt;TXXL&lt;/small&gt; directory, run</span>
<a name="l00607"></a>00607 <span class="comment"> * \verbatim svn update \endverbatim</span>
<a name="l00608"></a>00608 <span class="comment"> * and rebuild.</span>
<a name="l00609"></a>00609 <span class="comment"> * */</span>
<a name="l00610"></a>00610 <span class="comment"></span>
<a name="l00611"></a>00611 <span class="comment">/*!</span>
<a name="l00612"></a>00612 <span class="comment">  </span>
<a name="l00613"></a>00613 <span class="comment">\page intro-stream Introduction to the Stream Package</span>
<a name="l00614"></a>00614 <span class="comment"></span>
<a name="l00615"></a>00615 <span class="comment">\author Timo Bingmann (2012-06-11)</span>
<a name="l00616"></a>00616 <span class="comment"></span>
<a name="l00617"></a>00617 <span class="comment">This page gives a short introduction into the stream package. First the main</span>
<a name="l00618"></a>00618 <span class="comment">abstractions are discussed and then some examples on how to utilize the</span>
<a name="l00619"></a>00619 <span class="comment">existing algorithms are developed.</span>
<a name="l00620"></a>00620 <span class="comment"></span>
<a name="l00621"></a>00621 <span class="comment">All example code can be found in stream/test_intro1.cpp</span>
<a name="l00622"></a>00622 <span class="comment"></span>
<a name="l00623"></a>00623 <span class="comment">\section stream1 Abstraction, Interface and a Simple Example</span>
<a name="l00624"></a>00624 <span class="comment"></span>
<a name="l00625"></a>00625 <span class="comment">The stream package is built around the abstract notion of an object being able</span>
<a name="l00626"></a>00626 <span class="comment">to produce a sequence of output values. Only three simple operations are necessary:</span>
<a name="l00627"></a>00627 <span class="comment">- Retrieval of the current value: prefix * operator</span>
<a name="l00628"></a>00628 <span class="comment">- Advance to the next value in the sequence: prefix ++ operator</span>
<a name="l00629"></a>00629 <span class="comment">- Indication of the sequence&#39;s end: empty() function</span>
<a name="l00630"></a>00630 <span class="comment"></span>
<a name="l00631"></a>00631 <span class="comment">The most common place object that fits easily into this abstraction is the</span>
<a name="l00632"></a>00632 <span class="comment">random generator. Actually, a random generator only requires two operations: it</span>
<a name="l00633"></a>00633 <span class="comment">can be queried for its current value and be instructed to calculate/advance to</span>
<a name="l00634"></a>00634 <span class="comment">new value. Of course the random sequence should be unbounded, so an empty()</span>
<a name="l00635"></a>00635 <span class="comment">function would always be false. Nevertheless, this common-place example</span>
<a name="l00636"></a>00636 <span class="comment">illustrates the purpose of the stream interface pretty well.</span>
<a name="l00637"></a>00637 <span class="comment"></span>
<a name="l00638"></a>00638 <span class="comment">All stream objects must support the three operations above, they form the</span>
<a name="l00639"></a>00639 <span class="comment">stream algorithm concept. In C++ a class conforms to this concept if it</span>
<a name="l00640"></a>00640 <span class="comment">implements the following interface:</span>
<a name="l00641"></a>00641 <span class="comment"></span>
<a name="l00642"></a>00642 <span class="comment">\code</span>
<a name="l00643"></a>00643 <span class="comment">struct stream_object</span>
<a name="l00644"></a>00644 <span class="comment">{</span>
<a name="l00645"></a>00645 <span class="comment">    // Type of the values in the output sequence.</span>
<a name="l00646"></a>00646 <span class="comment">    typedef output_type value_type;</span>
<a name="l00647"></a>00647 <span class="comment"></span>
<a name="l00648"></a>00648 <span class="comment">    // Retrieval prefix * operator (like dereferencing a pointer or iterator).</span>
<a name="l00649"></a>00649 <span class="comment">    const value_type&amp; operator* () const;</span>
<a name="l00650"></a>00650 <span class="comment"></span>
<a name="l00651"></a>00651 <span class="comment">    // Prefix increment ++ operator, which advances the stream to the next value.</span>
<a name="l00652"></a>00652 <span class="comment">    stream_object&amp; operator++ ();</span>
<a name="l00653"></a>00653 <span class="comment"></span>
<a name="l00654"></a>00654 <span class="comment">    // Empty indicator. True if the last ++ operation could not fetch a value.</span>
<a name="l00655"></a>00655 <span class="comment">    bool empty() const;</span>
<a name="l00656"></a>00656 <span class="comment">};</span>
<a name="l00657"></a>00657 <span class="comment">\endcode</span>
<a name="l00658"></a>00658 <span class="comment"></span>
<a name="l00659"></a>00659 <span class="comment">A very simple stream object that produces the sequence 1,2,3,4,....,1000 is shown in the following snippet:</span>
<a name="l00660"></a>00660 <span class="comment"></span>
<a name="l00661"></a>00661 <span class="comment">\code</span>
<a name="l00662"></a>00662 <span class="comment">struct counter_object</span>
<a name="l00663"></a>00663 <span class="comment">{</span>
<a name="l00664"></a>00664 <span class="comment">    // This stream produces a sequence of integers.</span>
<a name="l00665"></a>00665 <span class="comment">    typedef int         value_type;</span>
<a name="l00666"></a>00666 <span class="comment"></span>
<a name="l00667"></a>00667 <span class="comment">private:</span>
<a name="l00668"></a>00668 <span class="comment">    // A class attribute to save the current value.</span>
<a name="l00669"></a>00669 <span class="comment">    int                 m_current_value;</span>
<a name="l00670"></a>00670 <span class="comment"></span>
<a name="l00671"></a>00671 <span class="comment">public:</span>
<a name="l00672"></a>00672 <span class="comment">    // A constructor to set the initial value to 1.</span>
<a name="l00673"></a>00673 <span class="comment">    counter_object()</span>
<a name="l00674"></a>00674 <span class="comment">        : m_current_value(1)</span>
<a name="l00675"></a>00675 <span class="comment">    {</span>
<a name="l00676"></a>00676 <span class="comment">    }</span>
<a name="l00677"></a>00677 <span class="comment"></span>
<a name="l00678"></a>00678 <span class="comment">    // The retrieve operator returning the current value.</span>
<a name="l00679"></a>00679 <span class="comment">    const value_type&amp; operator* () const</span>
<a name="l00680"></a>00680 <span class="comment">    {</span>
<a name="l00681"></a>00681 <span class="comment">        return m_current_value;</span>
<a name="l00682"></a>00682 <span class="comment">    }</span>
<a name="l00683"></a>00683 <span class="comment"></span>
<a name="l00684"></a>00684 <span class="comment">    // Increment operator advancing to the next integer.</span>
<a name="l00685"></a>00685 <span class="comment">    counter_object&amp; operator++ ()</span>
<a name="l00686"></a>00686 <span class="comment">    {</span>
<a name="l00687"></a>00687 <span class="comment">        ++m_current_value;</span>
<a name="l00688"></a>00688 <span class="comment">        return *this;</span>
<a name="l00689"></a>00689 <span class="comment">    }</span>
<a name="l00690"></a>00690 <span class="comment"></span>
<a name="l00691"></a>00691 <span class="comment">    // Empty indicator, which in this case can check the current value.</span>
<a name="l00692"></a>00692 <span class="comment">    bool empty() const</span>
<a name="l00693"></a>00693 <span class="comment">    {</span>
<a name="l00694"></a>00694 <span class="comment">        return (m_current_value &gt; 1000);</span>
<a name="l00695"></a>00695 <span class="comment">    }</span>
<a name="l00696"></a>00696 <span class="comment">};</span>
<a name="l00697"></a>00697 <span class="comment">\endcode</span>
<a name="l00698"></a>00698 <span class="comment"></span>
<a name="l00699"></a>00699 <span class="comment">After this verbose interface definition, the actual iteration over a stream object can be done as follows:</span>
<a name="l00700"></a>00700 <span class="comment"></span>
<a name="l00701"></a>00701 <span class="comment">\code</span>
<a name="l00702"></a>00702 <span class="comment">counter_object counter;</span>
<a name="l00703"></a>00703 <span class="comment"></span>
<a name="l00704"></a>00704 <span class="comment">while (!counter.empty())</span>
<a name="l00705"></a>00705 <span class="comment">{</span>
<a name="l00706"></a>00706 <span class="comment">    std::cout &lt;&lt; *counter &lt;&lt; &quot; &quot;;</span>
<a name="l00707"></a>00707 <span class="comment">    ++counter;</span>
<a name="l00708"></a>00708 <span class="comment">}</span>
<a name="l00709"></a>00709 <span class="comment">std::cout &lt;&lt; std::endl;</span>
<a name="l00710"></a>00710 <span class="comment">\endcode</span>
<a name="l00711"></a>00711 <span class="comment"></span>
<a name="l00712"></a>00712 <span class="comment">For those who like to shorten everything into fewer lines, the above can also be expressed as a for loop:</span>
<a name="l00713"></a>00713 <span class="comment"></span>
<a name="l00714"></a>00714 <span class="comment">\code</span>
<a name="l00715"></a>00715 <span class="comment">for (counter_object cnt; !cnt.empty(); ++cnt)</span>
<a name="l00716"></a>00716 <span class="comment">{</span>
<a name="l00717"></a>00717 <span class="comment">    std::cout &lt;&lt; *cnt &lt;&lt; &quot; &quot;;</span>
<a name="l00718"></a>00718 <span class="comment">}</span>
<a name="l00719"></a>00719 <span class="comment">std::cout &lt;&lt; std::endl;</span>
<a name="l00720"></a>00720 <span class="comment">\endcode</span>
<a name="l00721"></a>00721 <span class="comment"></span>
<a name="l00722"></a>00722 <span class="comment">Both loops will print the following output:</span>
<a name="l00723"></a>00723 <span class="comment">\verbatim</span>
<a name="l00724"></a>00724 <span class="comment">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [...] 995 996 997 998 999 1000 </span>
<a name="l00725"></a>00725 <span class="comment">\endverbatim</span>
<a name="l00726"></a>00726 <span class="comment"></span>
<a name="l00727"></a>00727 <span class="comment">\section stream2 Pipelining: Plugging Stream Objects Together</span>
<a name="l00728"></a>00728 <span class="comment"></span>
<a name="l00729"></a>00729 <span class="comment">The stream interface is so very useful for external memory algorithms because it represents the concept of sequential access to a stream of individual values. While the simple example above only works with integers, the value_type of streams will more often contain complex tuple structs with multiple components.</span>
<a name="l00730"></a>00730 <span class="comment"></span>
<a name="l00731"></a>00731 <span class="comment">A stream algorithm can then be constructed from multiple stream objects that pass data from one to another. This notion of &quot;plugging together&quot; stream objects is used in the following example to calculate the square of each value of an integer sequence:</span>
<a name="l00732"></a>00732 <span class="comment"></span>
<a name="l00733"></a>00733 <span class="comment">\code</span>
<a name="l00734"></a>00734 <span class="comment">template &lt;typename InputStream&gt;</span>
<a name="l00735"></a>00735 <span class="comment">struct squaring_object</span>
<a name="l00736"></a>00736 <span class="comment">{</span>
<a name="l00737"></a>00737 <span class="comment">    // This stream produces a sequence of integers.</span>
<a name="l00738"></a>00738 <span class="comment">    typedef int         value_type;</span>
<a name="l00739"></a>00739 <span class="comment"></span>
<a name="l00740"></a>00740 <span class="comment">private:</span>
<a name="l00741"></a>00741 <span class="comment">    // A reference to another stream of integers, which are our input.</span>
<a name="l00742"></a>00742 <span class="comment">    InputStream&amp;        m_input_stream;</span>
<a name="l00743"></a>00743 <span class="comment"></span>
<a name="l00744"></a>00744 <span class="comment">    // A temporary value buffer to hold the current square for retrieval.</span>
<a name="l00745"></a>00745 <span class="comment">    value_type          m_current_value;</span>
<a name="l00746"></a>00746 <span class="comment"></span>
<a name="l00747"></a>00747 <span class="comment">public:</span>
<a name="l00748"></a>00748 <span class="comment">    // A constructor taking another stream of integers as input.</span>
<a name="l00749"></a>00749 <span class="comment">    squaring_object(InputStream&amp; input_stream)</span>
<a name="l00750"></a>00750 <span class="comment">        : m_input_stream(input_stream)</span>
<a name="l00751"></a>00751 <span class="comment">    {</span>
<a name="l00752"></a>00752 <span class="comment">        if (!m_input_stream.empty())</span>
<a name="l00753"></a>00753 <span class="comment">        {</span>
<a name="l00754"></a>00754 <span class="comment">            m_current_value = *m_input_stream;</span>
<a name="l00755"></a>00755 <span class="comment">            m_current_value = m_current_value * m_current_value;</span>
<a name="l00756"></a>00756 <span class="comment">        }</span>
<a name="l00757"></a>00757 <span class="comment">    }</span>
<a name="l00758"></a>00758 <span class="comment"></span>
<a name="l00759"></a>00759 <span class="comment">    // The retrieve operator returning the square of the input stream.</span>
<a name="l00760"></a>00760 <span class="comment">    const value_type&amp; operator* () const</span>
<a name="l00761"></a>00761 <span class="comment">    {</span>
<a name="l00762"></a>00762 <span class="comment">        return m_current_value;</span>
<a name="l00763"></a>00763 <span class="comment">    }</span>
<a name="l00764"></a>00764 <span class="comment"></span>
<a name="l00765"></a>00765 <span class="comment">    // Increment operator: handled by incrementing the input stream.</span>
<a name="l00766"></a>00766 <span class="comment">    squaring_object&amp; operator++ ()</span>
<a name="l00767"></a>00767 <span class="comment">    {</span>
<a name="l00768"></a>00768 <span class="comment">        ++m_input_stream;</span>
<a name="l00769"></a>00769 <span class="comment">        if (!m_input_stream.empty())</span>
<a name="l00770"></a>00770 <span class="comment">        {</span>
<a name="l00771"></a>00771 <span class="comment">            m_current_value = *m_input_stream;</span>
<a name="l00772"></a>00772 <span class="comment">            m_current_value = m_current_value * m_current_value;</span>
<a name="l00773"></a>00773 <span class="comment">        }</span>
<a name="l00774"></a>00774 <span class="comment">        return *this;</span>
<a name="l00775"></a>00775 <span class="comment">    }</span>
<a name="l00776"></a>00776 <span class="comment"></span>
<a name="l00777"></a>00777 <span class="comment">    // Empty indicator: this stream is empty when the input stream is.</span>
<a name="l00778"></a>00778 <span class="comment">    bool empty() const</span>
<a name="l00779"></a>00779 <span class="comment">    {</span>
<a name="l00780"></a>00780 <span class="comment">        return m_input_stream.empty();</span>
<a name="l00781"></a>00781 <span class="comment">    }</span>
<a name="l00782"></a>00782 <span class="comment">};</span>
<a name="l00783"></a>00783 <span class="comment">\endcode</span>
<a name="l00784"></a>00784 <span class="comment"></span>
<a name="l00785"></a>00785 <span class="comment">For a beginner in stream object programming, the squaring example contains multiple unexpected, verbose complications.</span>
<a name="l00786"></a>00786 <span class="comment"></span>
<a name="l00787"></a>00787 <span class="comment">- We wish to allow many different integer sequences as input streams to the squaring class. For this we use template meta-programming and define squaring to take any class as InputStream template parameter. As yet, in C++ we cannot syntactically define which concepts the template parameters must fulfill, in this case one would require InputStream to implement the stream interface.</span>
<a name="l00788"></a>00788 <span class="comment"></span>
<a name="l00789"></a>00789 <span class="comment">- After defining the input stream class, one will usually need an instantiated object of that class inside the new stream class. Most common practice is to define references to other streams as class attributes, and have the actual objects be passed to the constructor of the new stream object. &lt;br&gt; In the case of the squaring class, any InputStream object is accepted by the constructor and a reference is saved into m_input_stream.</span>
<a name="l00790"></a>00790 <span class="comment"></span>
<a name="l00791"></a>00791 <span class="comment">- As second attribute, the squaring class contains m_current_value. The additional temporary value is required in this case because operator*() must return a const-reference, so the square must actually be stored in a variable after it is calculated. Now note that the squaring operation in this version is implemented at two places: in the constructor and the operator++(). &lt;br&gt; This is necessary, because the stream concept requires that the first value be &lt;em&gt;immediately available after construction&lt;/em&gt;! Therefore it must be calculated in the constructor, and this code is usually a duplicate to the action done in operator++(). A real implementation would probably combine the calculation code into a process() function and also do additional allocation work in the constructor.</span>
<a name="l00792"></a>00792 <span class="comment"></span>
<a name="l00793"></a>00793 <span class="comment">An instance of the counter_object can be plugged into a squaring_object as done in the following example:</span>
<a name="l00794"></a>00794 <span class="comment"></span>
<a name="l00795"></a>00795 <span class="comment">\code</span>
<a name="l00796"></a>00796 <span class="comment">counter_object counter;</span>
<a name="l00797"></a>00797 <span class="comment">squaring_object&lt;counter_object&gt; squares(counter);</span>
<a name="l00798"></a>00798 <span class="comment"></span>
<a name="l00799"></a>00799 <span class="comment">while (!squares.empty())</span>
<a name="l00800"></a>00800 <span class="comment">{</span>
<a name="l00801"></a>00801 <span class="comment">    std::cout &lt;&lt; *squares &lt;&lt; &quot; &quot;;</span>
<a name="l00802"></a>00802 <span class="comment">    ++squares;</span>
<a name="l00803"></a>00803 <span class="comment">}</span>
<a name="l00804"></a>00804 <span class="comment">std::cout &lt;&lt; std::endl;</span>
<a name="l00805"></a>00805 <span class="comment">\endcode</span>
<a name="l00806"></a>00806 <span class="comment"></span>
<a name="l00807"></a>00807 <span class="comment">The example outputs:</span>
<a name="l00808"></a>00808 <span class="comment"></span>
<a name="l00809"></a>00809 <span class="comment">\verbatim</span>
<a name="l00810"></a>00810 <span class="comment">1 4 9 16 25 36 49 64 81 100 121 144 169 [...] 986049 988036 990025 992016 994009 996004 998001 1000000</span>
<a name="l00811"></a>00811 <span class="comment">\endverbatim</span>
<a name="l00812"></a>00812 <span class="comment"></span>
<a name="l00813"></a>00813 <span class="comment">\section stream3 Miscellaneous Utilities Provided by the Stream Package</span>
<a name="l00814"></a>00814 <span class="comment"></span>
<a name="l00815"></a>00815 <span class="comment">The above examples are pure C++ interface manipulations and do not even require stxxl. However, when writing stream algorithms you can take advantage of the utilities provided by the stream package to create complex algorithms. Probably the most useful is the pair of sorting classes, which will be discussed after a few preliminaries.</span>
<a name="l00816"></a>00816 <span class="comment"></span>
<a name="l00817"></a>00817 <span class="comment">More complex algorithms will most often use tuples as values passed from one stream to another. These tuples wrap all information fields of a specific piece of data. Simple tuples can be created using std::pair, tuples with larger number of components can use Boost.Tuple or just plain structs with multiple fields. (In the tuple case, the temporary value inside the stream struct can mostly be avoided.)</span>
<a name="l00818"></a>00818 <span class="comment"></span>
<a name="l00819"></a>00819 <span class="comment">The stream package contains utilities to plug stream classes together to form complex algorithms. The following few examples are very basic algorithms:</span>
<a name="l00820"></a>00820 <span class="comment"></span>
<a name="l00821"></a>00821 <span class="comment">Very often the input to a sequence of stream classes comes from an array or other container. In this case one requires an input stream object, which iterates through the container and outputs each element once. Stxxl provides iterator2stream for this common purpose:</span>
<a name="l00822"></a>00822 <span class="comment">\code</span>
<a name="l00823"></a>00823 <span class="comment">std::vector&lt;int&gt; intvector;</span>
<a name="l00824"></a>00824 <span class="comment">// (fill intvector)</span>
<a name="l00825"></a>00825 <span class="comment"></span>
<a name="l00826"></a>00826 <span class="comment">// define stream class iterating over an integer vector</span>
<a name="l00827"></a>00827 <span class="comment">typedef stxxl::stream::iterator2stream&lt; std::vector&lt;int&gt;::const_iterator &gt; intstream_type;</span>
<a name="l00828"></a>00828 <span class="comment"></span>
<a name="l00829"></a>00829 <span class="comment">// instantiate the stream object, iterate from begin to end of intvector.</span>
<a name="l00830"></a>00830 <span class="comment">intstream_type intstream (intvector.begin(), intvector.end());</span>
<a name="l00831"></a>00831 <span class="comment"></span>
<a name="l00832"></a>00832 <span class="comment">// plug in squaring object after vector iterator stream.</span>
<a name="l00833"></a>00833 <span class="comment">squaring_object&lt;intstream_type&gt; squares(intstream);</span>
<a name="l00834"></a>00834 <span class="comment">\endcode</span>
<a name="l00835"></a>00835 <span class="comment"></span>
<a name="l00836"></a>00836 <span class="comment">Most important: if the input container is a stxxl::vector, then one should use vector_iterator2stream, because this class will prefetch additional blocks from the vector while processing the stream.</span>
<a name="l00837"></a>00837 <span class="comment">\code</span>
<a name="l00838"></a>00838 <span class="comment">stxxl::vector&lt;int&gt; intvector;</span>
<a name="l00839"></a>00839 <span class="comment">// (fill intvector)</span>
<a name="l00840"></a>00840 <span class="comment"></span>
<a name="l00841"></a>00841 <span class="comment">// define stream class iterating over an integer STXXL vector</span>
<a name="l00842"></a>00842 <span class="comment">typedef stxxl::stream::vector_iterator2stream&lt; stxxl::vector&lt;int&gt;::const_iterator &gt; intstream_type;</span>
<a name="l00843"></a>00843 <span class="comment"></span>
<a name="l00844"></a>00844 <span class="comment">// instantiate the stream object, iterate from begin to end of intvector using prefetching</span>
<a name="l00845"></a>00845 <span class="comment">intstream_type intstream (intvector.begin(), intvector.end());</span>
<a name="l00846"></a>00846 <span class="comment"></span>
<a name="l00847"></a>00847 <span class="comment">// plug in squaring object after vector iterator stream.</span>
<a name="l00848"></a>00848 <span class="comment">squaring_object&lt;intstream_type&gt; squares(intstream);</span>
<a name="l00849"></a>00849 <span class="comment">\endcode</span>
<a name="l00850"></a>00850 <span class="comment"></span>
<a name="l00851"></a>00851 <span class="comment">The opposite to iterator2stream is to collect the output of a sequence of stream objects into a container or stxxl vector. This operation is called materialize and also comes in the general version and a special version for the STXXL-vector, which uses asynchronous writes.</span>
<a name="l00852"></a>00852 <span class="comment"></span>
<a name="l00853"></a>00853 <span class="comment">This example shows how to materialize a stream into a usual STL vector.</span>
<a name="l00854"></a>00854 <span class="comment">\code</span>
<a name="l00855"></a>00855 <span class="comment">// construct the squared counter stream</span>
<a name="l00856"></a>00856 <span class="comment">counter_object counter;</span>
<a name="l00857"></a>00857 <span class="comment">squaring_object&lt;counter_object&gt; squares(counter);</span>
<a name="l00858"></a>00858 <span class="comment"></span>
<a name="l00859"></a>00859 <span class="comment">// allocate vector of 100 integers</span>
<a name="l00860"></a>00860 <span class="comment">std::vector&lt;int&gt; intvector (100);</span>
<a name="l00861"></a>00861 <span class="comment"></span>
<a name="l00862"></a>00862 <span class="comment">// materialize 100 integers from stream and put into vector</span>
<a name="l00863"></a>00863 <span class="comment">stxxl::stream::materialize(squares, intvector.begin(), intvector.end());</span>
<a name="l00864"></a>00864 <span class="comment">\endcode</span>
<a name="l00865"></a>00865 <span class="comment"></span>
<a name="l00866"></a>00866 <span class="comment">And the only modification needed to support larger data sets is to materialize to an STXXL vector:</span>
<a name="l00867"></a>00867 <span class="comment">\code</span>
<a name="l00868"></a>00868 <span class="comment">// construct the squared counter stream</span>
<a name="l00869"></a>00869 <span class="comment">counter_object counter;</span>
<a name="l00870"></a>00870 <span class="comment">squaring_object&lt;counter_object&gt; squares(counter);</span>
<a name="l00871"></a>00871 <span class="comment"></span>
<a name="l00872"></a>00872 <span class="comment">// allocate STXXL vector of 100 integers</span>
<a name="l00873"></a>00873 <span class="comment">stxxl::vector&lt;int&gt; intvector (100);</span>
<a name="l00874"></a>00874 <span class="comment"></span>
<a name="l00875"></a>00875 <span class="comment">// materialize 100 integers from stream and put into STXXL vector</span>
<a name="l00876"></a>00876 <span class="comment">stxxl::stream::materialize(squares, intvector.begin(), intvector.end());</span>
<a name="l00877"></a>00877 <span class="comment">\endcode</span>
<a name="l00878"></a>00878 <span class="comment"></span>
<a name="l00879"></a>00879 <span class="comment">\section stream4 Sorting As Provided by the Stream Package</span>
<a name="l00880"></a>00880 <span class="comment"></span>
<a name="l00881"></a>00881 <span class="comment">Maybe the most important set of tools in the stream package is the pairs of sorter classes runs_creator and runs_merger. The general way to sort a sequential input stream is to first consolidate a large number of input items in an internal memory buffer. Then when the buffer is full, it can be sorted in internal memory and subsequently written out to disk. This sorted sequence is then called a run. When the input stream is finished and the sorted output must be produced, theses sorted sequences can efficiently be merged using a tournament tree or similar multi-way comparison structure.</span>
<a name="l00882"></a>00882 <span class="comment"></span>
<a name="l00883"></a>00883 <span class="comment">STXXL implements this using two stream classes: runs_creator and runs_merger.</span>
<a name="l00884"></a>00884 <span class="comment"></span>
<a name="l00885"></a>00885 <span class="comment">The following examples shows how to sort the integer sequence 1,2,...,1000 first by the right-most decimal digit, then by its absolute value (yes a somewhat constructed example, but it serves its purpose well.) For all sorters a comparator object is required which tells the sorter which of two objects is the smaller one. This is similar to the requirements of the usual STL, however, the STXXL sorters need to additional functions: min_value() and max_value() which are used as padding sentinels. These functions return the smallest and highest possible values of the given data type.</span>
<a name="l00886"></a>00886 <span class="comment">\code</span>
<a name="l00887"></a>00887 <span class="comment">// define comparator class: compare right-most decimal and then absolute value</span>
<a name="l00888"></a>00888 <span class="comment">struct CompareMod10</span>
<a name="l00889"></a>00889 <span class="comment">{</span>
<a name="l00890"></a>00890 <span class="comment">    // comparison operator() returning true if (a &lt; b)</span>
<a name="l00891"></a>00891 <span class="comment">    inline bool operator() (int a, int b) const</span>
<a name="l00892"></a>00892 <span class="comment">    {</span>
<a name="l00893"></a>00893 <span class="comment">        if ((a % 10) == (b % 10))</span>
<a name="l00894"></a>00894 <span class="comment">            return a &lt; b;</span>
<a name="l00895"></a>00895 <span class="comment">        else</span>
<a name="l00896"></a>00896 <span class="comment">            return (a % 10) &lt; (b % 10);</span>
<a name="l00897"></a>00897 <span class="comment">    }</span>
<a name="l00898"></a>00898 <span class="comment"></span>
<a name="l00899"></a>00899 <span class="comment">    // smallest possible integer value</span>
<a name="l00900"></a>00900 <span class="comment">    int min_value() const { return INT_MIN; }</span>
<a name="l00901"></a>00901 <span class="comment">    // largest possible integer value</span>
<a name="l00902"></a>00902 <span class="comment">    int max_value() const { return INT_MAX; }</span>
<a name="l00903"></a>00903 <span class="comment">};</span>
<a name="l00904"></a>00904 <span class="comment">\endcode</span>
<a name="l00905"></a>00905 <span class="comment"></span>
<a name="l00906"></a>00906 <span class="comment">All sorters steps require an internal memory buffer. This size can be fixed using a parameter to runs_creator and runs_merger.</span>
<a name="l00907"></a>00907 <span class="comment">The following example code instantiates a counter object, plugs this into a runs_creator which is followed by a runs_merger.</span>
<a name="l00908"></a>00908 <span class="comment"></span>
<a name="l00909"></a>00909 <span class="comment">\code</span>
<a name="l00910"></a>00910 <span class="comment">static const int ram_use = 10*1024*1024;   // amount of memory to use in runs creation</span>
<a name="l00911"></a>00911 <span class="comment"></span>
<a name="l00912"></a>00912 <span class="comment">counter_object  counter;        // the counter stream from first examples</span>
<a name="l00913"></a>00913 <span class="comment"></span>
<a name="l00914"></a>00914 <span class="comment">// define a runs sorter for the counter stream which order by CompareMod10 object.</span>
<a name="l00915"></a>00915 <span class="comment">typedef stxxl::stream::runs_creator&lt;counter_object, CompareMod10&gt; rc_counter_type;</span>
<a name="l00916"></a>00916 <span class="comment"></span>
<a name="l00917"></a>00917 <span class="comment">// instance of CompareMod10 comparator class</span>
<a name="l00918"></a>00918 <span class="comment">CompareMod10    comparemod10;</span>
<a name="l00919"></a>00919 <span class="comment"></span>
<a name="l00920"></a>00920 <span class="comment">// instance of runs_creator which reads the counter stream.</span>
<a name="l00921"></a>00921 <span class="comment">rc_counter_type rc_counter (counter, comparemod10, ram_use);</span>
<a name="l00922"></a>00922 <span class="comment"></span>
<a name="l00923"></a>00923 <span class="comment">// define a runs merger for the sorted runs from rc_counter.</span>
<a name="l00924"></a>00924 <span class="comment">typedef stxxl::stream::runs_merger&lt;rc_counter_type::sorted_runs_type, CompareMod10&gt; rm_counter_type;</span>
<a name="l00925"></a>00925 <span class="comment"></span>
<a name="l00926"></a>00926 <span class="comment">// instance of runs_merger which merges sorted runs from rc_counter.</span>
<a name="l00927"></a>00927 <span class="comment">rm_counter_type rm_counter (rc_counter.result(), comparemod10, ram_use);</span>
<a name="l00928"></a>00928 <span class="comment"></span>
<a name="l00929"></a>00929 <span class="comment">// read sorted stream: runs_merger also conforms to the stream interface.</span>
<a name="l00930"></a>00930 <span class="comment">while (!rm_counter.empty())</span>
<a name="l00931"></a>00931 <span class="comment">{</span>
<a name="l00932"></a>00932 <span class="comment">    std::cout &lt;&lt; *rm_counter &lt;&lt; &quot; &quot;;</span>
<a name="l00933"></a>00933 <span class="comment">    ++rm_counter;</span>
<a name="l00934"></a>00934 <span class="comment">}</span>
<a name="l00935"></a>00935 <span class="comment">std::cout &lt;&lt; std::endl;</span>
<a name="l00936"></a>00936 <span class="comment">\endcode</span>
<a name="l00937"></a>00937 <span class="comment">The output of the code above is:</span>
<a name="l00938"></a>00938 <span class="comment">\verbatim</span>
<a name="l00939"></a>00939 <span class="comment">10 20 30 40 50 60 70 80 [...] 990 1000 1 11 21 31 41 51 61 [...] 909 919 929 939 949 959 969 979 989 999</span>
<a name="l00940"></a>00940 <span class="comment">\endverbatim</span>
<a name="l00941"></a>00941 <span class="comment"></span>
<a name="l00942"></a>00942 <span class="comment">Note that in the above example the input of the runs_creator is itself a stream. If however the data is not naturally available as a stream, one can use a variant of runs_creator which accepts input via a push() function. This is more useful when using an imperative programming style. Note that the runs_merger does not change.</span>
<a name="l00943"></a>00943 <span class="comment">\code</span>
<a name="l00944"></a>00944 <span class="comment">static const int ram_use = 10*1024*1024;   // amount of memory to use in runs creation</span>
<a name="l00945"></a>00945 <span class="comment"></span>
<a name="l00946"></a>00946 <span class="comment">// define a runs sorter which accepts imperative push()s and orders by CompareMod10 object.</span>
<a name="l00947"></a>00947 <span class="comment">typedef stxxl::stream::runs_creator&lt;stxxl::stream::use_push&lt;int&gt;, CompareMod10&gt; rc_counter_type;</span>
<a name="l00948"></a>00948 <span class="comment"></span>
<a name="l00949"></a>00949 <span class="comment">// instance of CompareMod10 comparator class.</span>
<a name="l00950"></a>00950 <span class="comment">CompareMod10    comparemod10;</span>
<a name="l00951"></a>00951 <span class="comment"></span>
<a name="l00952"></a>00952 <span class="comment">// instance of runs_creator which waits for input.</span>
<a name="l00953"></a>00953 <span class="comment">rc_counter_type rc_counter (comparemod10, ram_use);</span>
<a name="l00954"></a>00954 <span class="comment"></span>
<a name="l00955"></a>00955 <span class="comment">// write sequence of integers into runs</span>
<a name="l00956"></a>00956 <span class="comment">for (int i = 1; i &lt;= 1000; ++i)</span>
<a name="l00957"></a>00957 <span class="comment">    rc_counter.push(i);</span>
<a name="l00958"></a>00958 <span class="comment"></span>
<a name="l00959"></a>00959 <span class="comment">// define a runs merger for the sorted runs from rc_counter.</span>
<a name="l00960"></a>00960 <span class="comment">typedef stxxl::stream::runs_merger&lt;rc_counter_type::sorted_runs_type, CompareMod10&gt; rm_counter_type;</span>
<a name="l00961"></a>00961 <span class="comment"></span>
<a name="l00962"></a>00962 <span class="comment">// instance of runs_merger which merges sorted runs from rc_counter.</span>
<a name="l00963"></a>00963 <span class="comment">rm_counter_type rm_counter (rc_counter.result(), comparemod10, ram_use);</span>
<a name="l00964"></a>00964 <span class="comment"></span>
<a name="l00965"></a>00965 <span class="comment">// read sorted stream: runs_merger also conforms to the stream interface.</span>
<a name="l00966"></a>00966 <span class="comment">while (!rm_counter.empty())</span>
<a name="l00967"></a>00967 <span class="comment">{</span>
<a name="l00968"></a>00968 <span class="comment">    std::cout &lt;&lt; *rm_counter &lt;&lt; &quot; &quot;;</span>
<a name="l00969"></a>00969 <span class="comment">    ++rm_counter;</span>
<a name="l00970"></a>00970 <span class="comment">}</span>
<a name="l00971"></a>00971 <span class="comment">std::cout &lt;&lt; std::endl;</span>
<a name="l00972"></a>00972 <span class="comment">\endcode</span>
<a name="l00973"></a>00973 <span class="comment"></span>
<a name="l00974"></a>00974 <span class="comment">And as the last example in this tutorial we show how to use stxxl::sorter, which combines runs_creator and runs_merger into one object. The sorter has two states: input and output. During input, new elements can be sorted using push(). Then to switch to output state, the function sort() is called, after which the sorter can be queried using the usual stream interface.</span>
<a name="l00975"></a>00975 <span class="comment">\code</span>
<a name="l00976"></a>00976 <span class="comment">static const int ram_use = 10*1024*1024;   // amount of memory to use in runs creation</span>
<a name="l00977"></a>00977 <span class="comment"></span>
<a name="l00978"></a>00978 <span class="comment">// define a runs sorter which accepts imperative push()s and orders by CompareMod10 object.</span>
<a name="l00979"></a>00979 <span class="comment">typedef stxxl::sorter&lt;int, CompareMod10&gt; sr_counter_type;</span>
<a name="l00980"></a>00980 <span class="comment"></span>
<a name="l00981"></a>00981 <span class="comment">// instance of CompareMod10 comparator class.</span>
<a name="l00982"></a>00982 <span class="comment">CompareMod10    comparemod10;</span>
<a name="l00983"></a>00983 <span class="comment"></span>
<a name="l00984"></a>00984 <span class="comment">// instance of sorter which waits for input.</span>
<a name="l00985"></a>00985 <span class="comment">sr_counter_type sr_counter (comparemod10, ram_use);</span>
<a name="l00986"></a>00986 <span class="comment"></span>
<a name="l00987"></a>00987 <span class="comment">// write sequence of integers into sorter, which creates sorted runs</span>
<a name="l00988"></a>00988 <span class="comment">for (int i = 1; i &lt;= 1000; ++i)</span>
<a name="l00989"></a>00989 <span class="comment">    sr_counter.push(i);</span>
<a name="l00990"></a>00990 <span class="comment"></span>
<a name="l00991"></a>00991 <span class="comment">// signal sorter that the input stream is finished and switch to output mode.</span>
<a name="l00992"></a>00992 <span class="comment">sr_counter.sort();</span>
<a name="l00993"></a>00993 <span class="comment"></span>
<a name="l00994"></a>00994 <span class="comment">// read sorted stream: sorter also conforms to the stream interface.</span>
<a name="l00995"></a>00995 <span class="comment">while (!sr_counter.empty())</span>
<a name="l00996"></a>00996 <span class="comment">{</span>
<a name="l00997"></a>00997 <span class="comment">    std::cout &lt;&lt; *sr_counter &lt;&lt; &quot; &quot;;</span>
<a name="l00998"></a>00998 <span class="comment">    ++sr_counter;</span>
<a name="l00999"></a>00999 <span class="comment">}</span>
<a name="l01000"></a>01000 <span class="comment">std::cout &lt;&lt; std::endl;</span>
<a name="l01001"></a>01001 <span class="comment">\endcode</span>
<a name="l01002"></a>01002 <span class="comment"></span>
<a name="l01003"></a>01003 <span class="comment">All three examples have the same output.</span>
<a name="l01004"></a>01004 <span class="comment"></span>
<a name="l01005"></a>01005 <span class="comment"> */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
