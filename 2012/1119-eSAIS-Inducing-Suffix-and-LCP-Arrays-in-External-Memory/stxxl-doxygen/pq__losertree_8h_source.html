<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Stxxl: include/stxxl/bits/containers/pq_losertree.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stxxl
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">include/stxxl/bits/containers/pq_losertree.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="pq__losertree_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *  include/stxxl/bits/containers/pq_losertree.h</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  Part of the STXXL. See http://stxxl.sourceforge.net</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *  Copyright (C) 1999 Peter Sanders &lt;sanders@mpi-sb.mpg.de&gt;</span>
<a name="l00007"></a>00007 <span class="comment"> *  Copyright (C) 2003, 2004, 2007 Roman Dementiev &lt;dementiev@mpi-sb.mpg.de&gt;</span>
<a name="l00008"></a>00008 <span class="comment"> *  Copyright (C) 2007-2009 Johannes Singler &lt;singler@ira.uka.de&gt;</span>
<a name="l00009"></a>00009 <span class="comment"> *  Copyright (C) 2007, 2008 Andreas Beckmann &lt;beckmann@cs.uni-frankfurt.de&gt;</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> *  Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00012"></a>00012 <span class="comment"> *  (See accompanying file LICENSE_1_0.txt or copy at</span>
<a name="l00013"></a>00013 <span class="comment"> *  http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00014"></a>00014 <span class="comment"> **************************************************************************/</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#ifndef STXXL_PQ_LOSERTREE_HEADER</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_PQ_LOSERTREE_HEADER</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span>
<a name="l00019"></a>00019 __STXXL_BEGIN_NAMESPACE
<a name="l00020"></a>00020 <span class="comment"></span>
<a name="l00021"></a>00021 <span class="comment">//! \addtogroup stlcontinternals</span>
<a name="l00022"></a>00022 <span class="comment">//!</span>
<a name="l00023"></a>00023 <span class="comment">//! \{</span>
<a name="l00024"></a>00024 <span class="comment"></span><span class="comment"></span>
<a name="l00025"></a>00025 <span class="comment">/*! \internal</span>
<a name="l00026"></a>00026 <span class="comment"> */</span>
<a name="l00027"></a>00027 <span class="keyword">namespace </span>priority_queue_local
<a name="l00028"></a>00028 {<span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">//////////////////////////////////////////////////////////////////////</span>
<a name="l00030"></a>00030 <span class="comment"></span><span class="comment">// The data structure from Knuth, &quot;Sorting and Searching&quot;, Section 5.4.1</span><span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">    /**</span>
<a name="l00032"></a>00032 <span class="comment">     *!  \brief  Loser tree from Knuth, &quot;Sorting and Searching&quot;, Section 5.4.1</span>
<a name="l00033"></a>00033 <span class="comment">     *!  \param  KNKMAX  maximum arity of loser tree, has to be a power of two</span>
<a name="l00034"></a>00034 <span class="comment">     */</span>
<a name="l00035"></a>00035     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00036"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html">00036</a>     <span class="keyword">class </span><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &quot;Sorting and Searching&quot;, Section 5.4.1 !">loser_tree</a> : <span class="keyword">private</span> <a class="code" href="classnoncopyable.html">noncopyable</a>
<a name="l00037"></a>00037     {
<a name="l00038"></a>00038     <span class="keyword">public</span>:
<a name="l00039"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a18d3d69d1b0af6359673aac8ec627237">00039</a>         <span class="keyword">typedef</span> ValTp_ <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a18d3d69d1b0af6359673aac8ec627237">value_type</a>;
<a name="l00040"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a2749fcb86aa9c2c0f917e71ddb5a051d">00040</a>         <span class="keyword">typedef</span> Cmp_ <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a2749fcb86aa9c2c0f917e71ddb5a051d">comparator_type</a>;
<a name="l00041"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ad4c2c182a6aade29436da74c403de32a">00041</a>         <span class="keyword">typedef</span> <a class="code" href="test__push__sort_8cpp.html#ab13c28f7d568dcb8636b7a10c0a609a1">value_type</a> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ad4c2c182a6aade29436da74c403de32a">Element</a>;
<a name="l00042"></a>00042 
<a name="l00043"></a>00043     <span class="keyword">private</span>:
<a name="l00044"></a>00044 <span class="preprocessor">#if STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>        <span class="keyword">struct </span>Entry
<a name="l00046"></a>00046         {
<a name="l00047"></a>00047             <a class="code" href="test__push__sort_8cpp.html#ab13c28f7d568dcb8636b7a10c0a609a1">value_type</a> key;      <span class="comment">// Key of Loser element (winner for 0)</span>
<a name="l00048"></a>00048             <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> index; <span class="comment">// number of losing segment</span>
<a name="l00049"></a>00049         };
<a name="l00050"></a>00050 <span class="preprocessor">#endif //STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#af4ca117d7cff7a29459696983748d531">00052</a>         <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a2749fcb86aa9c2c0f917e71ddb5a051d">comparator_type</a> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#af4ca117d7cff7a29459696983748d531">cmp</a>;
<a name="l00053"></a>00053         <span class="comment">// stack of free segment indices</span>
<a name="l00054"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a49e850920a30672684331111b489c75d">00054</a>         <a class="code" href="classstxxl_1_1priority__queue__local_1_1internal__bounded__stack.html">internal_bounded_stack&lt;unsigned_type, KNKMAX&gt;</a> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a49e850920a30672684331111b489c75d">free_slots</a>;
<a name="l00055"></a>00055 
<a name="l00056"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ae7b9b6eb78d733b640ba7dde546ed758">00056</a>         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ae7b9b6eb78d733b640ba7dde546ed758">size_</a>; <span class="comment">// total number of elements stored</span>
<a name="l00057"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ad6fd8693c63101a05bcf11251d1fbfdd">00057</a>         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ad6fd8693c63101a05bcf11251d1fbfdd">logK</a>;  <span class="comment">// log of current tree size</span>
<a name="l00058"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a3b579ac18dcc2841e6cc421aa861c5d4">00058</a>         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a3b579ac18dcc2841e6cc421aa861c5d4">k</a>;     <span class="comment">// invariant (k == 1 &lt;&lt; logK), always a power of two</span>
<a name="l00059"></a>00059 
<a name="l00060"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ab46516a27997081f1dbc9a6a523fc60d">00060</a>         Element <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ab46516a27997081f1dbc9a6a523fc60d">sentinel</a>;    <span class="comment">// target of free segment pointers</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="preprocessor">#if STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>        <span class="comment">// upper levels of loser trees</span>
<a name="l00064"></a>00064         <span class="comment">// entry[0] contains the winner info</span>
<a name="l00065"></a>00065         Entry entry[KNKMAX];
<a name="l00066"></a>00066 <span class="preprocessor">#endif  //STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>
<a name="l00068"></a>00068         <span class="comment">// leaf information</span>
<a name="l00069"></a>00069         <span class="comment">// note that Knuth uses indices k..k-1</span>
<a name="l00070"></a>00070         <span class="comment">// while we use 0..k-1</span>
<a name="l00071"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a49f74353e496447454e07a5102355322">00071</a>         Element * current[KNKMAX];          <span class="comment">// pointer to current element</span>
<a name="l00072"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a5610bd850ab09fe23a92adcfc18b2971">00072</a>         Element * current_end[KNKMAX];      <span class="comment">// pointer to end of block for current element</span>
<a name="l00073"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ac7eb76ccf58934592007fd2bf508ef7d">00073</a>         Element * segment[KNKMAX];          <span class="comment">// start of Segments</span>
<a name="l00074"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a808908a2e0783b14d7531f7c77e61749">00074</a>         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> segment_size[KNKMAX]; <span class="comment">// just to count the internal memory consumption, in bytes</span>
<a name="l00075"></a>00075 
<a name="l00076"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a38f4b899fc18382612826401de6df6e1">00076</a>         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a38f4b899fc18382612826401de6df6e1">mem_cons_</a>;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078         <span class="comment">// private member functions</span>
<a name="l00079"></a>00079         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> initWinner(<a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> root);
<a name="l00080"></a>00080         <span class="keywordtype">void</span> update_on_insert(<a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> node, <span class="keyword">const</span> Element &amp; newKey, <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> newIndex,
<a name="l00081"></a>00081                               Element * winnerKey, <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> * winnerIndex, <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> * mask);
<a name="l00082"></a>00082         <span class="keywordtype">void</span> deallocate_segment(<a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> slot);
<a name="l00083"></a>00083         <span class="keywordtype">void</span> doubleK();
<a name="l00084"></a>00084         <span class="keywordtype">void</span> compactTree();
<a name="l00085"></a>00085         <span class="keywordtype">void</span> rebuildLoserTree();
<a name="l00086"></a>00086         <span class="keywordtype">bool</span> is_segment_empty(<a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> slot);
<a name="l00087"></a>00087         <span class="keywordtype">void</span> multi_merge_k(Element * target, <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> length);
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="preprocessor">#if STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span>        <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> LogK&gt;
<a name="l00091"></a>00091         <span class="keywordtype">void</span> multi_merge_f(Element * target, <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> length)
<a name="l00092"></a>00092         {
<a name="l00093"></a>00093             <span class="comment">//Entry *currentPos;</span>
<a name="l00094"></a>00094             <span class="comment">//Element currentKey;</span>
<a name="l00095"></a>00095             <span class="comment">//int currentIndex; // leaf pointed to by current entry</span>
<a name="l00096"></a>00096             Element * done = target + length;
<a name="l00097"></a>00097             Entry * regEntry = entry;
<a name="l00098"></a>00098             Element ** regStates = current;
<a name="l00099"></a>00099             <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> winnerIndex = regEntry[0].index;
<a name="l00100"></a>00100             Element winnerKey = regEntry[0].key;
<a name="l00101"></a>00101             Element * winnerPos;
<a name="l00102"></a>00102             <span class="comment">//Element sup = sentinel; // supremum</span>
<a name="l00103"></a>00103 
<a name="l00104"></a>00104             assert(logK &gt;= LogK);
<a name="l00105"></a>00105             <span class="keywordflow">while</span> (target != done)
<a name="l00106"></a>00106             {
<a name="l00107"></a>00107                 winnerPos = regStates[winnerIndex];
<a name="l00108"></a>00108 
<a name="l00109"></a>00109                 <span class="comment">// write result</span>
<a name="l00110"></a>00110                 *target = winnerKey;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112                 <span class="comment">// advance winner segment</span>
<a name="l00113"></a>00113                 ++winnerPos;
<a name="l00114"></a>00114                 regStates[winnerIndex] = winnerPos;
<a name="l00115"></a>00115                 winnerKey = *winnerPos;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117                 <span class="comment">// remove winner segment if empty now</span>
<a name="l00118"></a>00118                 <span class="keywordflow">if</span> (is_sentinel(winnerKey))
<a name="l00119"></a>00119                 {
<a name="l00120"></a>00120                     deallocate_segment(winnerIndex);
<a name="l00121"></a>00121                 }
<a name="l00122"></a>00122                 ++target;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124                 <span class="comment">// update loser tree</span>
<a name="l00125"></a>00125 <span class="preprocessor">#define TreeStep(L) \</span>
<a name="l00126"></a>00126 <span class="preprocessor">    if (1 &lt;&lt; LogK &gt;= 1 &lt;&lt; L) { \</span>
<a name="l00127"></a>00127 <span class="preprocessor">        Entry * pos ## L = regEntry + ((winnerIndex + (1 &lt;&lt; LogK)) &gt;&gt; (((int(LogK - L) + 1) &gt;= 0) ? ((LogK - L) + 1) : 0)); \</span>
<a name="l00128"></a>00128 <span class="preprocessor">        Element key ## L = pos ## L-&gt;key; \</span>
<a name="l00129"></a>00129 <span class="preprocessor">        if (cmp(winnerKey, key ## L)) { \</span>
<a name="l00130"></a>00130 <span class="preprocessor">            unsigned_type index ## L = pos ## L-&gt;index; \</span>
<a name="l00131"></a>00131 <span class="preprocessor">            pos ## L-&gt;key = winnerKey; \</span>
<a name="l00132"></a>00132 <span class="preprocessor">            pos ## L-&gt;index = winnerIndex; \</span>
<a name="l00133"></a>00133 <span class="preprocessor">            winnerKey = key ## L; \</span>
<a name="l00134"></a>00134 <span class="preprocessor">            winnerIndex = index ## L; \</span>
<a name="l00135"></a>00135 <span class="preprocessor">        } \</span>
<a name="l00136"></a>00136 <span class="preprocessor">    }</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span>                <a class="code" href="losertree_8h.html#a5e1b7a0efa28ce64aa3d35ef131016f8">TreeStep</a>(10);
<a name="l00138"></a>00138                 <a class="code" href="losertree_8h.html#a5e1b7a0efa28ce64aa3d35ef131016f8">TreeStep</a>(9);
<a name="l00139"></a>00139                 <a class="code" href="losertree_8h.html#a5e1b7a0efa28ce64aa3d35ef131016f8">TreeStep</a>(8);
<a name="l00140"></a>00140                 <a class="code" href="losertree_8h.html#a5e1b7a0efa28ce64aa3d35ef131016f8">TreeStep</a>(7);
<a name="l00141"></a>00141                 <a class="code" href="losertree_8h.html#a5e1b7a0efa28ce64aa3d35ef131016f8">TreeStep</a>(6);
<a name="l00142"></a>00142                 <a class="code" href="losertree_8h.html#a5e1b7a0efa28ce64aa3d35ef131016f8">TreeStep</a>(5);
<a name="l00143"></a>00143                 <a class="code" href="losertree_8h.html#a5e1b7a0efa28ce64aa3d35ef131016f8">TreeStep</a>(4);
<a name="l00144"></a>00144                 <a class="code" href="losertree_8h.html#a5e1b7a0efa28ce64aa3d35ef131016f8">TreeStep</a>(3);
<a name="l00145"></a>00145                 <a class="code" href="losertree_8h.html#a5e1b7a0efa28ce64aa3d35ef131016f8">TreeStep</a>(2);
<a name="l00146"></a>00146                 <a class="code" href="losertree_8h.html#a5e1b7a0efa28ce64aa3d35ef131016f8">TreeStep</a>(1);
<a name="l00147"></a>00147 <span class="preprocessor">#undef TreeStep</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span>            }
<a name="l00149"></a>00149             regEntry[0].index = winnerIndex;
<a name="l00150"></a>00150             regEntry[0].key = winnerKey;
<a name="l00151"></a>00151         }
<a name="l00152"></a>00152 <span class="preprocessor">#endif  //STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span>
<a name="l00154"></a>00154     <span class="keyword">public</span>:
<a name="l00155"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a2c998ed3e5c44b5abe5331201fdb725d">00155</a>         <span class="keywordtype">bool</span> is_sentinel(<span class="keyword">const</span> Element &amp; a)
<a name="l00156"></a>00156         {
<a name="l00157"></a>00157             <span class="keywordflow">return</span> !(<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>(<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>.min_value(), a));
<a name="l00158"></a>00158         }
<a name="l00159"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a586432821358523d17b29976658162fe">00159</a>         <span class="keywordtype">bool</span> not_sentinel(<span class="keyword">const</span> Element &amp; a)
<a name="l00160"></a>00160         {
<a name="l00161"></a>00161             <span class="keywordflow">return</span> <a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>(<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>.min_value(), a);
<a name="l00162"></a>00162         }
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="keyword">public</span>:
<a name="l00165"></a>00165         <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &quot;Sorting and Searching&quot;, Section 5.4.1 !">loser_tree</a>();
<a name="l00166"></a>00166         ~<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &quot;Sorting and Searching&quot;, Section 5.4.1 !">loser_tree</a>();
<a name="l00167"></a>00167         <span class="keywordtype">void</span> <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>();
<a name="l00168"></a>00168 
<a name="l00169"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ac100722f5190c8b88fb119a117a7314b">00169</a>         <span class="keywordtype">void</span> <a class="code" href="namespacestd.html#abc5bd04888275546472a3a5b813fe030">swap</a>(<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &quot;Sorting and Searching&quot;, Section 5.4.1 !">loser_tree</a> &amp; obj)
<a name="l00170"></a>00170         {
<a name="l00171"></a>00171             <a class="code" href="namespacestd.html#abc5bd04888275546472a3a5b813fe030">std::swap</a>(<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>, obj.<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#af4ca117d7cff7a29459696983748d531">cmp</a>);
<a name="l00172"></a>00172             <a class="code" href="namespacestd.html#abc5bd04888275546472a3a5b813fe030">std::swap</a>(free_slots, obj.<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a49e850920a30672684331111b489c75d">free_slots</a>);
<a name="l00173"></a>00173             <a class="code" href="namespacestd.html#abc5bd04888275546472a3a5b813fe030">std::swap</a>(size_, obj.<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ae7b9b6eb78d733b640ba7dde546ed758">size_</a>);
<a name="l00174"></a>00174             <a class="code" href="namespacestd.html#abc5bd04888275546472a3a5b813fe030">std::swap</a>(logK, obj.<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ad6fd8693c63101a05bcf11251d1fbfdd">logK</a>);
<a name="l00175"></a>00175             <a class="code" href="namespacestd.html#abc5bd04888275546472a3a5b813fe030">std::swap</a>(k, obj.<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a3b579ac18dcc2841e6cc421aa861c5d4">k</a>);
<a name="l00176"></a>00176             <a class="code" href="namespacestd.html#abc5bd04888275546472a3a5b813fe030">std::swap</a>(sentinel, obj.<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ab46516a27997081f1dbc9a6a523fc60d">sentinel</a>);
<a name="l00177"></a>00177 <span class="preprocessor">#if STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span>            <a class="code" href="namespacestxxl.html#afd3bad550fcb63fb35586590e8e96795">swap_1D_arrays</a>(entry, obj.entry, KNKMAX);
<a name="l00179"></a>00179 <span class="preprocessor">#endif      //STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span>            <a class="code" href="namespacestxxl.html#afd3bad550fcb63fb35586590e8e96795">swap_1D_arrays</a>(current, obj.<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a49f74353e496447454e07a5102355322">current</a>, KNKMAX);
<a name="l00181"></a>00181             <a class="code" href="namespacestxxl.html#afd3bad550fcb63fb35586590e8e96795">swap_1D_arrays</a>(current_end, obj.<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a5610bd850ab09fe23a92adcfc18b2971">current_end</a>, KNKMAX);
<a name="l00182"></a>00182             <a class="code" href="namespacestxxl.html#afd3bad550fcb63fb35586590e8e96795">swap_1D_arrays</a>(segment, obj.<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ac7eb76ccf58934592007fd2bf508ef7d">segment</a>, KNKMAX);
<a name="l00183"></a>00183             <a class="code" href="namespacestxxl.html#afd3bad550fcb63fb35586590e8e96795">swap_1D_arrays</a>(segment_size, obj.<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a808908a2e0783b14d7531f7c77e61749">segment_size</a>, KNKMAX);
<a name="l00184"></a>00184             <a class="code" href="namespacestd.html#abc5bd04888275546472a3a5b813fe030">std::swap</a>(mem_cons_, obj.<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a38f4b899fc18382612826401de6df6e1">mem_cons_</a>);
<a name="l00185"></a>00185         }
<a name="l00186"></a>00186 
<a name="l00187"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ae34c17d85595172f5f29f20afccef3a5">00187</a>         <span class="keywordtype">void</span> multi_merge(Element * begin, Element * end)
<a name="l00188"></a>00188         {
<a name="l00189"></a>00189             multi_merge(begin, end - begin);
<a name="l00190"></a>00190         }
<a name="l00191"></a>00191         <span class="keywordtype">void</span> multi_merge(Element *, <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> length);
<a name="l00192"></a>00192 
<a name="l00193"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ad2898f7f4beec65861ea3372c2f6a3b4">00193</a>         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ad2898f7f4beec65861ea3372c2f6a3b4">mem_cons</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mem_cons_; }
<a name="l00194"></a>00194 
<a name="l00195"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a980ea9b65de2af1f007619ea641a2a22">00195</a>         <span class="keywordtype">bool</span> is_space_available() const <span class="comment">// for new segment</span>
<a name="l00196"></a>00196         {
<a name="l00197"></a>00197             <span class="keywordflow">return</span> (k &lt; KNKMAX) || !free_slots.empty();
<a name="l00198"></a>00198         }
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         <span class="keywordtype">void</span> insert_segment(Element * target, <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> length); <span class="comment">// insert segment beginning at target</span>
<a name="l00201"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a15beee7108d07b5d022442f2c6b4e2fc">00201</a>         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a15beee7108d07b5d022442f2c6b4e2fc">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_; }
<a name="l00202"></a>00202     };
<a name="l00203"></a>00203 <span class="comment"></span>
<a name="l00204"></a>00204 <span class="comment">///////////////////////// LoserTree ///////////////////////////////////</span>
<a name="l00205"></a>00205 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00206"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a595cc359c62ad7662bc816f52ee26f3a">00206</a>     <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html" title="Loser tree from Knuth, &quot;Sorting and Searching&quot;, Section 5.4.1 !">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::loser_tree</a>() : size_(0), logK(0), k(1), mem_cons_(0)
<a name="l00207"></a>00207     {
<a name="l00208"></a>00208         <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a49e850920a30672684331111b489c75d">free_slots</a>.<a class="code" href="classstxxl_1_1priority__queue__local_1_1internal__bounded__stack.html#ac0a231b4f350fab02a9d8c8aad601536">push</a>(0);
<a name="l00209"></a>00209         <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ac7eb76ccf58934592007fd2bf508ef7d">segment</a>[0] = NULL;
<a name="l00210"></a>00210         <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a49f74353e496447454e07a5102355322">current</a>[0] = &amp;<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ab46516a27997081f1dbc9a6a523fc60d">sentinel</a>;
<a name="l00211"></a>00211         <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a5610bd850ab09fe23a92adcfc18b2971">current_end</a>[0] = &amp;<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ab46516a27997081f1dbc9a6a523fc60d">sentinel</a>;
<a name="l00212"></a>00212         <span class="comment">// entry and sentinel are initialized by init</span>
<a name="l00213"></a>00213         <span class="comment">// since they need the value of supremum</span>
<a name="l00214"></a>00214         <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#acc1b57034ccd4241ee8a829ad221aa29">init</a>();
<a name="l00215"></a>00215     }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00218"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#acc1b57034ccd4241ee8a829ad221aa29">00218</a>     <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#acc1b57034ccd4241ee8a829ad221aa29">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::init</a>()
<a name="l00219"></a>00219     {
<a name="l00220"></a>00220         assert(!<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>(<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>.min_value(), <a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>.min_value())); <span class="comment">// verify strict weak ordering</span>
<a name="l00221"></a>00221         sentinel = <a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>.min_value();
<a name="l00222"></a>00222         rebuildLoserTree();
<a name="l00223"></a>00223 <span class="preprocessor">#if STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00224"></a>00224 <span class="preprocessor"></span>        assert(current[entry[0].index] == &amp;sentinel);
<a name="l00225"></a>00225 <span class="preprocessor">#endif  //STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00226"></a>00226 <span class="preprocessor"></span>    }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="comment">// rebuild loser tree information from the values in current</span>
<a name="l00230"></a>00230     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00231"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ae48a8db81642a22779279826680cd7c9">00231</a>     <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ae48a8db81642a22779279826680cd7c9">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::rebuildLoserTree</a>()
<a name="l00232"></a>00232     {
<a name="l00233"></a>00233 <span class="preprocessor">#if STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span>        assert(<a class="code" href="classstxxl_1_1LOG2.html">LOG2&lt;KNKMAX&gt;::floor</a> == <a class="code" href="classstxxl_1_1LOG2.html">LOG2&lt;KNKMAX&gt;::ceil</a>); <span class="comment">// KNKMAX needs to be a power of two</span>
<a name="l00235"></a>00235         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> winner = initWinner(1);
<a name="l00236"></a>00236         entry[0].index = winner;
<a name="l00237"></a>00237         entry[0].key = *(current[winner]);
<a name="l00238"></a>00238 <span class="preprocessor">#endif //STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span>    }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <span class="preprocessor">#if STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00243"></a>00243 <span class="preprocessor"></span><span class="comment">// given any values in the leaves this</span>
<a name="l00244"></a>00244 <span class="comment">// routing recomputes upper levels of the tree</span>
<a name="l00245"></a>00245 <span class="comment">// from scratch in linear time</span>
<a name="l00246"></a>00246 <span class="comment">// initialize entry[root].index and the subtree rooted there</span>
<a name="l00247"></a>00247 <span class="comment">// return winner index</span>
<a name="l00248"></a>00248     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00249"></a>00249     <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a01f8ae94edbb538105911617a1a6835e">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::initWinner</a>(<a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> root)
<a name="l00250"></a>00250     {
<a name="l00251"></a>00251         <span class="keywordflow">if</span> (root &gt;= k) { <span class="comment">// leaf reached</span>
<a name="l00252"></a>00252             <span class="keywordflow">return</span> root - k;
<a name="l00253"></a>00253         } <span class="keywordflow">else</span> {
<a name="l00254"></a>00254             <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> left = initWinner(2 * root);
<a name="l00255"></a>00255             <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> right = initWinner(2 * root + 1);
<a name="l00256"></a>00256             Element lk = *(current[left]);
<a name="l00257"></a>00257             Element rk = *(current[right]);
<a name="l00258"></a>00258             <span class="keywordflow">if</span> (!(<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>(lk, rk))) { <span class="comment">// right subtree loses</span>
<a name="l00259"></a>00259                 entry[root].index = right;
<a name="l00260"></a>00260                 entry[root].key = rk;
<a name="l00261"></a>00261                 <span class="keywordflow">return</span> left;
<a name="l00262"></a>00262             } <span class="keywordflow">else</span> {
<a name="l00263"></a>00263                 entry[root].index = left;
<a name="l00264"></a>00264                 entry[root].key = lk;
<a name="l00265"></a>00265                 <span class="keywordflow">return</span> right;
<a name="l00266"></a>00266             }
<a name="l00267"></a>00267         }
<a name="l00268"></a>00268     }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="comment">// first go up the tree all the way to the root</span>
<a name="l00272"></a>00272 <span class="comment">// hand down old winner for the respective subtree</span>
<a name="l00273"></a>00273 <span class="comment">// based on new value, and old winner and loser</span>
<a name="l00274"></a>00274 <span class="comment">// update each node on the path to the root top down.</span>
<a name="l00275"></a>00275 <span class="comment">// This is implemented recursively</span>
<a name="l00276"></a>00276     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00277"></a>00277     <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a2482a4c0c43512a561143fa3cc59e5d6">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::update_on_insert</a>(
<a name="l00278"></a>00278         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> node,
<a name="l00279"></a>00279         <span class="keyword">const</span> Element &amp; newKey,
<a name="l00280"></a>00280         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> newIndex,
<a name="l00281"></a>00281         Element * winnerKey,
<a name="l00282"></a>00282         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> * winnerIndex,       <span class="comment">// old winner</span>
<a name="l00283"></a>00283         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> * mask)              <span class="comment">// 1 &lt;&lt; (ceil(log KNK) - dist-from-root)</span>
<a name="l00284"></a>00284     {
<a name="l00285"></a>00285         <span class="keywordflow">if</span> (node == 0) {                   <span class="comment">// winner part of root</span>
<a name="l00286"></a>00286             *mask = 1 &lt;&lt; (logK - 1);
<a name="l00287"></a>00287             *winnerKey = entry[0].key;
<a name="l00288"></a>00288             *winnerIndex = entry[0].index;
<a name="l00289"></a>00289             <span class="keywordflow">if</span> (<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>(entry[node].key, newKey))
<a name="l00290"></a>00290             {
<a name="l00291"></a>00291                 entry[node].key = newKey;
<a name="l00292"></a>00292                 entry[node].index = newIndex;
<a name="l00293"></a>00293             }
<a name="l00294"></a>00294         } <span class="keywordflow">else</span> {
<a name="l00295"></a>00295             update_on_insert(node &gt;&gt; 1, newKey, newIndex, winnerKey, winnerIndex, mask);
<a name="l00296"></a>00296             Element loserKey = entry[node].key;
<a name="l00297"></a>00297             <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> loserIndex = entry[node].index;
<a name="l00298"></a>00298             <span class="keywordflow">if</span> ((*winnerIndex &amp; *mask) != (newIndex &amp; *mask)) { <span class="comment">// different subtrees</span>
<a name="l00299"></a>00299                 <span class="keywordflow">if</span> (<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>(loserKey, newKey)) {                    <span class="comment">// newKey will have influence here</span>
<a name="l00300"></a>00300                     <span class="keywordflow">if</span> (<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>(*winnerKey, newKey)) {              <span class="comment">// old winner loses here</span>
<a name="l00301"></a>00301                         entry[node].key = *winnerKey;
<a name="l00302"></a>00302                         entry[node].index = *winnerIndex;
<a name="l00303"></a>00303                     } <span class="keywordflow">else</span> {                                    <span class="comment">// new entry loses here</span>
<a name="l00304"></a>00304                         entry[node].key = newKey;
<a name="l00305"></a>00305                         entry[node].index = newIndex;
<a name="l00306"></a>00306                     }
<a name="l00307"></a>00307                 }
<a name="l00308"></a>00308                 *winnerKey = loserKey;
<a name="l00309"></a>00309                 *winnerIndex = loserIndex;
<a name="l00310"></a>00310             }
<a name="l00311"></a>00311             <span class="comment">// note that nothing needs to be done if</span>
<a name="l00312"></a>00312             <span class="comment">// the winner came from the same subtree</span>
<a name="l00313"></a>00313             <span class="comment">// a) newKey &lt;= winnerKey =&gt; even more reason for the other tree to lose</span>
<a name="l00314"></a>00314             <span class="comment">// b) newKey &gt;  winnerKey =&gt; the old winner will beat the new</span>
<a name="l00315"></a>00315             <span class="comment">//                           entry further down the tree</span>
<a name="l00316"></a>00316             <span class="comment">// also the same old winner is handed down the tree</span>
<a name="l00317"></a>00317 
<a name="l00318"></a>00318             *mask &gt;&gt;= 1; <span class="comment">// next level</span>
<a name="l00319"></a>00319         }
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321 <span class="preprocessor">#endif //STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span>
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="comment">// make the tree two times as wide</span>
<a name="l00325"></a>00325     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00326"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a1040a6b44bbd368a59f12f598fd8d90d">00326</a>     <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a1040a6b44bbd368a59f12f598fd8d90d">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::doubleK</a>()
<a name="l00327"></a>00327     {
<a name="l00328"></a>00328         STXXL_VERBOSE3(<span class="stringliteral">&quot;loser_tree::doubleK (before) k=&quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot; logK=&quot;</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">&quot; KNKMAX=&quot;</span> &lt;&lt; KNKMAX &lt;&lt; <span class="stringliteral">&quot; #free=&quot;</span> &lt;&lt; free_slots.size());
<a name="l00329"></a>00329         assert(k &gt; 0);
<a name="l00330"></a>00330         assert(k &lt; KNKMAX);
<a name="l00331"></a>00331         assert(free_slots.empty());                      <span class="comment">// stack was free (probably not needed)</span>
<a name="l00332"></a>00332 
<a name="l00333"></a>00333         <span class="comment">// make all new entries free</span>
<a name="l00334"></a>00334         <span class="comment">// and push them on the free stack</span>
<a name="l00335"></a>00335         <span class="keywordflow">for</span> (<a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> i = 2 * k - 1; i &gt;= k; i--)   <span class="comment">// backwards</span>
<a name="l00336"></a>00336         {
<a name="l00337"></a>00337             current[i] = &amp;sentinel;
<a name="l00338"></a>00338             current_end[i] = &amp;sentinel;
<a name="l00339"></a>00339             segment[i] = NULL;
<a name="l00340"></a>00340             free_slots.push(i);
<a name="l00341"></a>00341         }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343         <span class="comment">// double the size</span>
<a name="l00344"></a>00344         k *= 2;
<a name="l00345"></a>00345         logK++;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347         STXXL_VERBOSE3(<span class="stringliteral">&quot;loser_tree::doubleK (after)  k=&quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot; logK=&quot;</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">&quot; KNKMAX=&quot;</span> &lt;&lt; KNKMAX &lt;&lt; <span class="stringliteral">&quot; #free=&quot;</span> &lt;&lt; free_slots.size());
<a name="l00348"></a>00348         assert(!free_slots.empty());
<a name="l00349"></a>00349 
<a name="l00350"></a>00350         <span class="comment">// recompute loser tree information</span>
<a name="l00351"></a>00351         rebuildLoserTree();
<a name="l00352"></a>00352     }
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="comment">// compact nonempty segments in the left half of the tree</span>
<a name="l00356"></a>00356     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00357"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a13eccebbd081ac1a0dfb55ef35a3650e">00357</a>     <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a13eccebbd081ac1a0dfb55ef35a3650e">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::compactTree</a>()
<a name="l00358"></a>00358     {
<a name="l00359"></a>00359         STXXL_VERBOSE3(<span class="stringliteral">&quot;loser_tree::compactTree (before) k=&quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot; logK=&quot;</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">&quot; #free=&quot;</span> &lt;&lt; free_slots.size());
<a name="l00360"></a>00360         assert(logK &gt; 0);
<a name="l00361"></a>00361 
<a name="l00362"></a>00362         <span class="comment">// compact all nonempty segments to the left</span>
<a name="l00363"></a>00363         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> pos = 0;
<a name="l00364"></a>00364         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> last_empty = 0;
<a name="l00365"></a>00365         <span class="keywordflow">for</span> ( ; pos &lt; k; pos++)
<a name="l00366"></a>00366         {
<a name="l00367"></a>00367             <span class="keywordflow">if</span> (not_sentinel(*(current[pos])))
<a name="l00368"></a>00368             {
<a name="l00369"></a>00369                 segment_size[last_empty] = segment_size[pos];
<a name="l00370"></a>00370                 current[last_empty] = current[pos];
<a name="l00371"></a>00371                 current_end[last_empty] = current_end[pos];
<a name="l00372"></a>00372                 segment[last_empty] = segment[pos];
<a name="l00373"></a>00373                 last_empty++;
<a name="l00374"></a>00374             } <span class="comment">/*</span>
<a name="l00375"></a>00375 <span class="comment">                else</span>
<a name="l00376"></a>00376 <span class="comment">                {</span>
<a name="l00377"></a>00377 <span class="comment">                if(segment[pos])</span>
<a name="l00378"></a>00378 <span class="comment">                {</span>
<a name="l00379"></a>00379 <span class="comment">                STXXL_VERBOSE2(&quot;loser_tree::compactTree() deleting segment &quot;&lt;&lt;pos&lt;&lt;</span>
<a name="l00380"></a>00380 <span class="comment">                                        &quot; address: &quot;&lt;&lt;segment[pos]&lt;&lt;&quot; size: &quot;&lt;&lt;segment_size[pos]);</span>
<a name="l00381"></a>00381 <span class="comment">                delete [] segment[pos];</span>
<a name="l00382"></a>00382 <span class="comment">                segment[pos] = 0;</span>
<a name="l00383"></a>00383 <span class="comment">                mem_cons_ -= segment_size[pos];</span>
<a name="l00384"></a>00384 <span class="comment">                }</span>
<a name="l00385"></a>00385 <span class="comment">                }*/</span>
<a name="l00386"></a>00386         }
<a name="l00387"></a>00387 
<a name="l00388"></a>00388         <span class="comment">// half degree as often as possible</span>
<a name="l00389"></a>00389         <span class="keywordflow">while</span> ((k &gt; 1) &amp;&amp; ((k / 2) &gt;= last_empty))
<a name="l00390"></a>00390         {
<a name="l00391"></a>00391             k /= 2;
<a name="l00392"></a>00392             logK--;
<a name="l00393"></a>00393         }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395         <span class="comment">// overwrite garbage and compact the stack of free segment indices</span>
<a name="l00396"></a>00396         free_slots.clear(); <span class="comment">// none free</span>
<a name="l00397"></a>00397         <span class="keywordflow">for</span> ( ; last_empty &lt; k; last_empty++)
<a name="l00398"></a>00398         {
<a name="l00399"></a>00399             current[last_empty] = &amp;sentinel;
<a name="l00400"></a>00400             current_end[last_empty] = &amp;sentinel;
<a name="l00401"></a>00401             free_slots.push(last_empty);
<a name="l00402"></a>00402         }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404         STXXL_VERBOSE3(<span class="stringliteral">&quot;loser_tree::compactTree (after)  k=&quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot; logK=&quot;</span> &lt;&lt; logK &lt;&lt; <span class="stringliteral">&quot; #free=&quot;</span> &lt;&lt; free_slots.size());
<a name="l00405"></a>00405 
<a name="l00406"></a>00406         <span class="comment">// recompute loser tree information</span>
<a name="l00407"></a>00407         rebuildLoserTree();
<a name="l00408"></a>00408     }
<a name="l00409"></a>00409 
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="comment">// insert segment beginning at target</span>
<a name="l00412"></a>00412 <span class="comment">// require: is_space_available() == 1</span>
<a name="l00413"></a>00413     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00414"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#af22a6b0f29a48bd7b2097dff4778652a">00414</a>     <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#af22a6b0f29a48bd7b2097dff4778652a">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::insert_segment</a>(<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ad4c2c182a6aade29436da74c403de32a">Element</a> * target, <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> length)
<a name="l00415"></a>00415     {
<a name="l00416"></a>00416         STXXL_VERBOSE2(<span class="stringliteral">&quot;loser_tree::insert_segment(&quot;</span> &lt;&lt; target &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; length &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>);
<a name="l00417"></a>00417         <span class="comment">//std::copy(target,target + length,std::ostream_iterator&lt;ValTp_&gt;(std::cout, &quot;\n&quot;));</span>
<a name="l00418"></a>00418 
<a name="l00419"></a>00419         <span class="keywordflow">if</span> (length &gt; 0)
<a name="l00420"></a>00420         {
<a name="l00421"></a>00421             assert(not_sentinel(target[0]));
<a name="l00422"></a>00422             assert(not_sentinel(target[length - 1]));
<a name="l00423"></a>00423             assert(is_sentinel(target[length]));
<a name="l00424"></a>00424 
<a name="l00425"></a>00425             <span class="comment">// get a free slot</span>
<a name="l00426"></a>00426             <span class="keywordflow">if</span> (free_slots.empty())
<a name="l00427"></a>00427             {   <span class="comment">// tree is too small</span>
<a name="l00428"></a>00428                 doubleK();
<a name="l00429"></a>00429             }
<a name="l00430"></a>00430             assert(!free_slots.empty());
<a name="l00431"></a>00431             <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> index = free_slots.top();
<a name="l00432"></a>00432             free_slots.pop();
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 
<a name="l00435"></a>00435             <span class="comment">// link new segment</span>
<a name="l00436"></a>00436             current[index] = segment[index] = target;
<a name="l00437"></a>00437             current_end[index] = target + length;
<a name="l00438"></a>00438             segment_size[index] = (length + 1) * <span class="keyword">sizeof</span>(<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a18d3d69d1b0af6359673aac8ec627237">value_type</a>);
<a name="l00439"></a>00439             mem_cons_ += (length + 1) * <span class="keyword">sizeof</span>(<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a18d3d69d1b0af6359673aac8ec627237">value_type</a>);
<a name="l00440"></a>00440             size_ += length;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="preprocessor">#if STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00443"></a>00443 <span class="preprocessor"></span>            <span class="comment">// propagate new information up the tree</span>
<a name="l00444"></a>00444             <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ad4c2c182a6aade29436da74c403de32a">Element</a> dummyKey;
<a name="l00445"></a>00445             <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> dummyIndex;
<a name="l00446"></a>00446             <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> dummyMask;
<a name="l00447"></a>00447             update_on_insert((index + k) &gt;&gt; 1, *target, index,
<a name="l00448"></a>00448                              &amp;dummyKey, &amp;dummyIndex, &amp;dummyMask);
<a name="l00449"></a>00449 <span class="preprocessor">#endif      //STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00450"></a>00450 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
<a name="l00451"></a>00451             <span class="comment">// immediately deallocate</span>
<a name="l00452"></a>00452             <span class="comment">// this is not only an optimization</span>
<a name="l00453"></a>00453             <span class="comment">// but also needed to keep free segments from</span>
<a name="l00454"></a>00454             <span class="comment">// clogging up the tree</span>
<a name="l00455"></a>00455             <span class="keyword">delete</span>[] target;
<a name="l00456"></a>00456         }
<a name="l00457"></a>00457     }
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 
<a name="l00460"></a>00460     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00461"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a6150062174a6abdf6808e5980611b7f3">00461</a>     <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a6150062174a6abdf6808e5980611b7f3">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::~loser_tree</a>()
<a name="l00462"></a>00462     {
<a name="l00463"></a>00463         STXXL_VERBOSE1(<span class="stringliteral">&quot;loser_tree::~loser_tree()&quot;</span>);
<a name="l00464"></a>00464         <span class="keywordflow">for</span> (<a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> i = 0; i &lt; k; ++i)
<a name="l00465"></a>00465         {
<a name="l00466"></a>00466             <span class="keywordflow">if</span> (segment[i])
<a name="l00467"></a>00467             {
<a name="l00468"></a>00468                 STXXL_VERBOSE2(<span class="stringliteral">&quot;loser_tree::~loser_tree() deleting segment &quot;</span> &lt;&lt; i);
<a name="l00469"></a>00469                 <span class="keyword">delete</span>[] segment[i];
<a name="l00470"></a>00470                 mem_cons_ -= segment_size[i];
<a name="l00471"></a>00471             }
<a name="l00472"></a>00472         }
<a name="l00473"></a>00473         <span class="comment">// check whether we have not lost any memory</span>
<a name="l00474"></a>00474         assert(mem_cons_ == 0);
<a name="l00475"></a>00475     }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="comment">// free an empty segment .</span>
<a name="l00478"></a>00478     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00479"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a2b04ee2c1b1e605010b8adaac236a1dc">00479</a>     <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a2b04ee2c1b1e605010b8adaac236a1dc">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::deallocate_segment</a>(<a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> slot)
<a name="l00480"></a>00480     {
<a name="l00481"></a>00481         <span class="comment">// reroute current pointer to some empty sentinel segment</span>
<a name="l00482"></a>00482         <span class="comment">// with a sentinel key</span>
<a name="l00483"></a>00483         STXXL_VERBOSE2(<span class="stringliteral">&quot;loser_tree::deallocate_segment() deleting segment &quot;</span> &lt;&lt;
<a name="l00484"></a>00484                        slot &lt;&lt; <span class="stringliteral">&quot; address: &quot;</span> &lt;&lt; segment[slot] &lt;&lt; <span class="stringliteral">&quot; size: &quot;</span> &lt;&lt; (segment_size[slot] / <span class="keyword">sizeof</span>(<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a18d3d69d1b0af6359673aac8ec627237">value_type</a>)) - 1);
<a name="l00485"></a>00485         current[slot] = &amp;sentinel;
<a name="l00486"></a>00486         current_end[slot] = &amp;sentinel;
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         <span class="comment">// free memory</span>
<a name="l00489"></a>00489         <span class="keyword">delete</span>[] segment[slot];
<a name="l00490"></a>00490         segment[slot] = NULL;
<a name="l00491"></a>00491         mem_cons_ -= segment_size[slot];
<a name="l00492"></a>00492 
<a name="l00493"></a>00493         <span class="comment">// push on the stack of free segment indices</span>
<a name="l00494"></a>00494         free_slots.push(slot);
<a name="l00495"></a>00495     }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 <span class="comment">// delete the length smallest elements and write them to target</span>
<a name="l00499"></a>00499 <span class="comment">// empty segments are deallocated</span>
<a name="l00500"></a>00500 <span class="comment">// require:</span>
<a name="l00501"></a>00501 <span class="comment">// - there are at least length elements</span>
<a name="l00502"></a>00502 <span class="comment">// - segments are ended by sentinels</span>
<a name="l00503"></a>00503     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00504"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a5047ebaeee423f4ea658c8709b27fe2e">00504</a>     <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ae34c17d85595172f5f29f20afccef3a5">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::multi_merge</a>(<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ad4c2c182a6aade29436da74c403de32a">Element</a> * target, <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> length)
<a name="l00505"></a>00505     {
<a name="l00506"></a>00506         STXXL_VERBOSE3(<span class="stringliteral">&quot;loser_tree::multi_merge(target=&quot;</span> &lt;&lt; target &lt;&lt; <span class="stringliteral">&quot;, len=&quot;</span> &lt;&lt; length &lt;&lt; <span class="stringliteral">&quot;) k=&quot;</span> &lt;&lt; k);
<a name="l00507"></a>00507 
<a name="l00508"></a>00508         <span class="keywordflow">if</span> (length == 0)
<a name="l00509"></a>00509             <span class="keywordflow">return</span>;
<a name="l00510"></a>00510 
<a name="l00511"></a>00511         assert(k &gt; 0);
<a name="l00512"></a>00512         assert(length &lt;= size_);
<a name="l00513"></a>00513 
<a name="l00514"></a>00514         <span class="comment">//This is the place to make statistics about internal multi_merge calls.</span>
<a name="l00515"></a>00515 
<a name="l00516"></a>00516 <span class="preprocessor">#if STXXL_PARALLEL &amp;&amp; STXXL_PARALLEL_PQ_MULTIWAY_MERGE_INTERNAL</span>
<a name="l00517"></a>00517 <span class="preprocessor"></span>        <a class="code" href="classstxxl_1_1priority__queue__local_1_1invert__order.html" title="Inverts the order of a comparison functor by swapping its arguments.">priority_queue_local::invert_order&lt;Cmp_, value_type, value_type&gt;</a> inv_cmp(<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>);
<a name="l00518"></a>00518 <span class="preprocessor">#endif</span>
<a name="l00519"></a>00519 <span class="preprocessor"></span>        <span class="keywordflow">switch</span> (logK) {
<a name="l00520"></a>00520         <span class="keywordflow">case</span> 0:
<a name="l00521"></a>00521             assert(k == 1);
<a name="l00522"></a>00522 <span class="preprocessor">#if STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00523"></a>00523 <span class="preprocessor"></span>            assert(entry[0].index == 0);
<a name="l00524"></a>00524 <span class="preprocessor">#endif      //STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00525"></a>00525 <span class="preprocessor"></span>            assert(free_slots.empty());
<a name="l00526"></a>00526             memcpy(target, current[0], length * <span class="keyword">sizeof</span>(<a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#ad4c2c182a6aade29436da74c403de32a">Element</a>));
<a name="l00527"></a>00527             <span class="comment">//std::copy(current[0], current[0] + length, target);</span>
<a name="l00528"></a>00528             current[0] += length;
<a name="l00529"></a>00529 <span class="preprocessor">#if STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00530"></a>00530 <span class="preprocessor"></span>            entry[0].key = **current;
<a name="l00531"></a>00531 <span class="preprocessor">#endif      //STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00532"></a>00532 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (is_segment_empty(0))
<a name="l00533"></a>00533                 deallocate_segment(0);
<a name="l00534"></a>00534 
<a name="l00535"></a>00535             <span class="keywordflow">break</span>;
<a name="l00536"></a>00536         <span class="keywordflow">case</span> 1:
<a name="l00537"></a>00537             assert(k == 2);
<a name="l00538"></a>00538 <span class="preprocessor">#if STXXL_PARALLEL &amp;&amp; STXXL_PARALLEL_PQ_MULTIWAY_MERGE_INTERNAL</span>
<a name="l00539"></a>00539 <span class="preprocessor"></span>            {
<a name="l00540"></a>00540                 std::pair&lt;Element *, Element *&gt; seqs[2] =
<a name="l00541"></a>00541                 {
<a name="l00542"></a>00542                     std::make_pair(current[0], current_end[0]),
<a name="l00543"></a>00543                     std::make_pair(current[1], current_end[1])
<a name="l00544"></a>00544                 };
<a name="l00545"></a>00545                 parallel::multiway_merge_sentinel(seqs, seqs + 2, target, inv_cmp, length);
<a name="l00546"></a>00546                 current[0] = seqs[0].first;
<a name="l00547"></a>00547                 current[1] = seqs[1].first;
<a name="l00548"></a>00548             }
<a name="l00549"></a>00549 <span class="preprocessor">#else</span>
<a name="l00550"></a>00550 <span class="preprocessor"></span>            <a class="code" href="namespacestxxl_1_1priority__queue__local.html#a71f4e78f71dfc103a2fc5488fd9e515d">merge_iterator</a>(current[0], current[1], target, length, <a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>);
<a name="l00551"></a>00551             rebuildLoserTree();
<a name="l00552"></a>00552 <span class="preprocessor">#endif</span>
<a name="l00553"></a>00553 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (is_segment_empty(0))
<a name="l00554"></a>00554                 deallocate_segment(0);
<a name="l00555"></a>00555 
<a name="l00556"></a>00556             <span class="keywordflow">if</span> (is_segment_empty(1))
<a name="l00557"></a>00557                 deallocate_segment(1);
<a name="l00558"></a>00558 
<a name="l00559"></a>00559             <span class="keywordflow">break</span>;
<a name="l00560"></a>00560         <span class="keywordflow">case</span> 2:
<a name="l00561"></a>00561             assert(k == 4);
<a name="l00562"></a>00562 <span class="preprocessor">#if STXXL_PARALLEL &amp;&amp; STXXL_PARALLEL_PQ_MULTIWAY_MERGE_INTERNAL</span>
<a name="l00563"></a>00563 <span class="preprocessor"></span>            {
<a name="l00564"></a>00564                 std::pair&lt;Element *, Element *&gt; seqs[4] =
<a name="l00565"></a>00565                 {
<a name="l00566"></a>00566                     std::make_pair(current[0], current_end[0]),
<a name="l00567"></a>00567                     std::make_pair(current[1], current_end[1]),
<a name="l00568"></a>00568                     std::make_pair(current[2], current_end[2]),
<a name="l00569"></a>00569                     std::make_pair(current[3], current_end[3])
<a name="l00570"></a>00570                 };
<a name="l00571"></a>00571                 parallel::multiway_merge_sentinel(seqs, seqs + 4, target, inv_cmp, length);
<a name="l00572"></a>00572                 current[0] = seqs[0].first;
<a name="l00573"></a>00573                 current[1] = seqs[1].first;
<a name="l00574"></a>00574                 current[2] = seqs[2].first;
<a name="l00575"></a>00575                 current[3] = seqs[3].first;
<a name="l00576"></a>00576             }
<a name="l00577"></a>00577 <span class="preprocessor">#else</span>
<a name="l00578"></a>00578 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (is_segment_empty(3))
<a name="l00579"></a>00579                 <a class="code" href="namespacestxxl_1_1priority__queue__local.html#a336bfc385e442b1fd3ddf7f1b6ba9534">merge3_iterator</a>(current[0], current[1], current[2], target, length, <a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>);
<a name="l00580"></a>00580             <span class="keywordflow">else</span>
<a name="l00581"></a>00581                 <a class="code" href="namespacestxxl_1_1priority__queue__local.html#a7fecd6e0c694412570c52e996dfc47ab">merge4_iterator</a>(current[0], current[1], current[2], current[3], target, length, <a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>);
<a name="l00582"></a>00582 
<a name="l00583"></a>00583             rebuildLoserTree();
<a name="l00584"></a>00584 <span class="preprocessor">#endif</span>
<a name="l00585"></a>00585 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (is_segment_empty(0))
<a name="l00586"></a>00586                 deallocate_segment(0);
<a name="l00587"></a>00587 
<a name="l00588"></a>00588             <span class="keywordflow">if</span> (is_segment_empty(1))
<a name="l00589"></a>00589                 deallocate_segment(1);
<a name="l00590"></a>00590 
<a name="l00591"></a>00591             <span class="keywordflow">if</span> (is_segment_empty(2))
<a name="l00592"></a>00592                 deallocate_segment(2);
<a name="l00593"></a>00593 
<a name="l00594"></a>00594             <span class="keywordflow">if</span> (is_segment_empty(3))
<a name="l00595"></a>00595                 deallocate_segment(3);
<a name="l00596"></a>00596 
<a name="l00597"></a>00597             <span class="keywordflow">break</span>;
<a name="l00598"></a>00598 <span class="preprocessor">#if !(STXXL_PARALLEL &amp;&amp; STXXL_PARALLEL_PQ_MULTIWAY_MERGE_INTERNAL)</span>
<a name="l00599"></a>00599 <span class="preprocessor"></span>        <span class="keywordflow">case</span>  3: multi_merge_f&lt;3&gt;(target, length);
<a name="l00600"></a>00600             <span class="keywordflow">break</span>;
<a name="l00601"></a>00601         <span class="keywordflow">case</span>  4: multi_merge_f&lt;4&gt;(target, length);
<a name="l00602"></a>00602             <span class="keywordflow">break</span>;
<a name="l00603"></a>00603         <span class="keywordflow">case</span>  5: multi_merge_f&lt;5&gt;(target, length);
<a name="l00604"></a>00604             <span class="keywordflow">break</span>;
<a name="l00605"></a>00605         <span class="keywordflow">case</span>  6: multi_merge_f&lt;6&gt;(target, length);
<a name="l00606"></a>00606             <span class="keywordflow">break</span>;
<a name="l00607"></a>00607         <span class="keywordflow">case</span>  7: multi_merge_f&lt;7&gt;(target, length);
<a name="l00608"></a>00608             <span class="keywordflow">break</span>;
<a name="l00609"></a>00609         <span class="keywordflow">case</span>  8: multi_merge_f&lt;8&gt;(target, length);
<a name="l00610"></a>00610             <span class="keywordflow">break</span>;
<a name="l00611"></a>00611         <span class="keywordflow">case</span>  9: multi_merge_f&lt;9&gt;(target, length);
<a name="l00612"></a>00612             <span class="keywordflow">break</span>;
<a name="l00613"></a>00613         <span class="keywordflow">case</span> 10: multi_merge_f&lt;10&gt;(target, length);
<a name="l00614"></a>00614             <span class="keywordflow">break</span>;
<a name="l00615"></a>00615 <span class="preprocessor">#endif</span>
<a name="l00616"></a>00616 <span class="preprocessor"></span>        <span class="keywordflow">default</span>:
<a name="l00617"></a>00617 <span class="preprocessor">#if STXXL_PARALLEL &amp;&amp; STXXL_PARALLEL_PQ_MULTIWAY_MERGE_INTERNAL</span>
<a name="l00618"></a>00618 <span class="preprocessor"></span>            {
<a name="l00619"></a>00619                 std::vector&lt;std::pair&lt;Element *, Element *&gt; &gt; seqs;
<a name="l00620"></a>00620                 std::vector&lt;int_type&gt; orig_seq_index;
<a name="l00621"></a>00621                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; k; ++i)
<a name="l00622"></a>00622                 {
<a name="l00623"></a>00623                     <span class="keywordflow">if</span> (current[i] != current_end[i] &amp;&amp; !is_sentinel(*current[i]))
<a name="l00624"></a>00624                     {
<a name="l00625"></a>00625                         seqs.push_back(std::make_pair(current[i], current_end[i]));
<a name="l00626"></a>00626                         orig_seq_index.push_back(i);
<a name="l00627"></a>00627                     }
<a name="l00628"></a>00628                 }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630                 parallel::multiway_merge_sentinel(seqs.begin(), seqs.end(), target, inv_cmp, length);
<a name="l00631"></a>00631 
<a name="l00632"></a>00632                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; seqs.size(); ++i)
<a name="l00633"></a>00633                 {
<a name="l00634"></a>00634                     <a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> seg = orig_seq_index[i];
<a name="l00635"></a>00635                     current[seg] = seqs[i].first;
<a name="l00636"></a>00636                 }
<a name="l00637"></a>00637 
<a name="l00638"></a>00638                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; k; ++i)
<a name="l00639"></a>00639                     <span class="keywordflow">if</span> (is_segment_empty(i))
<a name="l00640"></a>00640                     {
<a name="l00641"></a>00641                         STXXL_VERBOSE3(<span class="stringliteral">&quot;deallocated &quot;</span> &lt;&lt; i);
<a name="l00642"></a>00642                         deallocate_segment(i);
<a name="l00643"></a>00643                     }
<a name="l00644"></a>00644             }
<a name="l00645"></a>00645 <span class="preprocessor">#else</span>
<a name="l00646"></a>00646 <span class="preprocessor"></span>            multi_merge_k(target, length);
<a name="l00647"></a>00647 <span class="preprocessor">#endif</span>
<a name="l00648"></a>00648 <span class="preprocessor"></span>            <span class="keywordflow">break</span>;
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 
<a name="l00652"></a>00652         size_ -= length;
<a name="l00653"></a>00653 
<a name="l00654"></a>00654         <span class="comment">// compact tree if it got considerably smaller</span>
<a name="l00655"></a>00655         {
<a name="l00656"></a>00656             <span class="keyword">const</span> <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> num_segments_used = k - free_slots.size();
<a name="l00657"></a>00657             <span class="keyword">const</span> <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> num_segments_trigger = k - (3 * k / 5);
<a name="l00658"></a>00658             <span class="comment">// using k/2 would be worst case inefficient (for large k)</span>
<a name="l00659"></a>00659             <span class="comment">// for k \in {2, 4, 8} the trigger is k/2 which is good</span>
<a name="l00660"></a>00660             <span class="comment">// because we have special mergers for k \in {1, 2, 4}</span>
<a name="l00661"></a>00661             <span class="comment">// there is also a special 3-way-merger, that will be</span>
<a name="l00662"></a>00662             <span class="comment">// triggered if k == 4 &amp;&amp; is_segment_empty(3)</span>
<a name="l00663"></a>00663             STXXL_VERBOSE3(<span class="stringliteral">&quot;loser_tree  compact? k=&quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot; #used=&quot;</span> &lt;&lt; num_segments_used
<a name="l00664"></a>00664                                                      &lt;&lt; <span class="stringliteral">&quot; &lt;= #trigger=&quot;</span> &lt;&lt; num_segments_trigger &lt;&lt; <span class="stringliteral">&quot; ==&gt; &quot;</span>
<a name="l00665"></a>00665                                                      &lt;&lt; ((k &gt; 1 &amp;&amp; num_segments_used &lt;= num_segments_trigger) ? <span class="stringliteral">&quot;yes&quot;</span> : <span class="stringliteral">&quot;no &quot;</span>)
<a name="l00666"></a>00666                                                      &lt;&lt; <span class="stringliteral">&quot; || &quot;</span>
<a name="l00667"></a>00667                                                      &lt;&lt; ((k == 4 &amp;&amp; !free_slots.empty() &amp;&amp; !is_segment_empty(3)) ? <span class="stringliteral">&quot;yes&quot;</span> : <span class="stringliteral">&quot;no &quot;</span>)
<a name="l00668"></a>00668                                                      &lt;&lt; <span class="stringliteral">&quot; #free=&quot;</span> &lt;&lt; free_slots.size());
<a name="l00669"></a>00669             <span class="keywordflow">if</span> (k &gt; 1 &amp;&amp; ((num_segments_used &lt;= num_segments_trigger) ||
<a name="l00670"></a>00670                           (k == 4 &amp;&amp; !free_slots.empty() &amp;&amp; !is_segment_empty(3))))
<a name="l00671"></a>00671             {
<a name="l00672"></a>00672                 compactTree();
<a name="l00673"></a>00673             }
<a name="l00674"></a>00674         }
<a name="l00675"></a>00675         <span class="comment">//std::copy(target,target + length,std::ostream_iterator&lt;ValTp_&gt;(std::cout, &quot;\n&quot;));</span>
<a name="l00676"></a>00676     }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678 
<a name="l00679"></a>00679 <span class="comment">// is this segment empty and does not point to sentinel yet?</span>
<a name="l00680"></a>00680     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00681"></a><a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a7dad51bc515d578c613b98e9581aba1c">00681</a>     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a7dad51bc515d578c613b98e9581aba1c">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::is_segment_empty</a>(<a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> slot)
<a name="l00682"></a>00682     {
<a name="l00683"></a>00683         <span class="keywordflow">return</span> (is_sentinel(*(current[slot])) &amp;&amp; (current[slot] != &amp;sentinel));
<a name="l00684"></a>00684     }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 <span class="preprocessor">#if STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00687"></a>00687 <span class="preprocessor"></span><span class="comment">// multi-merge for arbitrary K</span>
<a name="l00688"></a>00688     <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_, <span class="keyword">class</span> Cmp_, <span class="keywordtype">unsigned</span> KNKMAX&gt;
<a name="l00689"></a>00689     <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a73ac0775206a5e3afb3ab79492c0d71f">loser_tree&lt;ValTp_, Cmp_, KNKMAX&gt;::</a>
<a name="l00690"></a>00690 <a class="code" href="classstxxl_1_1priority__queue__local_1_1loser__tree.html#a73ac0775206a5e3afb3ab79492c0d71f">    multi_merge_k</a>(Element * target, <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> length)
<a name="l00691"></a>00691     {
<a name="l00692"></a>00692         Entry * currentPos;
<a name="l00693"></a>00693         Element currentKey;
<a name="l00694"></a>00694         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> currentIndex; <span class="comment">// leaf pointed to by current entry</span>
<a name="l00695"></a>00695         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> kReg = k;
<a name="l00696"></a>00696         Element * done = target + length;
<a name="l00697"></a>00697         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> winnerIndex = entry[0].index;
<a name="l00698"></a>00698         Element winnerKey = entry[0].key;
<a name="l00699"></a>00699         Element * winnerPos;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701         <span class="keywordflow">while</span> (target != done)
<a name="l00702"></a>00702         {
<a name="l00703"></a>00703             winnerPos = current[winnerIndex];
<a name="l00704"></a>00704 
<a name="l00705"></a>00705             <span class="comment">// write result</span>
<a name="l00706"></a>00706             *target = winnerKey;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708             <span class="comment">// advance winner segment</span>
<a name="l00709"></a>00709             ++winnerPos;
<a name="l00710"></a>00710             current[winnerIndex] = winnerPos;
<a name="l00711"></a>00711             winnerKey = *winnerPos;
<a name="l00712"></a>00712 
<a name="l00713"></a>00713             <span class="comment">// remove winner segment if empty now</span>
<a name="l00714"></a>00714             <span class="keywordflow">if</span> (is_sentinel(winnerKey)) <span class="comment">//</span>
<a name="l00715"></a>00715                 deallocate_segment(winnerIndex);
<a name="l00716"></a>00716 
<a name="l00717"></a>00717 
<a name="l00718"></a>00718             <span class="comment">// go up the entry-tree</span>
<a name="l00719"></a>00719             <span class="keywordflow">for</span> (<a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> i = (winnerIndex + kReg) &gt;&gt; 1; i &gt; 0; i &gt;&gt;= 1) {
<a name="l00720"></a>00720                 currentPos = entry + i;
<a name="l00721"></a>00721                 currentKey = currentPos-&gt;key;
<a name="l00722"></a>00722                 <span class="keywordflow">if</span> (<a class="code" href="test__loop_8cpp.html#acd323997455266500c628a93bd060ff8">cmp</a>(winnerKey, currentKey)) {
<a name="l00723"></a>00723                     currentIndex = currentPos-&gt;index;
<a name="l00724"></a>00724                     currentPos-&gt;key = winnerKey;
<a name="l00725"></a>00725                     currentPos-&gt;index = winnerIndex;
<a name="l00726"></a>00726                     winnerKey = currentKey;
<a name="l00727"></a>00727                     winnerIndex = currentIndex;
<a name="l00728"></a>00728                 }
<a name="l00729"></a>00729             }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731             ++target;
<a name="l00732"></a>00732         }
<a name="l00733"></a>00733         entry[0].index = winnerIndex;
<a name="l00734"></a>00734         entry[0].key = winnerKey;
<a name="l00735"></a>00735     }
<a name="l00736"></a>00736 <span class="preprocessor">#endif //STXXL_PQ_INTERNAL_LOSER_TREE</span>
<a name="l00737"></a>00737 <span class="preprocessor"></span>} <span class="comment">//priority_queue_local</span>
<a name="l00738"></a>00738 <span class="comment"></span>
<a name="l00739"></a>00739 <span class="comment">//! \}</span>
<a name="l00740"></a>00740 <span class="comment"></span>
<a name="l00741"></a>00741 __STXXL_END_NAMESPACE
<a name="l00742"></a>00742 
<a name="l00743"></a>00743 <span class="preprocessor">#endif // !STXXL_PQ_LOSERTREE_HEADER</span>
<a name="l00744"></a>00744 <span class="preprocessor"></span><span class="comment">// vim: et:ts=4:sw=4</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
