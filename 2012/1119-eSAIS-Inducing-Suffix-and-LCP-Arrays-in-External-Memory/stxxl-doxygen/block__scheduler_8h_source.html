<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Stxxl: include/stxxl/bits/mng/block_scheduler.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Stxxl
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">include/stxxl/bits/mng/block_scheduler.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="block__scheduler_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *  include/stxxl/bits/mng/block_scheduler.h</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  Part of the STXXL. See http://stxxl.sourceforge.net</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> *  Copyright (C) 2010-2011 Raoul Steffen &lt;R-Steffen@gmx.de&gt;</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> *  Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00009"></a>00009 <span class="comment"> *  (See accompanying file LICENSE_1_0.txt or copy at</span>
<a name="l00010"></a>00010 <span class="comment"> *  http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00011"></a>00011 <span class="comment"> **************************************************************************/</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="preprocessor">#ifndef STXXL_BLOCK_SCHEDULER_HEADER</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_BLOCK_SCHEDULER_HEADER</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;stack&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;queue&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;<a class="code" href="mng_8h.html">stxxl/bits/mng/mng.h</a>&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;<a class="code" href="typed__block_8h.html">stxxl/bits/mng/typed_block.h</a>&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;<a class="code" href="addressable__queues_8h.html">stxxl/bits/common/addressable_queues.h</a>&gt;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 __STXXL_BEGIN_NAMESPACE
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">//! \brief Virtualization of a block of data.</span>
<a name="l00027"></a>00027 <span class="comment">//! Holds information for allocating and swapping. To use in cooperation with block_scheduler.</span>
<a name="l00028"></a>00028 <span class="comment">//!</span>
<a name="l00029"></a>00029 <span class="comment">//! A swappable_block can be uninitialized, i.e. it holds no data.</span>
<a name="l00030"></a>00030 <span class="comment">//! When access is required, is has to be acquired first, and released afterwards, so it can be swapped in and out as required.</span>
<a name="l00031"></a>00031 <span class="comment">//! If the stored data is no longer needed, it can get uninitialized, freeing both internal and external memory.</span>
<a name="l00032"></a>00032 <span class="comment">//! \tparam ValueType type of contained objects (POD with no references to internal memory).</span>
<a name="l00033"></a>00033 <span class="comment">//! \tparam BlockSize Number of objects in one block.</span>
<a name="l00034"></a>00034 <span class="comment">//!         BlockSize*sizeof(ValueType) must be divisible by 4096.</span>
<a name="l00035"></a>00035 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType, <span class="keywordtype">unsigned</span> BlockSize&gt;
<a name="l00036"></a><a class="code" href="classstxxl_1_1swappable__block.html">00036</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1swappable__block.html" title="Virtualization of a block of data. Holds information for allocating and swapping. To use in cooperati...">swappable_block</a>
<a name="l00037"></a>00037 {
<a name="l00038"></a>00038 <span class="keyword">protected</span>:
<a name="l00039"></a><a class="code" href="classstxxl_1_1swappable__block.html#a729a4ebb358e49f57a76cfd81829f47e">00039</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> raw_block_size = BlockSize * <span class="keyword">sizeof</span>(ValueType);
<a name="l00040"></a>00040 <span class="keyword">public</span>:
<a name="l00041"></a><a class="code" href="classstxxl_1_1swappable__block.html#ab860575cde314de079efa3ff62c5e057">00041</a>     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html" title="Block containing elements of fixed length.">typed_block&lt;raw_block_size, ValueType&gt;</a> <a class="code" href="classstxxl_1_1swappable__block.html#ab860575cde314de079efa3ff62c5e057">internal_block_type</a>;
<a name="l00042"></a><a class="code" href="classstxxl_1_1swappable__block.html#a24874fce2f6b3e840f8d372ca6b196ef">00042</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structstxxl_1_1BID.html">internal_block_type::bid_type</a> <a class="code" href="classstxxl_1_1swappable__block.html#a24874fce2f6b3e840f8d372ca6b196ef">external_block_type</a>;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">protected</span>:
<a name="l00045"></a><a class="code" href="classstxxl_1_1swappable__block.html#a373b104eee2e285bdc70ff4af8aaca62">00045</a>     <a class="code" href="structstxxl_1_1BID.html">external_block_type</a> <a class="code" href="classstxxl_1_1swappable__block.html#a373b104eee2e285bdc70ff4af8aaca62">external_data</a>;      <span class="comment">//!external_data.valid if no associated space on disk</span>
<a name="l00046"></a><a class="code" href="classstxxl_1_1swappable__block.html#a9cded2f42281427567bf1c9b4d5edfd2">00046</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1typed__block.html" title="Block containing elements of fixed length.">internal_block_type</a> * <a class="code" href="classstxxl_1_1swappable__block.html#a9cded2f42281427567bf1c9b4d5edfd2" title="external_data.valid if no associated space on disk">internal_data</a>;    <span class="comment">//NULL if there is no internal memory reserved</span>
<a name="l00047"></a><a class="code" href="classstxxl_1_1swappable__block.html#a02622af166af4b0de17a6a7f0dc039d1">00047</a>     <span class="keywordtype">bool</span> <a class="code" href="classstxxl_1_1swappable__block.html#a02622af166af4b0de17a6a7f0dc039d1">dirty</a>;
<a name="l00048"></a><a class="code" href="classstxxl_1_1swappable__block.html#a8fe149e5b20ca6e81f1d9a4cd921a699">00048</a>     <a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> <a class="code" href="classstxxl_1_1swappable__block.html#a8fe149e5b20ca6e81f1d9a4cd921a699">reference_count</a>;
<a name="l00049"></a>00049 
<a name="l00050"></a><a class="code" href="classstxxl_1_1swappable__block.html#a79357521ac451edf13f492c1b584bf38">00050</a>     <span class="keyword">static</span> <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> <a class="code" href="classstxxl_1_1swappable__block.html#a79357521ac451edf13f492c1b584bf38">disk_allocation_offset</a>;
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="classstxxl_1_1swappable__block.html#a2ec11b9ea6afd232145ff380fa26215b">00052</a>     <span class="keywordtype">void</span> get_external_block()
<a name="l00053"></a>00053     { block_manager::get_instance()-&gt;new_block(<a class="code" href="structstxxl_1_1striping.html" title="striping disk allocation scheme functor">striping</a>(), external_data, ++disk_allocation_offset); }
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="classstxxl_1_1swappable__block.html#af48fadc3a80fdc3fa4ecf9fb0131687c">00055</a>     <span class="keywordtype">void</span> free_external_block()
<a name="l00056"></a>00056     {
<a name="l00057"></a>00057         block_manager::get_instance()-&gt;delete_block(external_data);
<a name="l00058"></a>00058         external_data = <a class="code" href="structstxxl_1_1BID.html">external_block_type</a>(); <span class="comment">// make invalid</span>
<a name="l00059"></a>00059     }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00062"></a>00062 <span class="comment">    //! \brief Create in uninitialized state.</span>
<a name="l00063"></a><a class="code" href="classstxxl_1_1swappable__block.html#aa1812d2f6fa54b407bf5b771b66070b5">00063</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1swappable__block.html" title="Virtualization of a block of data. Holds information for allocating and swapping. To use in cooperati...">swappable_block</a>()
<a name="l00064"></a>00064         : external_data() <span class="comment">/*!valid*/</span>, internal_data(0), dirty(false), reference_count(0) {}
<a name="l00065"></a>00065 
<a name="l00066"></a><a class="code" href="classstxxl_1_1swappable__block.html#a6dd9c1d0dc54c654d69d46c861e54d65">00066</a>     <a class="code" href="classstxxl_1_1swappable__block.html#a6dd9c1d0dc54c654d69d46c861e54d65">~swappable_block</a>() {}
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">    //! \brief If it has an internal_block. The internal_block implicitly holds valid data.</span>
<a name="l00069"></a><a class="code" href="classstxxl_1_1swappable__block.html#abc89df6c9303c361b61ed9c834e12990">00069</a> <span class="comment"></span>    <span class="keywordtype">bool</span> is_internal()<span class="keyword"> const</span>
<a name="l00070"></a>00070 <span class="keyword">    </span>{ <span class="keywordflow">return</span> internal_data; }
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">    //! \brief If the external_block does not hold valid data.</span>
<a name="l00073"></a><a class="code" href="classstxxl_1_1swappable__block.html#ad3e3acdfc3410f9dec8a000008e17a8a">00073</a> <span class="comment"></span>    <span class="keywordtype">bool</span> is_dirty()<span class="keyword"> const</span>
<a name="l00074"></a>00074 <span class="keyword">    </span>{ <span class="keywordflow">return</span> dirty; }
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">    //! \brief If it has an external_block.</span>
<a name="l00077"></a><a class="code" href="classstxxl_1_1swappable__block.html#aaa52d0f74a6fd44024e1009303bb1fb7">00077</a> <span class="comment"></span>    <span class="keywordtype">bool</span> has_external_block()<span class="keyword"> const</span>
<a name="l00078"></a>00078 <span class="keyword">    </span>{ <span class="keywordflow">return</span> external_data.valid(); }
<a name="l00079"></a>00079 <span class="comment"></span>
<a name="l00080"></a>00080 <span class="comment">    //! \brief If it has an external_block that holds valid data.</span>
<a name="l00081"></a><a class="code" href="classstxxl_1_1swappable__block.html#a460fd740b98d884a800d0105434da982">00081</a> <span class="comment"></span>    <span class="keywordtype">bool</span> is_external()<span class="keyword"> const</span>
<a name="l00082"></a>00082 <span class="keyword">    </span>{ <span class="keywordflow">return</span> has_external_block() &amp;&amp; ! is_dirty(); }
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">    //! \brief If it is acquired.</span>
<a name="l00085"></a><a class="code" href="classstxxl_1_1swappable__block.html#a17536c2736c800c74aa76454272f77ad">00085</a> <span class="comment"></span>    <span class="keywordtype">bool</span> is_acquired()<span class="keyword"> const</span>
<a name="l00086"></a>00086 <span class="keyword">    </span>{ <span class="keywordflow">return</span> reference_count &gt; 0; }
<a name="l00087"></a>00087 <span class="comment"></span>
<a name="l00088"></a>00088 <span class="comment">    //! \brief If it holds an internal_block but does not need it.</span>
<a name="l00089"></a><a class="code" href="classstxxl_1_1swappable__block.html#a4a64229a9636b30ead15d59d4965db09">00089</a> <span class="comment"></span>    <span class="keywordtype">bool</span> is_evictable()<span class="keyword"> const</span>
<a name="l00090"></a>00090 <span class="keyword">    </span>{ <span class="keywordflow">return</span> ! is_acquired() &amp;&amp; is_internal(); }
<a name="l00091"></a>00091 <span class="comment"></span>
<a name="l00092"></a>00092 <span class="comment">    //! \brief If it has some valid data (in- or external).</span>
<a name="l00093"></a><a class="code" href="classstxxl_1_1swappable__block.html#ab6bbb4e1ef54d3bf36dea3e7d2ff2894">00093</a> <span class="comment"></span>    <span class="keywordtype">bool</span> is_initialized()<span class="keyword"> const</span>
<a name="l00094"></a>00094 <span class="keyword">    </span>{ <span class="keywordflow">return</span> is_internal() || is_external(); }
<a name="l00095"></a>00095 <span class="comment"></span>
<a name="l00096"></a>00096 <span class="comment">    //! \brief Invalidate external data if true.</span>
<a name="l00097"></a>00097 <span class="comment">    //! \return is_dirty()</span>
<a name="l00098"></a><a class="code" href="classstxxl_1_1swappable__block.html#a62db447e39ef062712daa7f3061d20fd">00098</a> <span class="comment"></span>    <span class="keywordtype">bool</span> make_dirty_if(<span class="keyword">const</span> <span class="keywordtype">bool</span> make_dirty)
<a name="l00099"></a>00099     {
<a name="l00100"></a>00100         assert(is_acquired());
<a name="l00101"></a>00101         <span class="keywordflow">return</span> dirty = make_dirty || dirty;
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103 <span class="comment"></span>
<a name="l00104"></a>00104 <span class="comment">    //! \brief Acquire the block, i.e. add a reference. Has to be internal.</span>
<a name="l00105"></a>00105 <span class="comment">    //! \return A reference to the data-block.</span>
<a name="l00106"></a><a class="code" href="classstxxl_1_1swappable__block.html#a8857ae641dbe14bbb6ff671353805c99">00106</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1typed__block.html" title="Block containing elements of fixed length.">internal_block_type</a> &amp; acquire()
<a name="l00107"></a>00107     {
<a name="l00108"></a>00108         assert(is_internal());
<a name="l00109"></a>00109         ++ reference_count;
<a name="l00110"></a>00110         <span class="keywordflow">return</span> * internal_data;
<a name="l00111"></a>00111     }
<a name="l00112"></a>00112 <span class="comment"></span>
<a name="l00113"></a>00113 <span class="comment">    //! \brief Release the block, i.e. subduct a reference. Has to be acquired.</span>
<a name="l00114"></a><a class="code" href="classstxxl_1_1swappable__block.html#a9288166547ca91778d42d66ce8d69da4">00114</a> <span class="comment"></span>    <span class="keywordtype">void</span> release()
<a name="l00115"></a>00115     {
<a name="l00116"></a>00116         assert(is_acquired());
<a name="l00117"></a>00117         -- reference_count;
<a name="l00118"></a>00118     }
<a name="l00119"></a>00119 <span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment">    //! \brief Get a reference to the data-block. Has to be acquired.</span>
<a name="l00121"></a><a class="code" href="classstxxl_1_1swappable__block.html#a28c3c1f91025f102772c30d15e1e856d">00121</a> <span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classstxxl_1_1typed__block.html" title="Block containing elements of fixed length.">internal_block_type</a> &amp; get_internal_block()<span class="keyword"> const</span>
<a name="l00122"></a>00122 <span class="keyword">    </span>{
<a name="l00123"></a>00123         assert(is_acquired());
<a name="l00124"></a>00124         <span class="keywordflow">return</span> * internal_data;
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126 <span class="comment"></span>
<a name="l00127"></a>00127 <span class="comment">    //! \brief Get a reference to the data-block. Has to be acquired.</span>
<a name="l00128"></a><a class="code" href="classstxxl_1_1swappable__block.html#a0d7f69f73a444b3439df0b51b30925e0">00128</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1typed__block.html" title="Block containing elements of fixed length.">internal_block_type</a> &amp; get_internal_block()
<a name="l00129"></a>00129     {
<a name="l00130"></a>00130         assert(is_acquired());
<a name="l00131"></a>00131         <span class="keywordflow">return</span> * internal_data;
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133 <span class="comment"></span>
<a name="l00134"></a>00134 <span class="comment">    //! \brief Fill block with default data, is supposed to be overwritten by subclass. Has to be internal.</span>
<a name="l00135"></a><a class="code" href="classstxxl_1_1swappable__block.html#a329981f27351bba02ed5190405efc664">00135</a> <span class="comment"></span>    <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1swappable__block.html#a329981f27351bba02ed5190405efc664" title="Fill block with default data, is supposed to be overwritten by subclass. Has to be internal...">fill_default</a>() {}
<a name="l00136"></a>00136 <span class="comment"></span>
<a name="l00137"></a>00137 <span class="comment">    //! \brief Read asyncronusly from external_block to internal_block. Has to be internal and have an external_block.</span>
<a name="l00138"></a>00138 <span class="comment">    //! \return A request pointer to the I/O.</span>
<a name="l00139"></a><a class="code" href="classstxxl_1_1swappable__block.html#a0bd12cd84a543bd9404024e0eb299736">00139</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1request__ptr.html" title="Implemented as reference counting smart pointer.">request_ptr</a> read_async(<a class="code" href="classstxxl_1_1completion__handler.html" title="Completion handler class (Loki-style)">completion_handler</a> on_cmpl = <a class="code" href="structstxxl_1_1default__completion__handler.html" title="Default completion handler class.">default_completion_handler</a>())
<a name="l00140"></a>00140     {
<a name="l00141"></a>00141         assert(is_internal());
<a name="l00142"></a>00142         assert(has_external_block());
<a name="l00143"></a>00143 <span class="preprocessor">        #ifdef RW_VERBOSE</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span>        <a class="code" href="leda__sm__pq__benchmark_8cpp.html#afec876b95f7d6cc4b0f0bd4c0d7d89a0">STXXL_MSG</a>(<span class="stringliteral">&quot;reading block&quot;</span>);
<a name="l00145"></a>00145 <span class="preprocessor">        #endif</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span>        dirty = <span class="keyword">false</span>;
<a name="l00147"></a>00147         <span class="keywordflow">return</span> internal_data-&gt;read(external_data, on_cmpl);
<a name="l00148"></a>00148     }
<a name="l00149"></a>00149 <span class="comment"></span>
<a name="l00150"></a>00150 <span class="comment">    //! \brief Read synchronously from external_block to internal_block. Has to be internal and have an external_block.</span>
<a name="l00151"></a><a class="code" href="classstxxl_1_1swappable__block.html#a4cf4132c1d683e24e18f68494926598f">00151</a> <span class="comment"></span>    <span class="keywordtype">void</span> read_sync()
<a name="l00152"></a>00152     { read_async()-&gt;wait(); }
<a name="l00153"></a>00153 <span class="comment"></span>
<a name="l00154"></a>00154 <span class="comment">    //! \brief Write asyncronusly from internal_block to external_block if necessary.</span>
<a name="l00155"></a>00155 <span class="comment">    //! \return A request pointer to the I/O, an invalid request pointer if not necessary.</span>
<a name="l00156"></a><a class="code" href="classstxxl_1_1swappable__block.html#a066fdd0e4190f7d72ddc731d21ff2e69">00156</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1request__ptr.html" title="Implemented as reference counting smart pointer.">request_ptr</a> clean_async(<a class="code" href="classstxxl_1_1completion__handler.html" title="Completion handler class (Loki-style)">completion_handler</a> on_cmpl = <a class="code" href="structstxxl_1_1default__completion__handler.html" title="Default completion handler class.">default_completion_handler</a>())
<a name="l00157"></a>00157     {
<a name="l00158"></a>00158         <span class="keywordflow">if</span> (! is_dirty())
<a name="l00159"></a>00159             <span class="keywordflow">return</span> <a class="code" href="classstxxl_1_1request__ptr.html" title="Implemented as reference counting smart pointer.">request_ptr</a>();
<a name="l00160"></a>00160         <span class="keywordflow">if</span> (! has_external_block())
<a name="l00161"></a>00161             get_external_block();
<a name="l00162"></a>00162 <span class="preprocessor">        #ifdef RW_VERBOSE</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span>        <a class="code" href="leda__sm__pq__benchmark_8cpp.html#afec876b95f7d6cc4b0f0bd4c0d7d89a0">STXXL_MSG</a>(<span class="stringliteral">&quot;writing block&quot;</span>);
<a name="l00164"></a>00164 <span class="preprocessor">        #endif</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span>        dirty = <span class="keyword">false</span>;
<a name="l00166"></a>00166         <span class="keywordflow">return</span> internal_data-&gt;write(external_data, on_cmpl);
<a name="l00167"></a>00167     }
<a name="l00168"></a>00168 <span class="comment"></span>
<a name="l00169"></a>00169 <span class="comment">    //! \brief Write synchronously from internal_block to external_block if necessary.</span>
<a name="l00170"></a><a class="code" href="classstxxl_1_1swappable__block.html#ab80d8412231f82ca654baf00a3bc8b8d">00170</a> <span class="comment"></span>    <span class="keywordtype">void</span> clean_sync()
<a name="l00171"></a>00171     {
<a name="l00172"></a>00172         <a class="code" href="classstxxl_1_1request__ptr.html" title="Implemented as reference counting smart pointer.">request_ptr</a> rp = clean_async();
<a name="l00173"></a>00173         <span class="keywordflow">if</span> (rp.<a class="code" href="classstxxl_1_1request__ptr.html#a3684b2b6b1ee2447da7a2f261cff5de3" title="Returns true if object is initialized.">valid</a>())
<a name="l00174"></a>00174             rp-&gt;<a class="code" href="classstxxl_1_1request__interface.html#ac740c3dd58d02842bed4a4e86fe42b22" title="Suspends calling thread until completion of the request.">wait</a>();
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176 <span class="comment"></span>
<a name="l00177"></a>00177 <span class="comment">    //! \brief Attach an internal_block, making the block internal. Has to be not internal.</span>
<a name="l00178"></a><a class="code" href="classstxxl_1_1swappable__block.html#ad2b434ef1b94bfcd09351c773edb1214">00178</a> <span class="comment"></span>    <span class="keywordtype">void</span> attach_internal_block(<a class="code" href="classstxxl_1_1typed__block.html" title="Block containing elements of fixed length.">internal_block_type</a> * iblock)
<a name="l00179"></a>00179     {
<a name="l00180"></a>00180         assert(! is_internal());
<a name="l00181"></a>00181         internal_data = iblock;
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183 <span class="comment"></span>
<a name="l00184"></a>00184 <span class="comment">    //! \brief Detach the internal_block. Writes to external_block if necessary. Has to be evictable.</span>
<a name="l00185"></a>00185 <span class="comment">    //! \return A pointer to the internal_block.</span>
<a name="l00186"></a><a class="code" href="classstxxl_1_1swappable__block.html#aee12f86d2a578fd57dd8dcc2ac63ce76">00186</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1typed__block.html" title="Block containing elements of fixed length.">internal_block_type</a> * detach_internal_block()
<a name="l00187"></a>00187     {
<a name="l00188"></a>00188         assert(is_evictable());
<a name="l00189"></a>00189         clean_sync();
<a name="l00190"></a>00190         <a class="code" href="classstxxl_1_1typed__block.html" title="Block containing elements of fixed length.">internal_block_type</a> * iblock = internal_data;
<a name="l00191"></a>00191         internal_data = 0;
<a name="l00192"></a>00192         <span class="keywordflow">return</span> iblock;
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194 <span class="comment"></span>
<a name="l00195"></a>00195 <span class="comment">    //! \brief Bring the block in uninitialized state, freeing external and internal memory.</span>
<a name="l00196"></a>00196 <span class="comment">    //! Returns a pointer to the internal_block, NULL if it had none.</span>
<a name="l00197"></a>00197 <span class="comment">    //! \return A pointer to the freed internal_block, NULL if it had none.</span>
<a name="l00198"></a><a class="code" href="classstxxl_1_1swappable__block.html#a872bfc0e183fea986915afa967107adc">00198</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1typed__block.html" title="Block containing elements of fixed length.">internal_block_type</a> * deinitialize()
<a name="l00199"></a>00199     {
<a name="l00200"></a>00200         assert(! is_acquired());
<a name="l00201"></a>00201         dirty = <span class="keyword">false</span>;
<a name="l00202"></a>00202         <span class="comment">// free external_block (so that it becomes invalid and the disk-space can be used again)</span>
<a name="l00203"></a>00203         <span class="keywordflow">if</span> (has_external_block())
<a name="l00204"></a>00204             free_external_block();
<a name="l00205"></a>00205         <span class="comment">// free internal_block</span>
<a name="l00206"></a>00206         <a class="code" href="classstxxl_1_1typed__block.html" title="Block containing elements of fixed length.">internal_block_type</a> * iblock = internal_data;
<a name="l00207"></a>00207         internal_data = 0;
<a name="l00208"></a>00208         <span class="keywordflow">return</span> iblock;
<a name="l00209"></a>00209     }
<a name="l00210"></a>00210 <span class="comment"></span>
<a name="l00211"></a>00211 <span class="comment">    //! \brief Set the external_block that holds the swappable_block&#39;s data. The block gets initialized with it.</span>
<a name="l00212"></a>00212 <span class="comment">    //! \param eblock The external_block holding initial data.</span>
<a name="l00213"></a><a class="code" href="classstxxl_1_1swappable__block.html#aff36a529415f519022fed79e8d509415">00213</a> <span class="comment"></span>    <span class="keywordtype">void</span> initialize(<a class="code" href="structstxxl_1_1BID.html">external_block_type</a> eblock)
<a name="l00214"></a>00214     {
<a name="l00215"></a>00215         assert(! is_initialized());
<a name="l00216"></a>00216         external_data = eblock;
<a name="l00217"></a>00217     }
<a name="l00218"></a>00218 <span class="comment"></span>
<a name="l00219"></a>00219 <span class="comment">    //! \brief Extract the swappable_blocks data in an external_block. The block gets uninitialized.</span>
<a name="l00220"></a>00220 <span class="comment">    //! \return The external_block that holds the swappable_block&#39;s data.</span>
<a name="l00221"></a><a class="code" href="classstxxl_1_1swappable__block.html#ac9fd66839e267bc0b0234f7e62c146b2">00221</a> <span class="comment"></span>    <a class="code" href="structstxxl_1_1BID.html">external_block_type</a> extract_external_block()
<a name="l00222"></a>00222     {
<a name="l00223"></a>00223         assert(! is_internal());
<a name="l00224"></a>00224         <a class="code" href="structstxxl_1_1BID.html">external_block_type</a> eblock = external_data;
<a name="l00225"></a>00225         external_data = <a class="code" href="structstxxl_1_1BID.html">external_block_type</a>();
<a name="l00226"></a>00226         <span class="keywordflow">return</span> eblock;
<a name="l00227"></a>00227     }
<a name="l00228"></a>00228 };
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType, <span class="keywordtype">unsigned</span> BlockSize&gt;
<a name="l00231"></a>00231 <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> swappable_block&lt;ValueType, BlockSize&gt;::disk_allocation_offset = 0;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="keyword">template</span> &lt;<span class="keyword">class</span> SwappableBlockType&gt; <span class="keyword">class </span>block_scheduler_algorithm;
<a name="l00234"></a>00234 <span class="keyword">template</span> &lt;<span class="keyword">class</span> SwappableBlockType&gt; <span class="keyword">class </span>block_scheduler_algorithm_online_lru;
<a name="l00235"></a>00235 <span class="comment"></span>
<a name="l00236"></a>00236 <span class="comment">//! \brief Schedules swapping of blocks and provides blocks for temporary storage.</span>
<a name="l00237"></a>00237 <span class="comment">//!</span>
<a name="l00238"></a>00238 <span class="comment">//! In simple mode, it tries to save I/Os through caching only.</span>
<a name="l00239"></a>00239 <span class="comment">//! In simulation mode, it records access patterns into a prediction sequence.</span>
<a name="l00240"></a>00240 <span class="comment">//! The prediction sequence can then be used for prefetching in the (offline) execute mode.</span>
<a name="l00241"></a>00241 <span class="comment">//! This will only work for algorithms with deterministic, data oblivious access patterns.</span>
<a name="l00242"></a>00242 <span class="comment">//! In simulation mode, no I/O is performed; the data provided is accessible but undefined.</span>
<a name="l00243"></a>00243 <span class="comment">//! In execute mode, it does caching, prefetching, and possibly other optimizations.</span>
<a name="l00244"></a>00244 <span class="comment">//! \tparam SwappableBlockType Type of swappable_blocks to manage. Can be some specialized subclass.</span>
<a name="l00245"></a>00245 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> SwappableBlockType&gt;
<a name="l00246"></a><a class="code" href="classstxxl_1_1block__scheduler.html">00246</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler</a> : <span class="keyword">private</span> <a class="code" href="classnoncopyable.html">noncopyable</a>
<a name="l00247"></a>00247 {
<a name="l00248"></a>00248 <span class="keyword">protected</span>:
<a name="l00249"></a>00249     <span class="comment">// tuning-parameter: To acquire blocks, internal memory has to be allocated.</span>
<a name="l00250"></a>00250     <span class="comment">// This constant limits the number of internal_blocks allocated at once.</span>
<a name="l00251"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a2f7628d155e8a8188a7e11bff3e7bdde">00251</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> <a class="code" href="classstxxl_1_1block__scheduler.html#a2f7628d155e8a8188a7e11bff3e7bdde">max_internal_blocks_alloc_at_once</a>;
<a name="l00252"></a>00252 
<a name="l00253"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a354693aa80756064868f8d3e0b85c40e">00253</a>     <span class="keyword">typedef</span> <a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> <a class="code" href="classstxxl_1_1block__scheduler.html#a354693aa80756064868f8d3e0b85c40e">time_type</a>;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 <span class="keyword">public</span>:
<a name="l00256"></a><a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">00256</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> SwappableBlockType::internal_block_type <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">internal_block_type</a>;
<a name="l00257"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a61d55f31ba1e9a6d65671567cb172b8c">00257</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> SwappableBlockType::external_block_type <a class="code" href="classstxxl_1_1block__scheduler.html#a61d55f31ba1e9a6d65671567cb172b8c">external_block_type</a>;
<a name="l00258"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">00258</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;SwappableBlockType&gt;::size_type <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a>;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260     <span class="comment">/*/! Mode the block scheduler currently works in</span>
<a name="l00261"></a>00261 <span class="comment">    enum mode</span>
<a name="l00262"></a>00262 <span class="comment">    {</span>
<a name="l00263"></a>00263 <span class="comment">        online,         //serve requests immediately, without any prediction, LRU caching</span>
<a name="l00264"></a>00264 <span class="comment">        simulation,     //record prediction sequence only, do not serve requests, (returned blocks must not be accessed)</span>
<a name="l00265"></a>00265 <span class="comment">        offline_lfd,    //serve requests based on prediction sequence, using longest-forward-distance caching</span>
<a name="l00266"></a>00266 <span class="comment">        offline_lfd_prefetch     //serve requests based on prediction sequence, using longest-forward-distance caching, and prefetching</span>
<a name="l00267"></a>00267 <span class="comment">    };*/</span>
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="keyword">public</span>:
<a name="l00270"></a>00270     <span class="comment">// -------- prediction_sequence -------</span>
<a name="l00271"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664">00271</a>     <span class="keyword">enum</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664">block_scheduler_operation</a>
<a name="l00272"></a>00272     {
<a name="l00273"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664a29ae9b5557ad6310a40d0e203ea4e36f">00273</a>         <a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664a29ae9b5557ad6310a40d0e203ea4e36f">op_acquire</a>,
<a name="l00274"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664a18acebfafdb17509d2c8917dd73abdfa">00274</a>         <a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664a18acebfafdb17509d2c8917dd73abdfa">op_acquire_uninitialized</a>,
<a name="l00275"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664a201a77b2f6ccf48a0967a6e423eaed78">00275</a>         <a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664a201a77b2f6ccf48a0967a6e423eaed78">op_release</a>,
<a name="l00276"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664ab7ec0872e5cd3eb0455a3a73a2d4ba23">00276</a>         <a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664ab7ec0872e5cd3eb0455a3a73a2d4ba23">op_release_dirty</a>,
<a name="l00277"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664af88a959b3e48f11f1657fbd36e0d9e0c">00277</a>         <a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664af88a959b3e48f11f1657fbd36e0d9e0c">op_deinitialize</a>,
<a name="l00278"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664ad697af9600f8b027fbeed11d312f8683">00278</a>         <a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664ad697af9600f8b027fbeed11d312f8683">op_initialize</a>,
<a name="l00279"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664a2ec149884a94faae8835457d7fea7a4d">00279</a>         op_extract_external_block
<a name="l00280"></a>00280     };
<a name="l00281"></a>00281 
<a name="l00282"></a><a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html">00282</a>     <span class="keyword">struct </span><a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html">prediction_sequence_element</a>
<a name="l00283"></a>00283     {
<a name="l00284"></a><a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html#a4168c87ed890d1499c9eaec6bc6d874c">00284</a>         <a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664">block_scheduler_operation</a> <a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html#a4168c87ed890d1499c9eaec6bc6d874c">op</a>;
<a name="l00285"></a><a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html#ab3b4181105fd8918f0bcd5ba84bbc2e1">00285</a>         <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> <a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html#ab3b4181105fd8918f0bcd5ba84bbc2e1">id</a>;
<a name="l00286"></a><a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html#ad38f52b20832924d6c0c40d4a11b5a5f">00286</a>         <a class="code" href="classstxxl_1_1block__scheduler.html#a354693aa80756064868f8d3e0b85c40e">time_type</a> <a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html#ad38f52b20832924d6c0c40d4a11b5a5f">time</a>;
<a name="l00287"></a>00287 
<a name="l00288"></a><a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html#aa27a2c8f8894465bccc4d8ec9ac56638">00288</a>         <a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html">prediction_sequence_element</a>(<a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664">block_scheduler_operation</a> op,
<a name="l00289"></a>00289                 <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> <span class="keywordtype">id</span>, <a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> time)
<a name="l00290"></a>00290             : op(op), id(id), time(time) {}
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     };
<a name="l00293"></a>00293 
<a name="l00294"></a><a class="code" href="classstxxl_1_1block__scheduler.html#af32d88394597ab0c88b792173272eafa">00294</a>     <span class="keyword">typedef</span> std::deque&lt;prediction_sequence_element&gt; <a class="code" href="classstxxl_1_1block__scheduler.html#af32d88394597ab0c88b792173272eafa">prediction_sequence_type</a>;
<a name="l00295"></a>00295     <span class="comment">// ---- end prediction_sequence -------</span>
<a name="l00296"></a>00296 
<a name="l00297"></a>00297 <span class="keyword">protected</span>:
<a name="l00298"></a><a class="code" href="classstxxl_1_1block__scheduler.html#aee755012f3c70ebd0d83d7b4a9bf9f44">00298</a>     <span class="keyword">template</span> &lt;<span class="keyword">class</span> SBT&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm</a>;
<a name="l00299"></a>00299 
<a name="l00300"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a85ebfd32bf189da3e5d016cd7f455dc7">00300</a>     <span class="keyword">const</span> <a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> <a class="code" href="classstxxl_1_1block__scheduler.html#a85ebfd32bf189da3e5d016cd7f455dc7">max_internal_blocks</a>;
<a name="l00301"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a1bd6b8c9648e7ff801a69d9fb65cbb71">00301</a>     <a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> <a class="code" href="classstxxl_1_1block__scheduler.html#a1bd6b8c9648e7ff801a69d9fb65cbb71">remaining_internal_blocks</a>;<span class="comment"></span>
<a name="l00302"></a>00302 <span class="comment">    //! \brief Stores pointers to arrays of internal_blocks. Used to deallocate them only.</span>
<a name="l00303"></a><a class="code" href="classstxxl_1_1block__scheduler.html#af2fad1fe1a4781c2190a7e8fc072a41a">00303</a> <span class="comment"></span>    std::stack&lt;internal_block_type *&gt; <a class="code" href="classstxxl_1_1block__scheduler.html#af2fad1fe1a4781c2190a7e8fc072a41a" title="Stores pointers to arrays of internal_blocks. Used to deallocate them only.">internal_blocks_blocks</a>;<span class="comment"></span>
<a name="l00304"></a>00304 <span class="comment">    //! \brief holds free internal_blocks with attributes reset</span>
<a name="l00305"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a3ad21f84bba89e992c5eee6e3a9a75d5">00305</a> <span class="comment"></span>    std::stack&lt;internal_block_type * &gt; <a class="code" href="classstxxl_1_1block__scheduler.html#a3ad21f84bba89e992c5eee6e3a9a75d5" title="holds free internal_blocks with attributes reset">free_internal_blocks</a>;<span class="comment"></span>
<a name="l00306"></a>00306 <span class="comment">    //! \brief temporary blocks that will not be needed after algorithm termination</span>
<a name="l00307"></a><a class="code" href="classstxxl_1_1block__scheduler.html#aef43e00f948535cd4f16c3a54e199fae">00307</a> <span class="comment"></span>    <span class="keyword">mutable</span> std::vector&lt;SwappableBlockType&gt; <a class="code" href="classstxxl_1_1block__scheduler.html#aef43e00f948535cd4f16c3a54e199fae" title="temporary blocks that will not be needed after algorithm termination">swappable_blocks</a>;<span class="comment"></span>
<a name="l00308"></a>00308 <span class="comment">    //! \brief holds indices of free swappable_blocks with attributes reset</span>
<a name="l00309"></a>00309 <span class="comment"></span>    std::priority_queue&lt;swappable_block_identifier_type, std::vector&lt;swappable_block_identifier_type&gt;,
<a name="l00310"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a97b8770056b82dd74e229274f98dac6d">00310</a>             std::greater&lt;swappable_block_identifier_type&gt; &gt; <a class="code" href="classstxxl_1_1block__scheduler.html#a97b8770056b82dd74e229274f98dac6d" title="holds indices of free swappable_blocks with attributes reset">free_swappable_blocks</a>;
<a name="l00311"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a717d73d136e3f0750da1942cdbe97f5b">00311</a>     <a class="code" href="classstxxl_1_1block__manager.html" title="Block manager class.">block_manager</a> * <a class="code" href="classstxxl_1_1block__scheduler.html#a717d73d136e3f0750da1942cdbe97f5b">bm</a>;
<a name="l00312"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a8beaa8bbf84339718bc1c9218246e9bf">00312</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm&lt;SwappableBlockType&gt;</a> * <a class="code" href="classstxxl_1_1block__scheduler.html#a8beaa8bbf84339718bc1c9218246e9bf">algo</a>;
<a name="l00313"></a>00313 <span class="comment"></span>
<a name="l00314"></a>00314 <span class="comment">    //! \brief Get an internal_block from the freelist or a newly allocated one if available.</span>
<a name="l00315"></a>00315 <span class="comment">    //! \return Pointer to the internal_block. NULL if none available.</span>
<a name="l00316"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a65e2a45dfa2cc529bd09f165dd849c24">00316</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">internal_block_type</a> * get_free_internal_block()
<a name="l00317"></a>00317     {
<a name="l00318"></a>00318         <span class="keywordflow">if</span> (! free_internal_blocks.empty())
<a name="l00319"></a>00319         {
<a name="l00320"></a>00320             <span class="comment">// =&gt; there are internal_blocks in the free-list</span>
<a name="l00321"></a>00321             <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">internal_block_type</a> * iblock = free_internal_blocks.top();
<a name="l00322"></a>00322             free_internal_blocks.pop();
<a name="l00323"></a>00323             <span class="keywordflow">return</span> iblock;
<a name="l00324"></a>00324         }
<a name="l00325"></a>00325         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (remaining_internal_blocks &gt; 0)
<a name="l00326"></a>00326         {
<a name="l00327"></a>00327             <span class="comment">// =&gt; more internal_blocks can be allocated</span>
<a name="l00328"></a>00328             <a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> num_blocks = std::min(max_internal_blocks_alloc_at_once, remaining_internal_blocks);
<a name="l00329"></a>00329             remaining_internal_blocks -= num_blocks;
<a name="l00330"></a>00330             <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">internal_block_type</a> * iblocks = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">internal_block_type</a>[num_blocks];
<a name="l00331"></a>00331             internal_blocks_blocks.push(iblocks);
<a name="l00332"></a>00332             <span class="keywordflow">for</span> (<a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> i = num_blocks - 1; i &gt; 0; --i)
<a name="l00333"></a>00333                 free_internal_blocks.push(iblocks + i);
<a name="l00334"></a>00334             <span class="keywordflow">return</span> iblocks;
<a name="l00335"></a>00335         }
<a name="l00336"></a>00336         <span class="keywordflow">else</span>
<a name="l00337"></a>00337         {
<a name="l00338"></a>00338             <span class="comment">// =&gt; no internal_block available</span>
<a name="l00339"></a>00339             <span class="keywordflow">return</span> 0;
<a name="l00340"></a>00340         }
<a name="l00341"></a>00341     }
<a name="l00342"></a>00342 <span class="comment"></span>
<a name="l00343"></a>00343 <span class="comment">    //! \brief Return an internal_block to the freelist.</span>
<a name="l00344"></a><a class="code" href="classstxxl_1_1block__scheduler.html#afb7cb6f814b6fc18a370a2dd86ff7ea9">00344</a> <span class="comment"></span>    <span class="keywordtype">void</span> return_free_internal_block(<a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">internal_block_type</a> * iblock)
<a name="l00345"></a>00345     { free_internal_blocks.push(iblock); }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="keyword">public</span>:<span class="comment"></span>
<a name="l00348"></a>00348 <span class="comment">    //! \brief create a block_scheduler with empty prediction sequence in simple mode.</span>
<a name="l00349"></a>00349 <span class="comment">    //! \param max_internal_memory Amount of internal memory (in bytes) the scheduler is allowed to use for acquiring, prefetching and caching.</span>
<a name="l00350"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a6814e7bbadf740386d3df8df3b2d6719">00350</a> <span class="comment"></span>    <span class="keyword">explicit</span> <a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler</a>(<span class="keyword">const</span> <a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> max_internal_memory)
<a name="l00351"></a>00351         : max_internal_blocks(<a class="code" href="namespacestxxl.html#a54c198b5a65673e56bfe8e7488560f32">div_ceil</a>(max_internal_memory, sizeof(<a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">internal_block_type</a>))),
<a name="l00352"></a>00352           remaining_internal_blocks(max_internal_blocks),
<a name="l00353"></a>00353           bm(<a class="code" href="classstxxl_1_1block__manager.html" title="Block manager class.">block_manager</a>::get_instance()),
<a name="l00354"></a>00354           algo(0)
<a name="l00355"></a>00355     { algo = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html" title="Block scheduling algorithm caching via the least recently used policy (online).">block_scheduler_algorithm_online_lru&lt;SwappableBlockType&gt;</a>(*this); }
<a name="l00356"></a>00356 
<a name="l00357"></a><a class="code" href="classstxxl_1_1block__scheduler.html#abfdac0d00d3257776eaba98e81023707">00357</a>     ~<a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler</a>()
<a name="l00358"></a>00358     {
<a name="l00359"></a>00359         <span class="keyword">delete</span> algo;
<a name="l00360"></a>00360         <a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> num_freed_internal_blocks = 0;
<a name="l00361"></a>00361         <span class="keywordflow">if</span> (free_swappable_blocks.size() != swappable_blocks.size())
<a name="l00362"></a>00362         {
<a name="l00363"></a>00363             <span class="comment">// =&gt; not all swappable_blocks are free, at least deinitialize them</span>
<a name="l00364"></a>00364             STXXL_ERRMSG(<span class="stringliteral">&quot;not all swappable_blocks are free, those not acquired will be deinitialized&quot;</span>);
<a name="l00365"></a>00365             <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::vector&lt;SwappableBlockType&gt;::iterator it = swappable_blocks.begin(); <span class="comment">// evictable_blocks would suffice</span>
<a name="l00366"></a>00366                     it != swappable_blocks.end(); ++it)
<a name="l00367"></a>00367                 <span class="keywordflow">if</span> (! it-&gt;is_acquired())
<a name="l00368"></a>00368                     num_freed_internal_blocks += <span class="keywordtype">bool</span>(it-&gt;deinitialize()); <span class="comment">// count internal_blocks that get freed</span>
<a name="l00369"></a>00369         }
<a name="l00370"></a>00370         <span class="keywordflow">if</span> (<a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> nlost = (max_internal_blocks - remaining_internal_blocks)
<a name="l00371"></a>00371                 - (free_internal_blocks.size() + num_freed_internal_blocks))
<a name="l00372"></a>00372             STXXL_ERRMSG(nlost &lt;&lt; <span class="stringliteral">&quot; internal_blocks are lost. They will get deallocated.&quot;</span>);
<a name="l00373"></a>00373         <span class="keywordflow">while</span> (! internal_blocks_blocks.empty())
<a name="l00374"></a>00374         {
<a name="l00375"></a>00375             <span class="keyword">delete</span> [] internal_blocks_blocks.top();
<a name="l00376"></a>00376             internal_blocks_blocks.pop();
<a name="l00377"></a>00377         }
<a name="l00378"></a>00378     }
<a name="l00379"></a>00379 <span class="comment"></span>
<a name="l00380"></a>00380 <span class="comment">    //! \brief Acquire the given block.</span>
<a name="l00381"></a>00381 <span class="comment">    //! Has to be in pairs with release. Pairs may be nested and interleaved.</span>
<a name="l00382"></a>00382 <span class="comment">    //! \return Reference to the block&#39;s data.</span>
<a name="l00383"></a>00383 <span class="comment">    //! \param sblock Swappable block to acquire.</span>
<a name="l00384"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a18207a3b273714d69d260056996f85ae">00384</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">internal_block_type</a> &amp; acquire(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> uninitialized = <span class="keyword">false</span>)
<a name="l00385"></a>00385     { <span class="keywordflow">return</span> algo-&gt;acquire(sbid, uninitialized); }
<a name="l00386"></a>00386 <span class="comment"></span>
<a name="l00387"></a>00387 <span class="comment">    //! \brief Release the given block.</span>
<a name="l00388"></a>00388 <span class="comment">    //! Has to be in pairs with acquire. Pairs may be nested and interleaved.</span>
<a name="l00389"></a>00389 <span class="comment">    //! \param sblock Swappable block to release.</span>
<a name="l00390"></a>00390 <span class="comment">    //! \param dirty If the data has been changed, invalidating possible data in external storage.</span>
<a name="l00391"></a><a class="code" href="classstxxl_1_1block__scheduler.html#af15cd4274e5e8e00fe7a164bf861c50c">00391</a> <span class="comment"></span>    <span class="keywordtype">void</span> release(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> dirty)
<a name="l00392"></a>00392     { algo-&gt;release(sbid, dirty); }
<a name="l00393"></a>00393 <span class="comment"></span>
<a name="l00394"></a>00394 <span class="comment">    //! \brief Drop all data in the given block, freeing in- and external memory.</span>
<a name="l00395"></a><a class="code" href="classstxxl_1_1block__scheduler.html#ab0dc5bdef851f303c2f78b2996f5f16a">00395</a> <span class="comment"></span>    <span class="keywordtype">void</span> deinitialize(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> sbid)
<a name="l00396"></a>00396     { algo-&gt;deinitialize(sbid); }
<a name="l00397"></a>00397 <span class="comment"></span>
<a name="l00398"></a>00398 <span class="comment">    //! \brief Initialize the swappable_block with the given external_block.</span>
<a name="l00399"></a>00399 <span class="comment">    //!</span>
<a name="l00400"></a>00400 <span class="comment">    //! It will use the the external_block for swapping and take care about it&#39;s deallocation. Has to be uninitialized.</span>
<a name="l00401"></a>00401 <span class="comment">    //! \param sbid identifier to the swappable_block</span>
<a name="l00402"></a>00402 <span class="comment">    //! \param eblock external_block a.k.a. bid</span>
<a name="l00403"></a><a class="code" href="classstxxl_1_1block__scheduler.html#abf6a714d3287e3a7443292b7546112d2">00403</a> <span class="comment"></span>    <span class="keywordtype">void</span> initialize(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> sbid, <a class="code" href="classstxxl_1_1block__scheduler.html#a61d55f31ba1e9a6d65671567cb172b8c">external_block_type</a> eblock)
<a name="l00404"></a>00404     { algo-&gt;initialize(sbid, eblock); }
<a name="l00405"></a>00405 <span class="comment"></span>
<a name="l00406"></a>00406 <span class="comment">    //! \brief deinitialize the swappable_block and return it&#39;s contents in an external_block.</span>
<a name="l00407"></a>00407 <span class="comment">    //!</span>
<a name="l00408"></a>00408 <span class="comment">    //! \param sbid identifier to the swappable_block</span>
<a name="l00409"></a>00409 <span class="comment">    //! \return external_block a.k.a. bid</span>
<a name="l00410"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a3490b18520b7f4df24b4f3637d26d23c">00410</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1block__scheduler.html#a61d55f31ba1e9a6d65671567cb172b8c">external_block_type</a> extract_external_block(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> sbid)
<a name="l00411"></a>00411     { <span class="keywordflow">return</span> algo-&gt;extract_external_block(sbid); }
<a name="l00412"></a>00412 <span class="comment"></span>
<a name="l00413"></a>00413 <span class="comment">    //! \brief check if the swappable_block is initialized</span>
<a name="l00414"></a>00414 <span class="comment">    //! \param sbid identifier to the swappable_block</span>
<a name="l00415"></a>00415 <span class="comment">    //! \return if the swappable_block is initialized</span>
<a name="l00416"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a0f06a033d47d9762f88e736d8ae4a3b0">00416</a> <span class="comment"></span>    <span class="keywordtype">bool</span> is_initialized(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> sbid)<span class="keyword"> const</span>
<a name="l00417"></a>00417 <span class="keyword">    </span>{ <span class="keywordflow">return</span> algo-&gt;is_initialized(sbid); }
<a name="l00418"></a>00418 <span class="comment"></span>
<a name="l00419"></a>00419 <span class="comment">    //! \brief Record a timestep in the prediction sequence to seperate consecutive acquire rsp. release-operations.</span>
<a name="l00420"></a>00420 <span class="comment">    //! Has an effect only in simulation mode.</span>
<a name="l00421"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a2c5049ccc0860cb3438236362e1b7ff5">00421</a> <span class="comment"></span>    <span class="keywordtype">void</span> explicit_timestep()
<a name="l00422"></a>00422     { algo-&gt;explicit_timestep(); }
<a name="l00423"></a>00423 <span class="comment"></span>
<a name="l00424"></a>00424 <span class="comment">    //! \brief Get a const reference to given block&#39;s data. Block has to be already acquired.</span>
<a name="l00425"></a>00425 <span class="comment">    //! \param sblock Swappable block to access.</span>
<a name="l00426"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a0d8f32715698e5b6ad7c54e5f2942c38">00426</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">internal_block_type</a> &amp; get_internal_block(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> sbid)<span class="keyword"> const</span>
<a name="l00427"></a>00427 <span class="keyword">    </span>{ <span class="keywordflow">return</span> swappable_blocks[sbid].get_internal_block(); }
<a name="l00428"></a>00428 <span class="comment"></span>
<a name="l00429"></a>00429 <span class="comment">    //! \brief Allocate an uninitialized swappable_block.</span>
<a name="l00430"></a>00430 <span class="comment">    //! \return An identifier of the block.</span>
<a name="l00431"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a5c397590ea370480cc01445880da92a2">00431</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> allocate_swappable_block()
<a name="l00432"></a>00432     {
<a name="l00433"></a>00433         <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> sbid;
<a name="l00434"></a>00434         <span class="keywordflow">if</span> (free_swappable_blocks.empty())
<a name="l00435"></a>00435         {
<a name="l00436"></a>00436             <span class="comment">// create new swappable_block</span>
<a name="l00437"></a>00437             sbid = swappable_blocks.size();
<a name="l00438"></a>00438             swappable_blocks.resize(sbid + 1);
<a name="l00439"></a>00439             algo-&gt;swappable_blocks_resize(sbid + 1);
<a name="l00440"></a>00440         }
<a name="l00441"></a>00441         <span class="keywordflow">else</span>
<a name="l00442"></a>00442         {
<a name="l00443"></a>00443             <span class="comment">// take swappable_block from freelist</span>
<a name="l00444"></a>00444             sbid = free_swappable_blocks.top();
<a name="l00445"></a>00445             free_swappable_blocks.pop();
<a name="l00446"></a>00446         }
<a name="l00447"></a>00447         <span class="keywordflow">return</span> sbid;
<a name="l00448"></a>00448     }
<a name="l00449"></a>00449 <span class="comment"></span>
<a name="l00450"></a>00450 <span class="comment">    //! \brief Free given no longer used temporary swappable_block.</span>
<a name="l00451"></a>00451 <span class="comment">    //! \param sblock Temporary swappable_block to free.</span>
<a name="l00452"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a4704994e6a55bddab50f2b7b36f31c58">00452</a> <span class="comment"></span>    <span class="keywordtype">void</span> free_swappable_block(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> sbid)
<a name="l00453"></a>00453     {
<a name="l00454"></a>00454         deinitialize(sbid);
<a name="l00455"></a>00455         free_swappable_blocks.push(sbid);
<a name="l00456"></a>00456     }
<a name="l00457"></a>00457 <span class="comment"></span>
<a name="l00458"></a>00458 <span class="comment">    //! \brief Returns if simulation mode is on, i.e. if a prediction sequence is being recorded.</span>
<a name="l00459"></a>00459 <span class="comment">    //! \return If simulation mode is on.</span>
<a name="l00460"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a79cdf18e51ac05233722db67a31b369b">00460</a> <span class="comment"></span>    <span class="keywordtype">bool</span> is_simulating()<span class="keyword"> const</span>
<a name="l00461"></a>00461 <span class="keyword">    </span>{ <span class="keywordflow">return</span> algo-&gt;is_simulating(); }
<a name="l00462"></a>00462 <span class="comment"></span>
<a name="l00463"></a>00463 <span class="comment">    //! \brief Switch the used algorithm, e.g. to simulation etc..</span>
<a name="l00464"></a>00464 <span class="comment">    //! \param new_algo Pointer to the new algorithm object. Has to be instantiated to the block scheduler (or the old algorithm object).</span>
<a name="l00465"></a>00465 <span class="comment">    //! \return Pointer to the old algorithm object.</span>
<a name="l00466"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a023226bf5952e8e3c45572e6b9a05899">00466</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm&lt;SwappableBlockType&gt;</a> * switch_algorithm_to(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm&lt;SwappableBlockType&gt;</a> * new_algo)
<a name="l00467"></a>00467     {
<a name="l00468"></a>00468         assert(&amp;new_algo-&gt;<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#af309feba9c42e185ad1fc9e196fdd055">bs</a> == <span class="keyword">this</span>);
<a name="l00469"></a>00469         <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm&lt;SwappableBlockType&gt;</a> * old_algo = algo;
<a name="l00470"></a>00470         algo = new_algo;
<a name="l00471"></a>00471         <span class="keywordflow">return</span> old_algo;
<a name="l00472"></a>00472     }
<a name="l00473"></a>00473 <span class="comment"></span>
<a name="l00474"></a>00474 <span class="comment">    //! \brief get the prediction_sequence</span>
<a name="l00475"></a>00475 <span class="comment">    //! \return reference to the prediction_sequence</span>
<a name="l00476"></a><a class="code" href="classstxxl_1_1block__scheduler.html#ac6b2aa56f946e72d5010ea4b96932698">00476</a> <span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler.html#af32d88394597ab0c88b792173272eafa">prediction_sequence_type</a> &amp; get_prediction_sequence()<span class="keyword"> const</span>
<a name="l00477"></a>00477 <span class="keyword">    </span>{ <span class="keywordflow">return</span> algo-&gt;<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a059c06470d1069faf1806c96f36c1fda">get_prediction_sequence</a>(); }
<a name="l00478"></a>00478 
<a name="l00479"></a><a class="code" href="classstxxl_1_1block__scheduler.html#a098d5c3d955ab11113a02002d9071029">00479</a>     <span class="keywordtype">void</span> flush()
<a name="l00480"></a>00480     {
<a name="l00481"></a>00481         std::vector&lt;request_ptr&gt; requests;
<a name="l00482"></a>00482         <span class="keywordflow">while</span> (! algo-&gt;evictable_blocks_empty())
<a name="l00483"></a>00483         {
<a name="l00484"></a>00484             <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">swappable_block_identifier_type</a> sbid = algo-&gt;evictable_blocks_pop();
<a name="l00485"></a>00485             <a class="code" href="classstxxl_1_1request__ptr.html" title="Implemented as reference counting smart pointer.">request_ptr</a> rq = swappable_blocks[sbid].clean_async();
<a name="l00486"></a>00486             <span class="keywordflow">if</span> (rq.<a class="code" href="classstxxl_1_1request__ptr.html#a3684b2b6b1ee2447da7a2f261cff5de3" title="Returns true if object is initialized.">valid</a>())
<a name="l00487"></a>00487                 requests.push_back(rq);
<a name="l00488"></a>00488             return_free_internal_block(swappable_blocks[sbid].detach_internal_block());
<a name="l00489"></a>00489         }
<a name="l00490"></a>00490         <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::vector&lt;request_ptr&gt;::reverse_iterator it = requests.rbegin();
<a name="l00491"></a>00491                 it != requests.rend(); ++it)
<a name="l00492"></a>00492             (*it)-&gt;wait();
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494 };
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 <span class="keyword">template</span> &lt;<span class="keyword">class</span> SwappableBlockType&gt;
<a name="l00497"></a>00497 <span class="keyword">const</span> <a class="code" href="namespacestxxl.html#add6239ebaf3d1e03a054aee6f1fd52d2">int_type</a> block_scheduler&lt;SwappableBlockType&gt;::max_internal_blocks_alloc_at_once = 128;
<a name="l00498"></a>00498 <span class="comment"></span>
<a name="l00499"></a>00499 <span class="comment">//! \brief Interface of a block scheduling algorithm.</span>
<a name="l00500"></a>00500 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> SwappableBlockType&gt;
<a name="l00501"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html">00501</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm</a> : <span class="keyword">private</span> <a class="code" href="classnoncopyable.html">noncopyable</a>
<a name="l00502"></a>00502 {
<a name="l00503"></a>00503 <span class="keyword">protected</span>:
<a name="l00504"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a7aa480658d54469bd49a8bba3fd80b87">00504</a>     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler&lt;SwappableBlockType&gt;</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a7aa480658d54469bd49a8bba3fd80b87">block_scheduler_type</a>;
<a name="l00505"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">00505</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">block_scheduler_type::internal_block_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a>;
<a name="l00506"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a688d2d348f5e023f2ffa2dfd503e3767">00506</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a61d55f31ba1e9a6d65671567cb172b8c">block_scheduler_type::external_block_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a688d2d348f5e023f2ffa2dfd503e3767">external_block_type</a>;
<a name="l00507"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">00507</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">block_scheduler_type::swappable_block_identifier_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a>;
<a name="l00508"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a117098214cb91f41f8eb6854bcc898d0">00508</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#af32d88394597ab0c88b792173272eafa">block_scheduler_type::prediction_sequence_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a117098214cb91f41f8eb6854bcc898d0">prediction_sequence_type</a>;
<a name="l00509"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a3180e74d6cfa77838173cf757c20b197">00509</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a354693aa80756064868f8d3e0b85c40e">block_scheduler_type::time_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a3180e74d6cfa77838173cf757c20b197">time_type</a>;
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 <span class="keyword">public</span>:
<a name="l00512"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#af309feba9c42e185ad1fc9e196fdd055">00512</a>     <a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler_type</a> &amp; <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#af309feba9c42e185ad1fc9e196fdd055">bs</a>;
<a name="l00513"></a>00513 <span class="keyword">protected</span>:
<a name="l00514"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#af1e0b0b475976718f9df5c978fd831a1">00514</a>     std::vector&lt;SwappableBlockType&gt; &amp; <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#af1e0b0b475976718f9df5c978fd831a1">swappable_blocks</a>;
<a name="l00515"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a085807eedd6cd7d6092b7731b395ae9f">00515</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a117098214cb91f41f8eb6854bcc898d0">prediction_sequence_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a085807eedd6cd7d6092b7731b395ae9f">prediction_sequence</a>;
<a name="l00516"></a>00516 
<a name="l00517"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a3efd0ff39461bc6115c7d95a2bc56219">00517</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm</a> * get_algorithm_from_block_scheduler()
<a name="l00518"></a>00518     { <span class="keywordflow">return</span> bs.algo; }
<a name="l00519"></a>00519 <span class="comment"></span>
<a name="l00520"></a>00520 <span class="comment">    //! \brief Get an internal_block from the block_scheduler.</span>
<a name="l00521"></a>00521 <span class="comment">    //! \return Pointer to the internal_block. NULL if none available.</span>
<a name="l00522"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a5e8d47d9b7ede49e71c603ebc53c34c0">00522</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * get_free_internal_block_from_block_scheduler()
<a name="l00523"></a>00523     { <span class="keywordflow">return</span> bs.get_free_internal_block(); }
<a name="l00524"></a>00524 <span class="comment"></span>
<a name="l00525"></a>00525 <span class="comment">    //! \brief Return an internal_block to the block_scheduler.</span>
<a name="l00526"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#aba6fcf8ac2d74213701c135696cfe103">00526</a> <span class="comment"></span>    <span class="keywordtype">void</span> return_free_internal_block_to_block_scheduler(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock)
<a name="l00527"></a>00527     { bs.return_free_internal_block(iblock); }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="keyword">public</span>:
<a name="l00530"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a9010803037a344ef3705a22e3723cc01">00530</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm</a>(<a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler_type</a> &amp; bs)
<a name="l00531"></a>00531         : bs(bs),
<a name="l00532"></a>00532           swappable_blocks(bs.swappable_blocks)
<a name="l00533"></a>00533     {}
<a name="l00534"></a>00534 
<a name="l00535"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a3511b35486b0679b0957e5a4c6a824f3">00535</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm</a>(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm</a> * old)
<a name="l00536"></a>00536         : bs(old-&gt;bs),
<a name="l00537"></a>00537           swappable_blocks(bs.swappable_blocks)
<a name="l00538"></a>00538     {}
<a name="l00539"></a>00539 
<a name="l00540"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a73a060aaceb3857fa9a02cd5e712b650">00540</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a73a060aaceb3857fa9a02cd5e712b650">~block_scheduler_algorithm</a>() {};
<a name="l00541"></a>00541 
<a name="l00542"></a>00542     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> evictable_blocks_empty() = 0;
<a name="l00543"></a>00543     <span class="keyword">virtual</span> swappable_block_identifier_type evictable_blocks_pop() = 0;
<a name="l00544"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a689782ee68f2ef9584bc81f4dadd670a">00544</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a689782ee68f2ef9584bc81f4dadd670a">swappable_blocks_resize</a>(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> <span class="comment">/*size*/</span>) {}
<a name="l00545"></a>00545 
<a name="l00546"></a>00546     <span class="keyword">virtual</span> internal_block_type &amp; acquire(<span class="keyword">const</span> swappable_block_identifier_type sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> uninitialized = <span class="keyword">false</span>) = 0;
<a name="l00547"></a>00547     <span class="keyword">virtual</span> <span class="keywordtype">void</span> release(swappable_block_identifier_type sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> dirty) = 0;
<a name="l00548"></a>00548     <span class="keyword">virtual</span> <span class="keywordtype">void</span> deinitialize(swappable_block_identifier_type sbid) = 0;
<a name="l00549"></a>00549     <span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize(swappable_block_identifier_type sbid, external_block_type eblock) = 0;
<a name="l00550"></a>00550     <span class="keyword">virtual</span> external_block_type extract_external_block(swappable_block_identifier_type sbid) = 0;
<a name="l00551"></a>00551 
<a name="l00552"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a2e3d0a4ecc042150e333f1325edd5ddb">00552</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_initialized(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid)<span class="keyword"> const</span>
<a name="l00553"></a>00553 <span class="keyword">        </span>{ <span class="keywordflow">return</span> swappable_blocks[sbid].is_initialized(); }
<a name="l00554"></a>00554 
<a name="l00555"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ac3b773d78bd95f72dae2fbc7ede5ba75">00555</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ac3b773d78bd95f72dae2fbc7ede5ba75">explicit_timestep</a>() {}
<a name="l00556"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a480224f1272cd6517c6df5a8102e6265">00556</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_simulating()<span class="keyword"> const</span>
<a name="l00557"></a>00557 <span class="keyword">        </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00558"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a059c06470d1069faf1806c96f36c1fda">00558</a>     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a117098214cb91f41f8eb6854bcc898d0">prediction_sequence_type</a> &amp; get_prediction_sequence()<span class="keyword"> const</span>
<a name="l00559"></a>00559 <span class="keyword">        </span>{ <span class="keywordflow">return</span> prediction_sequence; }
<a name="l00560"></a>00560 };
<a name="l00561"></a>00561 <span class="comment"></span>
<a name="l00562"></a>00562 <span class="comment">//! \brief Block scheduling algorithm caching via the least recently used policy (online).</span>
<a name="l00563"></a>00563 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> SwappableBlockType&gt;
<a name="l00564"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html">00564</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html" title="Block scheduling algorithm caching via the least recently used policy (online).">block_scheduler_algorithm_online_lru</a> : <span class="keyword">public</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm</a>&lt;SwappableBlockType&gt;
<a name="l00565"></a>00565 {
<a name="l00566"></a>00566 <span class="keyword">protected</span>:
<a name="l00567"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a47773f2914fb0803486abe09aed22fb7">00567</a>     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler&lt;SwappableBlockType&gt;</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a47773f2914fb0803486abe09aed22fb7">block_scheduler_type</a>;
<a name="l00568"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a22ae307a6132728d847301f8dcefee46">00568</a>     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm&lt;SwappableBlockType&gt;</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a22ae307a6132728d847301f8dcefee46">block_scheduler_algorithm_type</a>;
<a name="l00569"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a3cf1f79fd43030b888270606a3eb1a7d">00569</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">block_scheduler_type::internal_block_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a3cf1f79fd43030b888270606a3eb1a7d">internal_block_type</a>;
<a name="l00570"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a326322bf01386cd2677dd1db0ec8cefd">00570</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a61d55f31ba1e9a6d65671567cb172b8c">block_scheduler_type::external_block_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a326322bf01386cd2677dd1db0ec8cefd">external_block_type</a>;
<a name="l00571"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a0a46913facc96d2db4a0147668506e3c">00571</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">block_scheduler_type::swappable_block_identifier_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a0a46913facc96d2db4a0147668506e3c">swappable_block_identifier_type</a>;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573     <span class="keyword">using</span> block_scheduler_algorithm_type::bs;
<a name="l00574"></a>00574     <span class="keyword">using</span> block_scheduler_algorithm_type::swappable_blocks;
<a name="l00575"></a>00575     <span class="keyword">using</span> block_scheduler_algorithm_type::get_algorithm_from_block_scheduler;
<a name="l00576"></a>00576     <span class="keyword">using</span> block_scheduler_algorithm_type::get_free_internal_block_from_block_scheduler;
<a name="l00577"></a>00577     <span class="keyword">using</span> block_scheduler_algorithm_type::return_free_internal_block_to_block_scheduler;
<a name="l00578"></a>00578 <span class="comment"></span>
<a name="l00579"></a>00579 <span class="comment">    //! \brief Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired.</span>
<a name="l00580"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a60d3e6e4e0fefff6a7e504ebb517a661">00580</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1addressable__fifo__queue.html">addressable_fifo_queue&lt;swappable_block_identifier_type&gt;</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a60d3e6e4e0fefff6a7e504ebb517a661" title="Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired...">evictable_blocks</a>;
<a name="l00581"></a>00581 
<a name="l00582"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#ab7b76072efd97ea017a04d10ff4e7d6d">00582</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * get_free_internal_block()
<a name="l00583"></a>00583     {
<a name="l00584"></a>00584         <span class="comment">// try to get a free internal_block</span>
<a name="l00585"></a>00585         <span class="keywordflow">if</span> (<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock = get_free_internal_block_from_block_scheduler())
<a name="l00586"></a>00586             <span class="keywordflow">return</span> iblock;
<a name="l00587"></a>00587         <span class="comment">// evict block</span>
<a name="l00588"></a>00588         assert(! evictable_blocks.empty()); <span class="comment">// fails it there is not enough memory available</span>
<a name="l00589"></a>00589         <span class="keywordflow">return</span> swappable_blocks[evictable_blocks.pop()].detach_internal_block();
<a name="l00590"></a>00590     }
<a name="l00591"></a>00591 
<a name="l00592"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a6b377c02c193b954cbeb95242e111931">00592</a>     <span class="keywordtype">void</span> return_free_internal_block(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock)
<a name="l00593"></a>00593     { return_free_internal_block_to_block_scheduler(iblock); }
<a name="l00594"></a>00594 
<a name="l00595"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a50586f9247ff1115ee6ab077de53e204">00595</a>     <span class="keywordtype">void</span> <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>()
<a name="l00596"></a>00596     {
<a name="l00597"></a>00597         <span class="keywordflow">if</span> (get_algorithm_from_block_scheduler())
<a name="l00598"></a>00598             <span class="keywordflow">while</span> (! get_algorithm_from_block_scheduler()-&gt;evictable_blocks_empty())
<a name="l00599"></a>00599                 evictable_blocks.insert(get_algorithm_from_block_scheduler()-&gt;evictable_blocks_pop());
<a name="l00600"></a>00600     }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602 <span class="keyword">public</span>:
<a name="l00603"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#adf27aa7c5395ae589a0b9f267e19687b">00603</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html" title="Block scheduling algorithm caching via the least recently used policy (online).">block_scheduler_algorithm_online_lru</a>(<a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler_type</a> &amp; bs)
<a name="l00604"></a>00604         : <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a>(bs)
<a name="l00605"></a>00605     { <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>(); }
<a name="l00606"></a>00606 
<a name="l00607"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a656de54faeb04d4966cf5de1b2ce892f">00607</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html" title="Block scheduling algorithm caching via the least recently used policy (online).">block_scheduler_algorithm_online_lru</a>(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a> * old)
<a name="l00608"></a>00608         : <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a>(old)
<a name="l00609"></a>00609     { <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>(); }
<a name="l00610"></a>00610 
<a name="l00611"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a73c8c3fac495624d3764069b98f7cf18">00611</a>     <span class="keyword">virtual</span> ~<a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html" title="Block scheduling algorithm caching via the least recently used policy (online).">block_scheduler_algorithm_online_lru</a>()
<a name="l00612"></a>00612     {
<a name="l00613"></a>00613         <span class="keywordflow">if</span> (! evictable_blocks.empty())
<a name="l00614"></a>00614             STXXL_ERRMSG(<span class="stringliteral">&quot;Destructing block_scheduler_algorithm_online that still holds evictable blocks. They get deinitialized.&quot;</span>);
<a name="l00615"></a>00615         <span class="keywordflow">while</span> (! evictable_blocks.empty())
<a name="l00616"></a>00616         {
<a name="l00617"></a>00617             SwappableBlockType &amp; sblock = swappable_blocks[evictable_blocks.pop()];
<a name="l00618"></a>00618             <span class="keywordflow">if</span> (<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock = sblock.deinitialize())
<a name="l00619"></a>00619                 return_free_internal_block(iblock);
<a name="l00620"></a>00620         }
<a name="l00621"></a>00621     }
<a name="l00622"></a>00622 
<a name="l00623"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a4fe767f02671afa478901a9812658d50">00623</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> evictable_blocks_empty()
<a name="l00624"></a>00624     { <span class="keywordflow">return</span> evictable_blocks.empty(); }
<a name="l00625"></a>00625 
<a name="l00626"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#afd1812ef75949fda17466db2a5700103">00626</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> evictable_blocks_pop()
<a name="l00627"></a>00627     { <span class="keywordflow">return</span> evictable_blocks.pop(); }
<a name="l00628"></a>00628 
<a name="l00629"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a9466198ff87b6a3f6fd40851f1f359a7">00629</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> &amp; acquire(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> uninitialized = <span class="keyword">false</span>)
<a name="l00630"></a>00630     {
<a name="l00631"></a>00631         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l00632"></a>00632         <span class="comment">/* acquired =&gt; internal -&gt; increase reference count</span>
<a name="l00633"></a>00633 <span class="comment">           internal but not acquired -&gt; remove from evictable_blocks, increase reference count</span>
<a name="l00634"></a>00634 <span class="comment">           not internal =&gt; uninitialized or external -&gt; get internal_block, increase reference count</span>
<a name="l00635"></a>00635 <span class="comment">           uninitialized -&gt; fill with default value</span>
<a name="l00636"></a>00636 <span class="comment">           external -&gt; read */</span>
<a name="l00637"></a>00637         <span class="keywordflow">if</span> (sblock.is_internal())
<a name="l00638"></a>00638         {
<a name="l00639"></a>00639             <span class="keywordflow">if</span> (! sblock.is_acquired())
<a name="l00640"></a>00640                 <span class="comment">// not acquired yet -&gt; remove from evictable_blocks</span>
<a name="l00641"></a>00641                 evictable_blocks.erase(sbid);
<a name="l00642"></a>00642             sblock.<a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a9466198ff87b6a3f6fd40851f1f359a7">acquire</a>();
<a name="l00643"></a>00643         }
<a name="l00644"></a>00644         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sblock.is_initialized())
<a name="l00645"></a>00645         {
<a name="l00646"></a>00646             <span class="comment">// =&gt; external but not internal</span>
<a name="l00647"></a>00647             <span class="comment">//get internal_block</span>
<a name="l00648"></a>00648             sblock.attach_internal_block(get_free_internal_block());
<a name="l00649"></a>00649             <span class="keywordflow">if</span> (! uninitialized)
<a name="l00650"></a>00650                 <span class="comment">//load block synchronously</span>
<a name="l00651"></a>00651                 sblock.read_sync();
<a name="l00652"></a>00652             sblock.acquire();
<a name="l00653"></a>00653         }
<a name="l00654"></a>00654         <span class="keywordflow">else</span>
<a name="l00655"></a>00655         {
<a name="l00656"></a>00656             <span class="comment">// =&gt; ! sblock.is_initialized()</span>
<a name="l00657"></a>00657             <span class="comment">//get internal_block</span>
<a name="l00658"></a>00658             sblock.attach_internal_block(get_free_internal_block());
<a name="l00659"></a>00659             sblock.acquire();
<a name="l00660"></a>00660             <span class="comment">//initialize new block</span>
<a name="l00661"></a>00661             <span class="keywordflow">if</span> (! uninitialized)
<a name="l00662"></a>00662                 sblock.fill_default();
<a name="l00663"></a>00663         }
<a name="l00664"></a>00664         <span class="keywordflow">return</span> sblock.get_internal_block();
<a name="l00665"></a>00665     }
<a name="l00666"></a>00666 
<a name="l00667"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#ab63f83b9405ac02f385cdbefe50cd8c4">00667</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> release(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> dirty)
<a name="l00668"></a>00668     {
<a name="l00669"></a>00669         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l00670"></a>00670         sblock.make_dirty_if(dirty);
<a name="l00671"></a>00671         sblock.release();
<a name="l00672"></a>00672         <span class="keywordflow">if</span> (! sblock.is_acquired())
<a name="l00673"></a>00673         {
<a name="l00674"></a>00674             <span class="keywordflow">if</span> (sblock.is_dirty() || sblock.is_external())
<a name="l00675"></a>00675                 <span class="comment">// =&gt; evictable, put in pq</span>
<a name="l00676"></a>00676                 evictable_blocks.insert(sbid);
<a name="l00677"></a>00677             <span class="keywordflow">else</span>
<a name="l00678"></a>00678                 <span class="comment">// =&gt; uninitialized, release internal block and put it in freelist</span>
<a name="l00679"></a>00679                 return_free_internal_block(sblock.detach_internal_block());
<a name="l00680"></a>00680         }
<a name="l00681"></a>00681     }
<a name="l00682"></a>00682 
<a name="l00683"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a89d5f7af1d55a43e48e91c6ea2acedd5">00683</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> deinitialize(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid)
<a name="l00684"></a>00684     {
<a name="l00685"></a>00685         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l00686"></a>00686         <span class="keywordflow">if</span> (sblock.is_evictable())
<a name="l00687"></a>00687             evictable_blocks.erase(sbid);
<a name="l00688"></a>00688         <span class="keywordflow">if</span> (<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock = sblock.deinitialize())
<a name="l00689"></a>00689             return_free_internal_block(iblock);
<a name="l00690"></a>00690     }
<a name="l00691"></a>00691 
<a name="l00692"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#ae364f773e92242c5e1f3f22908760c38">00692</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a688d2d348f5e023f2ffa2dfd503e3767">external_block_type</a> eblock)
<a name="l00693"></a>00693     {
<a name="l00694"></a>00694         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l00695"></a>00695         sblock.initialize(eblock);
<a name="l00696"></a>00696     }
<a name="l00697"></a>00697 
<a name="l00698"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#a3fbf29e3baff0d26f666e11a015bf36f">00698</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a688d2d348f5e023f2ffa2dfd503e3767">external_block_type</a> extract_external_block(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid)
<a name="l00699"></a>00699     {
<a name="l00700"></a>00700         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l00701"></a>00701         <span class="keywordflow">if</span> (sblock.is_evictable())
<a name="l00702"></a>00702             evictable_blocks.erase(sbid);
<a name="l00703"></a>00703         <span class="keywordflow">if</span> (sblock.is_internal())
<a name="l00704"></a>00704             return_free_internal_block(sblock.detach_internal_block());
<a name="l00705"></a>00705         <span class="keywordflow">return</span> sblock.extract_external_block();
<a name="l00706"></a>00706     }
<a name="l00707"></a>00707 };
<a name="l00708"></a>00708 <span class="comment"></span>
<a name="l00709"></a>00709 <span class="comment">//! \brief Pseudo block scheduling algorithm only recording the request sequence.</span>
<a name="l00710"></a>00710 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> SwappableBlockType&gt;
<a name="l00711"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html">00711</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html" title="Pseudo block scheduling algorithm only recording the request sequence.">block_scheduler_algorithm_simulation</a> : <span class="keyword">public</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm</a>&lt;SwappableBlockType&gt;
<a name="l00712"></a>00712 {
<a name="l00713"></a>00713 <span class="keyword">protected</span>:
<a name="l00714"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#ae0821c64b3d08fc2919de8d7eb48a79e">00714</a>     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler&lt;SwappableBlockType&gt;</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#ae0821c64b3d08fc2919de8d7eb48a79e">block_scheduler_type</a>;
<a name="l00715"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a75418084f8f87582c74a26054ce810f5">00715</a>     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm&lt;SwappableBlockType&gt;</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a75418084f8f87582c74a26054ce810f5">block_scheduler_algorithm_type</a>;
<a name="l00716"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a69411e687e9f699a6717b8f93b7bffa2">00716</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">block_scheduler_type::internal_block_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a69411e687e9f699a6717b8f93b7bffa2">internal_block_type</a>;
<a name="l00717"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a3ee9c52371b779e5e32298dfc6ad7242">00717</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a61d55f31ba1e9a6d65671567cb172b8c">block_scheduler_type::external_block_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a3ee9c52371b779e5e32298dfc6ad7242">external_block_type</a>;
<a name="l00718"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#abd833d141e9c484946ae6e021488996d">00718</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">block_scheduler_type::swappable_block_identifier_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#abd833d141e9c484946ae6e021488996d">swappable_block_identifier_type</a>;
<a name="l00719"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#ac78e67c44fe70392c3d1cc56fd316302">00719</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html">block_scheduler_type::prediction_sequence_element</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#ac78e67c44fe70392c3d1cc56fd316302">prediction_sequence_element_type</a>;
<a name="l00720"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a2d498be7696dcbff03a9009d0ba410ef">00720</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a3180e74d6cfa77838173cf757c20b197">block_scheduler_algorithm_type::time_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a2d498be7696dcbff03a9009d0ba410ef">time_type</a>;
<a name="l00721"></a>00721 
<a name="l00722"></a>00722     <span class="keyword">using</span> block_scheduler_algorithm_type::bs;
<a name="l00723"></a>00723     <span class="keyword">using</span> block_scheduler_algorithm_type::prediction_sequence;
<a name="l00724"></a>00724     <span class="keyword">using</span> block_scheduler_algorithm_type::swappable_blocks;
<a name="l00725"></a>00725     <span class="keyword">using</span> block_scheduler_algorithm_type::get_algorithm_from_block_scheduler;
<a name="l00726"></a>00726     <span class="keyword">using</span> block_scheduler_algorithm_type::get_free_internal_block_from_block_scheduler;
<a name="l00727"></a>00727     <span class="keyword">using</span> block_scheduler_algorithm_type::return_free_internal_block_to_block_scheduler;
<a name="l00728"></a>00728 <span class="comment"></span>
<a name="l00729"></a>00729 <span class="comment">    //! \brief Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired.</span>
<a name="l00730"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a41eb3ddfbe35e8528b9dae4bf62a9bc0">00730</a> <span class="comment"></span>    std::stack&lt;swappable_block_identifier_type&gt; <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a41eb3ddfbe35e8528b9dae4bf62a9bc0" title="Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired...">evictable_blocks</a>;
<a name="l00731"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a2090e5622c587af102d59042e7843b23">00731</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a3180e74d6cfa77838173cf757c20b197">time_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a2090e5622c587af102d59042e7843b23">time_count</a>;
<a name="l00732"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a8aa0d5185a48e05983630d5170e220a3">00732</a>     <span class="keywordtype">bool</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a8aa0d5185a48e05983630d5170e220a3">last_op_release</a>;
<a name="l00733"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a06bca62c688dba9f7f1a61d941a0e240">00733</a>     std::vector&lt;int_type&gt; <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a06bca62c688dba9f7f1a61d941a0e240">reference_counts</a>;
<a name="l00734"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#afc7cd4c92aacaeba89d436525acf83da">00734</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#afc7cd4c92aacaeba89d436525acf83da">dummy_block</a>;
<a name="l00735"></a>00735 
<a name="l00736"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a8ca0ab112127d0c3bf989729c70c3f5c">00736</a>     <span class="keywordtype">void</span> return_free_internal_block(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock)
<a name="l00737"></a>00737     { return_free_internal_block_to_block_scheduler(iblock); }
<a name="l00738"></a>00738 
<a name="l00739"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#af4d388624ea9ade69a35824fde2050cf">00739</a>     <span class="keywordtype">void</span> <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>()
<a name="l00740"></a>00740     {
<a name="l00741"></a>00741         <span class="keywordflow">if</span> (get_algorithm_from_block_scheduler())
<a name="l00742"></a>00742             <span class="keywordflow">while</span> (! get_algorithm_from_block_scheduler()-&gt;evictable_blocks_empty())
<a name="l00743"></a>00743                 evictable_blocks.push(get_algorithm_from_block_scheduler()-&gt;evictable_blocks_pop());
<a name="l00744"></a>00744         <span class="keywordflow">for</span> (<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> i = 0; i &lt; reference_counts.size(); ++i)
<a name="l00745"></a>00745             reference_counts[i] = swappable_blocks[i].is_initialized();
<a name="l00746"></a>00746     }
<a name="l00747"></a>00747 
<a name="l00748"></a>00748 <span class="keyword">public</span>:
<a name="l00749"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a434bbe8bae538a59b5ceff9e57b631c4">00749</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html" title="Pseudo block scheduling algorithm only recording the request sequence.">block_scheduler_algorithm_simulation</a>(<a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler_type</a> &amp; bs)
<a name="l00750"></a>00750         : <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a>(bs),
<a name="l00751"></a>00751           time_count(0),
<a name="l00752"></a>00752           last_op_release(false),
<a name="l00753"></a>00753           reference_counts(swappable_blocks.size())
<a name="l00754"></a>00754     { <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>(); }
<a name="l00755"></a>00755 
<a name="l00756"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#ac8b03b6abc63cd9a106f254eb4d02eed">00756</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html" title="Pseudo block scheduling algorithm only recording the request sequence.">block_scheduler_algorithm_simulation</a>(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a> * old)
<a name="l00757"></a>00757         : <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a>(old),
<a name="l00758"></a>00758           time_count(0),
<a name="l00759"></a>00759           last_op_release(false),
<a name="l00760"></a>00760           reference_counts(swappable_blocks.size())
<a name="l00761"></a>00761     { <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>(); }
<a name="l00762"></a>00762 
<a name="l00763"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a58ccfaa5ad80162e7a298afb866fe3b7">00763</a>     <span class="keyword">virtual</span> ~<a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html" title="Pseudo block scheduling algorithm only recording the request sequence.">block_scheduler_algorithm_simulation</a>()
<a name="l00764"></a>00764     {
<a name="l00765"></a>00765         <span class="keywordflow">if</span> (! evictable_blocks.empty())
<a name="l00766"></a>00766             STXXL_ERRMSG(<span class="stringliteral">&quot;Destructing block_scheduler_algorithm_record_prediction_sequence that still holds evictable blocks. They get deinitialized.&quot;</span>);
<a name="l00767"></a>00767         <span class="keywordflow">while</span> (! evictable_blocks.empty())
<a name="l00768"></a>00768         {
<a name="l00769"></a>00769             SwappableBlockType &amp; sblock = swappable_blocks[evictable_blocks.top()];
<a name="l00770"></a>00770             <span class="keywordflow">if</span> (<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock = sblock.deinitialize())
<a name="l00771"></a>00771                 return_free_internal_block(iblock);
<a name="l00772"></a>00772             evictable_blocks.pop();
<a name="l00773"></a>00773         }
<a name="l00774"></a>00774     }
<a name="l00775"></a>00775 
<a name="l00776"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a1a8742c089815312e6ad6a6ab8b4e66d">00776</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> evictable_blocks_empty()
<a name="l00777"></a>00777     { <span class="keywordflow">return</span> evictable_blocks.empty(); }
<a name="l00778"></a>00778 
<a name="l00779"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#abfca40fefb1808cff4eb142037ba95d1">00779</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> evictable_blocks_pop()
<a name="l00780"></a>00780     {
<a name="l00781"></a>00781         <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid = evictable_blocks.top();
<a name="l00782"></a>00782         evictable_blocks.pop();
<a name="l00783"></a>00783         <span class="keywordflow">return</span> sbid;
<a name="l00784"></a>00784     }
<a name="l00785"></a>00785 
<a name="l00786"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#ad7953b9b53549e70688870a5a1d66a28">00786</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> &amp; acquire(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> uninitialized = <span class="keyword">false</span>)
<a name="l00787"></a>00787     {
<a name="l00788"></a>00788         ++reference_counts[sbid];
<a name="l00789"></a>00789         last_op_release = <span class="keyword">false</span>;
<a name="l00790"></a>00790         <span class="keywordflow">if</span> (uninitialized)
<a name="l00791"></a>00791             prediction_sequence.push_back(<a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html">prediction_sequence_element_type</a>
<a name="l00792"></a>00792                     (block_scheduler_type::op_acquire_uninitialized, sbid, time_count));
<a name="l00793"></a>00793         <span class="keywordflow">else</span>
<a name="l00794"></a>00794             prediction_sequence.push_back(<a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html">prediction_sequence_element_type</a>
<a name="l00795"></a>00795                     (block_scheduler_type::op_acquire, sbid, time_count));
<a name="l00796"></a>00796         <span class="keywordflow">return</span> dummy_block;
<a name="l00797"></a>00797     }
<a name="l00798"></a>00798 
<a name="l00799"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#ae3aa47bbbbc161de8607bfe253aab9e2">00799</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> release(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> dirty)
<a name="l00800"></a>00800     {
<a name="l00801"></a>00801         --reference_counts[sbid] += dirty;
<a name="l00802"></a>00802         time_count += ! last_op_release;
<a name="l00803"></a>00803         last_op_release = <span class="keyword">true</span>;
<a name="l00804"></a>00804         <span class="keywordflow">if</span> (dirty)
<a name="l00805"></a>00805             prediction_sequence.push_back(<a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html">prediction_sequence_element_type</a>
<a name="l00806"></a>00806                     (block_scheduler_type::op_release_dirty, sbid, time_count));
<a name="l00807"></a>00807         <span class="keywordflow">else</span>
<a name="l00808"></a>00808             prediction_sequence.push_back(<a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html">prediction_sequence_element_type</a>
<a name="l00809"></a>00809                     (block_scheduler_type::op_release, sbid, time_count));
<a name="l00810"></a>00810     }
<a name="l00811"></a>00811 
<a name="l00812"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a1950fefd878efe49b4e1e02a34dd5c30">00812</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> deinitialize(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid)
<a name="l00813"></a>00813     {
<a name="l00814"></a>00814         reference_counts[sbid] = <span class="keyword">false</span>;
<a name="l00815"></a>00815         prediction_sequence.push_back(<a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html">prediction_sequence_element_type</a>
<a name="l00816"></a>00816                 (block_scheduler_type::op_deinitialize, sbid, time_count));
<a name="l00817"></a>00817     }
<a name="l00818"></a>00818 
<a name="l00819"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a1bc09400046b9b62d7977f4dff5e442c">00819</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a688d2d348f5e023f2ffa2dfd503e3767">external_block_type</a>)
<a name="l00820"></a>00820     {
<a name="l00821"></a>00821         reference_counts[sbid] = <span class="keyword">true</span>;
<a name="l00822"></a>00822         prediction_sequence.push_back(<a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html">prediction_sequence_element_type</a>
<a name="l00823"></a>00823                 (block_scheduler_type::op_initialize, sbid, time_count));
<a name="l00824"></a>00824     }
<a name="l00825"></a>00825 
<a name="l00826"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#af3110fade4db2bbf84349468bbd0fc14">00826</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a688d2d348f5e023f2ffa2dfd503e3767">external_block_type</a> extract_external_block(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid)
<a name="l00827"></a>00827     {
<a name="l00828"></a>00828         reference_counts[sbid] = <span class="keyword">false</span>;
<a name="l00829"></a>00829         prediction_sequence.push_back(<a class="code" href="structstxxl_1_1block__scheduler_1_1prediction__sequence__element.html">prediction_sequence_element_type</a>
<a name="l00830"></a>00830                 (block_scheduler_type::op_extract_external_block, sbid, time_count));
<a name="l00831"></a>00831         <span class="keywordflow">return</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a688d2d348f5e023f2ffa2dfd503e3767">external_block_type</a>();
<a name="l00832"></a>00832     }
<a name="l00833"></a>00833 
<a name="l00834"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a27a46bd0d8b1a5e66e323a634567925f">00834</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> swappable_blocks_resize(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> size)
<a name="l00835"></a>00835     {
<a name="l00836"></a>00836         reference_counts.resize(size, 0);
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838 
<a name="l00839"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a1e20478d2f67a74b0fac59d490914ab1">00839</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_initialized(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid)<span class="keyword"> const</span>
<a name="l00840"></a>00840 <span class="keyword">    </span>{
<a name="l00841"></a>00841         <span class="keywordflow">return</span> reference_counts[sbid] &gt; 0;
<a name="l00842"></a>00842     }
<a name="l00843"></a>00843 
<a name="l00844"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a5f46e0029f83fdcf816d385908aae531">00844</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> explicit_timestep()
<a name="l00845"></a>00845     { ++time_count; };
<a name="l00846"></a>00846 
<a name="l00847"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__simulation.html#a00d1967e1c4a6cd35baadaff303ab9af">00847</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_simulating()<span class="keyword"> const</span>
<a name="l00848"></a>00848 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00849"></a>00849 };
<a name="l00850"></a>00850 <span class="comment"></span>
<a name="l00851"></a>00851 <span class="comment">//! \brief Block scheduling algorithm caching via the longest forward distance policy (offline).</span>
<a name="l00852"></a>00852 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> SwappableBlockType&gt;
<a name="l00853"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html">00853</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html" title="Block scheduling algorithm caching via the longest forward distance policy (offline).">block_scheduler_algorithm_offline_lfd</a> : <span class="keyword">public</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm</a>&lt;SwappableBlockType&gt;
<a name="l00854"></a>00854 {
<a name="l00855"></a>00855 <span class="keyword">protected</span>:
<a name="l00856"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#ab279053f8615be69fac23784fc7e3adb">00856</a>     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler&lt;SwappableBlockType&gt;</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#ab279053f8615be69fac23784fc7e3adb">block_scheduler_type</a>;
<a name="l00857"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a0adb0601b30d381eaba0efa45d8189b0">00857</a>     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm&lt;SwappableBlockType&gt;</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a0adb0601b30d381eaba0efa45d8189b0">block_scheduler_algorithm_type</a>;
<a name="l00858"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a27592e930c9dbcfcf1dd30dae61dc7dd">00858</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">block_scheduler_type::internal_block_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a27592e930c9dbcfcf1dd30dae61dc7dd">internal_block_type</a>;
<a name="l00859"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a3e04b494c1abcc1168053e59b92b1de6">00859</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a61d55f31ba1e9a6d65671567cb172b8c">block_scheduler_type::external_block_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a3e04b494c1abcc1168053e59b92b1de6">external_block_type</a>;
<a name="l00860"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#af3c8616c047a26bb94967fe11a8b62d2">00860</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">block_scheduler_type::swappable_block_identifier_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#af3c8616c047a26bb94967fe11a8b62d2">swappable_block_identifier_type</a>;
<a name="l00861"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a9907cf3901ddbf5a12f7c8ad7a19c407">00861</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a3180e74d6cfa77838173cf757c20b197">block_scheduler_algorithm_type::time_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a9907cf3901ddbf5a12f7c8ad7a19c407">time_type</a>;
<a name="l00862"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#ab884d9e51c35597533d82762ba4184f2">00862</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#af32d88394597ab0c88b792173272eafa">block_scheduler_type::prediction_sequence_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#ab884d9e51c35597533d82762ba4184f2">prediction_sequence_type</a>;
<a name="l00863"></a>00863 
<a name="l00864"></a>00864     <span class="keyword">using</span> block_scheduler_algorithm_type::bs;
<a name="l00865"></a>00865     <span class="keyword">using</span> block_scheduler_algorithm_type::swappable_blocks;
<a name="l00866"></a>00866     <span class="keyword">using</span> block_scheduler_algorithm_type::get_algorithm_from_block_scheduler;
<a name="l00867"></a>00867     <span class="keyword">using</span> block_scheduler_algorithm_type::get_free_internal_block_from_block_scheduler;
<a name="l00868"></a>00868     <span class="keyword">using</span> block_scheduler_algorithm_type::return_free_internal_block_to_block_scheduler;
<a name="l00869"></a>00869 
<a name="l00870"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd_1_1priority.html">00870</a>     <span class="keyword">class </span><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd_1_1priority.html">priority</a>
<a name="l00871"></a>00871     {
<a name="l00872"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd_1_1priority.html#a366df2df73202aa3e346bf9903444f8d">00872</a>         <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd_1_1priority.html#a366df2df73202aa3e346bf9903444f8d">p</a>;
<a name="l00873"></a>00873 
<a name="l00874"></a>00874     <span class="keyword">public</span>:
<a name="l00875"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd_1_1priority.html#a6a090e7b2f8ce616d2b9803a609d62bd">00875</a>         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd_1_1priority.html">priority</a>(<span class="keyword">const</span> SwappableBlockType &amp; sblock, <span class="keyword">const</span> std::pair&lt;bool, time_type&gt; &amp; t)
<a name="l00876"></a>00876         {
<a name="l00877"></a>00877             <span class="comment">// p larger =&gt; evict earlier</span>
<a name="l00878"></a>00878             <span class="keywordflow">if</span> (t.first)
<a name="l00879"></a>00879             {
<a name="l00880"></a>00880                 <span class="comment">// most significant: next use</span>
<a name="l00881"></a>00881                 p = <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a>(t.second) &lt;&lt; 2;
<a name="l00882"></a>00882                 <span class="comment">// less significant: not dirty</span>
<a name="l00883"></a>00883                 p |= <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a>(! sblock.is_dirty()) &lt;&lt; 1;
<a name="l00884"></a>00884                 <span class="comment">// less significant: has external_block</span>
<a name="l00885"></a>00885                 p |= <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a>(sblock.has_external_block()) &lt;&lt; 0;
<a name="l00886"></a>00886             }
<a name="l00887"></a>00887             <span class="keywordflow">else</span>
<a name="l00888"></a>00888             {
<a name="l00889"></a>00889                 <span class="comment">// most significant: next use</span>
<a name="l00890"></a>00890                 p = std::numeric_limits&lt;unsigned_type&gt;::max() &lt;&lt; 2;
<a name="l00891"></a>00891                 <span class="comment">// less significant: next operation: extract &gt; accessed no more &gt; deinitialize</span>
<a name="l00892"></a>00892                 p |= <a class="code" href="namespacestxxl.html#a7501995ff616f0144a8bda727c266d1b">unsigned_type</a>(t.second) &lt;&lt; 0;
<a name="l00893"></a>00893             }
<a name="l00894"></a>00894         }
<a name="l00895"></a>00895 
<a name="l00896"></a>00896         <span class="comment">// less =&gt; evict earlier</span>
<a name="l00897"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd_1_1priority.html#aa38a7453eaaeb74e5c907295bbea692b">00897</a>         <span class="keywordtype">bool</span> <a class="code" href="gen__file_8cpp.html#a5ec113fe35d70394d00253126988aedf">operator &lt; </a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd_1_1priority.html">priority</a> &amp; right)<span class="keyword"> const</span>
<a name="l00898"></a>00898 <span class="keyword">        </span>{ <span class="keywordflow">return</span> p &gt; right.<a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd_1_1priority.html#a366df2df73202aa3e346bf9903444f8d">p</a>; }
<a name="l00899"></a>00899     };
<a name="l00900"></a>00900 <span class="comment"></span>
<a name="l00901"></a>00901 <span class="comment">    //! \brief Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired.</span>
<a name="l00902"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a279eadcb0640d67a57e0131440615516">00902</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1addressable__priority__queue.html">addressable_priority_queue&lt;swappable_block_identifier_type, priority&gt;</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a279eadcb0640d67a57e0131440615516" title="Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired...">evictable_blocks</a>;<span class="comment"></span>
<a name="l00903"></a>00903 <span class="comment">    /*! \brief stores for the sequence of releases extracted from the prediction_sequence:</span>
<a name="l00904"></a>00904 <span class="comment">            (true, timestamp of the blocks next acquire) if it is acquired next</span>
<a name="l00905"></a>00905 <span class="comment">            (false, 0) if it is deinitialized next</span>
<a name="l00906"></a>00906 <span class="comment">            (false, 1) if it is not accessed any more</span>
<a name="l00907"></a>00907 <span class="comment">            (false, 2) if it is extracted next</span>
<a name="l00908"></a>00908 <span class="comment">            (false, 3) if it is initialized next */</span>
<a name="l00909"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#ae3dd5aee0fad854faff75b9994823a8b">00909</a>     std::deque&lt; std::pair&lt;bool, time_type&gt; &gt; <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#ae3dd5aee0fad854faff75b9994823a8b" title="stores for the sequence of releases extracted from the prediction_sequence: (true, timestamp of the blocks next acquire) if it is acquired next (false, 0) if it is deinitialized next (false, 1) if it is not accessed any more (false, 2) if it is extracted next (false, 3) if it is initialized next">next_use</a>;
<a name="l00910"></a>00910 
<a name="l00911"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a6d118758bd51421802c0dc6b65ca60e6">00911</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * get_free_internal_block()
<a name="l00912"></a>00912     {
<a name="l00913"></a>00913         <span class="comment">// try to get a free internal_block</span>
<a name="l00914"></a>00914         <span class="keywordflow">if</span> (<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock = get_free_internal_block_from_block_scheduler())
<a name="l00915"></a>00915             <span class="keywordflow">return</span> iblock;
<a name="l00916"></a>00916         <span class="comment">// evict block</span>
<a name="l00917"></a>00917         assert(! evictable_blocks.empty()); <span class="comment">// fails it there is not enough memory available</span>
<a name="l00918"></a>00918         <span class="keywordflow">return</span> swappable_blocks[evictable_blocks.pop()].detach_internal_block();
<a name="l00919"></a>00919     }
<a name="l00920"></a>00920 
<a name="l00921"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#aad8d519c7198de4cfb52d51b760e4140">00921</a>     <span class="keywordtype">void</span> return_free_internal_block(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock)
<a name="l00922"></a>00922     { return_free_internal_block_to_block_scheduler(iblock); }
<a name="l00923"></a>00923 
<a name="l00924"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#acab490ad749463564cef5105f880eb1d">00924</a>     <span class="keywordtype">void</span> <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a> * old_algo)
<a name="l00925"></a>00925     {
<a name="l00926"></a>00926         std::vector&lt; std::pair&lt;bool, time_type&gt; &gt;
<a name="l00927"></a>00927                 blocks_next_acquire(swappable_blocks.size(), std::make_pair(<span class="keyword">false</span>, 1));
<a name="l00928"></a>00928         <span class="keywordflow">if</span>(old_algo)
<a name="l00929"></a>00929         {
<a name="l00930"></a>00930             <span class="comment">// precomputations for priorities: init next_acquires</span>
<a name="l00931"></a>00931             <span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a117098214cb91f41f8eb6854bcc898d0">prediction_sequence_type</a> &amp; ps = old_algo-&gt;<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a059c06470d1069faf1806c96f36c1fda">get_prediction_sequence</a>();
<a name="l00932"></a>00932             <span class="keywordflow">for</span> (<span class="keyword">typename</span> prediction_sequence_type::const_reverse_iterator it = ps.rbegin(); it != ps.rend(); ++it)
<a name="l00933"></a>00933                 <span class="keywordflow">switch</span> (it-&gt;op)
<a name="l00934"></a>00934                 {
<a name="l00935"></a>00935                 <span class="keywordflow">case</span> (block_scheduler_type::op_acquire):
<a name="l00936"></a>00936                 <span class="keywordflow">case</span> (block_scheduler_type::op_acquire_uninitialized):
<a name="l00937"></a>00937                     blocks_next_acquire[it-&gt;id] = std::make_pair(<span class="keyword">true</span>, it-&gt;time);
<a name="l00938"></a>00938                     <span class="keywordflow">break</span>;
<a name="l00939"></a>00939                 <span class="keywordflow">case</span> (block_scheduler_type::op_release):
<a name="l00940"></a>00940                 <span class="keywordflow">case</span> (block_scheduler_type::op_release_dirty):
<a name="l00941"></a>00941                     next_use.push_front(blocks_next_acquire[it-&gt;id]);
<a name="l00942"></a>00942                     <span class="keywordflow">break</span>;
<a name="l00943"></a>00943                 <span class="keywordflow">case</span> (block_scheduler_type::op_deinitialize):
<a name="l00944"></a>00944                     blocks_next_acquire[it-&gt;id] = std::make_pair(<span class="keyword">false</span>, 0);
<a name="l00945"></a>00945                     <span class="keywordflow">break</span>;
<a name="l00946"></a>00946                 <span class="keywordflow">case</span> (block_scheduler_type::op_initialize):
<a name="l00947"></a>00947                     blocks_next_acquire[it-&gt;id] = std::make_pair(<span class="keyword">false</span>, 3);
<a name="l00948"></a>00948                     <span class="keywordflow">break</span>;
<a name="l00949"></a>00949                 <span class="keywordflow">case</span> (block_scheduler_type::op_extract_external_block):
<a name="l00950"></a>00950                     blocks_next_acquire[it-&gt;id] = std::make_pair(<span class="keyword">false</span>, 2);
<a name="l00951"></a>00951                     <span class="keywordflow">break</span>;
<a name="l00952"></a>00952                 }
<a name="l00953"></a>00953         }
<a name="l00954"></a>00954         <span class="keywordflow">if</span> (get_algorithm_from_block_scheduler())
<a name="l00955"></a>00955         {
<a name="l00956"></a>00956             <span class="keywordflow">while</span> (! get_algorithm_from_block_scheduler()-&gt;evictable_blocks_empty())
<a name="l00957"></a>00957             {
<a name="l00958"></a>00958                 <span class="comment">// insert already evictable blocks with the right priority</span>
<a name="l00959"></a>00959                 <span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid = get_algorithm_from_block_scheduler()-&gt;evictable_blocks_pop();
<a name="l00960"></a>00960                 evictable_blocks.insert(sbid, <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd_1_1priority.html">priority</a>(swappable_blocks[sbid], blocks_next_acquire[sbid]));
<a name="l00961"></a>00961             }
<a name="l00962"></a>00962         }
<a name="l00963"></a>00963     }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 <span class="keyword">public</span>:
<a name="l00966"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#ab7b7626e9e94267a4bd76b846f7dec7c">00966</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html" title="Block scheduling algorithm caching via the longest forward distance policy (offline).">block_scheduler_algorithm_offline_lfd</a>(<a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler_type</a> &amp; bs)
<a name="l00967"></a>00967         : <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a>(bs)
<a name="l00968"></a>00968     { <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>(get_algorithm_from_block_scheduler()); }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970     <span class="comment">// It is possible to keep an old simulation-algorithm object and reuse it&#39;s prediction sequence</span>
<a name="l00971"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a30135baf17dbd6dcf499ae4337d5d1a3">00971</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html" title="Block scheduling algorithm caching via the longest forward distance policy (offline).">block_scheduler_algorithm_offline_lfd</a>(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a> * old)
<a name="l00972"></a>00972         : <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a>(old)
<a name="l00973"></a>00973     { <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>(old); }
<a name="l00974"></a>00974 
<a name="l00975"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a17f402a7534dbe9d1e14f10e888a4141">00975</a>     <span class="keyword">virtual</span> ~<a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html" title="Block scheduling algorithm caching via the longest forward distance policy (offline).">block_scheduler_algorithm_offline_lfd</a>()
<a name="l00976"></a>00976     {
<a name="l00977"></a>00977         <span class="keywordflow">if</span> (! evictable_blocks.empty())
<a name="l00978"></a>00978             STXXL_ERRMSG(<span class="stringliteral">&quot;Destructing block_scheduler_algorithm_offline_lfd that still holds evictable blocks. They get deinitialized.&quot;</span>);
<a name="l00979"></a>00979         <span class="keywordflow">while</span> (! evictable_blocks.empty())
<a name="l00980"></a>00980         {
<a name="l00981"></a>00981             SwappableBlockType &amp; sblock = swappable_blocks[evictable_blocks.pop()];
<a name="l00982"></a>00982             <span class="keywordflow">if</span> (<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock = sblock.deinitialize())
<a name="l00983"></a>00983                 return_free_internal_block(iblock);
<a name="l00984"></a>00984         }
<a name="l00985"></a>00985     }
<a name="l00986"></a>00986 
<a name="l00987"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a62251147442fff8596645fd5ff6ce264">00987</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> evictable_blocks_empty()
<a name="l00988"></a>00988     { <span class="keywordflow">return</span> evictable_blocks.empty(); }
<a name="l00989"></a>00989 
<a name="l00990"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a08ceaf03709cae6aca65632beadd6a4f">00990</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> evictable_blocks_pop()
<a name="l00991"></a>00991     { <span class="keywordflow">return</span> evictable_blocks.pop(); }
<a name="l00992"></a>00992 
<a name="l00993"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#ab7364ccefa441a659383091166875ff8">00993</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> &amp; acquire(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> uninitialized = <span class="keyword">false</span>)
<a name="l00994"></a>00994     {
<a name="l00995"></a>00995         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l00996"></a>00996         <span class="comment">/* acquired =&gt; internal -&gt; increase reference count</span>
<a name="l00997"></a>00997 <span class="comment">           internal but not acquired -&gt; remove from evictable_blocks, increase reference count</span>
<a name="l00998"></a>00998 <span class="comment">           not intern =&gt; uninitialized or external -&gt; get internal_block, increase reference count</span>
<a name="l00999"></a>00999 <span class="comment">           uninitialized -&gt; fill with default value</span>
<a name="l01000"></a>01000 <span class="comment">           external -&gt; read */</span>
<a name="l01001"></a>01001         <span class="keywordflow">if</span> (sblock.is_internal())
<a name="l01002"></a>01002         {
<a name="l01003"></a>01003             <span class="keywordflow">if</span> (! sblock.is_acquired())
<a name="l01004"></a>01004                 <span class="comment">// not acquired yet -&gt; remove from evictable_blocks</span>
<a name="l01005"></a>01005                 evictable_blocks.erase(sbid);
<a name="l01006"></a>01006             sblock.<a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#ab7364ccefa441a659383091166875ff8">acquire</a>();
<a name="l01007"></a>01007         }
<a name="l01008"></a>01008         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sblock.is_initialized())
<a name="l01009"></a>01009         {
<a name="l01010"></a>01010             <span class="comment">// =&gt; external but not internal</span>
<a name="l01011"></a>01011             <span class="comment">//get internal_block</span>
<a name="l01012"></a>01012             sblock.attach_internal_block(get_free_internal_block());
<a name="l01013"></a>01013             <span class="keywordflow">if</span> (! uninitialized)
<a name="l01014"></a>01014                 <span class="comment">//load block synchronously</span>
<a name="l01015"></a>01015                 sblock.read_sync();
<a name="l01016"></a>01016             sblock.acquire();
<a name="l01017"></a>01017         }
<a name="l01018"></a>01018         <span class="keywordflow">else</span>
<a name="l01019"></a>01019         {
<a name="l01020"></a>01020             <span class="comment">// =&gt; ! sblock.is_initialized()</span>
<a name="l01021"></a>01021             <span class="comment">//get internal_block</span>
<a name="l01022"></a>01022             sblock.attach_internal_block(get_free_internal_block());
<a name="l01023"></a>01023             sblock.acquire();
<a name="l01024"></a>01024             <span class="comment">//initialize new block</span>
<a name="l01025"></a>01025             <span class="keywordflow">if</span> (! uninitialized)
<a name="l01026"></a>01026                 sblock.fill_default();
<a name="l01027"></a>01027         }
<a name="l01028"></a>01028         <span class="keywordflow">return</span> sblock.get_internal_block();
<a name="l01029"></a>01029     }
<a name="l01030"></a>01030 
<a name="l01031"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#aa6fecd166011788fe849280769a657d6">01031</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> release(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> dirty)
<a name="l01032"></a>01032     {
<a name="l01033"></a>01033         <span class="keywordflow">if</span> (next_use.empty())
<a name="l01034"></a>01034         {
<a name="l01035"></a>01035             STXXL_ERRMSG(<span class="stringliteral">&quot;block_scheduler_algorithm_offline_lfd got release-request but prediction sequence ended. Switching to block_scheduler_algorithm_online.&quot;</span>);
<a name="l01036"></a>01036             <span class="comment">// switch algorithm</span>
<a name="l01037"></a>01037             <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a> * new_algo,
<a name="l01038"></a>01038                                            * old_algo;
<a name="l01039"></a>01039             new_algo = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html" title="Block scheduling algorithm caching via the least recently used policy (online).">block_scheduler_algorithm_online_lru&lt;SwappableBlockType&gt;</a>(bs);
<a name="l01040"></a>01040             old_algo = bs.switch_algorithm_to(new_algo);
<a name="l01041"></a>01041             <span class="comment">// redirect call</span>
<a name="l01042"></a>01042             new_algo-&gt;<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a069aa8d725c782a5f6abc413253492cd">release</a>(sbid, dirty);
<a name="l01043"></a>01043             <span class="comment">// delete self</span>
<a name="l01044"></a>01044             <span class="keyword">delete</span> old_algo;
<a name="l01045"></a>01045             <span class="keywordflow">return</span>;
<a name="l01046"></a>01046         }
<a name="l01047"></a>01047         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l01048"></a>01048         sblock.make_dirty_if(dirty);
<a name="l01049"></a>01049         sblock.<a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html#ab63f83b9405ac02f385cdbefe50cd8c4">release</a>();
<a name="l01050"></a>01050         <span class="keywordflow">if</span> (! sblock.is_acquired())
<a name="l01051"></a>01051         {
<a name="l01052"></a>01052             <span class="keywordflow">if</span> (sblock.is_dirty() || sblock.is_external())
<a name="l01053"></a>01053                 <span class="comment">// =&gt; evictable, put in pq</span>
<a name="l01054"></a>01054                 evictable_blocks.insert(sbid, <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd_1_1priority.html">priority</a>(swappable_blocks[sbid], next_use.front()));
<a name="l01055"></a>01055             <span class="keywordflow">else</span>
<a name="l01056"></a>01056                 <span class="comment">// =&gt; uninitialized, release internal block and put it in freelist</span>
<a name="l01057"></a>01057                 return_free_internal_block(sblock.detach_internal_block());
<a name="l01058"></a>01058         }
<a name="l01059"></a>01059         next_use.pop_front();
<a name="l01060"></a>01060     }
<a name="l01061"></a>01061 
<a name="l01062"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#aaa3fc841fa42190d87ffd5258bb3653e">01062</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> deinitialize(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid)
<a name="l01063"></a>01063     {
<a name="l01064"></a>01064         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l01065"></a>01065         <span class="keywordflow">if</span> (sblock.is_evictable())
<a name="l01066"></a>01066             evictable_blocks.erase(sbid);
<a name="l01067"></a>01067         <span class="keywordflow">if</span> (<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock = sblock.deinitialize())
<a name="l01068"></a>01068             return_free_internal_block(iblock);
<a name="l01069"></a>01069     }
<a name="l01070"></a>01070 
<a name="l01071"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a40b073080ca8ae2c475bc3550829da5a">01071</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a688d2d348f5e023f2ffa2dfd503e3767">external_block_type</a> eblock)
<a name="l01072"></a>01072     {
<a name="l01073"></a>01073         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l01074"></a>01074         sblock.initialize(eblock);
<a name="l01075"></a>01075     }
<a name="l01076"></a>01076 
<a name="l01077"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lfd.html#a80edde4601a6f55cd62bff28a9588bd1">01077</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a688d2d348f5e023f2ffa2dfd503e3767">external_block_type</a> extract_external_block(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid)
<a name="l01078"></a>01078     {
<a name="l01079"></a>01079         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l01080"></a>01080         <span class="keywordflow">if</span> (sblock.is_evictable())
<a name="l01081"></a>01081             evictable_blocks.erase(sbid);
<a name="l01082"></a>01082         <span class="keywordflow">if</span> (sblock.is_internal())
<a name="l01083"></a>01083             return_free_internal_block(sblock.detach_internal_block());
<a name="l01084"></a>01084         <span class="keywordflow">return</span> sblock.extract_external_block();
<a name="l01085"></a>01085     }
<a name="l01086"></a>01086 };
<a name="l01087"></a>01087 <span class="comment"></span>
<a name="l01088"></a>01088 <span class="comment">//! \brief Block scheduling algorithm caching via the least recently used policy (offline),</span>
<a name="l01089"></a>01089 <span class="comment">//! and prefetching in addition.</span>
<a name="l01090"></a>01090 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> SwappableBlockType&gt;
<a name="l01091"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html">01091</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html" title="Block scheduling algorithm caching via the least recently used policy (offline), and prefetching in a...">block_scheduler_algorithm_offline_lru_prefetching</a> : <span class="keyword">public</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm</a>&lt;SwappableBlockType&gt;
<a name="l01092"></a>01092 {
<a name="l01093"></a>01093 <span class="keyword">protected</span>:
<a name="l01094"></a>01094     <span class="keyword">struct </span><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html">scheduled_block_meta</a>;
<a name="l01095"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a7778f0fe1fae65f660a872d236140753">01095</a>     <span class="keyword">struct </span><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html">write_read_request</a>;
<a name="l01096"></a>01096 
<a name="l01097"></a>01097     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler&lt;SwappableBlockType&gt;</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a7778f0fe1fae65f660a872d236140753">block_scheduler_type</a>;
<a name="l01098"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ad8a5b3bb99cce1437b30be5f76802c7f">01098</a>     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm&lt;SwappableBlockType&gt;</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ad8a5b3bb99cce1437b30be5f76802c7f">block_scheduler_algorithm_type</a>;
<a name="l01099"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a7142e962ec1fbb06b09a66b6c6385d01">01099</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#af1addb8326219fbdbd6d6d8b1a2703f0">block_scheduler_type::internal_block_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a7142e962ec1fbb06b09a66b6c6385d01">internal_block_type</a>;
<a name="l01100"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ae17635581183290bd621e69767d5299e">01100</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a61d55f31ba1e9a6d65671567cb172b8c">block_scheduler_type::external_block_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ae17635581183290bd621e69767d5299e">external_block_type</a>;
<a name="l01101"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a6f236bedac0e32c1a1cd3294f128d643">01101</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a3b5ff905d98c086f9b9a76dea9c68ac7">block_scheduler_type::swappable_block_identifier_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a6f236bedac0e32c1a1cd3294f128d643">swappable_block_identifier_type</a>;
<a name="l01102"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a39a9df58d9dce3abcd309ccd70c84309">01102</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a3180e74d6cfa77838173cf757c20b197">block_scheduler_algorithm_type::time_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a39a9df58d9dce3abcd309ccd70c84309">time_type</a>;
<a name="l01103"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a55d5c4ef712a2c31716a84d0e2ee069e">01103</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#af32d88394597ab0c88b792173272eafa">block_scheduler_type::prediction_sequence_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a55d5c4ef712a2c31716a84d0e2ee069e">prediction_sequence_type</a>;
<a name="l01104"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a933e44586c93fc39ecb1da98204e9afe">01104</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664">block_scheduler_type::block_scheduler_operation</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a933e44586c93fc39ecb1da98204e9afe">block_scheduler_operation</a>;
<a name="l01105"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a109d1ec473603f27bdf55d05e8623257">01105</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;SwappableBlockType&gt;::iterator <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a109d1ec473603f27bdf55d05e8623257">swappable_blocks_iterator</a>;
<a name="l01106"></a>01106 
<a name="l01107"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a8fc7bfdfe21db217fef93d0cfc95b51f">01107</a>     <span class="keyword">typedef</span> std::map&lt;swappable_block_identifier_type, scheduled_block_meta&gt; <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a8fc7bfdfe21db217fef93d0cfc95b51f">scheduled_blocks_type</a>;
<a name="l01108"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">01108</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> scheduled_blocks_type::iterator <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a>;
<a name="l01109"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0b0bcc605dcb7a9f5d206e54c516ebf0">01109</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> scheduled_blocks_type::reference <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0b0bcc605dcb7a9f5d206e54c516ebf0">scheduled_blocks_reference</a>;
<a name="l01110"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0af9087052e8227916a992eb43901662">01110</a>     <span class="keyword">typedef</span> std::map&lt;swappable_block_identifier_type, write_read_request *&gt; <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0af9087052e8227916a992eb43901662">write_scheduled_blocks_type</a>;
<a name="l01111"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">01111</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> write_scheduled_blocks_type::iterator <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">write_scheduled_blocks_iterator</a>;
<a name="l01112"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a05553be98a99d696e17c6c160b86c852">01112</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> write_scheduled_blocks_type::reference <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a05553be98a99d696e17c6c160b86c852">write_scheduled_blocks_reference</a>;
<a name="l01113"></a>01113 
<a name="l01114"></a>01114     <span class="keyword">using</span> block_scheduler_algorithm_type::bs;
<a name="l01115"></a>01115     <span class="keyword">using</span> block_scheduler_algorithm_type::swappable_blocks;
<a name="l01116"></a>01116     <span class="keyword">using</span> block_scheduler_algorithm_type::get_algorithm_from_block_scheduler;
<a name="l01117"></a>01117     <span class="keyword">using</span> block_scheduler_algorithm_type::get_free_internal_block_from_block_scheduler;
<a name="l01118"></a>01118     <span class="keyword">using</span> block_scheduler_algorithm_type::return_free_internal_block_to_block_scheduler;
<a name="l01119"></a>01119     <span class="keyword">using</span> block_scheduler_algorithm_type::prediction_sequence;
<a name="l01120"></a>01120 
<a name="l01121"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html">01121</a>     <span class="keyword">struct </span><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html">write_read_request</a>
<a name="l01122"></a>01122     {
<a name="l01123"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#ab1f18ba1e1bfe630b81faae824f043b9">01123</a>         <span class="keywordtype">bool</span> <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#ab1f18ba1e1bfe630b81faae824f043b9">write_done_soon</a>; <span class="comment">// set by read_after_write, checked by schedule_read()</span>
<a name="l01124"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#a889e827b0e5ee3db354b2af40a648730">01124</a>         <span class="keywordtype">bool</span> <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#a889e827b0e5ee3db354b2af40a648730">shall_read</a>; <span class="comment">// checked by read_after_write, set by schedule_read()</span>
<a name="l01125"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#aab2a7b3d623a4261bb71ed5c34b77f86">01125</a>         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a109d1ec473603f27bdf55d05e8623257">swappable_blocks_iterator</a> <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#aab2a7b3d623a4261bb71ed5c34b77f86">block_to_start_read</a>; <span class="comment">// used by read_after_write, set by schedule_read()</span>
<a name="l01126"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#ad093942c7d6451117fb350b19c093ab0">01126</a>         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#ad093942c7d6451117fb350b19c093ab0">taker</a>; <span class="comment">// read_req set by read_after_write</span>
<a name="l01127"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#af34562bb10fc9d66a3b23fcef06c261f">01127</a>         <a class="code" href="classstxxl_1_1request__ptr.html" title="Implemented as reference counting smart pointer.">request_ptr</a> <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#af34562bb10fc9d66a3b23fcef06c261f">write_req</a>; <span class="comment">// completes with read_after_write</span>
<a name="l01128"></a>01128 
<a name="l01129"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#a08acb5dd0cb1026410f73597243a56f0">01129</a>         <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html">write_read_request</a>()
<a name="l01130"></a>01130             : write_done_soon(false), shall_read(false), block_to_start_read(), taker(), write_req(0) {}
<a name="l01131"></a>01131     };
<a name="l01132"></a>01132 
<a name="l01133"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1read__after__write.html">01133</a>     <span class="keyword">struct </span><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1read__after__write.html">read_after_write</a>
<a name="l01134"></a>01134     {
<a name="l01135"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1read__after__write.html#ab309fff437ed58b629a0a89bc5437822">01135</a>         <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html">write_read_request</a> * <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1read__after__write.html#ab309fff437ed58b629a0a89bc5437822">wrr</a>;
<a name="l01136"></a>01136 
<a name="l01137"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1read__after__write.html#aab7ab93654b9d5344d53b37e17f246f1">01137</a>         <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1read__after__write.html">read_after_write</a>(<a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html">write_read_request</a> * write_read_req)
<a name="l01138"></a>01138             : wrr(write_read_req) {}
<a name="l01139"></a>01139 
<a name="l01140"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1read__after__write.html#a0aa979e28f2491558bbc4384b70ad202">01140</a>         <span class="keywordtype">void</span> operator () (<a class="code" href="classstxxl_1_1request.html" title="Request with basic properties like file and offset.">request</a> *)
<a name="l01141"></a>01141         {
<a name="l01142"></a>01142             wrr-&gt;write_done_soon = <span class="keyword">true</span>;
<a name="l01143"></a>01143             <span class="keywordflow">if</span> (wrr-&gt;shall_read)
<a name="l01144"></a>01144                 wrr-&gt;taker-&gt;second.read_req = wrr-&gt;block_to_start_read-&gt;read_async();
<a name="l01145"></a>01145         }
<a name="l01146"></a>01146     };
<a name="l01147"></a>01147 
<a name="l01148"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html">01148</a>     <span class="keyword">struct </span><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html">scheduled_block_meta</a>
<a name="l01149"></a>01149     {
<a name="l01150"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html#aebbfef184dec944facdbc14952a36515">01150</a>         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a7142e962ec1fbb06b09a66b6c6385d01">internal_block_type</a> * <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html#aebbfef184dec944facdbc14952a36515">reserved_iblock</a>;
<a name="l01151"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html#a7fce2e1371a6b3a01f5ac8c44a3079ba">01151</a>         std::pair&lt;bool, swappable_block_identifier_type&gt; <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html#a7fce2e1371a6b3a01f5ac8c44a3079ba">giver</a>;
<a name="l01152"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html#a8f6164b9b834e9e68ea8c16d11716d34">01152</a>         <a class="code" href="classstxxl_1_1request__ptr.html" title="Implemented as reference counting smart pointer.">request_ptr</a> <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html#a8f6164b9b834e9e68ea8c16d11716d34">read_req</a>;
<a name="l01153"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html#acc35dd3fe63531c3dc2470d07dab7be7">01153</a>         std::deque&lt;block_scheduler_operation&gt; <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html#acc35dd3fe63531c3dc2470d07dab7be7">operations</a>; <span class="comment">// invariant: not empty; front: last scheduled operation, back: upcoming operation</span>
<a name="l01154"></a>01154 
<a name="l01155"></a><a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html#a312076c67ac919f9f38c68145abcdf4f">01155</a>         <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1scheduled__block__meta.html">scheduled_block_meta</a>(<a class="code" href="classstxxl_1_1block__scheduler.html#a051d2cf7aac69f10c5a21f40f93a5664">block_scheduler_operation</a> op)
<a name="l01156"></a>01156             : reserved_iblock(0),
<a name="l01157"></a>01157               giver(false, 0),
<a name="l01158"></a>01158               read_req(0),
<a name="l01159"></a>01159               operations()
<a name="l01160"></a>01160         { operations.push_front(op); }
<a name="l01161"></a>01161     };
<a name="l01162"></a>01162 <span class="comment"></span>
<a name="l01163"></a>01163 <span class="comment">    //! \brief Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired.</span>
<a name="l01164"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#aed962e7b0003b3bec54c3c179d58e4d8">01164</a> <span class="comment"></span>    std::set&lt;swappable_block_identifier_type&gt; <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#aed962e7b0003b3bec54c3c179d58e4d8" title="Holds swappable blocks, whose internal block can be freed, i.e. that are internal but unacquired...">free_evictable_blocks</a>;
<a name="l01165"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#aaf3bb63e85ecfeab08b919f8046f56d3">01165</a>     std::set&lt;swappable_block_identifier_type&gt; <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#aaf3bb63e85ecfeab08b919f8046f56d3">scheduled_evictable_blocks</a>;<span class="comment"></span>
<a name="l01166"></a>01166 <span class="comment">    //! \brief Holds not internal swappable_blocks, whose next access has already been scheduled.</span>
<a name="l01167"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a65ffec64d617c8de01a76d5ce2f4f128">01167</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a8fc7bfdfe21db217fef93d0cfc95b51f">scheduled_blocks_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a65ffec64d617c8de01a76d5ce2f4f128" title="Holds not internal swappable_blocks, whose next access has already been scheduled.">scheduled_blocks</a>;<span class="comment"></span>
<a name="l01168"></a>01168 <span class="comment">    //! \brief Holds swappable_blocks, whose internal block has been taken away but the clean did not finish yet.</span>
<a name="l01169"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#af6b89f29756f96d643e34a0851fa9655">01169</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0af9087052e8227916a992eb43901662">write_scheduled_blocks_type</a> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#af6b89f29756f96d643e34a0851fa9655" title="Holds swappable_blocks, whose internal block has been taken away but the clean did not finish yet...">write_scheduled_blocks</a>;
<a name="l01170"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a687fffdad96cf8a7b0eb35d0a423888c">01170</a>     <span class="keyword">typename</span> prediction_sequence_type::iterator <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a687fffdad96cf8a7b0eb35d0a423888c">next_op_to_schedule</a>;
<a name="l01171"></a>01171 <span class="comment"></span>
<a name="l01172"></a>01172 <span class="comment">    //! \brief Schedule an internal, possibly dirty swappable_block to write.</span>
<a name="l01173"></a>01173 <span class="comment">    //!</span>
<a name="l01174"></a>01174 <span class="comment">    //! The block becomes not dirty. if it was dirty, an entry in write_scheduled_blocks is made referencing the write_read_request.</span>
<a name="l01175"></a>01175 <span class="comment">    //! \param sbid block to write</span>
<a name="l01176"></a>01176 <span class="comment">    //! \return pointer to the write_read_request</span>
<a name="l01177"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a84441f1d252f0d864bd8e943116d2675">01177</a> <span class="comment"></span>    <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html">write_read_request</a> * schedule_write(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid)
<a name="l01178"></a>01178     {
<a name="l01179"></a>01179         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l01180"></a>01180         <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html">write_read_request</a> * wrr = <span class="keyword">new</span> <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html">write_read_request</a>;
<a name="l01181"></a>01181         wrr-&gt;<a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#af34562bb10fc9d66a3b23fcef06c261f">write_req</a> = sblock.clean_async(<a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1read__after__write.html">read_after_write</a>(wrr));
<a name="l01182"></a>01182         <span class="keywordflow">if</span> (wrr-&gt;<a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#af34562bb10fc9d66a3b23fcef06c261f">write_req</a>.<a class="code" href="classstxxl_1_1request__ptr.html#a3684b2b6b1ee2447da7a2f261cff5de3" title="Returns true if object is initialized.">valid</a>())
<a name="l01183"></a>01183         {
<a name="l01184"></a>01184             <span class="keywordtype">bool</span> t = write_scheduled_blocks.insert(std::make_pair(sbid, wrr)).second;
<a name="l01185"></a>01185             assert(t);
<a name="l01186"></a>01186             <span class="keywordflow">return</span> wrr;
<a name="l01187"></a>01187         }
<a name="l01188"></a>01188         <span class="keywordflow">else</span>
<a name="l01189"></a>01189         {
<a name="l01190"></a>01190             <span class="keyword">delete</span> wrr;
<a name="l01191"></a>01191             <span class="keywordflow">return</span> 0;
<a name="l01192"></a>01192         }
<a name="l01193"></a>01193     }
<a name="l01194"></a>01194 <span class="comment"></span>
<a name="l01195"></a>01195 <span class="comment">    //! \brief try to interrupt a read scheduled in a write_read_request</span>
<a name="l01196"></a>01196 <span class="comment">    //!</span>
<a name="l01197"></a>01197 <span class="comment">    //! side-effect: possibly erases entry from write_scheduled_blocks, so the iterator writing_block may become invalid</span>
<a name="l01198"></a>01198 <span class="comment">    //! \return if successful</span>
<a name="l01199"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ae2642e905b85db5ab484cfd76503a706">01199</a> <span class="comment"></span>    <span class="keywordtype">bool</span> try_interrupt_read(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">write_scheduled_blocks_iterator</a> &amp; writing_block)
<a name="l01200"></a>01200     {
<a name="l01201"></a>01201         <span class="comment">// stop read</span>
<a name="l01202"></a>01202         writing_block-&gt;second-&gt;<a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#a889e827b0e5ee3db354b2af40a648730">shall_read</a> = <span class="keyword">false</span>;
<a name="l01203"></a>01203         <span class="comment">// check if stopped</span>
<a name="l01204"></a>01204         <span class="keywordflow">if</span> (! writing_block-&gt;second-&gt;write_done_soon)
<a name="l01205"></a>01205             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01206"></a>01206         <span class="comment">// =&gt; possibly to late</span>
<a name="l01207"></a>01207         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0b0bcc605dcb7a9f5d206e54c516ebf0">scheduled_blocks_reference</a> taker = *writing_block-&gt;second-&gt;taker;
<a name="l01208"></a>01208         <span class="comment">// wait</span>
<a name="l01209"></a>01209         wait_on_write(writing_block);
<a name="l01210"></a>01210         <span class="comment">// check if read started</span>
<a name="l01211"></a>01211         <span class="keywordflow">if</span> (taker.second.read_req.valid())
<a name="l01212"></a>01212             <span class="comment">// =&gt; read started, to late</span>
<a name="l01213"></a>01213             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01214"></a>01214         <span class="keywordflow">else</span>
<a name="l01215"></a>01215             <span class="comment">// =&gt; just in time</span>
<a name="l01216"></a>01216             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01217"></a>01217     }
<a name="l01218"></a>01218 <span class="comment"></span>
<a name="l01219"></a>01219 <span class="comment">    //! \brief Schedule an internal and external block to read.</span>
<a name="l01220"></a>01220 <span class="comment">    //!</span>
<a name="l01221"></a>01221 <span class="comment">    //! If the giver is still writing, schedule read via its write_read_request.</span>
<a name="l01222"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a36155ae2264124dfaea08bef48b38720">01222</a> <span class="comment"></span>    <span class="keywordtype">void</span> schedule_read(<a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> block_to_read)
<a name="l01223"></a>01223     {
<a name="l01224"></a>01224         <span class="comment">// first check if block_to_read is still writing. do not read before write finished</span>
<a name="l01225"></a>01225         <span class="comment">// wait_on_write(block_to_read-&gt;first);</span>
<a name="l01226"></a>01226 
<a name="l01227"></a>01227         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">write_scheduled_blocks_iterator</a> it = write_scheduled_blocks.find(block_to_read-&gt;first);
<a name="l01228"></a>01228         <span class="keywordflow">if</span> (it != write_scheduled_blocks.end())
<a name="l01229"></a>01229         {
<a name="l01230"></a>01230             <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> other_block_to_read = it-&gt;second-&gt;taker;
<a name="l01231"></a>01231             <span class="comment">// check if scheduled to read</span>
<a name="l01232"></a>01232             <span class="keywordflow">if</span> (it-&gt;second-&gt;shall_read)
<a name="l01233"></a>01233             {
<a name="l01234"></a>01234                 <span class="keywordflow">if</span> (try_interrupt_read(it))
<a name="l01235"></a>01235                 {
<a name="l01236"></a>01236                     <span class="comment">// =&gt; interrupted, swap internal_blocks</span>
<a name="l01237"></a>01237                     <a class="code" href="namespacestd.html#abc5bd04888275546472a3a5b813fe030">std::swap</a>(other_block_to_read-&gt;second.giver, block_to_read-&gt;second.giver);
<a name="l01238"></a>01238                     <span class="keywordflow">if</span> (other_block_to_read-&gt;second.giver.first)
<a name="l01239"></a>01239                     {
<a name="l01240"></a>01240                         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">write_scheduled_blocks_iterator</a> it = write_scheduled_blocks.find(other_block_to_read-&gt;second.giver.second);
<a name="l01241"></a>01241                         <span class="keywordflow">if</span> (it != write_scheduled_blocks.end())
<a name="l01242"></a>01242                             it-&gt;second-&gt;taker = other_block_to_read;
<a name="l01243"></a>01243                         <span class="keywordflow">else</span>
<a name="l01244"></a>01244                             other_block_to_read-&gt;second.giver.first = <span class="keyword">false</span>;
<a name="l01245"></a>01245                     }
<a name="l01246"></a>01246                     <span class="keywordflow">if</span> (block_to_read-&gt;second.giver.first)
<a name="l01247"></a>01247                     {
<a name="l01248"></a>01248                         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">write_scheduled_blocks_iterator</a> it = write_scheduled_blocks.find(block_to_read-&gt;second.giver.second);
<a name="l01249"></a>01249                         <span class="keywordflow">if</span> (it != write_scheduled_blocks.end())
<a name="l01250"></a>01250                             it-&gt;second-&gt;taker = block_to_read;
<a name="l01251"></a>01251                         <span class="keywordflow">else</span>
<a name="l01252"></a>01252                             block_to_read-&gt;second.giver.first = <span class="keyword">false</span>;
<a name="l01253"></a>01253                     }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255                     <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * tmp_iblock = swappable_blocks[block_to_read-&gt;first].detach_internal_block();
<a name="l01256"></a>01256                     swappable_blocks[block_to_read-&gt;first].attach_internal_block(
<a name="l01257"></a>01257                             swappable_blocks[other_block_to_read-&gt;first].detach_internal_block());
<a name="l01258"></a>01258                     swappable_blocks[other_block_to_read-&gt;first].attach_internal_block(tmp_iblock);
<a name="l01259"></a>01259                     <span class="comment">// =&gt; this block has its internal_block back, no need to read</span>
<a name="l01260"></a>01260                     <span class="comment">// reschedule other</span>
<a name="l01261"></a>01261                     schedule_read(other_block_to_read);
<a name="l01262"></a>01262                     <span class="keywordflow">return</span>;
<a name="l01263"></a>01263                 }
<a name="l01264"></a>01264                 <span class="comment">// else =&gt; read already started, but write done -&gt; read this</span>
<a name="l01265"></a>01265             }
<a name="l01266"></a>01266             <span class="keywordflow">else</span>
<a name="l01267"></a>01267             {
<a name="l01268"></a>01268                 <span class="comment">// =&gt; no read scheduled, swap internal_blocks</span>
<a name="l01269"></a>01269                 <a class="code" href="namespacestd.html#abc5bd04888275546472a3a5b813fe030">std::swap</a>(other_block_to_read-&gt;second.giver, block_to_read-&gt;second.giver);
<a name="l01270"></a>01270                 <span class="keywordflow">if</span> (other_block_to_read-&gt;second.giver.first)
<a name="l01271"></a>01271                 {
<a name="l01272"></a>01272                     <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">write_scheduled_blocks_iterator</a> it = write_scheduled_blocks.find(other_block_to_read-&gt;second.giver.second);
<a name="l01273"></a>01273                     <span class="keywordflow">if</span> (it != write_scheduled_blocks.end())
<a name="l01274"></a>01274                         it-&gt;second-&gt;taker = other_block_to_read;
<a name="l01275"></a>01275                     <span class="keywordflow">else</span>
<a name="l01276"></a>01276                         other_block_to_read-&gt;second.giver.first = <span class="keyword">false</span>;
<a name="l01277"></a>01277                 }
<a name="l01278"></a>01278                 <span class="keywordflow">if</span> (block_to_read-&gt;second.giver.first)
<a name="l01279"></a>01279                 {
<a name="l01280"></a>01280                     <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">write_scheduled_blocks_iterator</a> it = write_scheduled_blocks.find(block_to_read-&gt;second.giver.second);
<a name="l01281"></a>01281                     <span class="keywordflow">if</span> (it != write_scheduled_blocks.end())
<a name="l01282"></a>01282                         it-&gt;second-&gt;taker = block_to_read;
<a name="l01283"></a>01283                     <span class="keywordflow">else</span>
<a name="l01284"></a>01284                         block_to_read-&gt;second.giver.first = <span class="keyword">false</span>;
<a name="l01285"></a>01285                 }
<a name="l01286"></a>01286 
<a name="l01287"></a>01287                 <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * tmp_iblock = swappable_blocks[block_to_read-&gt;first].detach_internal_block();
<a name="l01288"></a>01288                 swappable_blocks[block_to_read-&gt;first].attach_internal_block(
<a name="l01289"></a>01289                         other_block_to_read-&gt;second.reserved_iblock);
<a name="l01290"></a>01290                 other_block_to_read-&gt;second.reserved_iblock = tmp_iblock;
<a name="l01291"></a>01291                 <span class="comment">// =&gt; this block has its internal_block back, no need to read</span>
<a name="l01292"></a>01292                 <span class="keywordflow">return</span>;
<a name="l01293"></a>01293             }
<a name="l01294"></a>01294         }
<a name="l01295"></a>01295 
<a name="l01296"></a>01296         <span class="comment">// schedule block_to_read to read</span>
<a name="l01297"></a>01297         <span class="keywordflow">if</span> (block_to_read-&gt;second.giver.first)
<a name="l01298"></a>01298         {
<a name="l01299"></a>01299             <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">write_scheduled_blocks_iterator</a> writing_block = write_scheduled_blocks.find(block_to_read-&gt;second.giver.second);
<a name="l01300"></a>01300             <span class="keywordflow">if</span> (writing_block != write_scheduled_blocks.end())
<a name="l01301"></a>01301             {
<a name="l01302"></a>01302                 <span class="comment">// =&gt; there is a write scheduled</span>
<a name="l01303"></a>01303                 <span class="comment">// tell the completion handler that we want a read</span>
<a name="l01304"></a>01304                 writing_block-&gt;second-&gt;block_to_start_read = swappable_blocks.begin() + block_to_read-&gt;first;
<a name="l01305"></a>01305                 writing_block-&gt;second-&gt;taker = block_to_read;
<a name="l01306"></a>01306                 writing_block-&gt;second-&gt;shall_read = <span class="keyword">true</span>;
<a name="l01307"></a>01307                 <span class="comment">// and check if it is not to late</span>
<a name="l01308"></a>01308                 <span class="keywordflow">if</span> (writing_block-&gt;second-&gt;write_done_soon)
<a name="l01309"></a>01309                 {
<a name="l01310"></a>01310                     <span class="comment">// =&gt; the completion handler may have missed our wish to read</span>
<a name="l01311"></a>01311                     <span class="comment">// so wait for it to finish and check</span>
<a name="l01312"></a>01312                     wait_on_write(writing_block);
<a name="l01313"></a>01313                     block_to_read-&gt;second.giver.first = <span class="keyword">false</span>;
<a name="l01314"></a>01314                     <span class="keywordflow">if</span> (block_to_read-&gt;second.read_req.valid())
<a name="l01315"></a>01315                         <span class="comment">// read scheduled</span>
<a name="l01316"></a>01316                         <span class="keywordflow">return</span>;
<a name="l01317"></a>01317                 }
<a name="l01318"></a>01318                 <span class="keywordflow">else</span>
<a name="l01319"></a>01319                     <span class="comment">// read scheduled</span>
<a name="l01320"></a>01320                     <span class="keywordflow">return</span>;
<a name="l01321"></a>01321             }
<a name="l01322"></a>01322             <span class="keywordflow">else</span>
<a name="l01323"></a>01323                 block_to_read-&gt;second.giver.first = <span class="keyword">false</span>;
<a name="l01324"></a>01324         }
<a name="l01325"></a>01325         <span class="comment">// =&gt; read could not be scheduled through the completion handler</span>
<a name="l01326"></a>01326         block_to_read-&gt;second.read_req = swappable_blocks[block_to_read-&gt;first].read_async();
<a name="l01327"></a>01327     }
<a name="l01328"></a>01328 <span class="comment"></span>
<a name="l01329"></a>01329 <span class="comment">    //! \brief wait for the write to finish</span>
<a name="l01330"></a>01330 <span class="comment">    //!</span>
<a name="l01331"></a>01331 <span class="comment">    //! side-effect: erases entry from write_scheduled_blocks</span>
<a name="l01332"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#abdaa2ef0512f8fce9f1bc029a3584071">01332</a> <span class="comment"></span>    <span class="keywordtype">void</span> wait_on_write(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">write_scheduled_blocks_iterator</a> &amp; writing_block)
<a name="l01333"></a>01333     {
<a name="l01334"></a>01334         writing_block-&gt;second-&gt;write_req-&gt;wait();
<a name="l01335"></a>01335         <span class="keyword">delete</span> writing_block-&gt;second;
<a name="l01336"></a>01336         write_scheduled_blocks.erase(writing_block);
<a name="l01337"></a>01337     }
<a name="l01338"></a>01338 <span class="comment"></span>
<a name="l01339"></a>01339 <span class="comment">    //! \brief wait for the write to finish</span>
<a name="l01340"></a>01340 <span class="comment">    //!</span>
<a name="l01341"></a>01341 <span class="comment">    //! side-effect: erases entry from write_scheduled_blocks</span>
<a name="l01342"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a1ec395bdec16447a443dc81f3f968191">01342</a> <span class="comment"></span>    <span class="keywordtype">void</span> wait_on_write(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> &amp; writing_block)
<a name="l01343"></a>01343     {
<a name="l01344"></a>01344         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">write_scheduled_blocks_iterator</a> it = write_scheduled_blocks.find(writing_block);
<a name="l01345"></a>01345         <span class="keywordflow">if</span> (it != write_scheduled_blocks.end())
<a name="l01346"></a>01346             wait_on_write(it);
<a name="l01347"></a>01347     }
<a name="l01348"></a>01348 <span class="comment"></span>
<a name="l01349"></a>01349 <span class="comment">    //! \brief wait for the write of the giver to finish</span>
<a name="l01350"></a>01350 <span class="comment">    //!</span>
<a name="l01351"></a>01351 <span class="comment">    //! side-effect: erases entry from write_scheduled_blocks</span>
<a name="l01352"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a6c906b88c48e175cacf0542c45057ddd">01352</a> <span class="comment"></span>    <span class="keywordtype">void</span> wait_on_write(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> &amp; schedule_meta)
<a name="l01353"></a>01353     {
<a name="l01354"></a>01354         <span class="keywordflow">if</span> (schedule_meta-&gt;second.giver.first)
<a name="l01355"></a>01355         {
<a name="l01356"></a>01356             wait_on_write(schedule_meta-&gt;second.giver.second);
<a name="l01357"></a>01357             schedule_meta-&gt;second.giver.first = <span class="keyword">false</span>;
<a name="l01358"></a>01358         }
<a name="l01359"></a>01359     }
<a name="l01360"></a>01360 <span class="comment"></span>
<a name="l01361"></a>01361 <span class="comment">    //! \brief wait for the read to finish</span>
<a name="l01362"></a>01362 <span class="comment">    //!</span>
<a name="l01363"></a>01363 <span class="comment">    //! side-effect: erases entry for the write of the giver from write_scheduled_blocks</span>
<a name="l01364"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a43daa8aa4b5aea88b9ca025f3956bc91">01364</a> <span class="comment"></span>    <span class="keywordtype">void</span> wait_on_read(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> &amp; schedule_meta)
<a name="l01365"></a>01365     {
<a name="l01366"></a>01366         wait_on_write(schedule_meta);
<a name="l01367"></a>01367         <span class="keywordflow">if</span> (schedule_meta-&gt;second.read_req.valid())
<a name="l01368"></a>01368         {
<a name="l01369"></a>01369             schedule_meta-&gt;second.read_req-&gt;wait();
<a name="l01370"></a>01370             schedule_meta-&gt;second.read_req = 0;
<a name="l01371"></a>01371         }
<a name="l01372"></a>01372     }
<a name="l01373"></a>01373 <span class="comment"></span>
<a name="l01374"></a>01374 <span class="comment">    //! \brief wait for the write of the giver to finish and return reserved internal_block</span>
<a name="l01375"></a>01375 <span class="comment">    //!</span>
<a name="l01376"></a>01376 <span class="comment">    //! side-effect: erases entry for the write of the giver from write_scheduled_blocks</span>
<a name="l01377"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ab2f420a0d01eb38fb1b7b0f7c0265e73">01377</a> <span class="comment"></span>    <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * get_ready_block(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> &amp; schedule_meta)
<a name="l01378"></a>01378     {
<a name="l01379"></a>01379         wait_on_write(schedule_meta);
<a name="l01380"></a>01380         <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * r = schedule_meta-&gt;second.reserved_iblock;
<a name="l01381"></a>01381         schedule_meta-&gt;second.reserved_iblock = 0;
<a name="l01382"></a>01382         <span class="keywordflow">return</span> r;
<a name="l01383"></a>01383     }
<a name="l01384"></a>01384 
<a name="l01385"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ab8990567e282d669a1813d0759ed1742">01385</a>     <span class="keywordtype">bool</span> shall_keep_internal_block(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> &amp; schedule_meta, <span class="keyword">const</span> <span class="keywordtype">bool</span> ignore_first = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l01386"></a>01386 <span class="keyword">    </span>{
<a name="l01387"></a>01387         <span class="comment">// returns true iif there is an acquire or acquire_uninitialized scheduled or there is a deinitialize scheduled and the block is dirty</span>
<a name="l01388"></a>01388         <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;block_scheduler_operation&gt;::reverse_iterator
<a name="l01389"></a>01389                 rit = schedule_meta-&gt;second.operations.rbegin() + ignore_first;
<a name="l01390"></a>01390                 rit != schedule_meta-&gt;second.operations.rend(); ++rit)
<a name="l01391"></a>01391             <span class="keywordflow">switch</span> (*rit)
<a name="l01392"></a>01392             {
<a name="l01393"></a>01393             <span class="keywordflow">case</span> block_scheduler_type::op_acquire:
<a name="l01394"></a>01394             <span class="keywordflow">case</span> block_scheduler_type::op_acquire_uninitialized:
<a name="l01395"></a>01395                 <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="keywordflow">break</span>;
<a name="l01396"></a>01396             <span class="keywordflow">case</span> block_scheduler_type::op_release:
<a name="l01397"></a>01397             <span class="keywordflow">case</span> block_scheduler_type::op_release_dirty:
<a name="l01398"></a>01398                 <span class="keywordflow">break</span>;
<a name="l01399"></a>01399             <span class="keywordflow">case</span> block_scheduler_type::op_deinitialize:
<a name="l01400"></a>01400                 <span class="keywordflow">if</span> (swappable_blocks[schedule_meta-&gt;first].is_dirty()) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="keywordflow">break</span>;
<a name="l01401"></a>01401             <span class="keywordflow">case</span> block_scheduler_type::op_initialize:
<a name="l01402"></a>01402             <span class="keywordflow">case</span> block_scheduler_type::op_extract_external_block:
<a name="l01403"></a>01403                 <span class="keywordflow">break</span>;
<a name="l01404"></a>01404             }
<a name="l01405"></a>01405         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01406"></a>01406     }
<a name="l01407"></a>01407 
<a name="l01408"></a>01408     <span class="comment">// assumes the current operation to be still in operations</span>
<a name="l01409"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#aea575b1a04ce4d0e3f23b3e6cb68065e">01409</a>     <span class="keywordtype">bool</span> shall_be_cleaned(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> &amp; schedule_meta)<span class="keyword"> const</span>
<a name="l01410"></a>01410 <span class="keyword">    </span>{
<a name="l01411"></a>01411         <span class="comment">// returns true iif there is an extract_external_block scheduled and no release_dirty, deinitialize or initialize before</span>
<a name="l01412"></a>01412         <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;block_scheduler_operation&gt;::reverse_iterator
<a name="l01413"></a>01413                 rit = schedule_meta-&gt;second.operations.rbegin() + 1;
<a name="l01414"></a>01414                 rit != schedule_meta-&gt;second.operations.rend(); ++rit)
<a name="l01415"></a>01415             <span class="keywordflow">switch</span> (*rit)
<a name="l01416"></a>01416             {
<a name="l01417"></a>01417             <span class="keywordflow">case</span> block_scheduler_type::op_acquire:
<a name="l01418"></a>01418             <span class="keywordflow">case</span> block_scheduler_type::op_acquire_uninitialized:
<a name="l01419"></a>01419             <span class="keywordflow">case</span> block_scheduler_type::op_release:
<a name="l01420"></a>01420                 <span class="keywordflow">break</span>;
<a name="l01421"></a>01421             <span class="keywordflow">case</span> block_scheduler_type::op_release_dirty:
<a name="l01422"></a>01422             <span class="keywordflow">case</span> block_scheduler_type::op_deinitialize:
<a name="l01423"></a>01423             <span class="keywordflow">case</span> block_scheduler_type::op_initialize:
<a name="l01424"></a>01424                 <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="keywordflow">break</span>;
<a name="l01425"></a>01425             <span class="keywordflow">case</span> block_scheduler_type::op_extract_external_block:
<a name="l01426"></a>01426                 <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="keywordflow">break</span>;
<a name="l01427"></a>01427             }
<a name="l01428"></a>01428         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01429"></a>01429     }
<a name="l01430"></a>01430 
<a name="l01431"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a70b0be0df2deb05341b1dd9b7d64ee74">01431</a>     <span class="keywordtype">bool</span> shall_be_read(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> &amp; schedule_meta, <span class="keyword">const</span> <span class="keywordtype">bool</span> ignore_first = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l01432"></a>01432 <span class="keyword">    </span>{
<a name="l01433"></a>01433         <span class="comment">// returns true iif there is an acquire scheduled next and the block is initialized</span>
<a name="l01434"></a>01434         <span class="keywordflow">return</span> swappable_blocks[schedule_meta-&gt;first].is_initialized()
<a name="l01435"></a>01435                 &amp;&amp; schedule_meta-&gt;second.operations.rbegin() + ignore_first != schedule_meta-&gt;second.operations.rend()
<a name="l01436"></a>01436                 &amp;&amp; *(schedule_meta-&gt;second.operations.rbegin() + ignore_first) == block_scheduler_type::op_acquire;
<a name="l01437"></a>01437     }
<a name="l01438"></a>01438 
<a name="l01439"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#aa91aa3b3e5f02d504a49d0aecf9ce865">01439</a>     <span class="keywordtype">void</span> operation_done(<a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> &amp; schedule_meta)
<a name="l01440"></a>01440     {
<a name="l01441"></a>01441         schedule_meta-&gt;second.operations.pop_back();
<a name="l01442"></a>01442         <span class="keywordflow">if</span> (schedule_meta-&gt;second.operations.empty())
<a name="l01443"></a>01443         {
<a name="l01444"></a>01444             assert(! schedule_meta-&gt;second.giver.first);
<a name="l01445"></a>01445             scheduled_blocks.erase(schedule_meta);
<a name="l01446"></a>01446         }
<a name="l01447"></a>01447     }
<a name="l01448"></a>01448 
<a name="l01449"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a17f53259ee202102925c86ad113665ea">01449</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a> * give_up(std::string err_msg = <span class="stringliteral">&quot;detected some error in the prediction sequence&quot;</span>)
<a name="l01450"></a>01450     {
<a name="l01451"></a>01451         STXXL_ERRMSG(<span class="stringliteral">&quot;block_scheduler_algorithm_offline_lru_prefetching: &quot;</span> &lt;&lt; err_msg &lt;&lt; <span class="stringliteral">&quot;. Switching to block_scheduler_algorithm_online.&quot;</span>);
<a name="l01452"></a>01452         <span class="comment">// switch algorithm</span>
<a name="l01453"></a>01453         <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a> * new_algo
<a name="l01454"></a>01454                 = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm__online__lru.html" title="Block scheduling algorithm caching via the least recently used policy (online).">block_scheduler_algorithm_online_lru&lt;SwappableBlockType&gt;</a>(bs);
<a name="l01455"></a>01455         <span class="comment">// and delete self</span>
<a name="l01456"></a>01456         <span class="keyword">delete</span> bs.switch_algorithm_to(new_algo);
<a name="l01457"></a>01457         <span class="keywordflow">return</span> new_algo;
<a name="l01458"></a>01458     }
<a name="l01459"></a>01459 
<a name="l01460"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a557212eee781cd4c982720137702ea20">01460</a>     <span class="keywordtype">void</span> return_free_internal_block(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock)
<a name="l01461"></a>01461     { return_free_internal_block_to_block_scheduler(iblock); }
<a name="l01462"></a>01462 
<a name="l01463"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#afa498843473a660c6fe83b53c005c060">01463</a>     <span class="keywordtype">void</span> schedule_next_operations()
<a name="l01464"></a>01464     {
<a name="l01465"></a>01465         <span class="keywordflow">while</span> (next_op_to_schedule != prediction_sequence.end())
<a name="l01466"></a>01466         {
<a name="l01467"></a>01467             <span class="comment">// list operation in scheduled_blocks</span>
<a name="l01468"></a>01468             std::pair&lt;scheduled_blocks_iterator, bool&gt; ins_res = scheduled_blocks.insert(
<a name="l01469"></a>01469                     std::make_pair(next_op_to_schedule-&gt;id, next_op_to_schedule-&gt;op));
<a name="l01470"></a>01470             <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> schedule_meta = ins_res.first;
<a name="l01471"></a>01471             <span class="keywordflow">if</span> (! ins_res.second)
<a name="l01472"></a>01472                 schedule_meta-&gt;second.operations.push_front(next_op_to_schedule-&gt;op);
<a name="l01473"></a>01473             SwappableBlockType &amp; sblock = swappable_blocks[next_op_to_schedule-&gt;id];
<a name="l01474"></a>01474 
<a name="l01475"></a>01475             <span class="comment">// do appropriate preparations</span>
<a name="l01476"></a>01476             <span class="keywordflow">if</span> (next_op_to_schedule-&gt;op == block_scheduler_type::op_acquire
<a name="l01477"></a>01477                     || next_op_to_schedule-&gt;op == block_scheduler_type::op_acquire_uninitialized)
<a name="l01478"></a>01478             {
<a name="l01479"></a>01479                 <span class="keywordflow">if</span> (sblock.is_internal())
<a name="l01480"></a>01480                 {
<a name="l01481"></a>01481                     <span class="keywordflow">if</span> (free_evictable_blocks.erase(next_op_to_schedule-&gt;id))
<a name="l01482"></a>01482                         scheduled_evictable_blocks.insert(next_op_to_schedule-&gt;id);
<a name="l01483"></a>01483                 }
<a name="l01484"></a>01484                 <span class="keywordflow">else</span>
<a name="l01485"></a>01485                     <span class="keywordflow">if</span> (! schedule_meta-&gt;second.reserved_iblock)
<a name="l01486"></a>01486                     {
<a name="l01487"></a>01487                         <span class="comment">// =&gt; needs internal_block -&gt; try to get one</span>
<a name="l01488"></a>01488                         <span class="comment">// -&gt; try to get one from block_scheduler</span>
<a name="l01489"></a>01489                         <span class="keywordflow">if</span> (! (schedule_meta-&gt;second.reserved_iblock = get_free_internal_block_from_block_scheduler()))
<a name="l01490"></a>01490                         {
<a name="l01491"></a>01491                             <span class="comment">// -&gt; try to get one by evicting</span>
<a name="l01492"></a>01492                             <span class="keywordflow">if</span> (free_evictable_blocks.empty())
<a name="l01493"></a>01493                             {
<a name="l01494"></a>01494                                 <span class="comment">// =&gt; can not schedule acquire</span>
<a name="l01495"></a>01495                                 <span class="comment">// remove operation from scheduled_blocks</span>
<a name="l01496"></a>01496                                 <span class="keywordflow">if</span> (ins_res.second)
<a name="l01497"></a>01497                                     scheduled_blocks.erase(ins_res.first);
<a name="l01498"></a>01498                                 <span class="keywordflow">else</span>
<a name="l01499"></a>01499                                     schedule_meta-&gt;second.operations.pop_front();
<a name="l01500"></a>01500                                 <span class="comment">// stop scheduling</span>
<a name="l01501"></a>01501                                 <span class="keywordflow">return</span>;
<a name="l01502"></a>01502                             }
<a name="l01503"></a>01503                             <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> giver = <a class="code" href="namespacestxxl.html#a37feb00474dd76f7dfc8fc5352123a34">pop_begin</a>(free_evictable_blocks);
<a name="l01504"></a>01504                             {
<a name="l01505"></a>01505                                 <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> giver_meta;
<a name="l01506"></a>01506                                 assert((giver_meta = scheduled_blocks.find(giver)) == scheduled_blocks.end()
<a name="l01507"></a>01507                                         || ! shall_keep_internal_block(giver_meta, <span class="keyword">false</span>));
<a name="l01508"></a>01508                             }
<a name="l01509"></a>01509                             <a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html">write_read_request</a> * wrr = schedule_write(giver);
<a name="l01510"></a>01510                             schedule_meta-&gt;second.giver.first = bool(wrr);
<a name="l01511"></a>01511                             schedule_meta-&gt;second.giver.second = giver;
<a name="l01512"></a>01512                             schedule_meta-&gt;second.reserved_iblock = swappable_blocks[giver].detach_internal_block();
<a name="l01513"></a>01513                             <span class="keywordflow">if</span> (wrr)
<a name="l01514"></a>01514                                 wrr-&gt;<a class="code" href="structstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching_1_1write__read__request.html#ad093942c7d6451117fb350b19c093ab0">taker</a> = schedule_meta;
<a name="l01515"></a>01515                         }
<a name="l01516"></a>01516                         <span class="comment">// read if desired</span>
<a name="l01517"></a>01517                         <span class="keywordflow">if</span> (shall_be_read(schedule_meta, <span class="keyword">false</span>))
<a name="l01518"></a>01518                         {
<a name="l01519"></a>01519                             <span class="comment">// =&gt; there is no operation scheduled for this block before this acquire and it is initialized</span>
<a name="l01520"></a>01520                             <span class="comment">// -&gt; start prefetching now</span>
<a name="l01521"></a>01521                             sblock.attach_internal_block(schedule_meta-&gt;second.reserved_iblock);
<a name="l01522"></a>01522                             schedule_meta-&gt;second.reserved_iblock = 0;
<a name="l01523"></a>01523                             scheduled_evictable_blocks.insert(next_op_to_schedule-&gt;id);
<a name="l01524"></a>01524                             schedule_read(schedule_meta);
<a name="l01525"></a>01525                         }
<a name="l01526"></a>01526                     }
<a name="l01527"></a>01527             }
<a name="l01528"></a>01528             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (next_op_to_schedule-&gt;op == block_scheduler_type::op_deinitialize)
<a name="l01529"></a>01529             {
<a name="l01530"></a>01530                 <span class="keywordflow">if</span> (sblock.is_dirty())
<a name="l01531"></a>01531                     <span class="keywordflow">if</span> (free_evictable_blocks.erase(next_op_to_schedule-&gt;id))
<a name="l01532"></a>01532                         scheduled_evictable_blocks.insert(next_op_to_schedule-&gt;id);
<a name="l01533"></a>01533             }
<a name="l01534"></a>01534 
<a name="l01535"></a>01535             ++ next_op_to_schedule;
<a name="l01536"></a>01536         }
<a name="l01537"></a>01537         <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::set&lt;swappable_block_identifier_type&gt;::iterator it = free_evictable_blocks.begin();
<a name="l01538"></a>01538                 it != free_evictable_blocks.end(); ++it)
<a name="l01539"></a>01539             <span class="keywordflow">if</span> (! write_scheduled_blocks.count(*it))
<a name="l01540"></a>01540                 schedule_write(*it);
<a name="l01541"></a>01541     }
<a name="l01542"></a>01542 
<a name="l01543"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a383fd0ba9b29e6a5062f2db2e2e63459">01543</a>     <span class="keywordtype">void</span> <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a> * old_algo)
<a name="l01544"></a>01544     {
<a name="l01545"></a>01545         <span class="keywordflow">if</span>(old_algo)
<a name="l01546"></a>01546             <span class="comment">// copy prediction sequence</span>
<a name="l01547"></a>01547             prediction_sequence = old_algo-&gt;<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a059c06470d1069faf1806c96f36c1fda">get_prediction_sequence</a>();
<a name="l01548"></a>01548         next_op_to_schedule = prediction_sequence.begin();
<a name="l01549"></a>01549         <span class="keywordflow">if</span> (get_algorithm_from_block_scheduler())
<a name="l01550"></a>01550             <span class="keywordflow">while</span> (! get_algorithm_from_block_scheduler()-&gt;evictable_blocks_empty())
<a name="l01551"></a>01551                 free_evictable_blocks.insert(get_algorithm_from_block_scheduler()-&gt;evictable_blocks_pop());
<a name="l01552"></a>01552         schedule_next_operations();
<a name="l01553"></a>01553     }
<a name="l01554"></a>01554 
<a name="l01555"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ae733b230d8d247ce95410d261754d996">01555</a>     <span class="keywordtype">void</span> deinit()
<a name="l01556"></a>01556     {
<a name="l01557"></a>01557         <span class="comment">// todo remove</span>
<a name="l01558"></a>01558         <span class="keywordflow">if</span> (! scheduled_blocks.empty())
<a name="l01559"></a>01559             <a class="code" href="leda__sm__pq__benchmark_8cpp.html#afec876b95f7d6cc4b0f0bd4c0d7d89a0">STXXL_MSG</a>(<span class="stringliteral">&quot;deinit while scheduled_blocks not empty&quot;</span>);
<a name="l01560"></a>01560         <span class="keywordflow">if</span> (! scheduled_evictable_blocks.empty())
<a name="l01561"></a>01561             <a class="code" href="leda__sm__pq__benchmark_8cpp.html#afec876b95f7d6cc4b0f0bd4c0d7d89a0">STXXL_MSG</a>(<span class="stringliteral">&quot;deinit while scheduled_evictable_blocks not empty&quot;</span>);
<a name="l01562"></a>01562 
<a name="l01563"></a>01563         <span class="comment">// empty scheduled_blocks</span>
<a name="l01564"></a>01564         free_evictable_blocks.insert(scheduled_evictable_blocks.begin(), scheduled_evictable_blocks.end());
<a name="l01565"></a>01565         <span class="comment">//for (typename std::set&lt;swappable_block_identifier_type&gt;::iterator it = scheduled_evictable_blocks.begin();</span>
<a name="l01566"></a>01566         <span class="comment">//        it != scheduled_evictable_blocks.end(); ++it)</span>
<a name="l01567"></a>01567         <span class="comment">//    free_evictable_blocks.insert(*it);</span>
<a name="l01568"></a>01568         scheduled_evictable_blocks.clear();
<a name="l01569"></a>01569         <span class="keywordflow">while</span> (! scheduled_blocks.empty())
<a name="l01570"></a>01570         {
<a name="l01571"></a>01571             <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> it = scheduled_blocks.begin();
<a name="l01572"></a>01572             wait_on_read(it);
<a name="l01573"></a>01573             <span class="keywordflow">if</span> (it-&gt;second.reserved_iblock)
<a name="l01574"></a>01574                 return_free_internal_block(it-&gt;second.reserved_iblock);
<a name="l01575"></a>01575             scheduled_blocks.erase(it);
<a name="l01576"></a>01576         }
<a name="l01577"></a>01577         <span class="keywordflow">while</span> (! write_scheduled_blocks.empty())
<a name="l01578"></a>01578         {
<a name="l01579"></a>01579             <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ac8883ff92c9b6368427ffe6d89ce8536">write_scheduled_blocks_iterator</a> it = write_scheduled_blocks.begin();
<a name="l01580"></a>01580             wait_on_write(it);
<a name="l01581"></a>01581         }
<a name="l01582"></a>01582     }
<a name="l01583"></a>01583 
<a name="l01584"></a>01584 <span class="keyword">public</span>:
<a name="l01585"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a4796c36c347e619f8816b5136a9be68f">01585</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html" title="Block scheduling algorithm caching via the least recently used policy (offline), and prefetching in a...">block_scheduler_algorithm_offline_lru_prefetching</a>(<a class="code" href="classstxxl_1_1block__scheduler.html" title="Schedules swapping of blocks and provides blocks for temporary storage.">block_scheduler_type</a> &amp; bs)
<a name="l01586"></a>01586         : <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a>(bs)
<a name="l01587"></a>01587     { <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>(get_algorithm_from_block_scheduler()); }
<a name="l01588"></a>01588 
<a name="l01589"></a>01589     <span class="comment">// It is possible to keep an old simulation-algorithm object and reuse it&#39;s prediction sequence</span>
<a name="l01590"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a093046b4f690605dba90e794ec153bbd">01590</a>     <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html" title="Block scheduling algorithm caching via the least recently used policy (offline), and prefetching in a...">block_scheduler_algorithm_offline_lru_prefetching</a>(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a> * old)
<a name="l01591"></a>01591         : <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html" title="Interface of a block scheduling algorithm.">block_scheduler_algorithm_type</a>(old)
<a name="l01592"></a>01592     { <a class="code" href="berkeley__db__benchmark_8cpp.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a>(old); }
<a name="l01593"></a>01593 
<a name="l01594"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a5b06ba836854177ac837da9ab00836ec">01594</a>     <span class="keyword">virtual</span> ~<a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html" title="Block scheduling algorithm caching via the least recently used policy (offline), and prefetching in a...">block_scheduler_algorithm_offline_lru_prefetching</a>()
<a name="l01595"></a>01595     {
<a name="l01596"></a>01596         deinit();
<a name="l01597"></a>01597         <span class="keywordflow">if</span> (! free_evictable_blocks.empty())
<a name="l01598"></a>01598             STXXL_ERRMSG(<span class="stringliteral">&quot;Destructing block_scheduler_algorithm_offline_lru_prefetching that still holds evictable blocks. They get deinitialized.&quot;</span>);
<a name="l01599"></a>01599         <span class="keywordflow">while</span> (! free_evictable_blocks.empty())
<a name="l01600"></a>01600         {
<a name="l01601"></a>01601             SwappableBlockType &amp; sblock = swappable_blocks[<a class="code" href="namespacestxxl.html#a37feb00474dd76f7dfc8fc5352123a34">pop_begin</a>(free_evictable_blocks)];
<a name="l01602"></a>01602             <span class="keywordflow">if</span> (<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock = sblock.deinitialize())
<a name="l01603"></a>01603                 return_free_internal_block(iblock);
<a name="l01604"></a>01604         }
<a name="l01605"></a>01605     }
<a name="l01606"></a>01606 
<a name="l01607"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a70aacef91a44d3fab5708d0f740c7e90">01607</a>     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> evictable_blocks_empty()
<a name="l01608"></a>01608     {
<a name="l01609"></a>01609         deinit();
<a name="l01610"></a>01610         <span class="keywordflow">return</span> free_evictable_blocks.empty();
<a name="l01611"></a>01611     }
<a name="l01612"></a>01612 
<a name="l01613"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#aca78d122cd7d00ee256e631d07960f74">01613</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> evictable_blocks_pop()
<a name="l01614"></a>01614     { <span class="keywordflow">return</span> <a class="code" href="namespacestxxl.html#a37feb00474dd76f7dfc8fc5352123a34">pop_begin</a>(free_evictable_blocks); }
<a name="l01615"></a>01615 
<a name="l01616"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a33dda105dddbbe4a0360c4e66ba598d4">01616</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> &amp; acquire(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> uninitialized = <span class="keyword">false</span>)
<a name="l01617"></a>01617     {
<a name="l01618"></a>01618         assert(! prediction_sequence.empty());
<a name="l01619"></a>01619         assert(prediction_sequence.front().op ==
<a name="l01620"></a>01620                 ((uninitialized) ? block_scheduler_type::op_acquire_uninitialized : block_scheduler_type::op_acquire));
<a name="l01621"></a>01621         assert(prediction_sequence.front().id == sbid);
<a name="l01622"></a>01622         prediction_sequence.pop_front();
<a name="l01623"></a>01623         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> schedule_meta = scheduled_blocks.find(sbid);
<a name="l01624"></a>01624         assert(schedule_meta != scheduled_blocks.end()); <span class="comment">// acquire not scheduled or out of internal_blocks (i.e. not enough internal memory)</span>
<a name="l01625"></a>01625         assert(schedule_meta-&gt;second.operations.back() ==
<a name="l01626"></a>01626                         ((uninitialized) ? block_scheduler_type::op_acquire_uninitialized : block_scheduler_type::op_acquire)); <span class="comment">// acquire not scheduled or out of internal_blocks (i.e. not enough internal memory)</span>
<a name="l01627"></a>01627 
<a name="l01628"></a>01628         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l01629"></a>01629         <span class="comment">/* acquired =&gt; internal -&gt; increase reference count</span>
<a name="l01630"></a>01630 <span class="comment">           internal but not acquired -&gt; remove from scheduled_evictable_blocks, increase reference count</span>
<a name="l01631"></a>01631 <span class="comment">           not internal =&gt; uninitialized or external -&gt; get internal_block, increase reference count</span>
<a name="l01632"></a>01632 <span class="comment">           uninitialized -&gt; fill with default value</span>
<a name="l01633"></a>01633 <span class="comment">           external -&gt; read */</span>
<a name="l01634"></a>01634         <span class="keywordflow">if</span> (sblock.is_internal())
<a name="l01635"></a>01635         {
<a name="l01636"></a>01636             <span class="keywordflow">if</span> (! sblock.is_acquired())
<a name="l01637"></a>01637             {
<a name="l01638"></a>01638                 <span class="comment">// not acquired yet -&gt; remove from scheduled_evictable_blocks</span>
<a name="l01639"></a>01639                 <span class="keywordtype">bool</span> t = scheduled_evictable_blocks.erase(sbid);
<a name="l01640"></a>01640                 assert(t);
<a name="l01641"></a>01641                 wait_on_read(schedule_meta);
<a name="l01642"></a>01642             }
<a name="l01643"></a>01643             sblock.acquire();
<a name="l01644"></a>01644         }
<a name="l01645"></a>01645         <span class="keywordflow">else</span>
<a name="l01646"></a>01646         {
<a name="l01647"></a>01647             assert(uninitialized || ! sblock.is_initialized()); <span class="comment">// initialized blocks should be scheduled to read and thus internal</span>
<a name="l01648"></a>01648             <span class="comment">//get internal_block</span>
<a name="l01649"></a>01649             sblock.attach_internal_block(get_ready_block(schedule_meta));
<a name="l01650"></a>01650             sblock.acquire();
<a name="l01651"></a>01651             <span class="comment">//initialize new block</span>
<a name="l01652"></a>01652             <span class="keywordflow">if</span> (! uninitialized)
<a name="l01653"></a>01653                 sblock.fill_default();
<a name="l01654"></a>01654         }
<a name="l01655"></a>01655 
<a name="l01656"></a>01656         operation_done(schedule_meta);
<a name="l01657"></a>01657         <span class="keywordflow">return</span> sblock.get_internal_block();
<a name="l01658"></a>01658     }
<a name="l01659"></a>01659 
<a name="l01660"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ad00d560b35894bea7835241b5dfaca8c">01660</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> release(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <span class="keyword">const</span> <span class="keywordtype">bool</span> dirty)
<a name="l01661"></a>01661     {
<a name="l01662"></a>01662         assert(! prediction_sequence.empty());
<a name="l01663"></a>01663         assert(prediction_sequence.front().op ==
<a name="l01664"></a>01664                 ((dirty) ? block_scheduler_type::op_release_dirty : block_scheduler_type::op_release));
<a name="l01665"></a>01665         assert(prediction_sequence.front().id == sbid);
<a name="l01666"></a>01666         prediction_sequence.pop_front();
<a name="l01667"></a>01667         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> schedule_meta = scheduled_blocks.find(sbid);
<a name="l01668"></a>01668         assert(schedule_meta != scheduled_blocks.end());
<a name="l01669"></a>01669         assert(schedule_meta-&gt;second.operations.back() ==
<a name="l01670"></a>01670                         ((dirty) ? block_scheduler_type::op_release_dirty : block_scheduler_type::op_release));
<a name="l01671"></a>01671 
<a name="l01672"></a>01672         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l01673"></a>01673         sblock.make_dirty_if(dirty);
<a name="l01674"></a>01674         sblock.release();
<a name="l01675"></a>01675         <span class="keywordflow">if</span> (! sblock.is_acquired())
<a name="l01676"></a>01676         {
<a name="l01677"></a>01677             <span class="keywordflow">if</span> (sblock.is_dirty() || sblock.is_external())
<a name="l01678"></a>01678             {
<a name="l01679"></a>01679                 <span class="comment">// =&gt; evictable</span>
<a name="l01680"></a>01680                 <span class="keywordflow">if</span> (shall_keep_internal_block(schedule_meta))
<a name="l01681"></a>01681                 {
<a name="l01682"></a>01682                     <span class="comment">// =&gt; swappable_block shall keep its internal_block</span>
<a name="l01683"></a>01683                     scheduled_evictable_blocks.insert(sbid);
<a name="l01684"></a>01684                     <span class="keywordflow">if</span> (shall_be_cleaned(schedule_meta))
<a name="l01685"></a>01685                         schedule_write(sbid);
<a name="l01686"></a>01686                 }
<a name="l01687"></a>01687                 <span class="keywordflow">else</span>
<a name="l01688"></a>01688                 {
<a name="l01689"></a>01689                     <span class="comment">// give block to scheduler</span>
<a name="l01690"></a>01690                     free_evictable_blocks.insert(sbid);
<a name="l01691"></a>01691                     <span class="keywordflow">if</span> (next_op_to_schedule != prediction_sequence.end())
<a name="l01692"></a>01692                         schedule_next_operations();
<a name="l01693"></a>01693                     <span class="keywordflow">else</span>
<a name="l01694"></a>01694                         <span class="keywordflow">if</span> (! write_scheduled_blocks.count(sbid))
<a name="l01695"></a>01695                             schedule_write(sbid);
<a name="l01696"></a>01696                 }
<a name="l01697"></a>01697             }
<a name="l01698"></a>01698             <span class="keywordflow">else</span>
<a name="l01699"></a>01699             {
<a name="l01700"></a>01700                 <span class="comment">// =&gt; uninitialized</span>
<a name="l01701"></a>01701                 <span class="keywordflow">if</span> (shall_keep_internal_block(schedule_meta))
<a name="l01702"></a>01702                     <span class="comment">// =&gt; swappable_block shall keep its internal_block</span>
<a name="l01703"></a>01703                     schedule_meta-&gt;second.reserved_iblock = sblock.detach_internal_block();
<a name="l01704"></a>01704                 <span class="keywordflow">else</span>
<a name="l01705"></a>01705                 {
<a name="l01706"></a>01706                     <span class="comment">// release internal block and give it to prefetcher</span>
<a name="l01707"></a>01707                     return_free_internal_block(sblock.detach_internal_block());
<a name="l01708"></a>01708                     <span class="keywordflow">if</span> (next_op_to_schedule != prediction_sequence.end())
<a name="l01709"></a>01709                         schedule_next_operations();
<a name="l01710"></a>01710                 }
<a name="l01711"></a>01711             }
<a name="l01712"></a>01712         }
<a name="l01713"></a>01713         operation_done(schedule_meta);
<a name="l01714"></a>01714     }
<a name="l01715"></a>01715 
<a name="l01716"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ab5f800ca83b31fbac851fe2deff1df19">01716</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> deinitialize(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid)
<a name="l01717"></a>01717     {
<a name="l01718"></a>01718         assert(! prediction_sequence.empty());
<a name="l01719"></a>01719         assert(prediction_sequence.front().op == block_scheduler_type::op_deinitialize);
<a name="l01720"></a>01720         assert(prediction_sequence.front().id == sbid);
<a name="l01721"></a>01721         prediction_sequence.pop_front();
<a name="l01722"></a>01722         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> schedule_meta = scheduled_blocks.find(sbid);
<a name="l01723"></a>01723         assert(schedule_meta != scheduled_blocks.end());
<a name="l01724"></a>01724         assert(schedule_meta-&gt;second.operations.back() == block_scheduler_type::op_deinitialize);
<a name="l01725"></a>01725 
<a name="l01726"></a>01726         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l01727"></a>01727         <span class="keywordflow">if</span> (sblock.is_evictable())
<a name="l01728"></a>01728         {
<a name="l01729"></a>01729             <span class="keywordtype">bool</span> t;
<a name="l01730"></a>01730             <span class="keywordflow">if</span> (shall_keep_internal_block(schedule_meta, <span class="keyword">false</span>))
<a name="l01731"></a>01731             {
<a name="l01732"></a>01732                 <span class="keywordflow">if</span> (! (t = scheduled_evictable_blocks.erase(sbid)))
<a name="l01733"></a>01733                 {
<a name="l01734"></a>01734                     STXXL_ERRMSG(<span class="stringliteral">&quot;dirty block not scheduled on deinitialize&quot;</span>);
<a name="l01735"></a>01735                     t = free_evictable_blocks.erase(sbid);
<a name="l01736"></a>01736                 }
<a name="l01737"></a>01737             }
<a name="l01738"></a>01738             <span class="keywordflow">else</span>
<a name="l01739"></a>01739                 t = free_evictable_blocks.erase(sbid);
<a name="l01740"></a>01740             assert(t);
<a name="l01741"></a>01741         }
<a name="l01742"></a>01742         <span class="keywordflow">if</span> (<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#ad1640b01510cdad9af156b6df4b23350">internal_block_type</a> * iblock = sblock.deinitialize())
<a name="l01743"></a>01743         {
<a name="l01744"></a>01744             <span class="keywordflow">if</span> (shall_keep_internal_block(schedule_meta))
<a name="l01745"></a>01745                 <span class="comment">// =&gt; swappable_block shall keep its internal_block</span>
<a name="l01746"></a>01746                 schedule_meta-&gt;second.reserved_iblock = iblock;
<a name="l01747"></a>01747             <span class="keywordflow">else</span>
<a name="l01748"></a>01748             {
<a name="l01749"></a>01749                 <span class="comment">// release internal block and give it to prefetcher</span>
<a name="l01750"></a>01750                 return_free_internal_block(iblock);
<a name="l01751"></a>01751                 <span class="keywordflow">if</span> (next_op_to_schedule != prediction_sequence.end())
<a name="l01752"></a>01752                     schedule_next_operations();
<a name="l01753"></a>01753             }
<a name="l01754"></a>01754         }
<a name="l01755"></a>01755         operation_done(schedule_meta);
<a name="l01756"></a>01756     }
<a name="l01757"></a>01757 
<a name="l01758"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#ab962d3ae69fcac58f9b9e1ad6d131011">01758</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid, <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a688d2d348f5e023f2ffa2dfd503e3767">external_block_type</a> eblock)
<a name="l01759"></a>01759     {
<a name="l01760"></a>01760         assert(! prediction_sequence.empty());
<a name="l01761"></a>01761         assert(prediction_sequence.front().op == block_scheduler_type::op_initialize);
<a name="l01762"></a>01762         assert(prediction_sequence.front().id == sbid);
<a name="l01763"></a>01763         prediction_sequence.pop_front();
<a name="l01764"></a>01764         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> schedule_meta = scheduled_blocks.find(sbid);
<a name="l01765"></a>01765         assert(schedule_meta != scheduled_blocks.end());
<a name="l01766"></a>01766         assert(schedule_meta-&gt;second.operations.back() == block_scheduler_type::op_initialize);
<a name="l01767"></a>01767 
<a name="l01768"></a>01768         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l01769"></a>01769         sblock.initialize(eblock);
<a name="l01770"></a>01770         <span class="keywordflow">if</span> (shall_be_read(schedule_meta))
<a name="l01771"></a>01771         {
<a name="l01772"></a>01772             sblock.attach_internal_block(schedule_meta-&gt;second.reserved_iblock);
<a name="l01773"></a>01773             schedule_meta-&gt;second.reserved_iblock = 0;
<a name="l01774"></a>01774             scheduled_evictable_blocks.insert(sbid);
<a name="l01775"></a>01775             schedule_read(schedule_meta);
<a name="l01776"></a>01776         }
<a name="l01777"></a>01777         operation_done(schedule_meta);
<a name="l01778"></a>01778     }
<a name="l01779"></a>01779 
<a name="l01780"></a><a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a30f586fea926d71869e8938464c4c18a">01780</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a688d2d348f5e023f2ffa2dfd503e3767">external_block_type</a> extract_external_block(<a class="code" href="classstxxl_1_1block__scheduler__algorithm.html#a240fb311c2073cc91a2061f259528644">swappable_block_identifier_type</a> sbid)
<a name="l01781"></a>01781     {
<a name="l01782"></a>01782         assert(! prediction_sequence.empty());
<a name="l01783"></a>01783         assert(prediction_sequence.front().op == block_scheduler_type::op_extract_external_block);
<a name="l01784"></a>01784         assert(prediction_sequence.front().id == sbid);
<a name="l01785"></a>01785         prediction_sequence.pop_front();
<a name="l01786"></a>01786         <a class="code" href="classstxxl_1_1block__scheduler__algorithm__offline__lru__prefetching.html#a0f34666b86baf37cf5100fb276a1ef27">scheduled_blocks_iterator</a> schedule_meta = scheduled_blocks.find(sbid);
<a name="l01787"></a>01787         assert(schedule_meta != scheduled_blocks.end());
<a name="l01788"></a>01788         assert(schedule_meta-&gt;second.operations.back() == block_scheduler_type::op_extract_external_block);
<a name="l01789"></a>01789 
<a name="l01790"></a>01790         SwappableBlockType &amp; sblock = swappable_blocks[sbid];
<a name="l01791"></a>01791         wait_on_write(sbid);
<a name="l01792"></a>01792         operation_done(schedule_meta);
<a name="l01793"></a>01793         <span class="keywordflow">return</span> sblock.extract_external_block();
<a name="l01794"></a>01794     }
<a name="l01795"></a>01795 };
<a name="l01796"></a>01796 
<a name="l01797"></a>01797 __STXXL_END_NAMESPACE
<a name="l01798"></a>01798 
<a name="l01799"></a>01799 <span class="preprocessor">#endif </span><span class="comment">/* STXXL_BLOCK_SCHEDULER_HEADER */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
